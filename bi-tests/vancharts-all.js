(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.VanCharts = factory();
    }
}(this, function () {/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

// Copyright 2006 Google Inc. 
// 
// Licensed under the Apache License, Version 2.0 (the "License"); 
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License.


// Known Issues: 
// 
// * Patterns are not implemented. 
// * Radial gradient are not implemented. The VML version of these look very 
//   different from the canvas one. 
// * Clipping paths are not implemented. 
// * Coordsize. The width and height attribute have higher priority than the 
//   width and height style values which isn't correct. 
// * Painting mode isn't implemented. 
// * Canvas width/height should is using content-box by default. IE in 
//   Quirks mode will draw the canvas using border-box. Either change your 
//   doctype to HTML5 
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype) 
//   or use Box Sizing Behavior from WebFX 
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html) 
// * Non uniform scaling does not correctly scale strokes. 
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation 
if (!document.createElement('vancanvas').getContext) {

    (function() {

        // alias some functions to make (compiled) code shorter
        var m = Math;
        var mr = m.round;
        var ms = m.sin;
        var mc = m.cos;
        var abs = m.abs;
        var sqrt = m.sqrt;

        // this is used for sub pixel precision
        var Z = 10;
        var Z2 = Z / 2;

        /**
         * This funtion is assigned to the <canvas> elements as element.getContext().
         * @this {HTMLElement}
         * @return {CanvasRenderingContext2D_}
         */
        function getContext() {
            return this.context_ ||
                (this.context_ = new CanvasRenderingContext2D_(this));
        }

        var slice = Array.prototype.slice;

        /**
         * Binds a function to an object. The returned function will always use the
         * passed in {@code obj} as {@code this}.
         *
         * Example:
         *
         *   g = bind(f, obj, a, b)
         *   g(c, d) // will do f.call(obj, a, b, c, d)
         *
         * @param {Function} f The function to bind the object to
         * @param {Object} obj The object that should act as this when the function
         *     is called
         * @param {*} var_args Rest arguments that will be used as the initial
         *     arguments when the function is called
         * @return {Function} A new function that has bound this
         */
        function bind(f, obj, var_args) {
            var a = slice.call(arguments, 2);
            return function() {
                return f.apply(obj, a.concat(slice.call(arguments)));
            };
        }

        var G_vmlCanvasManager_ = {
            init: function(opt_doc) {
                if (/MSIE/.test(navigator.userAgent) && !window.opera) {
                    var doc = opt_doc || document;
                    // Create a dummy element so that IE will allow canvas elements to be
                    // recognized.
                    doc.createElement('vancanvas');
                    doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
                }
            },

            init_: function(doc) {

                if(!doc.namespaces){
                    return;
                }

                // create xmlns
                if (!doc.namespaces['g_vml_']) {
                    doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',
                        '#default#VML');

                }
                if (!doc.namespaces['g_o_']) {
                    doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',
                        '#default#VML');
                }

                // Setup default CSS.  Only add one style sheet per document
                if (!doc.styleSheets['ex_canvas_']) {
                    var ss = doc.createStyleSheet();
                    ss.owningElement.id = 'ex_canvas_';
                    ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
                        // default size is 300x150 in Gecko and Opera
                        'text-align:left;width:300px;height:150px}' +
                        'g_vml_\\:*{behavior:url(#default#VML)}' +
                        'g_o_\\:*{behavior:url(#default#VML)}';

                }

                // find all canvas elements
                var els = doc.getElementsByTagName('vancanvas');
                for (var i = 0; i < els.length; i++) {
                    this.initElement(els[i]);
                }
            },

            /**
             * Public initializes a canvas element so that it can be used as canvas
             * element from now on. This is called automatically before the page is
             * loaded but if you are creating elements using createElement you need to
             * make sure this is called on the element.
             * @param {HTMLElement} el The canvas element to initialize.
             * @return {HTMLElement} the element that was created.
             */
            initElement: function(el) {
                if (!el.getContext) {

                    el.getContext = getContext;

                    // Remove fallback content. There is no way to hide text nodes so we
                    // just remove all childNodes. We could hide all elements and remove
                    // text nodes but who really cares about the fallback content.
                    el.innerHTML = '';

                    // do not use inline function because that will leak memory
                    el.attachEvent('onpropertychange', onPropertyChange);
                    el.attachEvent('onresize', onResize);

                    var attrs = el.attributes;
                    if (attrs.width && attrs.width.specified) {
                        // TODO: use runtimeStyle and coordsize
                        // el.getContext().setWidth_(attrs.width.nodeValue);
                        el.style.width = attrs.width.nodeValue + 'px';
                    } else {
                        el.width = el.clientWidth;
                    }
                    if (attrs.height && attrs.height.specified) {
                        // TODO: use runtimeStyle and coordsize
                        // el.getContext().setHeight_(attrs.height.nodeValue);
                        el.style.height = attrs.height.nodeValue + 'px';
                    } else {
                        el.height = el.clientHeight;
                    }
                    //el.getContext().setCoordsize_()
                }
                return el;
            }
        };

        function onPropertyChange(e) {
            var el = e.srcElement;

            switch (e.propertyName) {
                case 'width':
                    el.style.width = el.attributes.width.nodeValue + 'px';
                    el.getContext().clearRect();
                    break;
                case 'height':
                    el.style.height = el.attributes.height.nodeValue + 'px';
                    el.getContext().clearRect();
                    break;
            }
        }

        function onResize(e) {
            var el = e.srcElement;
            if (el.firstChild) {
                el.firstChild.style.width =  el.clientWidth + 'px';
                el.firstChild.style.height = el.clientHeight + 'px';
            }
        }

        G_vmlCanvasManager_.init();

        // precompute "00" to "FF"
        var dec2hex = [];
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++) {
                dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
            }
        }

        function createMatrixIdentity() {
            return [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ];
        }

        function matrixMultiply(m1, m2) {
            var result = createMatrixIdentity();

            for (var x = 0; x < 3; x++) {
                for (var y = 0; y < 3; y++) {
                    var sum = 0;

                    for (var z = 0; z < 3; z++) {
                        sum += m1[x][z] * m2[z][y];
                    }

                    result[x][y] = sum;
                }
            }
            return result;
        }

        function copyState(o1, o2) {
            o2.fillStyle     = o1.fillStyle;
            o2.lineCap       = o1.lineCap;
            o2.lineJoin      = o1.lineJoin;
            o2.lineWidth     = o1.lineWidth;
            o2.miterLimit    = o1.miterLimit;
            o2.shadowBlur    = o1.shadowBlur;
            o2.shadowColor   = o1.shadowColor;
            o2.shadowOffsetX = o1.shadowOffsetX;
            o2.shadowOffsetY = o1.shadowOffsetY;
            o2.strokeStyle   = o1.strokeStyle;
            o2.globalAlpha   = o1.globalAlpha;
            o2.arcScaleX_    = o1.arcScaleX_;
            o2.arcScaleY_    = o1.arcScaleY_;
            o2.lineScale_    = o1.lineScale_;
        }

        function processStyle(styleString) {
            var str, alpha = 1;

            styleString = String(styleString);
            if (styleString.substring(0, 3) == 'rgb') {
                var start = styleString.indexOf('(', 3);
                var end = styleString.indexOf(')', start + 1);
                var guts = styleString.substring(start + 1, end).split(',');

                str = '#';
                for (var i = 0; i < 3; i++) {
                    str += dec2hex[Number(guts[i])];
                }

                if (guts.length === 4 && styleString.substr(3, 1) === 'a') {
                    alpha = guts[3];
                }
            } else {
                str = styleString;
            }

            return {color: str, alpha: alpha};
        }

        function processLineCap(lineCap) {
            switch (lineCap) {
                case 'butt':
                    return 'flat';
                case 'round':
                    return 'round';
                case 'square':
                default:
                    return 'square';
            }
        }

        /**
         * This class implements CanvasRenderingContext2D interface as described by
         * the WHATWG.
         * @param {HTMLElement} surfaceElement The element that the 2D context should
         * be associated with
         */
        function CanvasRenderingContext2D_(surfaceElement) {
            this.m_ = createMatrixIdentity();

            this.mStack_ = [];
            this.aStack_ = [];
            this.currentPath_ = [];

            // Canvas context properties
            this.strokeStyle = '#000';
            this.fillStyle = '#000';
            this.font = '12px sans-serif';

            this.lineWidth = 1;
            this.lineJoin = 'miter';
            this.lineCap = 'butt';
            this.miterLimit = Z * 1;
            this.globalAlpha = 1;
            this.canvas = surfaceElement;

            var el = surfaceElement.ownerDocument.createElement('div');
            el.style.width =  surfaceElement.clientWidth + 'px';
            el.style.height = surfaceElement.clientHeight + 'px';
            // el.style.overflow = 'hidden';
            el.style.position = 'absolute';
            surfaceElement.appendChild(el);

            this.element_ = el;
            this.arcScaleX_ = 1;
            this.arcScaleY_ = 1;
            this.lineScale_ = 1;
        }

        var contextPrototype = CanvasRenderingContext2D_.prototype;
        contextPrototype.clearRect = function() {
            this.element_.innerHTML = '';
        };

        contextPrototype.beginPath = function() {
            // TODO: Branch current matrix so that save/restore has no effect
            //       as per safari docs.
            this.currentPath_ = [];
        };

        contextPrototype.moveTo = function(aX, aY) {
            var p = this.getCoords_(aX, aY);
            this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
            this.currentX_ = p.x;
            this.currentY_ = p.y;
        };

        contextPrototype.lineTo = function(aX, aY) {
            var p = this.getCoords_(aX, aY);
            this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

            this.currentX_ = p.x;
            this.currentY_ = p.y;
        };

        contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                                  aCP2x, aCP2y,
                                                  aX, aY) {
            var p = this.getCoords_(aX, aY);
            var cp1 = this.getCoords_(aCP1x, aCP1y);
            var cp2 = this.getCoords_(aCP2x, aCP2y);
            bezierCurveTo(this, cp1, cp2, p);
        };

        // Helper function that takes the already fixed cordinates.
        function bezierCurveTo(self, cp1, cp2, p) {
            self.currentPath_.push({
                type: 'bezierCurveTo',
                cp1x: cp1.x,
                cp1y: cp1.y,
                cp2x: cp2.x,
                cp2y: cp2.y,
                x: p.x,
                y: p.y
            });
            self.currentX_ = p.x;
            self.currentY_ = p.y;
        }

        contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
            // the following is lifted almost directly from
            // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

            var cp = this.getCoords_(aCPx, aCPy);
            var p = this.getCoords_(aX, aY);

            var cp1 = {
                x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
                y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
            };
            var cp2 = {
                x: cp1.x + (p.x - this.currentX_) / 3.0,
                y: cp1.y + (p.y - this.currentY_) / 3.0
            };

            bezierCurveTo(this, cp1, cp2, p);
        };

        contextPrototype.arc = function(aX, aY, aRadius,
                                        aStartAngle, aEndAngle, aClockwise) {
            aRadius *= Z;
            var arcType = aClockwise ? 'at' : 'wa';

            var xStart = aX + mc(aStartAngle) * aRadius - Z2;
            var yStart = aY + ms(aStartAngle) * aRadius - Z2;

            var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
            var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

            // IE won't render arches drawn counter clockwise if xStart == xEnd.
            if (xStart == xEnd && !aClockwise) {
                xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                                 // that can be represented in binary
            }

            var p = this.getCoords_(aX, aY);
            var pStart = this.getCoords_(xStart, yStart);
            var pEnd = this.getCoords_(xEnd, yEnd);

            this.currentPath_.push({type: arcType,
                x: p.x,
                y: p.y,
                radius: aRadius,
                xStart: pStart.x,
                yStart: pStart.y,
                xEnd: pEnd.x,
                yEnd: pEnd.y});

        };

        contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
        };

        contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
            var oldPath = this.currentPath_;
            this.beginPath();

            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
            this.stroke();

            this.currentPath_ = oldPath;
        };

        contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
            var oldPath = this.currentPath_;
            this.beginPath();

            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
            this.fill();

            this.currentPath_ = oldPath;
        };

        contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
            var gradient = new CanvasGradient_('gradient');
            gradient.x0_ = aX0;
            gradient.y0_ = aY0;
            gradient.x1_ = aX1;
            gradient.y1_ = aY1;
            return gradient;
        };

        contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                         aX1, aY1, aR1) {
            var gradient = new CanvasGradient_('gradientradial');
            gradient.x0_ = aX0;
            gradient.y0_ = aY0;
            gradient.r0_ = aR0;
            gradient.x1_ = aX1;
            gradient.y1_ = aY1;
            gradient.r1_ = aR1;
            return gradient;
        };

        contextPrototype.drawImage = function(image, var_args) {
            if (image.getContext) {
                this.element_.innerHTML += image.getContext("2d").element_.innerHTML;
            }
            var dx, dy, dw, dh, sx, sy, sw, sh;

            // to find the original width we overide the width and height
            var oldRuntimeWidth = image.runtimeStyle.width;
            var oldRuntimeHeight = image.runtimeStyle.height;
            image.runtimeStyle.width = 'auto';
            image.runtimeStyle.height = 'auto';

            // get the original size
            var w = image.width;
            var h = image.height;

            // and remove overides
            image.runtimeStyle.width = oldRuntimeWidth;
            image.runtimeStyle.height = oldRuntimeHeight;

            if (arguments.length === 3) {
                dx = arguments[1];
                dy = arguments[2];
                sx = sy = 0;
                sw = dw = w;
                sh = dh = h;
            } else if (arguments.length === 5) {
                dx = arguments[1];
                dy = arguments[2];
                dw = arguments[3];
                dh = arguments[4];
                sx = sy = 0;
                sw = w;
                sh = h;
            } else if (arguments.length === 9) {
                sx = arguments[1];
                sy = arguments[2];
                sw = arguments[3];
                sh = arguments[4];
                dx = arguments[5];
                dy = arguments[6];
                dw = arguments[7];
                dh = arguments[8];
            } else {
                throw Error('Invalid number of arguments');
            }

            var d = this.getCoords_(dx, dy);

            var w2 = sw / 2;
            var h2 = sh / 2;

            var vmlStr = [];

            var W = 10;
            var H = 10;

            // For some reason that I've now forgotten, using divs didn't work
            vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

            // If filters are necessary (rotation exists), create them
            // filters are bog-slow, so only create them if abbsolutely necessary
            // The following check doesn't account for skews (which don't exist
            // in the canvas spec (yet) anyway.

            if (this.m_[0][0] !== 1 || this.m_[0][1]) {
                var filter = [];

                // Note the 12/21 reversal
                filter.push('M11=', this.m_[0][0], ',',
                    'M12=', this.m_[1][0], ',',
                    'M21=', this.m_[0][1], ',',
                    'M22=', this.m_[1][1], ',',
                    'Dx=', mr(d.x / Z), ',',
                    'Dy=', mr(d.y / Z), '');

                // Bounding box calculation (need to minimize displayed area so that
                // filters don't waste time on unused pixels.
                var max = d;
                var c2 = this.getCoords_(dx + dw, dy);
                var c3 = this.getCoords_(dx, dy + dh);
                var c4 = this.getCoords_(dx + dw, dy + dh);

                max.x = m.max(max.x, c2.x, c3.x, c4.x);
                max.y = m.max(max.y, c2.y, c3.y, c4.y);

                vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                    'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                    filter.join(''), ", sizingmethod='clip');")
            } else {
                vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
            }

            vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px;"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

            this.element_.insertAdjacentHTML('BeforeEnd',
                vmlStr.join(''));
        };

        contextPrototype.stroke = function(aFill) {
            var lineStr = [];
            var lineOpen = false;
            var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
            var color = a.color;
            var opacity = a.alpha * this.globalAlpha;

            var W = 10;
            var H = 10;

            lineStr.push('<g_vml_:shape',
                ' filled="', !!aFill, '"',
                ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                ' coordorigin="0 0" coordsize="', Z * W, ' ', Z * H, '"',
                ' stroked="', !aFill, '"',
                ' path="');

            var newSeq = false;
            var min = {x: null, y: null};
            var max = {x: null, y: null};

            for (var i = 0; i < this.currentPath_.length; i++) {
                var p = this.currentPath_[i];
                var c;

                switch (p.type) {
                    case 'moveTo':
                        c = p;
                        lineStr.push(' m ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'lineTo':
                        lineStr.push(' l ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'close':
                        lineStr.push(' x ');
                        p = null;
                        break;
                    case 'bezierCurveTo':
                        lineStr.push(' c ',
                            mr(p.cp1x), ',', mr(p.cp1y), ',',
                            mr(p.cp2x), ',', mr(p.cp2y), ',',
                            mr(p.x), ',', mr(p.y));
                        break;
                    case 'at':
                    case 'wa':
                        lineStr.push(' ', p.type, ' ',
                            mr(p.x - this.arcScaleX_ * p.radius), ',',
                            mr(p.y - this.arcScaleY_ * p.radius), ' ',
                            mr(p.x + this.arcScaleX_ * p.radius), ',',
                            mr(p.y + this.arcScaleY_ * p.radius), ' ',
                            mr(p.xStart), ',', mr(p.yStart), ' ',
                            mr(p.xEnd), ',', mr(p.yEnd));
                        break;
                }


                // TODO: Following is broken for curves due to
                //       move to proper paths.

                // Figure out dimensions so we can do gradient fills
                // properly
                if (p) {
                    if (min.x == null || p.x < min.x) {
                        min.x = p.x;
                    }
                    if (max.x == null || p.x > max.x) {
                        max.x = p.x;
                    }
                    if (min.y == null || p.y < min.y) {
                        min.y = p.y;
                    }
                    if (max.y == null || p.y > max.y) {
                        max.y = p.y;
                    }
                }
            }
            lineStr.push(' ">');

            if (!aFill) {
                var lineWidth = this.lineScale_ * this.lineWidth;

                // VML cannot correctly render a line if the width is less than 1px.
                // In that case, we dilute the color to make the line look thinner.
                if (lineWidth < 1) {
                    opacity *= lineWidth;
                }

                lineStr.push(
                    '<g_vml_:stroke',
                    ' opacity="', opacity, '"',
                    ' joinstyle="', this.lineJoin, '"',
                    ' miterlimit="', this.miterLimit, '"',
                    ' endcap="', processLineCap(this.lineCap), '"',
                    ' weight="', lineWidth, 'px"',
                    ' color="', color, '" />'
                );
            } else if (this.fillStyle && typeof this.fillStyle == 'object') {
                var fillStyle = this.fillStyle;
                var angle = 0;
                var focus = {x: 0, y: 0};

                // additional offset
                var shift = 0;
                // scale factor for offset
                var expansion = 1;

                if (fillStyle.type_ == 'gradient') {
                    var x0 = fillStyle.x0_ / this.arcScaleX_;
                    var y0 = fillStyle.y0_ / this.arcScaleY_;
                    var x1 = fillStyle.x1_ / this.arcScaleX_;
                    var y1 = fillStyle.y1_ / this.arcScaleY_;
                    var p0 = this.getCoords_(x0, y0);
                    var p1 = this.getCoords_(x1, y1);
                    var dx = p1.x - p0.x;
                    var dy = p1.y - p0.y;
                    angle = Math.atan2(dx, dy) * 180 / Math.PI;

                    // The angle should be a non-negative number.
                    if (angle < 0) {
                        angle += 360;
                    }

                    // Very small angles produce an unexpected result because they are
                    // converted to a scientific notation string.
                    if (angle < 1e-6) {
                        angle = 0;
                    }
                } else {
                    var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
                    var width  = max.x - min.x;
                    var height = max.y - min.y;
                    focus = {
                        x: (p0.x - min.x) / width,
                        y: (p0.y - min.y) / height
                    };

                    width  /= this.arcScaleX_ * Z;
                    height /= this.arcScaleY_ * Z;
                    var dimension = m.max(width, height);
                    shift = 2 * fillStyle.r0_ / dimension;
                    expansion = 2 * fillStyle.r1_ / dimension - shift;
                }

                // We need to sort the color stops in ascending order by offset,
                // otherwise IE won't interpret it correctly.
                var stops = fillStyle.colors_;
                stops.sort(function(cs1, cs2) {
                    return cs1.offset - cs2.offset;
                });

                var length = stops.length;
                var color1 = stops[0].color;
                var color2 = stops[length - 1].color;
                var opacity1 = stops[0].alpha * this.globalAlpha;
                var opacity2 = stops[length - 1].alpha * this.globalAlpha;

                var colors = [];
                for (var i = 0; i < length; i++) {
                    var stop = stops[i];
                    colors.push(stop.offset * expansion + shift + ' ' + stop.color);
                }

                // When colors attribute is used, the meanings of opacity and o:opacity2
                // are reversed.
                lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                    ' method="none" focus="100%"',
                    ' color="', color1, '"',
                    ' color2="', color2, '"',
                    ' colors="', colors.join(','), '"',
                    ' opacity="', opacity2, '"',
                    ' g_o_:opacity2="', opacity1, '"',
                    ' angle="', angle, '"',
                    ' focusposition="', focus.x, ',', focus.y, '" />');
            } else {
                lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                    '" />');
            }

            lineStr.push('</g_vml_:shape>');

            this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
        };

        contextPrototype.fill = function() {
            this.stroke(true);
        }

        contextPrototype.closePath = function() {
            this.currentPath_.push({type: 'close'});
        };

        /**
         * @private
         */
        contextPrototype.getCoords_ = function(aX, aY) {
            var m = this.m_;
            return {
                x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
            }
        };

        contextPrototype.save = function() {
            var o = {};
            copyState(this, o);
            this.aStack_.push(o);
            this.mStack_.push(this.m_);
            this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
        };

        contextPrototype.restore = function() {
            copyState(this.aStack_.pop(), this);
            this.m_ = this.mStack_.pop();
        };

        function matrixIsFinite(m) {
            for (var j = 0; j < 3; j++) {
                for (var k = 0; k < 2; k++) {
                    if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
                        return false;
                    }
                }
            }
            return true;
        }

        function setM(ctx, m, updateLineScale) {
            if (!matrixIsFinite(m)) {
                return;
            }
            ctx.m_ = m;

            if (updateLineScale) {
                // Get the line scale.
                // Determinant of this.m_ means how much the area is enlarged by the
                // transformation. So its square root can be used as a scale factor
                // for width.
                var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                ctx.lineScale_ = sqrt(abs(det));
            }
        }

        contextPrototype.translate = function(aX, aY) {
            var m1 = [
                [1,  0,  0],
                [0,  1,  0],
                [aX, aY, 1]
            ];

            setM(this, matrixMultiply(m1, this.m_), false);
        };

        contextPrototype.rotate = function(aRot) {
            var c = mc(aRot);
            var s = ms(aRot);

            var m1 = [
                [c,  s, 0],
                [-s, c, 0],
                [0,  0, 1]
            ];

            setM(this, matrixMultiply(m1, this.m_), false);
        };

        contextPrototype.scale = function(aX, aY) {
            this.arcScaleX_ *= aX;
            this.arcScaleY_ *= aY;
            var m1 = [
                [aX, 0,  0],
                [0,  aY, 0],
                [0,  0,  1]
            ];

            setM(this, matrixMultiply(m1, this.m_), true);
        };

        contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
            var m1 = [
                [m11, m12, 0],
                [m21, m22, 0],
                [dx,  dy,  1]
            ];

            setM(this, matrixMultiply(m1, this.m_), true);
        };

        contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
            var m = [
                [m11, m12, 0],
                [m21, m22, 0],
                [dx,  dy,  1]
            ];

            setM(this, m, true);
        };

        /******** STUBS ********/
        contextPrototype.clip = function() {
            // TODO: Implement
        };

        contextPrototype.arcTo = function() {
            // TODO: Implement
        };

        contextPrototype.createPattern = function() {
            return new CanvasPattern_;
        };

        contextPrototype.measureText = function(textToDraw) {
            var hiddenSpan = document.createElement('span');
            hiddenSpan.style.font = this.font;
            hiddenSpan.innerHTML = textToDraw;
            var bodyNode = document.getElementsByTagName("body")[0];
            bodyNode.appendChild(hiddenSpan);
            var width = hiddenSpan.offsetWidth;
            bodyNode.removeChild(hiddenSpan);
            return {"width" : width + 1};
        }

        contextPrototype.fillText = function(textToDraw, x, y) {
            var vmlStr = [];
            var textHeightStr = this.font.split("px")[0].replace(/(^\s+)|(\s+$)/g, "");
            var textHeight = /^\d+$/.test(textHeightStr) ? parseInt(textHeightStr) : 0;
            vmlStr.push('<g_vml_:shape style="font:' + this.font + ';',
                ' color:' + this.fillStyle + ';',
                ' position:absolute;',
                ' left:' + x + 'px;',
                ' top:' + (y - textHeight) + 'px;',
                ' width:' + this.measureText(textToDraw).width + 'px;',
                ' height:' + textHeight + 'px;"',
                ' ><g_vml_:textbox inset="0,0,0,0">' + textToDraw,
                ' </g_vml_:textbox>',
                '</g_vml_:shape>');

            this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
        }

        // Gradient / Pattern Stubs
        function CanvasGradient_(aType) {
            this.type_ = aType;
            this.x0_ = 0;
            this.y0_ = 0;
            this.r0_ = 0;
            this.x1_ = 0;
            this.y1_ = 0;
            this.r1_ = 0;
            this.colors_ = [];
        }

        CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
            aColor = processStyle(aColor);
            this.colors_.push({offset: aOffset,
                color: aColor.color,
                alpha: aColor.alpha});
        };

        function CanvasPattern_() {}

        // set up externs
        VanCanvasManager = G_vmlCanvasManager_;
        CanvasRenderingContext2D = CanvasRenderingContext2D_;
        CanvasGradient = CanvasGradient_;
        CanvasPattern = CanvasPattern_;

    })();

} // if ;
define("excanvas", function(){});

/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var MOUSE_UP_DOWN = 'mousedown mouseup pointerdown pointerup MSPointerDown MSPointerUp';

    var _preventDefault = function (e) {

        if(e.type && MOUSE_UP_DOWN.indexOf(e.type) != -1){
            //bi那边不能prevent
            return;
        }


        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
        return this;
    };

    var ie8 = !(window.SVGSVGElement);

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function() {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            if(target.addEventListener){
                // IE9开始支持addEventListener和wheel，同时保留了非标准的事件mousewheel
                // IE9-IE11中"onwheel" in target返回false,为BUG,在Edge中已修复:https://connect.microsoft.com/IE/Feedback/Details/768199
                target.addEventListener(type, handler, false);  
            }else if(target.attachEvent){
                if(type == 'wheel'){
                    type = 'mousewheel';
                }
                target.attachEvent('on' + type, handler);

            }
        });

        return this;
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            if(target.removeEventListener){
                target.removeEventListener(type, handler, false);
            }else if(target.detachEvent){

                if(type == 'wheel'){
                    type = 'mousewheel';
                }

                target.detachEvent('on' + type, handler);
            }
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property.charAt(0).toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return (doc.defaultView || doc.parentWindow || window);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover wheel';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    //ie8的bug,在document上mouseup不相应
    if(ie8){
        MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover mouseup wheel';
        MOUSE_WINDOW_EVENTS = 'mousemove';
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var data = {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            };

            var eventType = MOUSE_INPUT_MAP[ev.type];

            var isLeftButton = ie8 ? ev.button === 1 : ev.button === 0;

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && isLeftButton) {
                this.pressed = true;
            }


            if (eventType & INPUT_MOVE && (ie8 ? !this.pressed : (ev.which !== 1))) {
                eventType = INPUT_END;
            }

            // mouse must be down
            if (!this.pressed) {

                var eventType = ev.type;
                if(eventType.indexOf('wheel') != -1){
                    eventType = 'wheel';
                }
                var handlers = this.manager.handlers[eventType]
                    && this.manager.handlers[eventType].slice();

                if(handlers && handlers.length){
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                }
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, data);
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

// in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var _MOUSE_EVENTS = 'mousemove mouseout mouseover wheel';
    var POINTER_ELEMENT_EVENTS = 'pointerdown wheel';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel mousemove mouseout mouseover';

// IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown mousemove mouseout mouseover wheel';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }


    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            var data = {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            };

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                
                var _evType = ev.type;
                _evType = _evType.indexOf("wheel") >= 0 ? "wheel" : _evType;  // @chart-1112 IE下触发mousewheel需要替换成wheel才能被识别
                
                if(_MOUSE_EVENTS.indexOf(_evType) != -1){
                    var handlers = this.manager.handlers[_evType]
                        && this.manager.handlers[_evType].slice();

                    if(handlers && handlers.length){
                        var i = 0;
                        while (i < handlers.length) {
                            handlers[i](data);
                            i++;
                        }
                    }
                }

                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, data);

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */

    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);

        this.primaryTouch = null;
        this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }

            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {x: touch.clientX, y: touch.clientY};
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                // #touchActionAndriod
                this._shouldChangeTouchAction = value === TOUCH_ACTION_MANIPULATION
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * by Jeffrey
         * #touchActionAndriod
         */
        setTouchActionNone: function () {
            if (this._shouldChangeTouchAction) {
                // set to none
                // enable the pan event
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = TOUCH_ACTION_NONE;
            }
        },
        recoverTouchAction: function () {
            if (this._shouldChangeTouchAction) {
                // recover to origin
                // enable scroll
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = TOUCH_ACTION_MANIPULATION;
            }
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            var hammerHandler = this.manager.options._handler;

            var _prevent = hammerHandler && (hammerHandler.preventDefault(input) && !hammerHandler.vanchart.isForceBubble());

            if(_prevent || this.manager.session.prevented){
                _preventDefault(srcEvent);
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {

                return;
            }

            // if (hasNone ||
            //     (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            //     (hasPanX && direction & DIRECTION_VERTICAL)) {
            //     return this.preventSrc(srcEvent);
            // }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            _preventDefault(srcEvent);
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning

        //部分的安卓机型，如果返回TOUCH_ACTION_NONE，页面滚动就没了。。。。
        //
        // 2017-04-27 Jeffrey:
        // 但是返回manipulation会导致blink上pan事件失效……
        // 只好要pan 的时候改回none试试→_→
        // 见上 setTouchActionNone / recoverTouchAction
        // #touchActionAndriod
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_MANIPULATION;
            // return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            //点击以后响应拖拽
            var _handler = this.manager.options._handler;
            var _pressed = _handler && _handler.preventDefault(input);

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;

            return _pressed && hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.offsetDirection &&
                input.distance > this.options.threshold &&
                input.maxPointers == this.options.pointers &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.7';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ['rotate']],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            if (events === undefined) {
                return;
            }
            if (handler === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            if (events === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                _preventDefault(data.srcEvent);
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
    freeGlobal[exportName] = Hammer;

    if (typeof define === 'function' && define.amd) {
        define('hammer',[],function() {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

})(window, document, 'VanHammer');

/**
 * Created by eason on 15/6/30.
 * some of the following methods are borrowed from zrender
 */

//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('utils/ColorUtils',[],function(){
    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    var _cache = {};
    var _emptyDefault = [0, 0, 0, 1];

    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    // 调整值区间
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 数组映射
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * 把颜色转化成数组数据，用于计算
     * @param color 颜色
     */
    function getRGBAColorArray(color){
        if (_nameColors[color]) {
            color = _nameColors[color];
        }

        if (_cache[color]) {
            return _cache[color].slice();
        }

        color = trim(color);

        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }

        var r = color.match(colorRegExp);

        // 2017.05.05 Jeffrey
        // to avoid "Cannot read property '2' of null" exception
        // default is black [0,0,0,1]
        // if anywhere's color is strangely black,
        // comment here, then you can trace the bug
        if (!r) {
            _cache[color] = _emptyDefault;
            return _emptyDefault.slice();
        }

        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );
        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }


        //统一rgba的格式
        if(data.length === 3){
            data.push(1);
        }

        _cache[color] = data.slice();

        return data;
    }

    function toColor(data, format){
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(', ') + ')';
            }

            return format + '(' + data.slice(0, 3).join(', ') + ')';
        }
    }

    function getHighLightColor(color){
        var rgba = getRGBAColorArray(color);
        var tmp = [];
        for(var i = 0; i < 3; i++){
            var x = rgba[i];
            if(x <= 128){
                tmp.push(adjust(x-(255-x)*(255-2*x)/(2*x), [0,255]));
            }else{
                tmp.push(adjust(x+x*(2*x-255)/(2*(255-x)), [0,255]));
            }
        }

        var result = [];
        for(i = 0; i < 3; i++){
            result.push(Math.round(0.65 * rgba[i] + 0.35 * tmp[i]));
        }

        return toColor(result, 'rgb');
    }

    function getColorWithDivider(color, divider){
        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 3; i++){
            rgba[i] = parseInt(rgba[i] / divider, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function getClickColor(color){

        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 2; i++){
            rgba[i] = parseInt(rgba[i] * 0.95, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function mixColorWithAlpha(color, alpha){
        var rgba = getRGBAColorArray(color);
        rgba[3] = alpha;
        return toColor(rgba, 'rgba');
    }

    function mixColorWithHSB(color, detH, detS, detB){
        var rgba = getRGBAColorArray(color);

        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        hsb[0] += detH;
        hsb[1] += detS;
        hsb[2] += detB;

        var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);

        return toColor(rgb, 'rgb');
    }

    function hsb2rgb(hue, saturation, brightness){

        saturation = Math.min(1, Math.max(0, saturation));

        brightness = Math.min(1, Math.max(0, brightness));

        var r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = brightness * 255.0 + 0.5;
        } else {
            var h = (hue - Math.floor(hue)) * 6.0;
            var f = h - Math.floor(h);
            var p = brightness * (1.0 - saturation);
            var q = brightness * (1.0 - saturation * f);
            var t = brightness * (1.0 - (saturation * (1.0 - f)));
            switch (Math.floor(h)) {
                case 0:
                    r = brightness * 255.0 + 0.5;
                    g = t * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 1:
                    r = q * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 2:
                    r = p * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = t * 255.0 + 0.5;
                    break;
                case 3:
                    r = p * 255.0 + 0.5;
                    g = q * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 4:
                    r = t * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 5:
                    r = brightness * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = q * 255.0 + 0.5;
                    break;
            }
        }
        var rgb = [];
        rgb.push(Math.floor(r));
        rgb.push(Math.floor(g));
        rgb.push(Math.floor(b));
        return rgb;
    }

    function createColorsWithHsb(color, count){

        color = color || 'blue';
        count = count || 1;

        var rgba = getRGBAColorArray(color);
        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        var result = [], h = hsb[0], s = hsb[1], b = hsb[2];

        for(var i = 0; i < count; i++){
            var tmpS = s * (1 - i / count);
            var tmpB = b + i * (1 - b) / count;
            result.push(toColor(hsb2rgb(h, tmpS, tmpB)));
        }

        return result;
    }

    function rgb2hsb(r, g, b){

        var hue, saturation, brightness;

        var hsbvals = [3];
        var cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        var cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }

        brightness = cmax / 255.0;
        if (cmax !== 0) {
            saturation = (cmax - cmin) / cmax;
        }else{
            saturation = 0;
        }


        if (saturation === 0) {
            hue = 0;
        }else{
            var redc = (cmax - r) / (cmax - cmin);
            var greenc = (cmax - g) / (cmax - cmin);
            var bluec = (cmax - b) / (cmax - cmin);
            if (r == cmax) {
                hue = bluec - greenc;
            }
            else if (g == cmax) {
                hue = 2.0 + redc - bluec;
            }
            else {
                hue = 4.0 + greenc - redc;
            }
            hue = hue / 6.0;
            if (hue < 0) {
                hue = hue + 1.0;
            }
        }

        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    function getColorOpacity(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1)) ?
            getRGBAColorArray(color)[3] :
            1;
    }

    //没有a定义的话返回空
    function getColorOpacityWithoutDefault(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1))
                                                    ? getColorOpacity(color) : undefined;

    }

    function colorToHex(color){
        return colorToHexAlpha(color).hex;
    }

    function colorToHexAlpha(color){
        var rgb = toColor(getRGBAColorArray(color), 'rgba');

        var rRgba = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/,
            r, g, b, a,
            rsa = rgb.replace(/\s+/g, "").match(rRgba);

        r = (+rsa[1]).toString(16);
        r = r.length === 1 ? "0" + r : r;
        g = (+rsa[2]).toString(16);
        g = g.length === 1 ? "0" + g : g;
        b = (+rsa[3]).toString(16);
        b = b.length === 1 ? "0" + b : b;
        a = +(rsa[5] ? rsa[5] : 1);

        return {hex: "#" + r + g + b, alpha: a};
    }

    /**
     * 返回十六进制颜色和透明度
     * @param color 各种形式color，rgb、gdba、red、#ffffff
     * @param alpha 透明度
     */
    function getStandardColorAndOpacity(color, alpha) {

        if(color == null){
            return {hex:color, alpha:alpha};
        }

        if(alpha == null) {
            alpha = 1;
        }

        alpha = adjust(parseFloat(alpha), [ 0, 1 ]);

        var hexAlpha = colorToHexAlpha(color);

        if(hexAlpha.alpha != null) {
            alpha *= hexAlpha.alpha;
        }

        return {hex:hexAlpha.hex, alpha: alpha};
    }

    function hasColorName(name){
        return _nameColors[name];
    }

    var ColorUtils = {
        hasColorName:hasColorName,
        toColor:toColor,
        hsb2rgb:hsb2rgb,
        rgb2hsb:rgb2hsb,
        createColorsWithHsb:createColorsWithHsb,
        getRGBAColorArray:getRGBAColorArray,
        mixColorWithHSB:mixColorWithHSB,
        getHighLightColor:getHighLightColor,
        getColorWithDivider:getColorWithDivider,
        mixColorWithAlpha:mixColorWithAlpha,
        getColorOpacity:getColorOpacity,
        getColorOpacityWithoutDefault:getColorOpacityWithoutDefault,
        colorToHex:colorToHex,
        colorToHexAlpha:colorToHexAlpha,
        getClickColor:getClickColor,
        getStandardColorAndOpacity:getStandardColorAndOpacity
    };

    window.ColorUtils = ColorUtils;

    return ColorUtils;
});
/**
 * Created by eason on 15/5/4.
 */
define('Constants',[],function(){
    return {

        BLANK_VALUE_PERCENTAGE:'\xa0\xa0',

        INSTANCES_KEY:'vancharts_index_',

        SELECT_ANIMATION:'select',

        CHART_HIDE: 'vancharts-chart-hide',
        EXPORT_HIDE: 'vancharts-export-hide',

        //坐标系类型
        GEO:'geographic_co_sys',
        PLANE:'plane_co_sys',

        // switch style
        BUTTON: 'button',
        CAROUSEL: 'carousel',

        //图表类型
        BAR_CHART:'bar',//条形图
        COLUMN_CHART:'column',//柱形图
        LINE_CHART:'line',//折线图
        AREA_CHART:'area',//面积图
        PIE_CHART:'pie',//饼图
        MULTIPIE_CHART:'multiPie',//多层饼图
        TREEMAP_CHART:'treeMap',//矩形树图
        SCATTER_CHART:'scatter',//散点图
        BUBBLE_CHART:'bubble',//气泡图
        FORCE_BUBBLE_CHART:'forceBubble',//力学气泡图
        GANTT_CHART: 'gantt',// 甘特图

        GAUGE_CHART:'gauge',//仪表盘
        POINTER_GAUGE:'pointer',//指针仪表盘
        POINTER_SEMI_GAUGE:'pointer_semi',
        SLOT_GAUGE:'slot',//刻度槽仪表盘
        THERMOMETER_GAUGE:'thermometer',//试管仪表盘
        RING_GAUGE:'ring',//圆环仪表盘

        RADAR_CHART:'radar',//雷达图
        COLUMN_RADAR:'columnRadar',
        LINE_RADAR:'lineRadar',

        POINT_MAP:'pointMap',
        AREA_MAP:'areaMap',
        HEAT_MAP:'heatMap',
        LINE_MAP:'lineMap',

        FUNNEL_CHART:'funnel',//漏斗图
        WORD_CLOUD_CHART:'wordCloud',//词云
        STRUCTURE_CHART:'structure',//框架图

        MULTI_CHARTS: 'multiCharts', // 组合图

        VANCHART:'vanchart',

        //工具栏的icon类型
        FULL_SCREEN_ICON : 'fullScreen',
        EXPORT_ICON : 'toImage',
        SORT : 'sort',
        MENU_ICON : 'vancharts-icon-menu',
        REFRESH_ICON : 'vancharts-icon-refresh',

        AXIS_GROUP:'vanchart-axis-group',

        //位置相关的常量
        BOTTOM:'bottom',
        TOP:'top',
        LEFT:'left',
        RIGHT:'right',
        RIGHT_TOP:'right-top',
        RIGHT_BOTTOM:'right-bottom',

        //动画的方向
        LEFT_TO_RIGHT:'left-to-right',
        RIGHT_TO_LEFT:'right-to-right',
        BOTTOM_TO_TOP:'bottom-to-top',
        TOP_TO_BOTTOM:'top-to-botttom',

        //图的排序的状态
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //标记点类型
        CIRCLE:'circle',
        SQUARE:'square',
        DIAMOND:'diamond',
        TRIANGLE:'triangle',
        STAR:'star',
        LOCATION: 'location',

        CIRCLE_HOLLOW:'circle_hollow',
        SQUARE_HOLLOW:'square_hollow',
        DIAMOND_HOLLOW:'diamond_hollow',
        TRIANGLE_HOLLOW:'triangle_hollow',

        //图例的另外三种类型
        NORMAL_ICON:'normal-legend-icon',//一般的图例
        PIE_ICON:'pie-legend-icon',
        DONUT_ICON:'donut-legend-icon',
        BUBBLE_ICON:'bubble-legend-icon',
        SCATTER_ICON:'scatter-legend-icon',
        TREEMAP_ICON:'treeMap-legend-icon',

        //虚线的类型
        DASH_TYPE:{
            Solid:'none', // 0,0 bug IE9; 0 bug phantom;
            Dash:'8,6'
        },

        //玫瑰图的不同形状
        SAME_ARC : 'sameArc',//所有扇形弧长相同
        DIFFERENT_ARC : 'differentArc',//所有扇形弧长不相等

        //标签的位置
        OUTSIDE : 'outside',
        INSIDE : 'inside',
        CENTER:'center',

        //样式的名字
        STYLE_GRADUAL:'gradual', //渐变

        //仪表盘布局
        HORIZONTAL_LAYOUT:'horizontal',
        VERTICAL_LAYOUT:'vertical',

        //雷达图底边
        POLYGON_RADAR:'polygon',
        CIRCLE_RADAR:'circle',

        //size是通过气泡的半径还是面积表现出来
        SIZE_BY_AREA:'area',
        SIZE_BY_WIDTH:'width',

        GRADUAL_LIGHTER: 'lighter',
        GRADUAL_DARKER: 'darker',

        //系列的几个状态
        STATE_TO_DROP:'to-drop',
        STATE_DROPPED:'dropped',
        STATE_TO_SHOW:'to-show',
        STATE_SHOW:'show',

        // trend line
        EXPONENTIAL: 'exponential',
        LINEAR: 'linear',
        LOGARITHMIC: 'logarithmic',
        POLYNOMIAL: 'polynomial'

    }

});
/**
 * Created by eason on 2017/2/15.
 */
define('utils/vMap',['require'],function(require){

    var d3_map_proto = "__proto__", d3_map_zero = "\x00";

    function vMap(object, f) {
        this._ = Object.create(null);

        if(object){
            var map = this;
            if (object instanceof vMap) {
                object.forEach(function(key, value) {
                    map.set(key, value);
                });
            } else if (Array.isArray(object)) {
                var i = -1, n = object.length, o;
                if (arguments.length === 1) {
                    while (++i < n) {
                        map.set(i, object[i]);
                    }
                } else {
                    while (++i < n) {
                        map.set(f.call(object, o = object[i], i), o);
                    }
                }
            } else {
                for (var key in object) {
                    map.set(key, object[key]);
                }
            }
        }
    }

    vMap.prototype = {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for (var key in this._) {
                values.push(this._[key]);
            }
            return values;
        },
        entries: function() {
            var entries = [];
            for (var key in this._) {
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            }
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) {
                f.call(this, d3_map_unescape(key), this._[key]);
            }
        }
    };

    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._) {
            keys.push(d3_map_unescape(key));
        }
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._){
            ++size;
        }
        return size;
    }
    function d3_map_empty() {
        for (var key in this._) {
            return false;
        }
        return true;
    }

    return vMap;

});
/**
 * Created by eason on 15/5/4.
 * 一些最常用的工具方法
 */
define('utils/BaseUtils',['require','./ColorUtils','../Constants','./vMap'],function(require){

    var ColorUtils = require('./ColorUtils');
    var Constants = require('../Constants');
    var vMap = require('./vMap');
    var templateRe = /\{ *([\w_\-]+) *\}/g;

    var DIV_CONTAINER, SVG_CONTAINER, CANVAS_CTX;

    var lastID = 0;

    var DOUBLE_PI = 2 * Math.PI;

    var decimalPlacesRegExp = /(?:\d+)(?:\.(\d+))?(?:[eE]-(\d+))?/; // ["0.111e-7", "111", "7"]
    var decimalRegExp = /\.|[eE]-\d+/g; // (1.1e-7 + '').match(/\.|e-\d+/ig) -> [".", "e-7"]

    //options中不需要合并起来的key
    var skipKeys = {'minSize':true, 'maxSize':true, 'name':true};

    var SCALE = 1;

    var styleToCss = {
        color:'fill',
        font:'font',
        fontFamily:'font-family',
        fontSize:'font-size',
        fontStretch:'font-stretch',
        fontStyle:'font-style',
        fontVariant:'font-variant',
        fontWeight:'font-weight',
        letterSpacing:'letter-spacing',
        lineHeight:'line-height',
        quotes:'quotes',
        textAlign:'text-align',
        textDecoration:'text-decoration',
        textIndent:'text-indent',
        textShadow:'text-shadow',
        textTransform:'text-transform',
        whiteSpace:'white-space',
        wordSpacing:'word-spacing',
        padding:'padding'
    };

    function initConst() {

        if (utils.isMS != null) {
            return;
        }

        // MS includes IE and Edge
        utils.isMS = navigator.appName === 'Microsoft Internet Explorer' ||
            (navigator.appVersion.indexOf('Trident') > -1) ||
            (navigator.appName === "Netscape" && navigator.appVersion.indexOf('Edge') > -1);

        utils.transPrefix = "-webkit-transform" in document.body.style ? "-webkit-"
            : "-moz-transform" in document.body.style ? "-moz-"
            : "-ms-transform" in document.body.style ? "-ms-"
            : "";

        DIV_CONTAINER = document.createElement("div");
        document.body.appendChild(DIV_CONTAINER);

        if(isSupportSVG()){
            var c = document.createElement("canvas");
            // document.body.appendChild(c);
            CANVAS_CTX = c.getContext('2d');

            SVG_CONTAINER = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            document.body.appendChild(SVG_CONTAINER);
            var node = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            SVG_CONTAINER.appendChild(node);
            SVG_CONTAINER._textNode = node;
            SVG_CONTAINER.style.visibility = "hidden";
        }
    }

    /**
     * 存储间距缩放比例
     * @param scale
     * @returns {boolean} scale改变返回true
     */
    function initPaddingScale(scale) {
        if(scale && scale === SCALE){
            return false;
        }
        SCALE = scale || 1;
        return true;
    }

    /**
     * pick参数里第一个不为null和undefined的值
     * @returns {*}
     */
    function pick(){
        var arg, length = arguments.length;
        for (var i = 0; i < length; i++) {
            arg = arguments[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
        return null;
    }

    /**
     * 判断对象是否是数组
     * @param value 对象
     * @returns {boolean} 是否是数组
     */
    function isArray(value){
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /**
     * 将具有length属性的对象转成数组
     * @param sequence 对象
     */
    function toArray(sequence){
        return Array.prototype.slice.call(sequence);
    }

    function setTextStyle(textS, style){
        style = cssNormalization(style);
        for(var attr in style){
            textS.style(attr, style[attr]);
        }
    }

    /**
     * get text dimension by html, svg or canvas
     * @param {string} text
     * @param {object} style
     * @param {boolean} useHtml
     */
    function getTextDimension(text, style, useHtml) {
        if (text == null) {
            return {width: 0, height: 0};
        }

        if (useHtml) {
            return _getHtmlTextDim(text, style);
        }

        if (!isSupportSVG()) {
            return _getHtmlTextDim(text, style, false);
        }

        var fontSizePxNum = convertREMtoPX(style.fontSize);
        // only svg can display <12px
        // IE11 cannot use 'rem' in canvas
        if (!style['writing-mode'] && fontSizePxNum >= 12) {
            return {
                width: _getCanvasTextWidth(text, fontSizePxNum + 'px', style),
                height: getTextHeight(style)
            }
        }

        return _getSvgTextDim(text, style);
    }

    function getTextWrapDimension(text, style, useHTML){

        var newStyle = extend({
            'white-space': 'normal',
            'whiteSpace': 'normal',
            'word-wrap': 'break-word',
            'wordWrap': 'break-word'
        }, style);

        return _getHtmlTextDim(text, newStyle, useHTML);
    }

    function _getHtmlTextDim(text, style, useHtml){
        DIV_CONTAINER.style.cssText = '';

        DIV_CONTAINER.style.visibility = "hidden";
        DIV_CONTAINER.style.whiteSpace = "nowrap";
        DIV_CONTAINER.style.position = 'absolute';
        DIV_CONTAINER.style.display = '';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                DIV_CONTAINER.style[property] = style[property];
            }
        }

        if (useHtml === false) {
            DIV_CONTAINER.textContent ?
                (DIV_CONTAINER.textContent = text) :
                (DIV_CONTAINER.innerText = text);
        } else {
            DIV_CONTAINER.innerHTML = text;
        }

        var width = DIV_CONTAINER.offsetWidth || 0;
        var height = DIV_CONTAINER.offsetHeight || 0;
        var size = {width:width, height:height};

        DIV_CONTAINER.style.display = 'none';
        return size;
    }

    function _getSvgTextDim(text, style) {

        SVG_CONTAINER.style.display = "";

        var node = SVG_CONTAINER._textNode;
        node.textContent = text;

        node.style.cssText = '';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                node.style[property] = style[property];
            }
        }

        var box = node.getBBox();
        var size = {width: box.width, height:box.height};

        SVG_CONTAINER.style.display = "none";
        return size;
    }

    function _getCanvasTextWidth(text, fontSize, style) {
        if(!CANVAS_CTX){
            return 0;
        }

        var fontStyle = style['fontStyle'] || '';
        var fontWeight = style['fontWeight'] || '';
        var fontFamily = style['fontFamily'] || '';

        var det = fontStyle === 'italic' ? 5 : 0;

        CANVAS_CTX.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;
        return CANVAS_CTX.measureText(text).width + det || 0;
    }

    function setDomBackground(dom, opt){

        var cssText = [];
        if (opt.backgroundColor) {
            if(typeof opt.backgroundColor == 'string'){
                if(isSupportSVG()){
                    cssText.push('background-Color:' + opt.backgroundColor);
                }else{
                    var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                    cssText.push('background-Color:' + hexAlpha.hex);
                    cssText.push('filter:alpha(opacity=' + hexAlpha.alpha * 100 + ')')
                }
            }else if(typeof opt.backgroundColor == 'object'){

                var color = opt.backgroundColor;
                var startColor = ColorUtils.colorToHex(color.startColor);
                var endColor = ColorUtils.colorToHex(color.endColor);

                var start = 'left';

                var startPos = 'left top';
                var endPos = 'right top';
                var type = 1;

                if(color.x1 == color.x2){
                    start = 'top';

                    startPos = 'left top';
                    endPos = 'left bottom';

                    type = 0;
                }

                cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
            }
        }

        if(opt.backgroundImage){
            cssText.push('background-image:url(' + opt.backgroundImage + ')');
            cssText.push('background-size:100% 100%');
        }

        if (opt.borderWidth != null) {
            cssText.push('border-style:solid');
            cssText.push('border-width:' + opt.borderWidth + 'px');
        }

        if (opt.borderColor != null) {
            cssText.push('border-color:' + opt.borderColor);
        }

        if (opt.borderRadius != null) {
            cssText.push(
                'border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-moz-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-webkit-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-o-border-radius:' + opt.borderRadius + 'px'
            );
        }

        if(opt.shadow){
            cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
        }

        dom.style.cssText += cssText.join(';') + ';';
    }

    function getTextHeight(style) {
        var fontSize = style.fontSize || '0.75rem';
        return convertREMtoPX(fontSize);
    }

    function stamp(obj){
        obj._vanchart_id = obj._vanchart_id || ('vancharts' + ++lastID);
        return obj._vanchart_id;
    }

    //properties mix in
    function extend(dest) {
        var i, j, len, src;

        for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
                dest[i] = src[i];
            }
        }

        return dest;
    }

    function domRotate(div, rotation){

        var cssText = [];
        cssText.push('transform:rotate(' + rotation + 'deg)');
        cssText.push('-ms-transform:rotate(' + rotation + 'deg)');
        cssText.push('-webkit-transform:rotate(' + rotation + 'deg)');
        cssText.push('-moz-transform:rotate(' + rotation + 'deg)');
        cssText.push('-o-transform:rotate(' + rotation + 'deg)');

        var costheta = Math.cos(toRadian(rotation));
        var sintheta = Math.sin(toRadian(rotation));

        //ie9的时候filter和ms-transform同时生效了
        if(!isSupportSVG()){
            var filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                ', sizingMethod=\'auto expand\')'].join('') : 'none';
            cssText.push('filter:' + filter);
        }

        div.style.cssText += (cssText.join(';') + ';');
    }

    //breakWord == false:英文截断时用-连接。之后可能会考虑数字
    function splitText(text, style, offeredSize, padding, breakWord){

        if(!text){
            return [];
        }

        text += '';

        padding = padding || 0;

        offeredSize -= 2*padding;

        var result = [];

        var startIndex = 0;
        var textCount = text.length;

        while(startIndex < textCount){
            var i = startIndex;
            while(getTextDimension(text.substring(i, startIndex + 1), style, false).width < offeredSize){
                startIndex++;
                if(startIndex >= textCount){
                    break;
                }
            }

            if(i == startIndex){
                //一个字符都放不下的时候显示。。。吧
                return ['...'];
            }else{
                var substring = text.substring(i, startIndex);

                if(breakWord == false && startIndex != textCount && startIndex - 1 > i) {

                    var lastChar = text.charAt(startIndex - 1);
                    var nextChar = text.charAt(startIndex);

                    //本行最后一个&&下一行第一个字符都是英文，才考虑用"-"连接
                    if (/[A-Za-z]/.test(lastChar) && /[A-Za-z]/.test(nextChar)) {
                        var char = text.charAt(startIndex - 2);
                        substring = text.substring(i, startIndex - 1);
                        startIndex--;

                        if (char !== ' ' && char !== '-') {
                            substring += '-';
                        }
                    }
                    //数字换行，没考虑负数，没考虑下一行第一个不是数字
                    // else if(/[0-9]/.test(lastChar)){
                    //     var lastIndex = startIndex - 1;
                    //
                    //     while (lastIndex > i){
                    //         var char = text.charAt(lastIndex - 1);
                    //         lastIndex--;
                    //         if(!/[0-9]/.test(char)){
                    //             break;
                    //         }
                    //     }
                    //     if(lastIndex == i){//数字本身一行放不下
                    //         lastIndex = startIndex - 1;
                    //     }
                    //
                    //     startIndex = lastIndex + 1;
                    //     substring = text.substring(i, startIndex);
                    // }
                }

                result.push(substring);
            }

        }

        return result;
    }

    function getTextDimensionWithRotation(text, style, useHtml, rotation){

        var dim = getTextDimension(text, style, useHtml);

        return getTextDimRotated(dim, rotation);
    }

    function getTextDimRotated(dim, rotation) {
        var angle = Math.abs(toRadian(rotation || 0));

        var width = dim.width * Math.cos(angle) + dim.height * Math.sin(angle);
        var height = dim.width * Math.sin(angle) + dim.height * Math.cos(angle);

        return {
            width:width,
            height:height
        }
    }

    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (isArray(source)) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            }else{
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }

        return source;
    }

    //style对象的表示方法转css表示
    function cssNormalization(style){
        var result = {};
        for(var attr in style){
            if(styleToCss[attr]){
                result[styleToCss[attr]] = style[attr];
            }

            if(attr == 'color'){
                result.color = style[attr];
            }

            //转px
            if(attr == 'fontSize'){
                var fontSize = style[attr];
                if(fontSize.indexOf('pt') != -1){
                    fontSize = parseFloat(fontSize) * 4 / 3;
                    result['font-size'] = fontSize + 'px';
                }
            }
        }
        return result;
    }

    /**
     * css类属性数组补全，如padding，margin等~
     */
    function reformCssArray(p) {
        if (p instanceof Array) {
            switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [p[0], p[1], p[2], p[1]];
                case '2':
                    return [p[0], p[1], p[0], p[1]];
                case '1':
                    return [p[0], p[0], p[0], p[0]];
                case '0':
                    return [0, 0, 0, 0];
            }
        }
        else {
            return [p, p, p, p];
        }
    }

    function lineSubPixelOpt(xOry, lineWidth){
        return lineWidth % 2 === 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }

    function rectSubPixelOpt(){

        var x, y, width, height, lineWidth;
        if(arguments.length === 2){
            x = arguments[0].x; y = arguments[0].y; width = arguments[0].width; height = arguments[0].height;
            lineWidth = arguments[1];
        }else{
            x = arguments[0]; y = arguments[1]; width = arguments[2]; height = arguments[3];
            lineWidth = arguments[4];
        }

        lineWidth = lineWidth || 0;
        x = lineSubPixelOpt(x, lineWidth);
        y = lineSubPixelOpt(y, lineWidth);
        width = Math.round(width);
        height = Math.round(height);
        return {x:x, y:y, width:width, height:height};
    }

    function addArray(targetArray, sourceArray){

        var result = [];

        if(targetArray && targetArray.length){
            for(var i = 0, len = targetArray.length; i < len; i++){
                result.push(targetArray[i]);
            }
        }

        if(sourceArray && sourceArray.length){
            for(var i = 0, len = sourceArray.length; i < len; i++){
                result.push(sourceArray[i]);
            }
        }

        return result;
    }

    function toFront(el){
        if(el && el.parentNode){
            el.parentNode.appendChild(el);
        }
    }

    function toBack(el){
        if(el && el.parentNode){
            el.parentNode.insertBefore(el,el.parentNode.firstChild);
        }
    }

    function toFrontOfAll(el){
        el.ownerSVGElement.appendChild(el);
    }

    function toBackOfAll(el){
        el.ownerSVGElement.appendChild(el,el.ownerSVGElement.firstChild);
    }

    //一定是在同一个坐标原点下
    function containsRect(biggerOne, smallOne){

        return biggerOne.x <= smallOne.x
                    && biggerOne.y <= smallOne.y
                    && biggerOne.x + biggerOne.width >= smallOne.x + smallOne.width
                    && biggerOne.y + biggerOne.height >= smallOne.y + smallOne.height;

    }

    function rectangleOverlapped(aBounds, bBounds){
        if (!aBounds|| !bBounds) {
            return false;
        }
        var minx = Math.max(aBounds.x, bBounds.x);
        var miny = Math.max(aBounds.y, bBounds.y);
        var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
        var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
        return (minx <= maxx && miny <= maxy);
    }

    function outsideRect(biggerOne, smallOne){

        return !containsRect(biggerOne, smallOne) && !rectangleOverlapped(biggerOne, smallOne);

    }

    function containsPoint(rect, point){

        if(!rect || !point){
            return false;
        }

        var x = pick(point.x || point[0]);

        var y = pick(point.y || point[1]);

        return rect.x < x && rect.x + rect.width > x
                && rect.y < y && rect.y + rect.height > y;
    }

    function isSupportSVG(){
        return !!(window.SVGSVGElement);
    }

    function makeValueInRange(min, max, value){

        var rMin = Math.min(min, max);
        var rMax = Math.max(min, max);
        var gap = rMax - rMin;

        return ((value-rMin) % gap + gap) % gap + rMin;
    }

    function getValueInDomain(value, domain){

        return Math.min(Math.max(value, domain[0]), domain[1]);

    }

    function toRadian(degree){
        return Math.PI * (degree / 180);
    }

    function toDegree(radian){
        return radian * 180 / Math.PI;
    }

    //设计器那边传过来的formatter函数是字符串
    function getFormatterFunction(formatter){

        if(formatter == null || formatter === ''){
            return null;
        }

        if(typeof formatter == 'string'){
            var formatterFunc = (new Function("return "+ formatter))();

            //浙江农信的奇葩问题
            if(typeof formatterFunc == 'string'){
                eval("var _tmpFunc = " + formatterFunc);
                return _tmpFunc;
            }

            return formatterFunc;
        }

        return formatter;
    }

    function format(cv, fmt){

        fmt = getFormatterFunction(fmt);

        return typeof fmt == 'function' ? fmt.bind(cv)(cv) : cv;
    }

    function clone(obj) {
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj) {
            return obj;
        }

        // Handle Date
        if (obj instanceof Date) {
            var copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }

        // Handle Array
        if (obj instanceof Array) {
            var copy = [];
            for (var i = 0, len = obj.length; i < len; ++i) {
                copy[i] = clone(obj[i]);
            }
            return copy;
        }

        if(obj instanceof String){
            // convert String 'object' to 'string'
            // do not use String object
            return obj + '';
        }

        // Handle Object
        if (obj instanceof Object) {
            var copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) {
                    copy[attr] = clone(obj[attr]);
                }
            }
            return copy;
        }
    }

    function isEmpty(value){
        var result = value === "" || value === null || value === undefined;
        return result;
    }

    function isNull(v){
        return v == undefined || v == null
    }

    function isIE() { //ie?
        if (!!window.ActiveXObject || "ActiveXObject" in window)
            return true;
        else
            return false;
    }

    // null == undefined 为 true
    function hasNotDefined(value){
        return value === null || value === undefined;
    }

    function hasDefined(value){
        return !hasNotDefined(value);
    }

    function makeBounds(){

        var x = 0, y = 0, width = 0, height = 0;

        if(arguments.length === 2){

            var pos = arguments[0];
            var dim = arguments[1];

            x = pick(pos.x, pos[0]);
            y = pick(pos.y, pos[1]);

            width = pick(dim.width, dim[0]);
            height = pick(dim.height, dim[1]);

        }else if(arguments.length === 4){

            x = arguments[0];
            y = arguments[1];

            width = arguments[2];
            height = arguments[3];
        }

        return {
            x:x,
            y:y,
            width:width,
            height:height
        };

    }

    function distance(p1, p2){
        var x1 = pick(p1.x, p1[0]);
        var y1 = pick(p1.y, p1[1]);

        var x2 = pick(p2.x, p2[0]);
        var y2 = pick(p2.y, p2[1]);

        var detX = x1 - x2;
        var detY = y1 - y2;

        return Math.sqrt(detX * detX + detY * detY);
    }

    function isEmptyBounds(bounds){
        return bounds.width <= 0 || bounds.height <= 0;
    }

    function log(logBase, value){
        return accDiv(newMathLog(value), newMathLog(logBase));
    }

    /**
     * Math.pow(Math.E, Math.log(0.1)) = 0.10000000000000003
     * 而 Math.pow(Math.E, Math.log(10)) = 10
     * @param value
     * @returns {number}
     */
    function newMathLog(value){
        return value < 1 ? -Math.log(accDiv(1,value)) : Math.log(value);
    }

    function getOrder(value) {
        var order = 0;
        if(value > 0 && value < 1) {
            while(value < 1) {
                value = accMul(value, 10);
                order--;
            }
        } else if(value >= 10) {
            while(value >= 10) {
                value = accDiv(value, 10);
                order++;
            }
        }

        return order;
    }

    //用百分比表示或者数字表示的值
    function getPercentValue(value, total){
        if(value){
            value += '';
            if(value.indexOf('%') != -1){
                value = parseFloat(value) * total / 100;
            }
            return parseFloat(value);
        }
        return 0;
    }

    // 1.1e-7 -> 8
    function getDecimalPlaces(num) {
        var m = (num + '').match(decimalPlacesRegExp);
        return m ? ((m[1] ? m[1].length : 0) + (+m[2] || 0)) : 0;
    }

    function accAdd(arg1, arg2) {
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 + arg2; }

        var r1 = getDecimalPlaces(arg1);
        var r2 = getDecimalPlaces(arg2);

        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }

    function accDiv(arg1,arg2){
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 / arg2; }

        var s1 = arg1 + '', s2 = arg2 + '';
        var m = -getDecimalPlaces(arg1);
        m += getDecimalPlaces(arg2);

        var a = s1.replace(decimalRegExp, '');
        var b = s2.replace(decimalRegExp, '');

        return (m > 0) ? (a / b * Math.pow(10, m)) : (a / b / Math.pow(10, -m));
    }

    function accMul(arg1, arg2){
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 * arg2; }

        var s1 = arg1 + '', s2 = arg2 + '';
        var m = getDecimalPlaces(arg1);
        m += getDecimalPlaces(arg2);

        return s1.replace(decimalRegExp, '') * s2.replace(decimalRegExp, '') / Math.pow(10, m);
    }

    function objectToArray(object){
        if (object.length) {
            return [].slice.call(object);
        }
        var result = [];
        for(var key in object){
            result.push(object[key]);
        }
        return result;
    }

    function date2int(date){
        if(date == null) {
            return null;
        }

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }

        var baseDate = new Date("1970/01/01");

        if(typeof date == typeof(0)){
            return date;
        }else{
            return date.getTime() - baseDate.getTime();
        }

    }

    function int2date(milliseconds){

        var baseDate = new Date("1970/01/01");

        milliseconds = milliseconds || 0;

        return new Date(milliseconds + baseDate.getTime());
    }

    function object2date(obj){

        var date = obj;

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }else if(typeof date == typeof(0)){
            date = new Date(date)
        }

        return date;
    }

    function makeTranslate(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);
        return 'translate(' + x + ',' + y + ')';
    }

    function makeTranslate3d(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);
        var z = pick(pos.z, pos[2], 0);
        return 'translate3d(' + x + 'px,' + y + 'px,' + z + 'px)';
    }

    function isImageMarker(markerType){
        var ALL_SYMBOLS = Constants.LOCATION + Constants.STAR + Constants.CIRCLE + Constants.SQUARE + Constants.DIAMOND + Constants.TRIANGLE
            + Constants.CIRCLE_HOLLOW + Constants.SQUARE_HOLLOW + Constants.DIAMOND_HOLLOW + Constants.TRIANGLE_HOLLOW;

        return ALL_SYMBOLS.indexOf(markerType) == -1 && hasDefined(markerType);
    }

    function isNullMarker(marker){
        return hasNotDefined(marker.symbol);
    }

    function getDefaultMarkerSymbol(seriesIndex){
        var ALL_SYMBOLS = [Constants.CIRCLE, Constants.CIRCLE_HOLLOW, Constants.SQUARE, Constants.SQUARE_HOLLOW,
            Constants.DIAMOND, Constants.DIAMOND_HOLLOW, Constants.TRIANGLE, Constants.TRIANGLE_HOLLOW];

        return ALL_SYMBOLS[seriesIndex%ALL_SYMBOLS.length];
    }

    function splitWords (str) {
        str = str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        return str.split(/\s+/);
    }

    function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    function removeEvent(el, type, fn){

        if (el.removeEventListener) {
            el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
            el.detachEvent('on' + type, fn);
        }

    }

    function dealFloatPrecision(v){
        return Math.abs(v) < 1e-6 ? 0 : v;
    }

    function getDomWidth(root){
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
    }

    function getDomHeight(root){
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
    }

    function hasTouch(){
        var doc = window.document;
        return doc && doc.documentElement.ontouchstart !== undefined;
    }

    function getArcPoint(r, radian){
        return [r * Math.sin(radian), -r * Math.cos(radian)]
    }

    function getArcByPoint (x, y) {
        return (2 * Math.PI - (Math.atan2(y, x) - Math.PI/2)) % (2 * Math.PI);
    }

    function calculateAutoMinMaxAndGap (minValue, maxValue, splitNumber){

        if(maxValue < minValue){
            minValue = 0; maxValue = 100;
        }

        var increment = accAdd(maxValue, -minValue);
        var order = getOrder(increment);
        var pow = Math.pow(10, order);

        if(order <= 0){
            minValue = accMul(minValue, Math.pow(10, 1 - order));
            minValue = accDiv(Math.floor(minValue), Math.pow(10, 1 - order));
        }else{
            minValue = Math.floor(minValue / pow) * pow;
        }

        var base = accMul(accDiv(splitNumber, 10),pow);
        var gap = 0;
        while(gap < increment){
            gap = accAdd(base, gap);
        }

        var bd = accDiv(gap, splitNumber);

        while(minValue + bd * splitNumber < maxValue){
            gap = accAdd(base, gap);
            bd = accDiv(gap, splitNumber);
        }
        gap = accDiv(gap, splitNumber);

        maxValue = accAdd(minValue, accMul(gap, splitNumber));

        return [minValue, maxValue, gap];
    }

    //原因：FR重写了Array.prototype.indexOf，递归所有属性
    //point-points-series-point
    function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === el) { return i; }
        }
        return -1;
    }
    
    function hasChn(str) {
        return /[\u4E00-\u9FA5]/.test(str);
    }

    //组件间距代码里写rem，然后根据浏览器的一倍字体行高转化成px，之后参与布局计算
    //计算字体高度
    //字体不需要计算缩放比例，前台拿到的就是缩放后的字体大小
    function convertREMtoPX(size) {
        size += '';
        if(size.indexOf('rem') != -1){
            size = parseFloat(size);
            size = size * getDefaultFontSize();
        }else if (size.indexOf('pt') != -1){
            size = parseFloat(size) * 4 / 3;
        }else{
            size = parseFloat(size);
        }
        return size;
    }

    /**
     * 根据缩放统一处理图表中各种间隙
     * @param  {Number} size 默认的间隙大小
     * @return {Number}      根据缩放参数Scale和默认间隙字体大小计算后的间隙大小
     */
    function paddingConvertWithScale(size) {
        return Math.round(convertREMtoPX(size) * SCALE);
    }
    /**
     * 根据Scale计算字体(px单位)
     * @param  {[Obejct]} style [转换前的样式对象]
     * @return {[Object]}       [转换后的样式对象]
     */
    function calculateFontSizeWithScale(style){ 
        if(style){ 
            var size = style.fontSize + ''; 
 
            style.FONT_SCALE = style.FONT_SCALE || 1; 
 
            if (size.indexOf('rem') != -1) { 
                size = parseFloat(size) * 16; 
            }else if (size.indexOf('pt') != -1) { 
                size = parseFloat(size) * 4 / 3; 
            }else { 
                size = parseFloat(size); 
            } 
 
            style.fontSize = size * SCALE / style.FONT_SCALE + 'px'; 
            style.FONT_SCALE = SCALE; 
        } 
 
        return style; 
    }

    function getDefaultFontSize() {
        if(hasNotDefined(utils.defaultFontSize)){
            var style = document.documentElement.currentStyle || document.defaultView.getComputedStyle(document.documentElement);
            utils.defaultFontSize = _getDefaultFontSizeToPX(style.fontSize);
        }
        return utils.defaultFontSize;
    }

    function _getDefaultFontSizeToPX(size) {
        if (size.indexOf('px') != -1){
            return parseFloat(size);
        }
        if (size.indexOf('pt') != -1){
            return parseFloat(size) * 4 / 3;
        }

        return 16;
    }

    //浏览器默认1em(一倍字体行高)=16px。以此为基准，对传递到前台的字体统一进行换算.如设计器中设置的10px字体则自动转化为0.625rem
    //ie8以下不支持rem，仍然用px
    function convertToREMUseDefault16PX(style) {
        if(style) {
            var size = style.fontSize + '';

            if(isSupportSVG()) {
                size = isNaN(parseFloat(size)) ? '0.75rem' : size;

                if (size.indexOf('rem') != -1) {
                    size = parseFloat(size) * 16;
                }else if (size.indexOf('pt') != -1) {
                    size = parseFloat(size) * 4 / 3;
                }

                style.fontSize = parseFloat(size) / 16 + 'rem';
            } else if(size && size.indexOf('rem') != -1){
                style.fontSize = parseFloat(size) * 16 + 'px';
            }
        }
        return style;
    }

    function toPng(url) {
        var a = document.createElement("a");
        var img = document.createElement("img");
        a.style.display = "none";
        a.appendChild(img);
        img.setAttribute('src', url);
        document.body.appendChild(a);
        a.setAttribute("target","_blank");
        a.setAttribute("href", url);
        a.setAttribute("download", 'export.png');
        a.click();
    }

    function getPlainText(val) {
        DIV_CONTAINER.style.cssText = 'visibility: hidden;';
        DIV_CONTAINER.innerHTML = val;

        if (DIV_CONTAINER.textContent) {
            return DIV_CONTAINER.textContent;
        }

        return DIV_CONTAINER.innerText;
    }

    function computeArc (ax, ay, bx, by, c) {
        var th = Math.asin(c),
            absX = Math.abs(ax - bx),
            absY = Math.abs(ay - by),
            l = Math.sqrt(absX * absX + absY * absY) / 2,
            direction = ax > bx ? -1 : 1,
            d = direction * l / Math.tan(th),
            al = Math.atan((ay - by) / (bx - ax)),
            w = d * Math.sin(al),
            h = d * Math.cos(al),
            mx = (ax + bx) / 2,
            my = (ay + by) / 2,
            ox = mx + w,
            oy = my + h,
            sAngX = ax - ox,
            sAngY = ay - oy,
            eAngX = bx - ox,
            eAngY = by - oy,
            sAng = normalRadian(Math.atan2(sAngY, sAngX)),
            eAng = normalRadian(Math.atan2(eAngY, eAngX));

        if (sAng > eAng) {
            eAng += DOUBLE_PI;
        }

        return [ox, oy, l / c, sAng, eAng];
    }

    function normalRadian (angle) {
        angle %= DOUBLE_PI;
        if (angle < 0) {
            angle += DOUBLE_PI;
        }
        return angle;
    }

    // @function formatNum(num: Number, digits?: Number): Number
    // Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
    function formatNum(num, digits){
        var pow = Math.pow(10, digits || 5);
        return Math.round(num * pow) / pow;
    }

    function wrapNum(x, range, includeMax) {
        var max = range[1],
            min = range[0],
            d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
    }

    // @function bind(fn: Function, …): Function
    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
    // Has a `L.bind()` shortcut.
    function bind(fn, obj) {
        var slice = Array.prototype.slice;

        if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
        }

        var args = slice.call(arguments, 2);

        return function () {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
    }

    function getParamString(obj, existingUrl, uppercase){
        var params = [];
        for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
        }
        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
    }

    function template(str, data) {
        return str.replace(templateRe, function (str, key) {
            var value = data[key];

            if (value === undefined) {
                throw new Error('No value provided for variable ' + str);

            } else if (typeof value === 'function') {
                value = value(data);
            }
            return value;
        });
    }

    // @function setOptions(obj: Object, options: Object): Object
    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `BaseUtils.setOptions` shortcut.
    function setOptions(obj, options) {
        if (!obj.hasOwnProperty('options')) {
            obj.options = obj.options ? Object.create(obj.options) : {};
        }
        for (var i in options) {
            obj.options[i] = options[i];
        }
        return obj.options;
    }

    function createOptions(options, optArray){
        optArray.forEach(function(opt){
            if(opt){
                for(var i in opt){
                    if(hasNotDefined(options[i]) && !skipKeys[i]){
                        options[i] = opt[i];
                    }
                }
            }
        });

        return options;
    }

    // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

    function getPrefixed(name) {
        return window['webkit' + name] || window['moz' + name] || window['ms' + name];
    }

    var lastTime = 0;

    // fallback for IE 7-8
    function timeoutDefer(fn) {
        var time = +new Date(),
            timeToCall = Math.max(0, 16 - (time - lastTime));

        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
    }

    var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
        cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
            getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


    // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
    // `context` if given. When `immediate` is set, `fn` is called immediately if
    // the browser doesn't have native support for
    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
    function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
        } else {
            return requestFn.call(window, bind(fn, context));
        }
    }

    // @function cancelAnimFrame(id: Number): undefined
    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
    function cancelAnimFrame (id) {
        if (id) {
            cancelFn.call(window, id);
        }
    }

    // @function throttle(fn: Function, time: Number, context: Object): Function
    // Returns a function which executes function `fn` with the given scope `context`
    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
    // `fn` will be called no more than one time per given amount of `time`. The arguments
    // received by the bound function will be any arguments passed when binding the
    // function, followed by any arguments passed when invoking the bound function.
    // Has an `L.bind` shortcut.
    function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;

        later = function () {
            // reset lock and call if queued
            lock = false;
            if (args) {
                wrapperFn.apply(context, args);
                args = false;
            }
        };

        wrapperFn = function () {
            if (lock) {
                // called too soon, queue to call later
                args = arguments;

            } else {
                // call and lock until later
                fn.apply(context, arguments);
                setTimeout(later, time);
                lock = true;
            }
        };

        return wrapperFn;
    }

    function rebind(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) {
            target[method = arguments[i]] = _rebind(target, source, source[method]);
        }
        return target;
    }

    function _rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }

    function bindData (layers, dataArray, keyFunction){
        var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [], updateLayers = [];
        var nodeByKeyValue = {}, keyValues = [], keyValue, layer, datum;
        for (i = -1; ++i < n; ) {
            layer = layers[i];
            keyValue = keyFunction ? keyFunction(layer.datum()) : i;
            nodeByKeyValue[keyValue] = layer;
            keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
            datum = dataArray[i];
            keyValue = keyFunction ? keyFunction(datum) : i;
            layer = nodeByKeyValue[keyValue];
            if (!layer) {
                enterFeatures.push(datum);
            }else if(layer !== true){
                layer.datum(datum);
                updateLayers.push(layer);
            }
            nodeByKeyValue[keyValue] = true;
        }

        for (i = -1; ++i < n; ) {
            if (nodeByKeyValue[keyValues[i]] !== true) {
                exitLayers.push(layers[i]);
            }
        }

        return {
            update:updateLayers,
            enter:enterFeatures,
            exit:exitLayers
        }
    }

    function dispatch() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) {
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        }
        return dispatch;
    };

    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) {
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        }
        if (arguments.length === 2) {
            if (listener == null) {
                for (type in this) {
                    if (this.hasOwnProperty(type)) {
                        this[type].on(name, null);
                    }
                }
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new vMap();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) {
                if (l = z[i].on) {
                    l.apply(this, arguments);
                }
            }
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) {
                return l && l.on;
            }
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) {
                listeners.push(listenerByName.set(name, {
                    on: listener
                }))
            };
            return dispatch;
        };
        return event;
    }

    function falseFn() {
        return false;
    }

    function trueFn(){
        return true;
    }

    function emptyFn() {

    }

    /**
     * 把数组形式的categoryArray转化为字符串
     * @param array
     * @returns {string}
     */
    function encodeCategoryArray(categoryArray){
        if(!isArray(categoryArray)){ return categoryArray; }

        if(window.JSON) {
            return JSON['stringify'](categoryArray);
        } else {
            var output = '[';
            for(var i = -1; ++i < categoryArray.length;) {
                output += (i > 0 ? ',' : '') + '"' + categoryArray[i] + '"';
            }
            return output + ']';
        }
    }

    /**
     * 把字符串化的categoryArray转换成数组
     * @param  {[string]} categoryArrayStr [description]
     * @return {[array]}                  [description]
     */
    function decodeCategoryArray(categoryArrayStr){
        if(window.JSON) {
            return JSON['parse'](categoryArrayStr);
        } else {
            return eval('(' + categoryArrayStr + ')');
        }
    }

    var utils = {
        dispatch:dispatch,
        rebind:rebind,
        throttle:throttle,
        requestAnimFrame:requestAnimFrame,
        cancelAnimFrame:cancelAnimFrame,
        getParamString:getParamString,
        template:template,
        setOptions:setOptions,
        createOptions:createOptions,
        formatNum:formatNum,
        wrapNum:wrapNum,
        bind:bind,
        initConst:initConst,
        initPaddingScale:initPaddingScale,
        toPng:toPng,
        getDomWidth:getDomWidth,
        getDomHeight:getDomHeight,
        makeTranslate:makeTranslate,
        makeTranslate3d:makeTranslate3d,
        clone:clone,
        date2int:date2int,
        int2date:int2date,
        object2date:object2date,
        log:log,
        getOrder:getOrder,
        getPercentValue:getPercentValue,
        accAdd:accAdd,
        accDiv:accDiv,
        accMul:accMul,
        dealFloatPrecision:dealFloatPrecision,
        isEmpty:isEmpty,
        isEmptyBounds:isEmptyBounds,
        objectToArray:objectToArray,
        toArray:toArray,
        pick:pick,
        isNull:isNull,
        getTextDimension:getTextDimension,
        getTextHeight:getTextHeight,
        splitText:splitText,
        getTextDimensionWithRotation:getTextDimensionWithRotation,
        getTextDimRotated:getTextDimRotated,
        isArray:isArray,
        indexOf:indexOf,
        cssNormalization:cssNormalization,
        reformCssArray:reformCssArray,
        rectSubPixelOpt:rectSubPixelOpt,
        lineSubPixelOpt:lineSubPixelOpt,
        addArray:addArray,
        toFront:toFront,
        toBack:toBack,
        toFrontOfAll:toFrontOfAll,
        toBackOfAll:toBackOfAll,
        containsRect:containsRect,
        rectangleOverlapped:rectangleOverlapped,
        outsideRect:outsideRect,
        containsPoint:containsPoint,
        isSupportSVG:isSupportSVG,
        setTextStyle:setTextStyle,
        domRotate:domRotate,
        makeValueInRange:makeValueInRange,
        getValueInDomain:getValueInDomain,
        toRadian:toRadian,
        toDegree:toDegree,
        getFormatterFunction:getFormatterFunction,
        format:format,
        isIE:isIE,
        hasTouch:hasTouch,
        hasNotDefined:hasNotDefined,
        hasDefined:hasDefined,
        distance:distance,
        makeBounds:makeBounds,
        isImageMarker:isImageMarker,
        isNullMarker:isNullMarker,
        getDefaultMarkerSymbol:getDefaultMarkerSymbol,
        removeEvent:removeEvent,
        getArcPoint:getArcPoint,
        getTextWrapDimension:getTextWrapDimension,
        stamp:stamp,
        splitWords:splitWords,
        trim:trim,
        extend:extend,
        setDomBackground:setDomBackground,
        getArcByPoint:getArcByPoint,
        calculateAutoMinMaxAndGap:calculateAutoMinMaxAndGap,
        hasChn:hasChn,
        convertREMtoPX:convertREMtoPX,
        paddingConvertWithScale:paddingConvertWithScale,
        getDefaultFontSize:getDefaultFontSize,
        convertToREMUseDefault16PX:convertToREMUseDefault16PX,
        getPlainText:getPlainText,
        computeArc:computeArc,
        normalRadian: normalRadian,
        bindData: bindData,
        falseFn:falseFn,
        trueFn:trueFn,
        emptyFn:emptyFn, 
        calculateFontSizeWithScale: calculateFontSizeWithScale,
        decodeCategoryArray: decodeCategoryArray,
        encodeCategoryArray: encodeCategoryArray
    };

    window.VanUtils = utils;//export to the global env

    return utils;
});
/**
 * Created by eason on 15/6/16.
 */

define('utils/QueryUtils',['require'],function(require){

    //从可能的属性列表里读optLocation的属性，前面的优先级高
    function queryList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        for(var i = 0; i < optList.length; i++){
            var result = optList[i] && optList[i][optLocation];
            if(result != undefined){
                return result;
            }
        }
    }

    function merge(target, source, overwrite){
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object') {

                    //target[key]不为对象时？
                    merge(target[key], source[key], overwrite);
                }else if(overwrite || !(key in target) || targetProp == undefined){
                    target[key] = source[key];
                }
            }
        }
        return target;
    }

    return {
        queryList:queryList,
        merge:merge
    };
});
/**
 * Created by eason on 16/5/26.
 *
 * try to use Behavior Delegation
 */

define('utils/Class',['require','./QueryUtils','./BaseUtils'],function(require){

    var QueryUtils = require('./QueryUtils');
    var BaseUtils = require('./BaseUtils');

    function Class(){};

    Class.extend = function(props){

        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            this.callInitHooks();
        };

        var parentProto = NewClass.__super__ = this.prototype;

        var proto = Object.create(parentProto);
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        // inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        // // merge options
        if (proto.options) {
            props.options = BaseUtils.extend(Object.create(proto.options), props.options);
        }

        // mix given properties into the prototype
        BaseUtils.extend(proto, props);

        proto._initHooks = [];

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) { return; }

            if (parentProto.callInitHooks) {
                parentProto.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };

    Class.include = function (props) {
        BaseUtils.extend(this.prototype, props);
        return this;
    };

    // @function addInitHook(fn: Function)
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };

    return Class;
});


/**
 * Created by eason on 16/5/26.
 */

define('dom/Evented',['require','../utils/BaseUtils','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var Class = require('../utils/Class');

    var Evented = Class.extend({

        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function (types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(type, types[type], fn);
                }

            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(types[i], fn, context);
                }
            }

            return this;
        },

        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object.
         */
        off: function (types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(types[i], fn, context);
                }
            }

            return this;
        },

        // attach listener (without syntactic sugar now)
        _on: function (type, fn, context) {

            if(!type || !fn ){//跳过未定义的listener
                return ;
            }

            this._events = this._events || {};

            /* get/init listeners for type */
            var typeListeners = this._events[type];
            if (!typeListeners) {
                typeListeners = [];
                this._events[type] = typeListeners;
            }

            if (context === this) {
                // Less memory footprint.
                context = undefined;
            }
            var newListener = {fn: fn, ctx: context},
                listeners = typeListeners;

            // check if fn already there
            for (var i = 0, len = listeners.length; i < len; i++) {
                if (listeners[i].fn === fn && listeners[i].ctx === context) {
                    return;
                }
            }

            listeners.push(newListener);
            typeListeners.count++;
        },

        _off: function (type, fn, context) {
            var listeners,
                i,
                len;

            if (!this._events) { return; }

            listeners = this._events[type];

            if (!listeners) {
                return;
            }

            if (!fn) {
                // Set all removed listeners to noop so they are not called if remove happens in fire
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].fn = BaseUtils.falseFn;
                }
                // clear all listeners for a type if function isn't specified
                delete this._events[type];
                return;
            }

            if (context === this) {
                context = undefined;
            }

            if (listeners) {

                // find fn and remove it
                for (i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.ctx !== context) { continue; }
                    if (l.fn === fn) {

                        // set the removed listener to noop so that's not called if remove happens in fire
                        l.fn = BaseUtils.falseFn;

                        if (this._firingCount) {
                            /* copy array in case events are being fired */
                            this._events[type] = listeners = listeners.slice();
                        }
                        listeners.splice(i, 1);

                        return;
                    }
                }
            }
        },

        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide an data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function (type, data, propagate) {
            if (!this.listens(type, propagate)) { return this; }

            //todo 这个extend非常浪费性能，暂时屏蔽掉，应该不会有问题才对
            var event = data;

            if (this._events) {
                var listeners = this._events[type];

                if (listeners) {
                    this._firingCount = (this._firingCount + 1) || 1;
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        var l = listeners[i];
                        l.fn.call(l.ctx || this, event);
                    }

                    this._firingCount--;
                }
            }

            if (propagate) {
                // propagate the event to parents (set with addEventParent)
                this._propagateEvent(event);
            }

            return this;
        },

        // @method listens(type: String): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        listens: function (type, propagate) {
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) { return true; }

            if (propagate) {
                // also check parents for listeners if event propagates
                for (var id in this._eventParents) {
                    if (this._eventParents[id].listens(type, propagate)) { return true; }
                }
            }
            return false;
        },

        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function (types, fn, context) {

            if (typeof types === 'object') {
                for (var type in types) {
                    this.once(type, types[type], fn);
                }
                return this;
            }

            var handler = BaseUtils.bind(function () {
                this
                    .off(types, fn, context)
                    .off(types, handler, context);
            }, this);

            // add a listener that's executed once and removed after that
            return this
                .on(types, fn, context)
                .on(types, handler, context);
        },

        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function (obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[BaseUtils.stamp(obj)] = obj;
            return this;
        },

        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function (obj) {
            if (this._eventParents) {
                delete this._eventParents[BaseUtils.stamp(obj)];
            }
            return this;
        },

        _propagateEvent: function (e) {
            for (var id in this._eventParents) {
                this._eventParents[id].fire(e.srcEvent.type, e, true);
            }
        }
    });

    return Evented;
});
/**
 * Created by eason on 15/5/18.
 * 各种注册了的组件
 */
define('ComponentLibrary',[],function(){

    var _registeredComponents = Object.create(null);

    //控制下初始化的顺序
    var ComponentsOrder = [
        'tooltip',
        'tools',
        'title',
        'dTools',

        'geo',
        'rangeLegend',
        'legend',
        'zoom',
        'dataSheet',

        'xAxis',
        'yAxis',
        'polar',
        'angleAxis',
        'radiusAxis',

        'gaugeAxis',
        'value',
        'category',

        'multiCategory',

        'datetime',

        'levelBar',
        'processes',
        'timeAxis',

        'moreLabel'
    ];

    /**
     * 根据名字获得组件的function
     * @param name 组件的名字
     */
    function get(name){
        return _registeredComponents[name];
    }

    /**
     * 注册某种组件类型
     * @param name 组件的名字
     * @param chart 组件的实现
     */
    function register(name, compnent){
        _registeredComponents[name] = compnent;
    }

    function getRegisteredComponents(){
        return _registeredComponents;
    }

    return {
        TOOLTIP_COMPONENT:'tooltip',
        TOOLBAR_COMPONENT:'tools',
        GEO_COMPONENT:'geo',
        DRILL_TOOLS:'dTools',

        TITLE_COMPONENT:'title',
        RANGE_LEGEND_COMPONENT:'rangeLegend',
        INTERVAL_RANGE_LEGEND:'intervalRangeLegend',
        GradientRangeLegend:'gradientRangeLegend',
        LEGEND_COMPONENT:'legend',
        DATA_SHEET_COMPONENT:'dataSheet',

        ZOOM_COMPONENT:'zoom',
        X_AXIS_COMPONENT:'xAxis',
        Y_AXIS_COMPONENT:'yAxis',
        POLAR_COMPONENT:'polar',

        RADIUS_AXIS_COMPONENT:'radiusAxis',
        ANGLE_AXIS_COMPONENT:'angleAxis',
        GAUGE_AXIS_COMPONENT:'gaugeAxis',
        VALUE_AXIS_COMPONENT:'value',

        CATEGORY_AXIS_COMPONENT:'category',
        DATE_AXIS_COMPONENT:'datetime',

        LEVELBAR: 'levelBar',
        PROCESSES: 'processes',
        TIMEAXIS: 'timeAxis',

        MORELABEL_COMPONENT: 'moreLabel',
        MULTI_CATEGORY_AXIS_COMPONENT: 'multiCategory', 

        ComponentsOrder:ComponentsOrder,
        getRegisteredComponents:getRegisteredComponents,
        get:get,
        register:register
    }

});
/**
 * Created by eason on 15/8/7.
 */
//管理标签位置
define('utils/BoundsManager',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function BoundsManager(){
        this.addedBounds = [];
    }

    BoundsManager.prototype = {

        constructor:BoundsManager,

        addBounds:function(bounds){
            this.addedBounds.push(bounds);
        },

        isOverlapped:function(bounds){
            for (var i = 0, len = this.addedBounds.length; i < len; i++){
                if (BaseUtils.rectangleOverlapped(bounds, this.addedBounds[i])){
                    return true;
                }
            }
            return false;
        },

        isEmpty:function(){
            return this.addedBounds.length === 0;
        }

    };

    return BoundsManager;
});
/**
 * Created by eason on 15/6/24.
 */
//
//Copyright (c) 2014 Ga?tan Renaudeau
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//    copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//    The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

define('utils/BezierEasing',['require','./vMap'],function(require){

    var vMap = require('./vMap');

    var global = this;

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = 'Float32Array' in global;

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }

    function BezierEasing (mX1, mY1, mX2, mY2) {
        // Validate arguments
        if (arguments.length !== 4) {
            throw new Error("BezierEasing requires 4 arguments.");
        }
        for (var i=0; i<4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                throw new Error("BezierEasing arguments should be integers.");
            }
        }
        if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
            throw new Error("BezierEasing x values must be in [0, 1] range.");
        }

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : [];

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) {return aGuessT;}
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function getTForX (aX) {
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }
            --currentSample;

            // Interpolate to provide an initial guess for t
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;

            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }

        var _precomputed = false;
        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2)
            {calcSampleValues();}
        }

        var f = function (aX) {
            if (!_precomputed) {precompute();}
            if (mX1 === mY1 && mX2 === mY2) {return aX;} // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
            if (aX === 0) {return 0;}
            if (1 - aX  < 0.001) {return 1;}
            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var args = [mX1, mY1, mX2, mY2];
        var str = "BezierEasing("+args+")";
        f.toString = function () { return str; };

        //var css = "cubic-bezier("+args+")";
        //f.toCSS = function () {?return css; };

        return f;
    }

    // CSS mapping
    BezierEasing.css = {
        "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
        "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
        "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
        "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
        "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0),
        "swing":       BezierEasing(0.02, 0.01,0.47, 1.0),
        "ease-in-back":BezierEasing(0.6,-0.28,0.735,0.045),
        "ease-out-back":BezierEasing(0.175, 0.885, 0.32, 1.275),
        "ease-in-quart":BezierEasing(0.895, 0.03, 0.685, 0.22),
        "ease-out-quart":BezierEasing(0.165, 0.84, 0.44, 1),
        "ease-in-quint":BezierEasing(0.755, 0.05, 0.855, 0.06),
        "ease-out-quint":BezierEasing(0.23, 1, 0.32, 1),
        "ease-in-quad":BezierEasing(0.55,0.085,0.68,0.53),
        "ease-out-quad":BezierEasing(0.25,0.46,0.45,0.94),
        "ease-in-out-quad": BezierEasing(0.455, 0.03, 0.515, 0.955),
        "ease-out-cubic":BezierEasing(0.215,0.61,0.355,1)
    };

    BezierEasing.custom = {
        "ease-out":BezierEasing(0.00, 0.0, 0.16, 1.03),
        "ease-out-quint":BezierEasing(0.19, 1, 0.22, 1),
        "ease-out-back":BezierEasing(0.18, 0.89, 0.32, 1.6)
    };

    BezierEasing.calculateCubicOutT = function (det) {
        return (1 - Math.pow(1 - det, 1/3));
    };

    BezierEasing.calculateQuadInT = function (det) {
        return Math.sqrt(det);
    };

    var τ = 2 * Math.PI;

    var d3_identity = function(d){
        return d;
    };

    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = new vMap({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = new vMap({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });

    BezierEasing.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
    };

    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) {
            p = .45;
        }
        if (arguments.length) {
            s = p / τ * Math.asin(1 / a);
        }else {
            a = 1, s = p / 4;
        }
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) {
            s = 1.70158;
        }
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }

    return BezierEasing;
});
/**
 * Created by eason on 2016/11/8.
 */


define('vans/VanChartLayout',['require','../Constants','../utils/BaseUtils','../ComponentLibrary','../utils/BoundsManager','../utils/BezierEasing'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var BoundsManager = require('../utils/BoundsManager');
    var BezierEasing = require('../utils/BezierEasing');

    function calculateSeries(vanchart){

        _calculatePercentageRelated(vanchart);

        _calculateTypePercentage(vanchart.seriesOfType(Constants.WORD_CLOUD_CHART));

        calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.BUBBLE_CHART), Constants.BUBBLE_CHART);

        calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.SCATTER_CHART), Constants.SCATTER_CHART);

        calculateBubbleRadius(vanchart.seriesOfType(Constants.BUBBLE_CHART));

        calculateBubbleRadius(vanchart.seriesOfType(Constants.FORCE_BUBBLE_CHART));
    }

    function calculateSeriesShapes(vanchart){
        for(var i = 0, len = vanchart.series.length; i < len; i++){
            var ser = vanchart.series[i];
            if (ser.visible) {
                ser.doLayout();
                ser._calculateLabelPos();
            }
        }

        var manager = new BoundsManager();
        //计算自动调整的标签位置，只有柱形图，条形图，面积图，折线图有这个功能
        for(var category in vanchart.cateMap){

            var points = vanchart.cateMap[category].filter(function (p) {
                var type = p.series.type;

                var isValidChartType = (type == Constants.BAR_CHART || type == Constants.COLUMN_CHART || type == Constants.AREA_CHART || type == Constants.LINE_CHART);

                return p.labelPos && p.options.dataLabels.autoAdjust && isValidChartType;
            });

            if(!points.length){
                continue;
            }

            var isHorizontalBaseAxis = vanchart.xAxis() && vanchart.xAxis().isHorizontal();
            var key = isHorizontalBaseAxis ? 'y' : 'x';
            var plotBounds = vanchart.bounds, maxY = plotBounds.height, maxX = plotBounds.x;
            points = points.sort(function(a, b){return a.labelPos[key] - b.labelPos[key] + 1});

            var toRightBottom =  isHorizontalBaseAxis ? (points[0].labelPos.y < maxY/2) : (points[0].labelPos.x < maxX/2);

            if(toRightBottom){
                points.reverse();
            }

            for(var i = points.length - 1; i >= 0; i--){
                var point = points[i];
                point.labelPos = point.series._calculateAutoLabelPos(point, point.labelPos, isHorizontalBaseAxis, manager, toRightBottom);
                manager.addBounds(BaseUtils.makeBounds(point.labelPos, point.labelDim));
            }
        }

        _adjustPieRadius(vanchart.seriesOfType(Constants.PIE_CHART));
    }

    function PLANE_SYSTEM_LAYOUT(vanchart){

        calculateSeries(vanchart);

        fixCoordinateSystem(vanchart);
    }

    function _adjustPieRadius (series) {
        var _sCache = [];
        var minRadius = series.reduce(function (min, s) {
            if (!s.options.radius) { // if it's calculated by us
                _sCache.push(s);
                return s.chartInfo.radius // get min calculated radius
            }
        }, 0);

        _sCache.map(function (s) {
            s.adjustRadius(minRadius);
        });
    }

    /**
     *计算百分比，然后堆积的值，然后标签
     * @private
     */
    function _calculatePercentageRelated(vanchart){
        var stackMap = {}, series = vanchart.series;
        for(var i = 0, len = series.length; i < len; i++){
            var ser = series[i], type = ser.type;

            if(ser.isTreeSeries() || type == Constants.WORD_CLOUD_CHART){
                continue;//树图在内部计算
            }

            if(ser.isSeriesAccumulated()){
                if(ser._calculatePercentage){
                    ser._calculatePercentage();
                } else {
                    var key = ser.getTargetKey();
                    _calculatePercentage(ser.points, key);
                    _calculateStackedValue(ser.points, key);
                }
            }else{
                if(ser.visible){
                    ser.points.map(function (p) {
                        var stackKey = [type, ser.stack, p.getCategory()].join('-');
                        stackMap[stackKey] || (stackMap[stackKey] = []);
                        stackMap[stackKey].push(p);
                    });
                }
            }
        }

        for (var stackKey in stackMap) {
            var points = stackMap[stackKey];
            var key = points[0].series.getTargetKey();

            _calculatePercentage(points, key);

            _calculateStackedValue(points, key);
        }

        //百分比确定以后标签也确定了
        for(var i = 0, len = series.length; i < len; i++){
            var sery = series[i];
            sery.points.forEach(function(p){
                sery.calculateLabelInfo(p);
            });
        }
    }

    function _calculateTypePercentage(series) {
        if(series && series.length){
            var allPoints = [];
            series.forEach(function (ser) {
                allPoints = allPoints.concat(ser.points);
            });

            _calculatePercentage(allPoints, series[0].getTargetKey());
        }
    }

    function calculateDelayTime(vanchart, series, type) {
        var sortFunc, easeFunc;

        if(type == Constants.BUBBLE_CHART){
            easeFunc = 'swing';
            sortFunc = function (pointA, pointB) {
                return pointB.radius - pointA.radius;
            }
        } else if(type == Constants.SCATTER_CHART){
            var isInverted = vanchart.isInverted();
            easeFunc = 'exp-in-out';
            sortFunc = function (pA, pB) {
                return isInverted ? pA.posY - pB.posY : pA.posX - pB.posX;
            }
        }

        var allPoints = [];

        series.forEach(function(sery){
            allPoints = allPoints.concat(sery.points);
        });

        allPoints.sort(sortFunc);

        var len = allPoints.length;
        if (len > 0) {
            allPoints.forEach(function (point, i) {
                point.delayTime = BezierEasing.ease(easeFunc)(i/len) * 800;
            });
        }
    }

    function calculateBubbleRadius(bubbleSeries) {
        //要先把各个系列计算半径用的最大最小值算清楚，再去算各个点的半径
        bubbleSeries.forEach(function(sery) {
            sery._calculateMinMax4Radius();
        });

        bubbleSeries.forEach(function (sery) {
            sery._calculateBubbleRadius();
        });
    }

    function _calculateStackedValue(points, key){
        if(points && points.length){

            var series = points[0].series;
            var byPercent = series.options.stackByPercent;
            var stack = series.stack || byPercent;
            var stackAxis = series.getStackAxis();
            var dividingLine = stackAxis && stackAxis.isLog() ? 1 : 0;

            var preSumP = dividingLine, preSumN = dividingLine;

            for(var i = 0, count = points.length; i < count; i++){
                var point = points[i], options = point.options;
                if(stack){
                    var usedValue = byPercent ? point.percentage : point.getTargetValue();
                    if(usedValue >= dividingLine){
                        options[key + '0'] = preSumP;
                        preSumP += usedValue;
                    }else{
                        options[key + '0'] = preSumN;
                        preSumN += usedValue;
                    }
                }else{
                    options[key + '0'] = dividingLine;
                }
            }
        }
    }

    function _calculatePercentage(points, key){
        var total = 0;
        points.filter(function (d) {return !d.isNull && d.visible;})
            .forEach(function(d){
                total += Math.abs(d[key]);
            });

        total = total > 0 ? total : 1;

        points.forEach(function(point){
            var series = point.series, key = series.getTargetKey(), baseAxis = series[series.getBaseAxisType()];
            var temp = !series.stack && baseAxis && baseAxis.type != ComponentLibrary.CATEGORY_AXIS_COMPONENT;
           
            //不堆积，双值轴，百分比为1
            point.percentage = temp ? 1 : Math.abs(point[key]) / total;
        });
    }

    
    function fixCoordinateSystem(vanchart){

        vanchart.bounds = vanchart._getDefaultBounds();

        //组件的布局只有在刷新属性的时候会发生
        ComponentLibrary.ComponentsOrder.map(function (c) {

            //axis layout的时候不去clip vanchart.bounds,这一步的时候认为坐标轴和绘图区是一起的

            if (c in vanchart.components) {
                vanchart.components[c] && vanchart.components[c].doLayout();
            }

        }, this);


        vanchart.plotBounds = vanchart.bounds;//记录一下plotBounds

        //先确定横向宽度, 再更新分类轴的自动旋转和数据表的高度
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisClip();
        });

        // only for axis bounds now
        _cutPlotBounds(vanchart);

        //先确定横向宽度, 再更新分类轴的自动旋转和数据表的高度
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisSizeAndBounds();
        });

        var adjusted = false;
        //先确定横向宽度, 再更新分类轴的自动旋转
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            adjusted = vanchart.components[cName] && vanchart.components[cName].adjustDomain4Radius() || adjusted;
        });

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT,
                    ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.ZOOM_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].fixBoundsByPlot();
        });

        [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT]
            .forEach(function(cName){
                vanchart.components[cName] && vanchart.components[cName].dealOnZero();
            });

        // in case:
        // 'adjustDomain4Radius' adjust yAxis max label 800 -> 1000.
        // Thus yAxis width is changed;
        adjusted && reLayoutPlotBounds(vanchart);

        calculateSeriesShapes(vanchart);
    }


    function reLayoutPlotBounds(vanchart){

        // tmp solution: map has no plotBounds
        if (vanchart.plotBounds) {
            vanchart.bounds = BaseUtils.makeBounds(vanchart.plotBounds, vanchart.plotBounds);
        }

        vanchart.clipPool = {};
        vanchart.axisSize = {
            'left':0, 'right':0, 'bottom':0, 'top':0
        };

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].reCalculateSize();
        });

        //先确定横向宽度, 再更新分类轴的自动旋转和数据表的高度
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisClip();
        });

        // only for axis bounds now
        _cutPlotBounds(vanchart);

        //先确定横向宽度, 再更新分类轴的自动旋转和数据表的高度
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisSizeAndBounds();
        });

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT,
            ComponentLibrary.ZOOM_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].fixBoundsByPlot();
        });

        [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT]
            .forEach(function(cName){
                vanchart.components[cName] && vanchart.components[cName].dealOnZero();
            });
    }

    // compare bounds to check if we need cut more
    function _cutPlotBounds(vanchart) {
        var chartBounds = vanchart.getChartBounds();
        var originBounds = vanchart.bounds;
        var x = originBounds.x;
        var y = originBounds.y;
        var width = originBounds.width;
        var height = originBounds.height;

        var left = Math.max(vanchart.clipPool[Constants.LEFT] || 0, x);
        var right = Math.max(vanchart.clipPool[Constants.RIGHT] || 0, chartBounds.width - (x + width));
        var top = Math.max(vanchart.clipPool[Constants.TOP] || 0, y);
        var bottom = Math.max(vanchart.clipPool[Constants.BOTTOM] || 0, chartBounds.height - (y + height));

        originBounds = {
            x: left,
            y: top,
            width: chartBounds.width - left - right,
            height: chartBounds.height - top - bottom
        };

        vanchart.setPlotBounds(originBounds);
    }
    

    return {
        PLANE_SYSTEM_LAYOUT:PLANE_SYSTEM_LAYOUT,
        reLayoutPlotBounds:reLayoutPlotBounds,
        calculateBubbleRadius:calculateBubbleRadius,
        calculateDelayTime:calculateDelayTime,
        calculateSeries:calculateSeries,
        calculateSeriesShapes:calculateSeriesShapes,
        fixCoordinateSystem:fixCoordinateSystem
    }
});
/**
 * Created by eason on 15/5/4.
 * 注册了的图表的工厂,所有加载的图表模块都在这里注册
 */
define('ChartLibrary',['require'],function(require){
    var _registeredCharts = {};

    /**
     * 根据名字获得某种图表类型的function
     * @param name 图表名字
     */
    function get(name){
        return _registeredCharts[name];
    }

    /**
     * 注册某种图表类型
     * @param name 图表的名字
     * @param chart 图表的实现
     */
    function register(name, chart){
        _registeredCharts[name] = chart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 2017/1/19.
 */


define('utils/Point2D',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    var Point = function (x, y, round) {
        // @property x: Number; The `x` coordinate of the point
        this.x = (round ? Math.round(x) : x);
        // @property y: Number; The `y` coordinate of the point
        this.y = (round ? Math.round(y) : y);
    };

    Point.prototype = {

        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function () {
            return new Point(this.x, this.y);
        },

        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function (point) {
            // non-destructive, returns a new point
            return this.clone()._add(Point.create(point));
        },

        _add: function (point) {
            // destructive, used directly for performance in situations where it's safe to modify existing point
            this.x += point.x;
            this.y += point.y;
            return this;
        },

        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function (point) {
            return this.clone()._subtract(Point.create(point));
        },

        _subtract: function (point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },

        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function (num) {
            return this.clone()._divideBy(num);
        },

        _divideBy: function (num) {
            this.x /= num;
            this.y /= num;
            return this;
        },

        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function (num) {
            return this.clone()._multiplyBy(num);
        },

        _multiplyBy: function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        },

        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function (point) {
            return new Point(this.x * point.x, this.y * point.y);
        },

        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function (point) {
            return new Point(this.x / point.x, this.y / point.y);
        },

        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function () {
            return this.clone()._round();
        },

        _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },

        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function () {
            return this.clone()._floor();
        },

        _floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },

        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function () {
            return this.clone()._ceil();
        },

        _ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },

        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function (point) {
            point = Point.create(point);

            var x = point.x - this.x,
                y = point.y - this.y;

            return Math.sqrt(x * x + y * y);
        },

        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function (point) {
            point = Point.create(point);

            return point.x === this.x &&
                point.y === this.y;
        },

        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function (point) {
            point = Point.create(point);

            return Math.abs(point.x) <= Math.abs(this.x) &&
                Math.abs(point.y) <= Math.abs(this.y);
        },

        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function () {
            return 'Point(' +
                BaseUtils.formatNum(this.x) + ', ' +
                BaseUtils.formatNum(this.y) + ')';
        }
    };

    Point.create = function(x, y, round){
        if (x instanceof Point) {
            return x;
        }
        if (BaseUtils.isArray(x)) {
            return new Point(x[0], x[1]);
        }
        if (x === undefined || x === null) {
            return x;
        }
        if (typeof x === 'object' && 'x' in x && 'y' in x) {
            return new Point(x.x, x.y);
        }
        return new Point(x, y, round);
    };

    return Point;

});
/**
 * Created by eason on 16/5/26.
 */

define('dom/Browser',[],function(){

    var ua = navigator.userAgent.toLowerCase(),
        doc = document.documentElement,

        ie = 'ActiveXObject' in window,

        webkit    = ua.indexOf('webkit') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android23 = ua.search('android [23]') !== -1,
        chrome    = ua.indexOf('chrome') !== -1,
        gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

        win = navigator.platform.indexOf('Win') === 0,

        mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = window.PointerEvent || msPointer,

        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera12 = 'OTransition' in doc.style;


    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
        (window.DocumentTouch && document instanceof window.DocumentTouch));

    return {

        // @property ie: Boolean
        // `true` for all Internet Explorer versions (not Edge).
        ie: ie,

        // @property ielt9: Boolean
        // `true` for Internet Explorer versions less than 9.
        ielt9: ie && !document.addEventListener,

        // @property edge: Boolean
        // `true` for the Edge web browser.
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),

        // @property webkit: Boolean
        // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
        webkit: webkit,

        // @property gecko: Boolean
        // `true` for gecko-based browsers like Firefox.
        gecko: gecko,

        // @property android: Boolean
        // `true` for any browser running on an Android platform.
        android: ua.indexOf('android') !== -1,

        // @property android23: Boolean
        // `true` for browsers running on Android 2 or Android 3.
        android23: android23,

        // @property chrome: Boolean
        // `true` for the Chrome browser.
        chrome: chrome,

        // @property safari: Boolean
        // `true` for the Safari browser.
        safari: !chrome && ua.indexOf('safari') !== -1,


        // @property win: Boolean
        // `true` when the browser is running in a Windows platform
        win: win,


        // @property ie3d: Boolean
        // `true` for all Internet Explorer versions supporting CSS transforms.
        ie3d: ie3d,

        // @property webkit3d: Boolean
        // `true` for webkit-based browsers supporting CSS transforms.
        webkit3d: webkit3d,

        // @property gecko3d: Boolean
        // `true` for gecko-based browsers supporting CSS transforms.
        gecko3d: gecko3d,

        // @property opera12: Boolean
        // `true` for the Opera browser supporting CSS transforms (version 12 or later).
        opera12: opera12,

        // @property any3d: Boolean
        // `true` for all browsers supporting CSS transforms.
        any3d:(ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


        // @property mobile: Boolean
        // `true` for all browsers running in a mobile device.
        mobile: mobile,

        // @property mobileWebkit: Boolean
        // `true` for all webkit-based browsers in a mobile device.
        mobileWebkit: mobile && webkit,

        // @property mobileWebkit3d: Boolean
        // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
        mobileWebkit3d: mobile && webkit3d,

        // @property mobileOpera: Boolean
        // `true` for the Opera browser in a mobile device.
        mobileOpera: mobile && window.opera,

        // @property mobileGecko: Boolean
        // `true` for gecko-based browsers running in a mobile device.
        mobileGecko: mobile && gecko,


        // @property touch: Boolean
        // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
        touch: !!touch,

        // @property msPointer: Boolean
        // `true` for browsers implementing the Microsoft touch events model (notably IE10).
        msPointer: !!msPointer,

        // @property pointer: Boolean
        // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
        pointer: !!pointer,


        // @property retina: Boolean
        // `true` for browsers on a high-resolution "retina" screen.
        retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
    };

});

/**
 * Created by eason on 16/6/1.
 */

define('dom/DomUtils',['require','../utils/BaseUtils','../utils/Point2D','./Browser'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Point = require('../utils/Point2D');
    var Browser = require('./Browser');

    var DomUtils = {
        // @function get(id: String|HTMLElement): HTMLElement
        // Returns an element given its DOM id, or returns the element itself
        // if it was passed directly.
        get: function (id) {
            return typeof id === 'string' ? document.getElementById(id) : id;
        },

        // @function getStyle(el: HTMLElement, styleAttrib: String): String
        // Returns the value for a certain style attribute on an element,
        // including computed values or values set through CSS.
        getStyle: function (el, style) {

            var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

            if ((!value || value === 'auto') && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }

            return value === 'auto' ? null : value;
        },

        // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
        // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
        create: function (tagName, className, container) {

            var el = document.createElement(tagName);
            el.className = className || '';

            if (container) {
                container.appendChild(el);
            }

            return el;
        },

        // @function remove(el: HTMLElement)
        // Removes `el` from its parent element
        remove: function (el) {
            var parent = el.parentNode;
            if (parent) {
                parent.removeChild(el);
            }
        },

        // @function empty(el: HTMLElement)
        // Removes all of `el`'s children elements from `el`
        empty: function (el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        },

        // @function toFront(el: HTMLElement)
        // Makes `el` the last children of its parent, so it renders in front of the other children.
        toFront: function (el) {
            el.parentNode.appendChild(el);
        },

        // @function toBack(el: HTMLElement)
        // Makes `el` the first children of its parent, so it renders back from the other children.
        toBack: function (el) {
            if(el && el.parentNode){
                var parent = el.parentNode;
                parent.insertBefore(el, parent.firstChild);
            }
        },

        // @function hasClass(el: HTMLElement, name: String): Boolean
        // Returns `true` if the element's class attribute contains `name`.
        hasClass: function (el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = DomUtils.getClass(el);
            return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
        },

        // @function addClass(el: HTMLElement, name: String)
        // Adds `name` to the element's class attribute.
        addClass: function (el, name) {
            if (el.classList !== undefined) {
                var classes = BaseUtils.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!DomUtils.hasClass(el, name)) {
                var className = DomUtils.getClass(el);
                DomUtils.setClass(el, (className ? className + ' ' : '') + name);
            }
        },

        // @function removeClass(el: HTMLElement, name: String)
        // Removes `name` from the element's class attribute.
        removeClass: function (el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                DomUtils.setClass(el, BaseUtils.trim((' ' + DomUtils.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
            }
        },

        // @function setClass(el: HTMLElement, name: String)
        // Sets the element's class.
        setClass: function (el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                // in case of SVG element
                el.className.baseVal = name;
            }
        },

        // @function getClass(el: HTMLElement): String
        // Returns the element's class.
        getClass: function (el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },

        // @function setOpacity(el: HTMLElement, opacity: Number)
        // Set the opacity of an element (including old IE support).
        // `opacity` must be a number from `0` to `1`.
        setOpacity: function (el, value) {

            if ('opacity' in el.style) {
                el.style.opacity = value;

            } else if ('filter' in el.style) {
                DomUtils._setOpacityIE(el, value);
            }
        },

        _setOpacityIE: function (el, value) {
            var filter = false,
                filterName = 'DXImageTransform.Microsoft.Alpha';

            // filters collection throws an error if we try to retrieve a filter that doesn't exist
            try {
                filter = el.filters.item(filterName);
            } catch (e) {
                // don't set opacity to 1 if we haven't already set an opacity,
                // it isn't needed and breaks transparent pngs.
                if (value === 1) { return; }
            }

            value = Math.round(value * 100);

            if (filter) {
                filter.Enabled = (value !== 100);
                filter.Opacity = value;
            } else {
                el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
            }
        },

        // @function testProp(props: String[]): String|false
        // Goes through the array of style names and returns the first name
        // that is a valid style name for an element. If no such name is found,
        // it returns false. Useful for vendor-prefixed styles like `transform`.
        testProp: function (props) {

            var style = document.documentElement.style;

            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },

        // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
        // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
        // and optionally scaled by `scale`. Does not have an effect if the
        // browser doesn't support 3D CSS transforms.
        setTransform: function (el, offset, scale) {
            var pos = offset || {x:0, y:0};

            el.style[DomUtils.TRANSFORM] =
                (Browser.ie3d ?
                'translate(' + pos.x + 'px,' + pos.y + 'px)' :
                'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
                (scale ? ' scale(' + scale + ')' : '');
        },

        // @function setPosition(el: HTMLElement, position: Point)
        // Sets the position of `el` to coordinates specified by `position`,
        // using CSS translate or top/left positioning depending on the browser
        // (used by Leaflet internally to position its layers).
        setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

            /*eslint-disable */
            el._leaflet_pos = point;
            /*eslint-enable */

            if (Browser.any3d) {
                DomUtils.setTransform(el, point);
            } else {
                el.style.left = point.x + 'px';
                el.style.top = point.y + 'px';
            }
        },

        // @function getPosition(el: HTMLElement): Point
        // Returns the coordinates of an element previously positioned with setPosition.
        getPosition: function (el) {
            // this method is only used for elements previously positioned using setPosition,
            // so it's safe to cache the position for performance
            return el._leaflet_pos || Point.create({x:0, y:0});
        },

        getMousePos:function(event, el){
            event = event.touches ?  (event.touches.length ? event.touches[0] : event.changedTouches[0]) : event;
            var docElem = document.documentElement,
                box = el.getBoundingClientRect();

            var top = box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0);
            var left = box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0);

            var chartX, chartY;
            if (event.pageX == null) {
                chartX = Math.min(event.x, event.clientX - left);
                chartY = Math.min(event.y, event.clientY - top);
            } else {
                chartX = event.pageX - left;
                chartY = event.pageY - top;
            }

            return Point.create(chartX, chartY);
        },

        // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
        // and Firefox scrolls device pixels, not CSS pixels
        _wheelPxFactor: (Browser.win && Browser.chrome) ? 2 :
            Browser.gecko ? window.devicePixelRatio :
                1,

        // @function getWheelDelta(ev: DOMEvent): Number
        // Gets normalized wheel delta from a mousewheel DOM event, in vertical
        // pixels scrolled (negative if scrolling down).
        // Events from pointing devices without precise scrolling are mapped to
        // a best guess of 60 pixels.
        getWheelDelta: function (e) {
            return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
                (e.deltaY && e.deltaMode === 0) ? -e.deltaY / DomUtils._wheelPxFactor : // Pixels
                    (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
                        (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
                            (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
                                e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                                    (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
                                        e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
                                            0;
        },

        preventDefault: function (e) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },

        stopPropagation: function (e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
            return this;
        },

        stop: function (e) {
            return DomUtils
                .preventDefault(e)
                .stopPropagation(e);
        },

        attr: function () {
            if(arguments.length < 2){
                return;
            }
            var elem = arguments[0], prop = arguments[1], value = arguments[2];
            var key, ret;
            if (typeof prop == 'string') {
                // set the value
                if (BaseUtils.hasDefined(value)) {
                    elem.setAttribute(prop, value);
                    // get the value
                } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                    ret = elem.getAttribute(prop);
                }
                // else if prop is defined, it is a hash of key/value pairs
            } else if (BaseUtils.hasDefined(prop) && typeof prop == 'object') {
                for (key in prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            return ret;
        }
    };

    (function () {
        // prefix style property names

        // @property TRANSFORM: String
        // Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
        DomUtils.TRANSFORM = DomUtils.testProp(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

        DomUtils.TRANSFORM_ORIGIN = DomUtils.testProp(
            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);


        // webkitTransition comes first because some browser versions that drop vendor prefix don't do
        // the same for the transitionend event, in particular the Android 4.1 stock browser

        // @property TRANSITION: String
        // Vendor-prefixed transform style name.
        var transition = DomUtils.TRANSITION = DomUtils.testProp(
            ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

        DomUtils.TRANSITION_END =
            transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

    })();

    return DomUtils;
});
/**
 * Created by eason on 16/7/28.
 * 用hammer.js来封装我们的事件,这样可以统一处理移动端的问题
 */
/**
 * Created by eason on 16/2/19.
 * 处理事件
 */

define('HammerHandler',['require','./utils/BaseUtils','./dom/DomUtils','./Constants','./dom/Evented','./ComponentLibrary'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var DomUtils = require('./dom/DomUtils');
    var Constants = require('./Constants');
    var Evented = require('./dom/Evented');
    var ComponentLibrary = require('./ComponentLibrary');

    var isMobile = BaseUtils.hasTouch();

    // normalizeWheel
    var PIXEL_STEP  = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;

    // states
    var RESIZE_END = null,
        RESIZE_START = 1,
        GANTT_PAN_END = null,
        GANTT_PAN_START = 2;

    var mobileHoverTimer,    
        MOBILE_HOVER_HIDE_DELAY = 4000;

    var Handler = Evented.extend({

        initialize:function(vanchart, container){
            this.vanchart = vanchart;
            this._container = container;
            this._state = null;

            var hammer = this.hammer = new VanHammer.Manager(container, {_handler:this});
            
            hammer.add(new VanHammer.Pan({threshold: 0}));

            hammer.add(new VanHammer.Tap());

            //ie下不支持点击效果
            if(BaseUtils.isSupportSVG()){
                hammer.add(new VanHammer.Press());
            }

            hammer.on("panstart panmove panend tap press pressup", fireDOMEvent);

            //对于鼠标还要处理悬浮的情况
            if(!isMobile){
                hammer.on('mouseover mousemove mouseout wheel', fireDOMEvent);
            }

            if(vanchart.isMap() && vanchart._zoomEnabled()){
                hammer.add(new VanHammer.Pinch());
                hammer.on('pinchstart pinchmove', fireDOMEvent);
            }

            var rootHandler = this;
            var rootTarget = vanchart.isMap() ? vanchart : rootHandler;
            this.panTarget = null;
            rootHandler.on(rootHandler.getEvents());

            /**
             * 判断事件是否需要向上冒泡
             * @param ele  触发事件的元素
             * @param type 事件类型
             */
            var needPropagateEvent = function (ele, type){
                // 图例的滚轮事件不需要向上传播，否则可能和地图的滚轮事件冲突
                if(ele.componentType === ComponentLibrary.LEGEND_COMPONENT && type === "wheel"){
                    return false;
                }

                return true;
            };

            function fireDOMEvent(ev){
                var srcEvent = ev.srcEvent, type = ev.type || srcEvent.type;

                type = (type.indexOf('wheel') != -1) ? 'wheel' : type;

                var src = srcEvent.target || srcEvent.srcElement;
                ev.containerPoint = DomUtils.getMousePos(srcEvent, container);

                var isHover = type === 'tap' || type === 'mouseover' || type == 'mouseout';
                var isPan = type == 'panstart' || type == 'panmove' || type == 'panend';

                //移动端上需要长按以后才能响应事件
                if(isMobile && vanchart.chartType() !== Constants.GANTT_CHART){
                    if(type == 'press'){
                        rootHandler.pressed = true;
                    }else if(type != 'panstart' && type != 'panmove'){
                        rootHandler.pressed = false;
                    }
                }else{
                    rootHandler.pressed = true;
                }

                var target;
                if(isPan && rootHandler.panTarget){
                    target = rootHandler.panTarget;
                }else{
                    while (src) {

                        // CHART-1071
                        // 把linemap视为最上层
                        // 优先响应
                        if (type === 'tap'
                            && rootTarget._lineMapLayer
                            && rootTarget._lineMapLayer.hoverPoint) {
                            target = rootTarget._lineMapLayer.hoverPoint;
                            break;
                        }

                        if(!(target = rootHandler._findTargetByBounds(ev.containerPoint, type))){
                            target = vanchart.findInteractiveTarget(src);
                        }

                        if ((target && target.listens(type, false)) || (src === rootHandler._container)) {
                            break;
                        }

                        src = src.parentNode;
                    }

                    target = target && target.listens(type, false) ? target : rootTarget;
                }

                if(vanchart.force && !rootHandler.panTarget){
                    rootHandler.forceTarget = vanchart.force.dragFire(ev, rootHandler._container);
                }

                if (target && target.listens(type, false)){

                    target.fire(type, ev, needPropagateEvent(target, type));

                    if(type == 'panstart'){

                        rootHandler.removeAllChosen(ev);

                        if(!rootHandler.forceTarget) {
                            rootHandler.panTarget = target;
                        }
                    } else if(type == 'panend'){
                        rootHandler.panTarget = null;
                    }

                    if(isMobile && type === "tap") {
                        clearTimeout(mobileHoverTimer);
                        mobileHoverTimer = setTimeout(function () {
                            rootHandler.removeAllChosen(ev);
                        }, MOBILE_HOVER_HIDE_DELAY);
                    }
                }
            }
        },

        //通过区域来判断target
        _findTargetByBounds:function(containerPoint, type){

            var vanchart = this.vanchart, series = vanchart.series, plotBounds = vanchart.bounds;
            var legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            legend = legend || rangeLegend;

            //图例,范围图例
            if((type == 'panstart' || type == 'wheel') && legend && legend.bounds && BaseUtils.containsPoint(legend.bounds, containerPoint)){
                return legend;
            }

            //只在绘图区域找仪表盘相关的对象
            if(BaseUtils.containsPoint(plotBounds, containerPoint)){
                return;
            }

            //仪表盘
            var gaugeSeries = vanchart.seriesOfType(Constants.GAUGE_CHART);

            if(gaugeSeries && gaugeSeries.length){

                for(var i = 0, len = gaugeSeries.length; i < len; i++){
                    var gauge = gaugeSeries[i];

                    if(gauge.bounds && BaseUtils.containsPoint(gauge.bounds, containerPoint)){
                        return gauge;
                    }

                }
            }

        },

        cursor: function (cursor) {
            this._container.style.cursor = cursor || '';
            this.vanchart.bindIEDragCursor && this.vanchart.bindIEDragCursor();  // IE下地图的手型还需要特殊处理一下
        },

        onContainerMouseOver:function(ev){

        },

        //鼠标在绘图区域里的操作
        onContainerMouseMove:function(ev){
            var plotBounds = this.vanchart.bounds, vanchart = this.vanchart, renderer = vanchart.renderer;

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (vanchart.isResizeEnabled()) {
                    if (BaseUtils.containsPoint(vanchart.resizeBounds, ev.containerPoint)) {
                        this.cursor('col-resize');
                        // mouse
                        this._state = RESIZE_START;
                        this.fire('resizeStart', ev);
                    } else
                    if (this._state === RESIZE_START) {
                        this.cursor();
                        this._state = RESIZE_END;
                        this.fire('resizeEnd', ev);
                    }
                }
                this.fire('over', ev);

                if (this._state === RESIZE_START) {
                    return
                }
            }

            var legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            if(legend && legend.bounds){
                legend.fire(BaseUtils.containsPoint(legend.bounds, ev.containerPoint) ? 'mouseover' : 'mouseout', ev);
            }

            //鼠标在绘图区空白区域悬浮时,需要响应一下按照范围选中的点
            if(BaseUtils.containsPoint(plotBounds, ev.containerPoint)){

                var event = ev.srcEvent, src = event.target || event.srcElement;

                this.cursor();

                if(!this._highlightShared(ev)){
                    this._removeHightlight(ev);
                    var closestPoint;

                    if(vanchart.isLargeMode() && !vanchart.hoverSeries){//canvas
                        closestPoint = this._getCanvasClosestPoint(ev.containerPoint);
                        if(closestPoint){
                            if(!closestPoint._events){
                                closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                            }
                            vanchart.showTooltip(closestPoint, ev);
                            vanchart.hoverPoint = closestPoint;
                            if (closestPoint.options.click) {
                                this.cursor('pointer');
                            }
                        }
                    }else if(vanchart.hoverSeries){
                        closestPoint = vanchart.hoverSeries.getClosestPoint(ev.containerPoint);
                        if(closestPoint){

                            vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
                            closestPoint.fire('mouseover', ev);
                            vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);

                            if (closestPoint.options.click) {
                                this.cursor('pointer');
                            }
                        }
                    }
                }
            }else{
                this.removeAllChosen(ev);
            }
        },

        removeAllChosen: function (ev) {
            //移出绘图区的时候取消所有的选中状态
            var vanchart = this.vanchart,
                toolbar = vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT],
                toolbarBounds = toolbar.getToolbarBounds(),
                mouseInToolbarBounds = ev ? BaseUtils.containsPoint(toolbarBounds, ev.containerPoint) && toolbar.needTooltip() : false;   // 全屏时候传进来的ev是undefined ？

            this._removeHightlight(ev);

            if(vanchart.hoverPoint){
                vanchart.hoverPoint.fire('mouseout', ev);
                vanchart.hoverPoint = null;
            }

            if(vanchart.hoverSeries){
                vanchart.hoverSeries.fire('seriesUnChosen', ev);
                vanchart.hoverSeries = null;
            }

            var tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);

            if(tooltip && vanchart.vanChartType !== 'vanChartMap' && !mouseInToolbarBounds){
                tooltip.immediateHide();
            }

            ev && vanchart.cancelLegendHighlight(ev.containerPoint);
        },

        _getCanvasClosestPoint:function(containerPoint){
            var vanchart = this.vanchart;
            var series = vanchart.seriesOfType(Constants.BUBBLE_CHART).concat(vanchart.seriesOfType(Constants.SCATTER_CHART));

            var isMap = vanchart.isMap(), heatSeries = vanchart.seriesOfType(Constants.HEAT_MAP);
            series = series.concat(heatSeries);

            var plotBounds = this.vanchart.bounds;

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var pointPos = (isMap && point.options.lnglat) ? vanchart.latLngToContainerPoint(point.getLatLng()) : {x:point.posX + plotBounds.x, y:point.posY + plotBounds.y};

                    var detX = pointPos.x  - containerPoint.x;

                    var detY = pointPos.y  - containerPoint.y;

                    var len = Math.sqrt(detX * detX + detY * detY);

                    var radius = point.radius || (point.options.marker && point.options.marker.radius) || 4.5;

                    if(len <= radius && point.visible){
                        return point;
                    }
                }
            }
        },

        onContainerMouseOut:function(ev){

        },

        onContainerTap:function(ev){
            this.onContainerMouseMove(ev);
            var p = this.vanchart.hoverPoint;

            p && p.fire('tap', ev);

        },

        onContainerPanStart:function(ev){
            if(this.forceTarget){
                return;//力学拖拽
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer, mousePos = ev.containerPoint;
            var plotBounds = vanchart.bounds;

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (BaseUtils.containsPoint(vanchart.resizeBounds, mousePos)) {
                    this._state = RESIZE_START;
                    this.fire('resizeStart', ev);
                } else
                if (!this._state && BaseUtils.containsPoint(vanchart.panBounds, mousePos)) {
                    this._state = GANTT_PAN_START;
                    this.fire('pan', ev);
                }
                return
            }

            //缩放
            if(!this.selectRect && this._supportCoordinateZoom() && BaseUtils.containsPoint(plotBounds, mousePos)){
                this.selectRect = renderer.rect().style({'fill':'rgb(69,114,167)', 'fill-opacity':0.25}).add();
                this.downPos = mousePos;

                vanchart.hoverPoint && vanchart.hoverPoint.fire('mouseout');
            }

            //在绘图区和数据表里面拖拽也生效
            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(this._zoomAsTarget(zoom, mousePos)){
                zoom._panStart(ev, zoom.centerRect);
            }

        },

        _zoomAsTarget:function(zoom, mousePos){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, validPos = false;
            var dataSheet = vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
            if(dataSheet){
                validPos = BaseUtils.containsPoint(dataSheet.bounds, mousePos);
            }
            validPos = validPos || BaseUtils.containsPoint(plotBounds, mousePos);

            return zoom && zoom.zoomToolEnabled() && validPos;
        },

        onContainerPanMove:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.options;
            var mousePos = ev.containerPoint, downPos = this.downPos;
            var inverted = vanchart.isInverted();

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (BaseUtils.containsPoint(this.vanchart.panBounds, mousePos)) {
                    if (this._state === RESIZE_START) {
                        this.fire('resizeMove', ev);
                    } else
                    if (this._state === GANTT_PAN_START) {
                        this.fire('pan', ev);
                    }
                }
                return
            }

            if(this.selectRect){
                var zoomType = options.zoom.zoomType;
                var x = Math.min(mousePos.x, downPos.x);
                var y = Math.min(mousePos.y, downPos.y);
                var width = Math.abs(mousePos.x - downPos.x);
                var height = Math.abs(mousePos.y - downPos.y);

                var isXZoom = zoomType.indexOf('x') != -1;
                var isYZoom = zoomType.indexOf('y') != -1;

                if(inverted){
                    isXZoom = zoomType.indexOf('y') != -1;
                    isYZoom = zoomType.indexOf('x') != -1;
                }

                if(isXZoom && !isYZoom){
                    y = plotBounds.y;
                    height = plotBounds.height;
                }else if(isYZoom && !isXZoom){
                    x = plotBounds.x;
                    width = plotBounds.width;
                }
                this.selectRect.attr({x:x, y:y, width:width, height:height});
            }


            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled()){
                zoom._panContainerMove(ev);
            }

        },

        onContainerPanEnd:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.options;
            var mousePos = ev.containerPoint, downPos = this.downPos;
            var toolbar = vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];

            // 缩放图表的时候移除MoreLabel 
            vanchart.removeMoreLabel(); 

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (this._state === RESIZE_START) {
                    this._state = RESIZE_END;
                    this.fire('resizeEnd', ev);
                } else
                if (this._state === GANTT_PAN_START) {
                    this._state = GANTT_PAN_END;
                    this.fire('pan', ev);
                }
                return
            }

            if(this.selectRect){
                //兼容一些微小的误操作,14约等于10*1.414
                if(BaseUtils.distance(downPos, mousePos) > 14){
                    vanchart.clearAllEffects();
                    vanchart.dealAxisZoom(downPos, mousePos);
                    toolbar && toolbar.showRefreshIconWhenZoom();
                }

                this.selectRect.remove();
                this.selectRect = null;
            }

            this.panTarget = null;

            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled()){
                zoom._panEnd();
            }
        },

        onContainerWheel:function (ev) {

            // preventDefault all wheel events ?

            var vanchart = this.vanchart;

            if (vanchart.chartType() === Constants.GANTT_CHART
                && BaseUtils.containsPoint(vanchart.panBounds, ev.containerPoint)) {

                // `event` is global in IE8
                ev.preventDefault ? ev.preventDefault() : (event.returnValue = false);
                ev.wheel = this.normalizeWheel(ev.srcEvent);

                this.fire('wheelMove', ev);

            }

        },

        _highlightShared: function (event) {

            var axis = this.vanchart.getSharedAxis();

            if(axis && axis.getPointsInCategory){
                var pos = event.containerPoint;
                var catePoints = axis.getPointsInCategory(pos);
                if (catePoints && catePoints.length) {
                    catePoints[0]._onPointMouseOver.call(catePoints[0], event);
                    axis.drawHighlightBackground(catePoints);
                    this.vanchart.showSharedTooltip(catePoints[0], event);
                    return true;
                }
            }

            return false;
        },

        _removeHightlight: function (ev) {
            var vanchart = this.vanchart, axis = vanchart.getSharedAxis(), hoverPoints = vanchart.hoverPoints;

            axis && axis.removeHighlightBackground && axis.removeHighlightBackground();

            hoverPoints && hoverPoints.length && hoverPoints[0]._onPointMouseOut.call(hoverPoints[0], ev);

            vanchart.hoverPoints = null;
        },

        getEvents:function(){
            return {
                'mouseover':this.onContainerMouseOver,
                'mousemove':this.onContainerMouseMove,
                'mouseout':this.onContainerMouseOut,

                'tap':this.onContainerTap,
                'panstart':this.onContainerPanStart,
                'panmove':this.onContainerPanMove,
                'panend':this.onContainerPanEnd,

                'wheel':this.onContainerWheel
            };
        },

        _supportCoordinateZoom:function(){
            var isForceBubble = this.vanchart.hoverPoint && this.vanchart.vanChartType == 'vanChartForceBubble';
            var option = this.vanchart.options;
            return BaseUtils.isSupportSVG() && option.zoom && option.zoom.zoomType && !isForceBubble;
        },

        destroy: function () {
            this.hammer.destroy();
        },

        _inZoomBar:function(containerPoint){
            var zoomBar = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            return zoomBar && zoomBar.bounds && BaseUtils.containsPoint(zoomBar.bounds, containerPoint);
        },

        //判断是否需要阻止浏览器默认行为
        //如果是pressed状态或者位置在缩放控件内，则阻止浏览器默认行为
        preventDefault:function(input){
            var srcEvent = input.srcEvent;
            var src = srcEvent.target || srcEvent.srcElement;
            var containerPoint = DomUtils.getMousePos(srcEvent, this._container);

            var prevent = this.pressed || this._inZoomBar(containerPoint);
            var zoom = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(!prevent && zoom){
                prevent = zoom.target || this._zoomAsTarget(zoom, containerPoint);
                // 这边有个特殊的情况，值得考虑一下，默认的input.angle应该是Math.atan((p2.y - p1.y) / (p2.x - p1.x))
                // 但是如果浏览器默认的default为页面滚动，那么第一次panMove触发的input.angle为90度，这时prevent为false
                // 接着触发浏览器默认滚动，而之后的input计算angle的时候p2 = p1即位置手指相对页面的位置没变，那么这时angle就为0
                // 从而把prevent有设置成true,而又阻止了浏览器默认事件，然后就是反复的允许和阻止，从而导致页面的默认滚动不能进行
                prevent = prevent && (Math.abs(input.angle) < 45 || Math.abs(input.angle) > 135) && input.angle != 0;
            }

            if(this.vanchart.isMap()){
                prevent = this.vanchart._zoomEnabled() && src.nodeName != 'A';
            };

            if (this.vanchart.chartType() === Constants.GANTT_CHART) {
                prevent = BaseUtils.containsPoint(this.vanchart.panBounds, containerPoint)
            }

            // #touchActionAndriod
            if (prevent) {
                this.hammer.touchAction.setTouchActionNone();
            } else {
                this.hammer.touchAction.recoverTouchAction();
            }

            return prevent;
        },

        // worth reading:
        // https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
        //
        normalizeWheel: function normalizeWheel(/*object*/ event) /*object*/ {
            var sX = 0, sY = 0,       // spinX, spinY
                pX = 0, pY = 0;       // pixelX, pixelY

            // Legacy
            if ('detail'      in event) { sY = event.detail; }
            if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
            if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
            if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

            // side scrolling on FF with DOMMouseScroll
            if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
                sX = sY;
                sY = 0;
            }

            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;

            if ('deltaY' in event) { pY = event.deltaY; }
            if ('deltaX' in event) { pX = event.deltaX; }

            if ((pX || pY) && event.deltaMode) {
                if (event.deltaMode === 1) {          // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {                             // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }

            // Fall-back if spin cannot be determined
            if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
            if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

            return { spinX  : sX,
                spinY  : sY,
                pixelX : pX,
                pixelY : pY };
        }
    });

    return Handler;
});
/**
 * Created by eason on 2017/1/20.
 */

define('vector/Layer',['require','../dom/Evented','../utils/BaseUtils'],function(require){

    var Evented = require('../dom/Evented');
    var BaseUtils = require('../utils/BaseUtils');

    var Layer = Evented.extend({
        options: {
            pane: 'overlayPane',
            nonBubblingEvents: []
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        remove: function () {
            return this.removeFrom(this._map || this._mapToAdd);
        },

        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        removeFrom: function (obj) {
            if (obj) {
                obj.removeLayer(this);
            }
            return this;
        },

        // 默认的移除layer的方法，需要移除动画的可以重写改方法
        exitAnimate: function (vanchart){
            var layer = this, group = vanchart._pointLayer;
            group.remove(layer);
        },

        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function (name) {
            return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
        },

        beforeAdd: function (map) {
            // Renderer is set here because we need to call renderer.getEvents
            // before this.getEvents.
            this._renderer = map.getMapRenderer(this);
        },

        _layerAdd: function (e) {
            var map = e.target;

            // check in case layer gets added and then removed before the map is ready
            if (!map.hasLayer(this)) { return; }

            this._map = map;
            this._zoomAnimated = map._zoomAnimated;

            if (this.getEvents) {
                var events = this.getEvents();
                map.on(events, this);
                this.once('remove', function () {
                    map.off(events, this);
                }, this);
            }
            this.onAdd(map);
        },

        _reset:BaseUtils.falseFn,
        _project:BaseUtils.falseFn,
        _update:BaseUtils.falseFn
    });

    return Layer;
});
/**
 * Created by eason on 2017/1/19.
 */
define('utils/Bounds',['require','./Point2D'],function(require){
    var Point = require('./Point2D');

    var Bounds = function (a, b) {
        if (!a) { return; }

        var points = b ? [a, b] : a;

        for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
        }
    };

    Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        extend: function (point) { // (Point)
            point = Point.create(point);

            // @property min: Point
            // The top left corner of the rectangle.
            // @property max: Point
            // The bottom right corner of the rectangle.
            if (!this.min && !this.max) {
                this.min = point.clone();
                this.max = point.clone();
            } else {
                this.min.x = Math.min(point.x, this.min.x);
                this.max.x = Math.max(point.x, this.max.x);
                this.min.y = Math.min(point.y, this.min.y);
                this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
        },

        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function (round) {
            return new Point(
                (this.min.x + this.max.x) / 2,
                (this.min.y + this.max.y) / 2, round);
        },

        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function () {
            return new Point(this.min.x, this.max.y);
        },

        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function () { // -> Point
            return new Point(this.max.x, this.min.y);
        },

        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function () {
            return this.max.subtract(this.min);
        },

        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function (obj) {
            var min, max;

            if (typeof obj[0] === 'number' || obj instanceof Point) {
                obj = Point.create(obj);
            } else {
                obj = Bounds.create(obj);
            }

            if (obj instanceof Bounds) {
                min = obj.min;
                max = obj.max;
            } else {
                min = max = obj;
            }

            return (min.x >= this.min.x) &&
                (max.x <= this.max.x) &&
                (min.y >= this.min.y) &&
                (max.y <= this.max.y);
        },

        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function (bounds) { // (Bounds) -> Boolean
            bounds = Bounds.create(bounds);

            var min = this.min,
                max = this.max,
                min2 = bounds.min,
                max2 = bounds.max,
                xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
                yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

            return xIntersects && yIntersects;
        },

        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function (bounds) { // (Bounds) -> Boolean
            bounds = Bounds.create(bounds);

            var min = this.min,
                max = this.max,
                min2 = bounds.min,
                max2 = bounds.max,
                xOverlaps = (max2.x > min.x) && (min2.x < max.x),
                yOverlaps = (max2.y > min.y) && (min2.y < max.y);

            return xOverlaps && yOverlaps;
        },

        isValid: function () {
            return !!(this.min && this.max);
        }
    };

    Bounds.create = function(a, b){
        if (!a || a instanceof Bounds) {
            return a;
        }
        return new Bounds(a, b);
    };

    return Bounds;
});
/**
 * Created by eason on 2017/2/15.
 */
define('utils/Timer',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    //timer的定义
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = BaseUtils.requestAnimFrame;

    var timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) {
            delay = 0;
        }
        if (n < 3) {
            then = Date.now();
        }
        var time = then + delay, timer = {
            c: callback,
            t: time,
            f: false,
            n: null
        };
        if (d3_timer_queueTail){
            d3_timer_queueTail.n = timer;
        }else {
            d3_timer_queueHead = timer;
        }
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }

    timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };

    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t) {
                d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            }
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }

    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time) {
                    time = t1.t;
                }
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    };

    timer.getActiveTimer = function(){
        return d3_timer_active;
    };

    return timer;
});
/**
 * Created by eason on 2017/2/14.
 */

define('utils/Interpolator',['require','./ColorUtils'],function(require){
    var ColorUtils = require('./ColorUtils');

    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");

    function interpolate(a, b){
        var t = typeof b;
        return (t === "string" ? ColorUtils.hasColorName(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    }

    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }

    function d3_interpolateRgb(a, b) {

        a = (a == 'none' || a == '') ? b : a;

        a = ColorUtils.getRGBAColorArray(a);
        b = ColorUtils.getRGBAColorArray(b);
        var ar = a[0], ag = a[1], ab = a[2], br = b[0] - ar, bg = b[1] - ag, bb = b[2] - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }

    function checkMatrixTransform(string) {
        var trans = string.match(/matrix\((\d+\.?\d*|\.?\d+), 0, 0, (\d+\.?\d*|\.?\d+), ([-+]?\d+\.?\d*|\.?\d+), ([-+]?\d+\.?\d*|\.?\d+)\)/);
        return trans ? "translate(" + trans[3] + "px," + trans[4] + "px)scale(" + trans[1] + ")" : string;
    }
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + ""; b = b + "";
        a = checkMatrixTransform(a);b = checkMatrixTransform(b);
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) {
                    s[i] += bs;
                } else {
                    s[++i] = bs;
                }
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) {
                    s[i] += bm;
                } else {
                    s[++i] = bm;
                }
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) {
                s[i] += bs;
            } else {
                s[++i] = bs;
            }
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) {
                s[(o = q[i]).i] = o.x(t);
            }
            return s.join("");
        });
    }

    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) {
                c[k] = i[k](t);
            }
            return c;
        };
    }

    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }

    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) {
            x.push(interpolate(a[i], b[i]));
        }
        for (;i < na; ++i) {
            c[i] = a[i];
        }
        for (;i < nb; ++i) {
            c[i] = b[i];
        }
        return function(t) {
            for (i = 0; i < n0; ++i) {
                c[i] = x[i](t);
            }
            return c;
        };
    }

    function transform(string) {
        var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        return (transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    }

    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * 180 / Math.PI;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * 180 / Math.PI : 0;
    }

    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    }

    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }

    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };

    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = transform(a), B = transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180) {
                rb += 360;
            } else if (rb - ra > 180) {
                ra += 360;
            }
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n) {
                s[(o = q[i]).i] = o.x(t);
            }
            return s.join("");
        };
    }

    interpolate.identity = function(d){
        return d;
    };

    interpolate.interpolateRound = function(a, b){
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    };

    interpolate.uninterpolateNumber = function (a, b){
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    };

    interpolate.interpolateNumber = function (a, b){
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    };

    interpolate.interpolate = interpolate;
    interpolate.interpolateRgb = d3_interpolateRgb;
    interpolate.interpolateTransform = d3_interpolateTransform;
    interpolate.interpolateArray = d3_interpolateArray;

    return interpolate;
});
/**
 * Created by eason on 2017/2/15.
 */
define('vector/Transition',['require','../utils/BaseUtils','../utils/Timer','../utils/vMap','../utils/Interpolator','../utils/BezierEasing'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Timer = require('../utils/Timer');
    var vMap = require('../utils/vMap');
    var Interpolator = require('../utils/Interpolator');
    var BezierEasing = require('../utils/BezierEasing');
    var isSupportSVG = BaseUtils.isSupportSVG();

    var d3_transitionId = 0;

    var Transition = function(elW, name, transition, noAnimation){
        var id = nextTransitionID(), ns = d3_transitionNamespace(name);

        transition = transition || {
                time: Date.now(),
                // do not know why, css.linear is wrong
                ease: BezierEasing.ease('linear'),
                delay: 0,
                duration: 250
            };

        if(!elW.node){//for elw not elementWrapper but element
            elW.node = function () {
                return elW;
            }
        }
        this.noAnimation = noAnimation || !isSupportSVG;
        if (noAnimation) {
            transition.time = 0;
        }

        d3_transitionNode(elW.node(), ns, id, transition);

        this.elW = elW;
        this.namespace = ns;
        this.id = id;
    };

    BaseUtils.extend(Transition.prototype, {

        setAnimation:function(para){
            for(var key in para){
                this[key] && this[key](para[key]);
            }

            return this;
        },

        /**
         * !!!consider VML
         * @param name
         * @param tween !!!consider VML
         * @returns {*}
         */
        tween:function(name, tween){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 2) {
                return node[ns][id].tween.get(name);
            }
            tween == null ? node[ns][id].tween.remove(name)
                                        : node[ns][id].tween.set(name, tween);

            return this;
        },

        attr:function(nameNS, value){
            if (arguments.length < 2) {
                for (value in nameNS){
                    this.attr(value, nameNS[value]);
                }
                return this;
            }

            if (this.noAnimation) {
                this.elW.attr(nameNS, value);
                return this;
            }

            var interpolate = nameNS == "transform" ? Interpolator.interpolateTransform : Interpolator, name = nameNS;
            function attrNull() {
                this.removeAttribute(name);
            }
            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local);
            }
            function attrTween(b) {
                return b == null ? attrNull : (b += "", function() {
                    var a = this.getAttribute(name), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttribute(name, i(t));
                        });
                });
            }
            function attrTweenNS(b) {
                return b == null ? attrNullNS : (b += "", function() {
                    var a = this.getAttributeNS(name.space, name.local), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttributeNS(name.space, name.local, i(t));
                        });
                });
            }
            return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        },

        attrTween:function(nameNS, tween){

            if (arguments.length < 2) {
                for (tween in nameNS){
                    this.attrTween(tween, nameNS[tween]);
                }
                return this;
            }

            var name = nameNS;

            if (this.noAnimation) {
                var f = tween.call(this.elW.node());
                this.elW.attr(name, f(1));
                return this;
            }

            function attrTween(d, i) {
                var f = tween.call(this, d, i, this.getAttribute(name));
                return f && function(t) {
                        this.setAttribute(name, f(t));
                    };
            }
            function attrTweenNS(d, i) {
                var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                return f && function(t) {
                        this.setAttributeNS(name.space, name.local, f(t));
                    };
            }
            return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        },

        style:function(name, value, priority){
            var n = arguments.length;
            if (n < 3) {
                if (typeof name !== "string") {
                    if (n < 2){
                        value = "";
                    }
                    for (priority in name){
                        this.style(priority, name[priority], value);
                    }
                    return this;
                }
                priority = "";
            }

            if (this.noAnimation) {
                this.elW.style && this.elW.style(name, value);
                return this;
            }

            function styleNull() {
                this.style.removeProperty(name);
            }
            function styleString(b) {
                return b == null ? styleNull : (b += "", function() {
                        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                        return a !== b && (i = Interpolator(a, b), function(t) {
                            this.style.setProperty(name, i(t), priority);
                        });
                });
            }
            return d3_transition_tween(this, "style." + name, value, styleString);
        },

        styleTween:function(name, tween, priority){
            if (arguments.length < 3){
                priority = "";
            }

            if (this.noAnimation) {
                var f = tween.call(this.elW.node());
                this.elW.style(name, f(1));
                return this;
            }

            function styleTween(d, i) {
                var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
                return f && function(t) {
                        this.style.setProperty(name, f(t), priority);
                    };
            }
            return this.tween("style." + name, styleTween);
        },

        remove:function(){
            var ns = this.namespace;
            return this.each("end.transition", function() {
                var p;
                if (this[ns].count < 2 && (p = this.parentNode)) {
                    p.removeChild(this);
                }
            });
        },

        each:function(type, listener){
            var node = this.elW.node(), id = this.id, ns = this.namespace;
            var transition = node[ns][id];
            (transition.event || (transition.event = BaseUtils.dispatch("start", "end", "interrupt"))).on(type, listener);
            return this;
        },

        ease:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].ease;
            }

            if (typeof value !== "function") {
                value = BezierEasing.ease.apply(null, arguments)
            }

            node[ns][id].ease = value;
            return this;
        },

        delay:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].delay;
            }

            value = +value;
            node[ns][id].delay = value;

            return this;
        },

        duration:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].duration;
            }
            value = Math.max(1, value);
            node[ns][id].duration = value;
            return this;
        },

        transition:function(para){
            var id0 = this.id, ns = this.namespace, node = this.elW.node();
            var transition = node[ns][id0];

            return new Transition(this.elW, ns, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
            }, this.noAnimation).setAnimation(para);
        },

        animate:function(para){
            return this.setAnimation(para);
        }
    });

    function d3_transition_tween(transition, name, value, tween) {
        var id = transition.id, ns = transition.namespace, value = tween(value);
        transition.elW.node()[ns][id].tween.set(name, value);
        return transition;
    }

    function d3_transitionNode(node, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new vMap(),
                time: time,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease
            };
            inherit = null;
            ++lock.count;
            Timer(function(elapsed) {
                var delay = transition.delay, duration, ease, timer = Timer.getActiveTimer(), tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed) {
                    return start(elapsed - delay);
                }
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id) {
                        return stop();
                    }
                    var active = lock[lock.active];
                    if (active) {
                        --lock.count;
                        delete lock[lock.active];
                        active.event && active.event.interrupt.call(node);
                    }
                    lock.active = id;
                    transition.event && transition.event.start.call(node);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node)) {
                            tweened.push(value);
                        }
                    });
                    ease = transition.ease;
                    duration = transition.duration;
                    Timer(function() {
                        timer.c = tick(elapsed || 1) ? BaseUtils.trueFn : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id) {
                        return 1;
                    }
                    var t = elapsed / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count) {
                        lock[id] = undefined;
                        // delete lock[id];
                    }else{
                        node[ns] = undefined;
                        // IE 11 兼容7下抛错: "对象不支持此操作"
                        // delete node[ns]
                    };
                    return 1;
                }
            }, 0, time);
        }
    }

    function nextTransitionID(){
        return ++d3_transitionId;
    }

    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }

    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }

    Transition.d3_transitionNamespace = d3_transitionNamespace;
    Transition.nextTransitionID = nextTransitionID;

    return Transition;
});
/**
 * Created by eason on 16/7/22.
 */

define('vector/ElementWrapper',['require','../utils/Class','../dom/DomUtils','./Transition','../utils/BaseUtils'],function(require){

    var Class = require('../utils/Class');
    var DomUtils = require('../dom/DomUtils');
    var Transition = require('./Transition');
    var isArray = require('../utils/BaseUtils').isArray;

    var ElementWrapper = Class.extend({

        /**
         * wrap the elements to hide implementation details
         * @param rawElement dom elements for svg and vml,and data object for canvas
         * @param renderer the renderer that the rawElement belongs to
         */
        initialize:function(rawElement, renderer){
            this.rawElement = rawElement;

            this.renderer = renderer;

            return this;
        },

        node: function () {
            return this.rawElement;
        },

        /**
         * add the rawElement to the parent container
         * append to the container for svg and vml
         * or show for canvas
         * @param parentElementWrapper
         * @returns {ElementWrapper}
         */
        addTo:function(parent){

            parent = parent || this.renderer._container;

            parent.append(this);

            return this;
        },

        addToBack:function(parent){

            parent = parent || this.renderer._container;

            parent = parent.node();

            parent.firstChild ? parent.insertBefore(this.node(), parent.firstChild) : parent.appendChild(this.node());

            return this;
        },

        add:function(){
            if (this.type === 'div') {
                return this.addTo(this.renderer._divContainer);
            }
            return this.addTo(this.renderer._container);
        },

        append: function (child) {
            this.node().appendChild(child.node());
            return child;
        },

        //bind data to the elementWrapper
        datum:function(){
            if(arguments.length){
                this._datum = arguments[0];
                return this;
            }
            return this._datum;
        },

        addClass:function(name){
            DomUtils.addClass(this.node(), name);

            return this;
        },

        /**
         * remove from the renderer container
         * for canvas, we shall clear the context and redraw all
         * the other elements on the container
         */
        remove:function(){
            DomUtils.remove(this.node());
            return this;
        },

        removed:function(){
            return !(this.node().parentNode && this.node().parentNode.tagName);
        },

        isVisible:function(){
            return !this.removed() && this.node().style.display != 'none';
        },

        //ie下面用vml path模拟所有的形状,所以需要记录一下形状的类型
        setType:function(type){
            this.type = type;
            return this;
        },

        // rotate text(div, svg) according to center
        // for less dom operation, set textContent & style first
        // then rotate
        // delayMove for animation
        vRotate: function (deg, delayMove) {
            this.renderer.vRotate(this, deg, delayMove);
            return this;
        },

        vMiddle: function () {
            this.renderer.vMiddle(this);
        },

        // transition stuff
        animate:function(para){

            if (!para) {
                throw new Error('animate para empty')

            } else
            if (isArray(para)) {
                var transition = this.transition().setAnimation(para[0]);

                for(var i = 1, len = para.length; i < len; i++){
                    transition = transition.transition(para[i]);
                }

                return this.setTransitionEnd(transition, para[len - 1].style);

            } else {
                return this.setTransitionEnd(this.transition().setAnimation(para), para.style)
            }

        },

        setTransitionEnd:function (transition, styles) {
            var el = this;
            var vanchart = this.renderer.vanchart;
            ++vanchart.animationCount;
            return transition.each('end', function () {
                styles && el.style(styles);

                if(vanchart._animationStarted){
                    if(!--vanchart.animationCount) {
                        vanchart.animationCount = -1;
                        // console.log('ani transition end');
                        vanchart.fire('animationEnd');
                    }
                }

            });
        },

        effectTransition:function () {
            return new Transition(this);
        },

        transition:function(name){
            return new Transition(this, name, null, !this.renderer.isAnimation);
        },

        interrupt:function(name){

            var node = this.node(), ns = Transition.d3_transitionNamespace(name);

            var lock;
            if ((lock = node[ns]) && (lock[lock.active])) {
                if (--lock.count){
                    delete lock[lock.active];
                } else {
                    delete node[ns];
                }
                lock.active += .5;
            }

            return this
        }

    });

    return ElementWrapper;
});
/**
 * Created by eason on 16/6/1.
 * 这个js做成类似接口的东西吧
 */

define('vector/Renderer',['require','./Layer','../dom/DomUtils','../dom/Browser','../utils/Bounds','../utils/BaseUtils','./ElementWrapper'],function(require){

    var Layer = require('./Layer');
    var DomUtils = require('../dom/DomUtils');
    var Browser = require('../dom/Browser');
    var Bounds = require('../utils/Bounds');
    var BaseUtils = require('../utils/BaseUtils');
    var ElementWrapper = require('./ElementWrapper');

    var PADDING = 0;

    var Renderer = Layer.extend({
        /**
         * this._container may be svg,canvas,dom
         */
        initialize:function(dom, vanchart, config){
            this.dom = dom;
            this.vanchart = vanchart;
            this.config = config;
            this.isSupportSVG = BaseUtils.isSupportSVG();
            this.isAnimation = this.isSupportSVG && BaseUtils.pick(this.vanchart.options.plotOptions.animation, true);
        },

        resize:function() {

        },

        remove:function(){
            DomUtils.remove(this._container.node());

            this.off('update', this._updatePaths, this);
        },

        div: function (isHtml) {
            var d = new ElementWrapper(document.createElement('div'), this).setType('div')
                .style({position:'absolute',left:0,top:0})
            d.isHtml = isHtml;// log for IE8
            return d;
        },

        vgroup: function () {
            var divG = this.div();
            var renderG = this.group();
            return {
                divG: divG,
                renderG: renderG,
                type: 'vgroup',
                attr: function () {
                    this.divG.attr.apply(this.divG, arguments);
                    this.renderG.attr.apply(this.renderG, arguments);
                    return this;
                },
                style: function () {
                    this.divG.style.apply(this.divG, arguments);
                    this.renderG.style.apply(this.renderG, arguments);
                    return this;
                },
                append: function (ele) {
                    if (ele.type === 'div' && ele.isHtml) {
                        divG.append(ele);
                    } else if (ele.type === 'vgroup') {
                        divG.append(ele.divG);
                        renderG.append(ele.renderG);
                    } else {
                        renderG.append(ele);
                    }
                    return ele;
                },
                add: function (parentG) {
                    parentG ? this.renderG.addTo(parentG) : this.renderG.add();
                    this.divG.add();
                    return this;
                },
                remove: function () {
                    this.divG.node() && this.divG.remove();
                    this.renderG.node() && this.renderG.remove();
                },
                node:function(){
                    return renderG.node();
                },
                vRotate: function (deg) {
                    if (isNaN(deg)) { return }
                    this.divG.vRotate(deg);
                    this.renderG.vRotate(deg);
                }
            };
        },

        vtext: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div(isHtml); // for IE8, innerText or innerHtml
            }
            return this.text();
        },

        vtspan: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div(isHtml);
            }
            return this.tspan();
        },

        onAdd:function(){
            if (!this._container){
                this._initContainer(); // defined by renderer implementations
                if (this._zoomAnimated) {
                    DomUtils.addClass(this._container.node(), 'leaflet-zoom-animated');
                }
            }

            this.dom.appendChild(this._container.node());

            this._divContainer && this.dom.appendChild(this._divContainer.node());

            this._update();

            this.on('update', this._updatePaths, this);
        },

        _update: function () {
            var size = this.vanchart.getSize();
            this._bounds = new Bounds([0,0], size);
            if(this._map){
                var p = PADDING, min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
                this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
                this._center = this._map.getCenter();
                this._zoom = this._map.getZoom();
            }
        },

        getEvents: function () {
            var events = {
                viewreset: this._reset,
                zoom: this._onZoom,
                moveend: this._update,
                zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
                events.zoomanim = this._onAnimZoom;
            }
            return events;
        },

        _onAnimZoom: function (ev) {
            this._updateTransform(ev.center, ev.zoom);
        },

        _onZoom: function () {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },

        _reset: function () {
            this._update();
            this._updateTransform(this._center, this._zoom);

            var layers = this.vanchart._layers;
            for (var id in layers) {
                layers[id]._path && layers[id]._reset();
            }
        },

        _onZoomEnd: function () {

            var layers = this.vanchart._layers;

            for (var id in layers) {
                layers[id]._path && layers[id]._project();
            }
        },

        _updatePaths: function () {
            var layers = this.vanchart._layers;

            for (var id in layers) {
                layers[id]._path && layers[id]._update();
            }
        },

        _updateTransform: function (center, zoom) {
            var container = this._container.node();

            var scale = this._map.getZoomScale(zoom, this._zoom),
                position = DomUtils.getPosition(container),
                viewHalf = this._map.getSize().multiplyBy(0.5 + PADDING),
                currentCenterPoint = this._map.project(this._center, zoom),
                destCenterPoint = this._map.project(center, zoom),
                centerOffset = destCenterPoint.subtract(currentCenterPoint),

                topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

            if (Browser.any3d) {
                DomUtils.setTransform(container, topLeftOffset, scale);
            } else if(BaseUtils.isSupportSVG()){
                DomUtils.setPosition(container, topLeftOffset);
            }else {
                container.style.left = 0 + 'px';
                container.style.top = 0 + 'px';
            }
        }
    });

    return Renderer;
});
/**
 * Created by eason on 16/6/1.
 */

define('vector/SvgRenderer',['require','./Renderer','../dom/DomUtils','../utils/BaseUtils','./ElementWrapper'],function(require){

    var Renderer = require('./Renderer');
    var DomUtils = require('../dom/DomUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ElementWrapper = require('./ElementWrapper');

    var included = false;

    var Svg = Renderer.extend({

        _initContainer:function(){
            includeElementWrapper();
            this._container = new ElementWrapper(this.create('svg'), this);
            this.defs = new ElementWrapper(this.create('defs'), this).addTo(this._container);

            //svg的divContainer要单独拿出来
            this._divContainer = this.div()
                .style({'white-space':'nowrap','pointer-events':'none'});
        },

        resize:function(){
            var width = this.vanchart.width, height = this.vanchart.height;
            this._container.style({width:width + 'px', height:height + 'px'});
        },

        _update: function () {
            if (this._map && this._map._animatingZoom && this._bounds) {
                return;
            }

            Renderer.prototype._update.call(this);

            var b = this._bounds,
                size = b.getSize(),
                container = this._container.node();

            // set size of svg-container if changed
            if (!this._svgSize || !this._svgSize.equals(size)) {
                this._svgSize = size;
                container.setAttribute('width', size.x);
                container.setAttribute('height', size.y);
            }

            // movement: update container viewBox so that we don't have to change coordinates of individual layers

            if(this._map){
                DomUtils.setPosition(container, b.min);   // todo @BI-10054,地图这边暂不处理，即使不使用translate3d,也还是有问题,原因尚在排查
                container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
            } else {
                container.style.left = b.min.x + 'px';
                container.style.top = b.min.y + 'px';
            }

            this.fire('update');
        },

        line:function(attrs){
            return new ElementWrapper(this.create('line'), this).attr(attrs);
        },

        rect:function(attrs){
            return new ElementWrapper(this.create('rect'), this).attr(attrs);
        },

        circle:function(attrs){
            return new ElementWrapper(this.create('circle'), this).attr(attrs);
        },

        path:function(attrs){
            return new ElementWrapper(this.create('path'), this).attr(attrs);
        },

        text:function(attrs){
            return new ElementWrapper(this.create('text'), this).attr(attrs);
        },

        tspan:function(attrs){
            return new ElementWrapper(this.create('tspan'), this).attr(attrs);
        },

        image:function(attrs){
            return new ElementWrapper(this.create('image'), this).attr(attrs);
        },

        group:function(attrs){
            return new ElementWrapper(this.create('g'), this).attr(attrs);
        },

        colorGradient:function(attrs, stops, type){
            type = type || 'linearGradient';

            var fillFilter = new ElementWrapper(this.create(type), this);
            attrs.id = BaseUtils.stamp(fillFilter);
            fillFilter.attr(attrs);

            fillFilter.stops = [];
            for(var i = 0, len = stops.length; i < len; i++){
                fillFilter.stops[i] = new ElementWrapper(this.create('stop'), this)
                    .attr(stops[i])
                    .addTo(fillFilter);
            }

            return fillFilter.addTo(this.defs);
        },

        updateColorGradient:function(gradient, attrs, stops){
            gradient.attr(attrs);
            for(var i = 0, len = stops.length; i < len; i++){
                if (gradient.stops[i]) {
                    gradient.stops[i].attr(stops[i]);
                }else {
                    gradient.stops[i] = new ElementWrapper(this.create('stop'), this)
                        .attr(stops[i])
                        .addTo(gradient);
                }
            }
        },

        createClip: function (attrs, type) {
            type = type || 'rect';
            var clip = new ElementWrapper(this.create('clipPath'), this);
            clip.attr('id', BaseUtils.stamp(clip));

            clip.setType(type);

            clip[type] = new ElementWrapper(this.create(type), this).attr(attrs).addTo(clip);

            clip.addTo(this.defs);

            return clip;
        },

        clip:function(elementWrapper, clipWrapper){
            elementWrapper.attr('clip-path', "url(#" + BaseUtils.stamp(clipWrapper) +")");
        },

        updateClip:function(clipWrapper, attrs){
            if(clipWrapper){
                clipWrapper[clipWrapper.type].attr(attrs);
            }
        },

        imagePattern:function(patterAttr, imageAttr, url){

            var pattern = new ElementWrapper(this.create('pattern'), this);
            patterAttr.id = BaseUtils.stamp(pattern);

            pattern.attr(patterAttr);

            pattern.image = new ElementWrapper(this.create('image'), this).addTo(pattern);
            pattern.image.attr(imageAttr);
            pattern.image.imageContent(url);
            pattern.image._imageUrl = url;

            pattern.addTo(this.defs);

            return pattern;
        },

        updateImagePattern:function(imagePattern, patterAttr, imageAttr, url){
            imagePattern.attr(patterAttr);
            imagePattern.image.attr(imageAttr);

            //避免重复请求图片
            if(imagePattern.image._imageUrl != url){
                imagePattern.image.imageContent(url);
                imagePattern.image._imageUrl = url;
            }
        },

        createDropShadowFilter:function(dx, dy, alpha, deviation, r, g, b){
            r = r || 0; g = g || 0; b = b || 0;

            var dropFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(dropFilter);
            dropFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            this.updateDropShadowFilter(dropFilter, dx, dy, alpha, deviation, r, g, b);

            dropFilter.feBlend = dropFilter.feBlend || new ElementWrapper(this.create('feBlend'), this).addTo(dropFilter);
            dropFilter.feBlend.attr({
                "in": 'SourceGraphic', 'in2':'blurOut', 'mode':'normal'
            });

            dropFilter.addTo(this.defs);

            return dropFilter;
        },

        updateDropShadowFilter:function (dropFilter, dx, dy, alpha, deviation, r, g, b) {
            r = r || 0; g = g || 0; b = b || 0;

            dropFilter.feOffset = dropFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(dropFilter);
            dropFilter.feOffset.attr({
                'in':'SourceGraphic', 'dx':dx, 'dy':dy, 'result':'offOut'
            });

            dropFilter.feColorMatrix = dropFilter.feColorMatrix || new ElementWrapper(this.create('feColorMatrix'), this).addTo(dropFilter);
            dropFilter.feColorMatrix.attr({
                'in':'offOut', 'type':'matrix', 'values':r+' 0 0 0 0 0 ' +g+' 0 0 0 0 0 '+b+' 0 0 0 0 0 '+alpha+' 0','result':'matrixOut'
            });

            dropFilter.feGaussianBlur = dropFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(dropFilter);
            dropFilter.feGaussianBlur.attr({
                'in':'matrixOut', 'stdDeviation':deviation, 'result':'blurOut'
            });
        },

        createInnerShadowFilter:function(dx, dy, alpha, deviation){
            var innerFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(innerFilter);
            innerFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            innerFilter.feComponentTransfer = innerFilter.feComponentTransfer || new ElementWrapper(this.create('feComponentTransfer'), this).attr({'in':'SourceAlpha'}).addTo(innerFilter);
            innerFilter.feComponentTransfer.feFuncA = innerFilter.feComponentTransfer.feFuncA || new ElementWrapper(this.create('feFuncA'), this).attr({'type':'table', 'tableValues': '1 0'}).addTo(innerFilter.feComponentTransfer);

            innerFilter.feGaussianBlur = innerFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(innerFilter);
            innerFilter.feGaussianBlur.attr('stdDeviation', deviation);

            innerFilter.feOffset = innerFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(innerFilter);
            innerFilter.feOffset.attr({'dx': dx, 'dy': dy, 'result':'offsetblur'});

            innerFilter.feFlood = innerFilter.feFlood || new ElementWrapper(this.create('feFlood'), this).addTo(innerFilter);
            innerFilter.feFlood.attr({'flood-color': 'black', 'flood-opacity': alpha, 'result':'color'});

            innerFilter.feComposite1 = innerFilter.feComposite1 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'offsetblur', 'operator':'in'}).addTo(innerFilter);

            innerFilter.feComposite2 = innerFilter.feComposite2 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'SourceAlpha', 'operator':'in'}).addTo(innerFilter);

            innerFilter.merge = innerFilter.merge || new ElementWrapper(this.create('feMerge'), this).addTo(innerFilter);

            innerFilter.merge.feMergeNode1 = innerFilter.merge.feMergeNode1 || new ElementWrapper(this.create('feMergeNode'), this).attr('in', 'SourceGraphic').addTo(innerFilter.merge);
            innerFilter.merge.feMergeNode2 = innerFilter.merge.feMergeNode2 || new ElementWrapper(this.create('feMergeNode'), this).addTo(innerFilter.merge);

            innerFilter.addTo(this.defs);

            return innerFilter;
        },

        create: function (name) {
            return document.createElementNS('http://www.w3.org/2000/svg', name);
        },

        // rotate text(div, svg) according to center
        // for less dom operation, set textContent & style first
        // then rotate
        // delayMove for animation
        vRotate: function (domWrapper, deg, delayMove) {
            var trans, transform, rotateStr, dom = domWrapper.node();
            if (domWrapper.type === 'div') {
                transform = domWrapper.styles[BaseUtils.transPrefix + 'transform'] || '';
                if (transform) {
                    trans = transformParser(transform.replace(/px/gi, ''));
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px) ';
                    }
                }
                rotateStr = 'rotate(' + deg + 'deg)';
                transform += rotateStr;
                var t = BaseUtils.transPrefix + 'transform';
                domWrapper.styles[t] = transform;
                dom.style[t] = transform;
            } else {
                var centerX = dom.getBBox().width / 2; // firefox has no scroll size
                // IE 11 height > text height; result in a wrong position
                var centerY = dom.getBBox().height/ 2 - 1;

                centerX += (+dom.getAttribute('x') || 0);
                centerY += (+dom.getAttribute('y') || 0);

                transform = dom.getAttribute('transform') || '';
                if (transform) {
                    trans = transformParser(transform);
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + ' ' + trans.translate[1] + ') ';
                    }
                }
                rotateStr = 'rotate(' + deg + ' ' + centerX + ' ' + centerY + ')';
                transform += rotateStr;
                if (!delayMove) {
                    domWrapper.attr('transform', transform);
                }
            }
            domWrapper.rotateStr = rotateStr;
            return this;
        },

        vMiddle: function (domWrapper) {
            if (domWrapper.type === 'div') {
                var dom = domWrapper.node();
                var ow = dom.offsetWidth;
                dom.style.marginLeft = -ow / 2 + 'px';
            } else {
                domWrapper.attr('text-anchor', 'middle');
            }

            return this;
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }
    }

    //map specific func
    Svg.include({
        getEvents: function () {
            var events = Renderer.prototype.getEvents.call(this);
            events.zoomstart = this._onZoomStart;
            return events;
        },

        _onZoomStart: function () {
            // Drag-then-pinch interactions might mess up the center and zoom.
            // In this case, the easiest way to prevent this is re-do the renderer
            //   bounds and padding when the zooming starts.
            this._update();
        }
    });

    function includeElementWrapper () {

        if (included) {return}

        included = true;

        ElementWrapper.include({

            imageContent:function(url){
                this.node().setAttributeNS("http://www.w3.org/1999/xlink", "href", url);
                return this;
            },

            textContent:function(text){
                this.type === 'div' ? this.node().innerHTML = text : this.node().textContent = text;
                return this;
            },

            attr:function(){
                if (this.type === 'div') {
                    this.style.apply(this, arguments);
                }else{
                    DomUtils.attr.apply(null, [this.node()].concat(BaseUtils.objectToArray(arguments)));
                }
                return this;
            },

            style:function(style){
                var styles;
                if (arguments.length === 2) {
                    styles = {};
                    styles[arguments[0]] = arguments[1];
                } else {
                    styles = arguments[0];
                }

                var oldStyles = this.styles,
                    newStyles = {},
                    elem = this.node(),
                    serializedCss = '',
                    hasNew = !oldStyles,
                    styleName;

                // convert legacy
                if (styles && styles.color) {
                    styles.fill = styles.color;
                }

                if (styles && styles.fill && this.type === 'div') {
                    styles.color = styles.fill;
                }

                // Filter out existing styles to increase performance (#2640)
                if (oldStyles) {
                    for (styleName in styles) {
                        if (styles[styleName] !== oldStyles[styleName]) {
                            newStyles[styleName] = styles[styleName];
                            hasNew = true;
                        }
                    }
                }

                if (hasNew) {

                    if (this.type === 'div') {
                        // some problems:
                        // 1. rotate
                        // 2. default, here add 'px' to attributes
                        var map = {
                            'x': 'left',
                            'y': 'top',
                            'dx': 'margin-left'
                            // 'dy': 'margin-top'
                        };

                        for (var name in map) {
                            var s;
                            if ((s = newStyles[name]) != null) {
                                // em or +'px' suffix
                                newStyles[map[name]] = /em/gi.test(s) ? s : s + 'px';
                                delete newStyles[name];
                            }
                        }

                        if (newStyles['transform']) {
                            var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                            if (trans.translate) {
                                newStyles[BaseUtils.transPrefix + 'transform'] = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px)';
                            }
                        }
                    }

                    // Merge the new styles with the old ones
                    if (oldStyles) {
                        styles = BaseUtils.extend(oldStyles, newStyles);
                    }

                    this.styles = styles;

                    var hyphenate = function (a, b) {
                        return '-' + b.toLowerCase();
                    };

                    for (styleName in styles) {
                        serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                    }

                    elem.style.cssText = serializedCss;

                    //todo fireFox下面style会多一个'none'
                    //http://stackoverflow.com/questions/15123953/svg-fill-url-behaving-strangely-in-firefox
                    if(styles.fill){
                        elem.style.fill = styles.fill;
                    }
                }

                return this;
            }

        });
    }

    return Svg;
});
/**
 * Created by eason on 16/6/20.
 */
/**
 * Created by eason on 16/6/7.
 * vml下面用path来构造所有的形状,输出vml的path
 */

define('utils/PathUtils',['require'],function(require){

    var pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
    var concat = "concat", apply = "apply", upperCase = String.prototype.toUpperCase, mmax = Math.max, math = Math, round = math.round;
    var PI = math.PI, abs = Math.abs, split = "split";
    var p2s = /,?([achlmqrstvxz]),?/gi, val = /-?\d*\.?\d+(?:[eE][\-+]?\d+)?/g;
    var S = " ", E = "", fillString = "fill", zoom = 1;

    function path2vml(path){
        var bites = /([clmz]),?([^clmz]*)/gi;
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"};
        var total =  /[ahqstv]/ig, command = pathToAbsolute;
        String(path).match(total) && (command = path2curve);
        total = /[clmz]/g;
        if (command == pathToAbsolute && !String(path).match(total)) {
            var res = String(path).replace(bites, function (all, command, args) {
                var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                args.replace(val, function (value) {
                    if (isMove && vals.length === 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });
            return res;
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.join(S);
    }

    function parsePathString(pathString){

        if (!pathString && typeof pathString != 'string') {
            return null;
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];

        String(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") {
                data.push([b][concat](params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
        data.toString = path2string;
        return data;
    }

    function path2string(){
        return this.join(",").replace(p2s, "$1");
    }

    function path2curve(path, path2){

        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny, tq = {T:1, Q:1};
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in tq) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny][concat](path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i]="A"); // the same as above
                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") { pcoms1[i] = "C" }; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C")
                {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i-1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i]!="A" && pfirst=="C") { pcoms2[i]="C"; }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
    }

    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    }

    function l2c (x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }

    function a2c (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y}
            };
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }

    function pathToAbsolute(pathArray) {

        if(typeof pathArray == 'string'){
            pathArray = parsePathString(pathArray);
        }

        if(!pathArray || !pathArray.length){
            return [["M", 0, 0]];
        }

        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = path2string;
        return res;

    }

    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }

    function rectPath(x, y, w, h, r){
        if (r) {
            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
        }
        return path2vml([["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]]);
    }

    function circlePath (x, y, r) {
        return path2vml([["M", x, y], ["m", 0, -r], ["a", r, r, 0, 1, 1, 0, 2 * r], ["a", r, r, 0, 1, 1, 0, -2 * r], ["z"]]);
    }

    function linePath(x1, y1, x2, y2){
        return path2vml([["M", x1, y1], ["L", x2, y2]]);
    }

    window.tmp = {
        path2vml:path2vml,
        rectPath:rectPath,
        linePath:linePath,
        circlePath:circlePath
    }

    return window.tmp;

});
/**
 * Created by eason on 16/6/1.
 */

define('vector/VmlRenderer',['require','./Renderer','../utils/PathUtils','../utils/BaseUtils','../utils/ColorUtils','./ElementWrapper','../dom/DomUtils'],function(require){
    var Renderer = require('./Renderer');
    var PathUtils = require('../utils/PathUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var ElementWrapper = require('./ElementWrapper');
    var DomUtils = require('../dom/DomUtils');

    var CSS = "position:absolute;left:0px;top:0px;width:1px;height:1px;behavior:url(#default#VML);display:inline-block;";

    var SubCss = "position:absolute;behavior:url(#default#VML);display:inline-block;";

    var included = false;

    var Vml = Renderer.extend({

        _initContainer: function (){
            includeElementWrapper();
            var root = this.div().style({'white-space':'nowrap','display':'inline-block'});
            DomUtils.addClass(root.node(), 'van-vml');
            this.dom.appendChild(root.node());

            //vml可以和div混合
            this._divContainer = root;

            this._container = root;

            return root;
        },

        line:function(attrs){
            return this._shapeWithPath(attrs, 'line');
        },

        rect:function(attrs){
            return this._shapeWithPath(attrs, 'rect');
        },

        circle:function(attrs){
            return this._shapeWithPath(attrs, 'circle');
        },

        path:function(attrs){
            return this._shapeWithPath(attrs, 'path');
        },

        image:function(attrs){
            var image =  new ElementWrapper(document.createElement('image'), this).setType('image');

            image.attr(attrs);

            return image;
        },

        //ie8 group套group就显示不出了,奇葩
        group:function(attrs){
            var group = this.div().style({'white-space':'nowrap','pointer-events':'none'});

            return group.attr(attrs);
        },

        colorGradient:function(attrs, stops, type){
            type = type || 'linearGradient';
            return {
                type:type,
                attrs:attrs,
                stops:stops,
                elements:[]
            }
        },

        updateColorGradient:function(gradient, attrs, stops){
            gradient.attrs = attrs;
            gradient.stops = stops;
        },

        //todo 怎样和svg的效果统一
        _updateGradientFill:function(elementWrapper, colorGradient){
            var node = elementWrapper.node(), fill = elementWrapper._fill;
            var stops = colorGradient.stops, attrs = colorGradient.attrs;

            if(fill){
                node.removeChild(fill);

                fill.on = true;
                fill.method = "none";
                fill.color = stops[0]['stop-color'];
                fill.color2 = stops[stops.length - 1]['stop-color'];
                var clrs = [];
                for (var i = 0, ii = stops.length; i < ii; i++) {
                    var offset = stops[i].offset * 100 + '%';
                    clrs.push(offset + ' ' + stops[i]['stop-color']);
                }
                // fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                fill.type = "gradient";
                fill.angle = (attrs.x1 == attrs.x2 ? 0 : 270);

                node.appendChild(fill);
            }
        },

        textContent:function(elementW, text){

        },



        text:function(){
            return this.vtext(false);
        },

        tspan:function(){
            return this.vtspan(false);
        },

        _shapeWithPath:function(attrs, type){
            var shape = new ElementWrapper(this.create('shape'), this).setType(type), container = shape.rawElement;
            container.style.cssText = CSS;container.coordsize = '1 1';

            return shape.attr(attrs);
        },

        create:(function () {
            try {
                document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                return function (name) {
                    return document.createElement('<lvml:' + name + ' class="lvml">');
                };
            } catch (e) {
                return function (name) {
                    return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        })(),

        createClip: function (attrs, type) {
            if(type && type != 'rect'){
                return;
            }

            return {
                'x':attrs.x,
                'y':attrs.y,
                'width':attrs.width,
                'height':attrs.height,
                'clipped':[]
            };
        },

        _getClipStr:function(elementWrapper, attrs){
            var top = attrs.y || 0, left = attrs.x || 0, right = left + attrs.width, bottom = top + attrs.height;

            if(elementWrapper.type != 'div'){
                var node = elementWrapper.isLineChart ? elementWrapper.node().parentNode.firstChild : elementWrapper.node();
                
                top -= node.offsetTop;
                bottom -= node.offsetTop;
            }

            return 'rect(' + top + 'px '+ right +'px '+ bottom +'px ' + left + 'px)';
        },

        clip:function(elementWrapper, clipWrapper){
            if(clipWrapper){
                var node;
                if(elementWrapper.node && (node = elementWrapper.node())){
                    node.style.clip = this._getClipStr(elementWrapper, clipWrapper);
                    clipWrapper.clipped.push(elementWrapper);
                }
            }
        },

        updateClip:function(clipWrapper, attrs){
            var renderer = this;
            if(clipWrapper){
                BaseUtils.extend(clipWrapper, attrs);
                clipWrapper.clipped.forEach(function(elementWrapper){
                    var node = elementWrapper.node();
                    if(node){
                        node.style.clip = renderer._getClipStr(elementWrapper, clipWrapper);
                    }
                });
            }
        },

        imagePattern:function(p, attrs){

        },

        createDropShadowFilter:function(){
            return {};
        },

        createInnerShadowFilter:function(){
            return {};
        },

        attr:function(domWrapper, arguments){

            if(!arguments || arguments.length <= 0 || !arguments[0]){
                return;
            }

            var attrs = {}, elem = domWrapper.rawElement;
            if(arguments.length === 2){
                attrs[arguments[0]] = arguments[1];
            }else{
                attrs = arguments[0];
            }

            var oldAttrs = domWrapper.attrs, type = domWrapper.type;

            if(oldAttrs){
                attrs = BaseUtils.extend(oldAttrs, attrs);
            } else {
                // avoid revising original attr obj
                attrs = BaseUtils.extend({}, attrs);
            }

            domWrapper.attrs = attrs;

            //transform属性先屏蔽掉,暂时只更新矩形
            if(attrs.transform){
                var transform = transformParser(attrs.transform);
                try {
                    if (transform.translate) {
                        elem.style.left = transform.translate[0] + 'px';
                        elem.style.top = transform.translate[1] + 'px';
                    }
                } catch (e) {
                    
                }

                if(transform.rotate){

                }
            }

            if(type == 'image'){
                elem.style.position = 'absolute';
                elem.style.left = attrs.x + 'px';
                elem.style.top = attrs.y + 'px';
                elem.style.width = attrs.width + 'px';
                elem.style.height = attrs.height + 'px';
            }else if(type != 'group'){

                var pathStr = '';
                if(type == 'rect'){
                    pathStr = PathUtils.rectPath(attrs.x || 0, attrs.y || 0, attrs.width, attrs.height);
                }else if(type == 'line'){
                    pathStr = PathUtils.linePath(attrs.x1, attrs.y1, attrs.x2, attrs.y2);
                }else if(type == 'path'){
                    pathStr = PathUtils.path2vml(attrs.d);
                }else if(type == 'circle'){
                    pathStr = PathUtils.circlePath(attrs.cx || 0, attrs.cy || 0, attrs.r);
                }

                elem.path = pathStr;
            }
        },
        
        style:function(domWrapper, styles){
            var oldStyles = domWrapper.styles,
                newStyles = {},
                elem = domWrapper.rawElement,
                styleName;

            // convert legacy
            if (styles && styles.color) {
                styles.fill = styles.color;
            }

            if (styles && styles.fill && domWrapper.type === 'div') {
                styles.color = styles.fill;
            }

            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                for (styleName in styles) {
                    if (styles[styleName] !== oldStyles[styleName]) {
                        newStyles[styleName] = styles[styleName];
                    }
                }
            }

            if (domWrapper.type === 'div') {

                if (newStyles['transform']) {
                    var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                    if (trans.translate) {
                        newStyles['transform'] = '';
                        newStyles['x'] = trans.translate[0];
                        newStyles['y'] = trans.translate[1];
                    }
                }

                var map = {
                    'x': 'left',
                    'y': 'top',
                    'dx': 'margin-left'
                    // 'dy': 'margin-top'
                };

                for (var name in map) {
                    var s;
                    if ((s = newStyles[name]) != null) {
                        // em or +'px' suffix
                        newStyles[map[name]] = /em/gi.test(s) ? s : s + 'px';
                        delete newStyles[name];
                    }
                }

            }

            // Merge the new styles with the old ones
            if (oldStyles) {
                styles = BaseUtils.extend(oldStyles, newStyles);
            }
            domWrapper.styles = styles;

            if (domWrapper.type === 'div') {
                var hyphenate = function (a, b) {
                    return '-' + b.toLowerCase();
                };

                var alpha = 1;
                if (/rgba/i.test(styles.color)) {
                    var c = ColorUtils.colorToHexAlpha(styles.color);
                    styles.color = c.hex;
                    alpha = c.alpha;
                }

                if(BaseUtils.hasDefined(styles['fill-opacity'])){
                    alpha *= styles['fill-opacity'];
                }

                if(alpha < 1){
                    styles['filter'] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + alpha * 100 + ")";
                }

                var serializedCss = '';
                for (styleName in styles) {
                    serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                }

                elem.style.cssText = serializedCss;
            }else if(domWrapper.type != 'group'){

                if(domWrapper.type == 'image'){
                    domWrapper.node().src = styles.src;
                }else{

                    var stroke = domWrapper._stroke,
                        fill = domWrapper._fill,
                        container = domWrapper.node();

                    container.stroked = true;//默认的样式
                    container.filled = !!((styles.fill && styles.fill != 'none') || domWrapper.type == 'image');

                    if (!stroke) {
                        stroke = domWrapper._stroke = this.create('stroke');
                        stroke.style.cssText = SubCss;
                    }
                    container.appendChild(stroke);
                    stroke.weight = (styles['stroke-width'] || 0) + 'px';

                    var strokeColor = styles.stroke;
                    var strokeOpacity = BaseUtils.hasDefined(styles['stroke-opacity']) ? styles['stroke-opacity'] : 1;
                    //兼容rgba的写法
                    if(strokeColor && strokeColor.indexOf('rgba') != -1){
                        strokeColor = ColorUtils.colorToHexAlpha(strokeColor);
                        strokeOpacity *= strokeColor.alpha;
                        strokeColor = strokeColor.hex;
                    }
                    stroke.color = strokeColor;
                    stroke.opacity = styles['stroke-width'] ? strokeOpacity : 0;

                    if(styles['stroke-dasharray']){
                        stroke.dashStyle = styles['stroke-dasharray'].replace(/( *, *)/g, ' ');
                    }else{
                        stroke.dashStyle = '';
                    }

                    if(styles['stroke-linecap'] == 'round'){
                        stroke.endcap = 'round';
                    }

                    if (container.filled) {
                        if (!fill) {
                            fill = domWrapper._fill = this.create('fill');
                            fill.style.cssText = SubCss;
                        }
                        container.appendChild(fill);

                        var fillColor = styles.fill;
                        var fillOpacity = BaseUtils.hasDefined(styles['fill-opacity']) ? styles['fill-opacity'] : 1;

                        //兼容rgba的写法
                        if(fillColor.indexOf('rgba') != -1){
                            fillColor = ColorUtils.colorToHexAlpha(fillColor);
                            fillOpacity *= fillColor.alpha;
                            fillColor = fillColor.hex;
                        }

                        fill.color = fillColor;
                        fill.opacity =  Math.min(1, Math.max(fillOpacity, 0));  // todo 这之前肯定有操作导致的fillOpacity>1，从而在IE8下面报错，有时间在慢慢找吧

                    } else if (fill) {
                        container.removeChild(fill);
                        domWrapper._fill = null;
                    }

                }
            }

            if ('display' in styles) {
                domWrapper.node().style.display = styles.display;
            }
            if ('cursor' in styles) {
                domWrapper.node().style.cursor = styles.cursor;
            }
        },

        // assume there's no margin
        // if margin(as offset) is needed,
        // revise this func, record offset to other attr
        // then combine the offset and the rotate adjustment to margin.
        vRotate: function (domWrapper, deg) {
            deg = deg % 360;
            var dom = domWrapper.node();
            BaseUtils.domRotate(dom, 0);
            var ow = dom.offsetWidth, oh = dom.offsetHeight;
            BaseUtils.domRotate(dom, deg);
            var rw = dom.offsetWidth, rh = dom.offsetHeight;
            dom.style.marginLeft = (ow - rw) / 2 + 'px';
            dom.style.marginTop = (oh - rh) / 2 + 'px';
        },

        // again, no dx/margin-left used,
        // or revise it
        vMiddle: function (domWrapper) {
            var dom = domWrapper.node();
            var ow = dom.offsetWidth;
            dom.style.marginLeft = -ow / 2 + 'px';
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }
    }

    function includeElementWrapper () {

        if (included) {return}

        included = true;

        ElementWrapper.include({

            imageContent:function(url){
                this.style({'src':url});
                return this;
            },

            textContent:function(text){
                this.type === 'div' ? this.node().innerHTML = text : this.node().textContent = text;
                return this;
            },

            attr:function(){

                if (this.type === 'div') {
                    this.style.apply(this, arguments);
                } else {
                    this.renderer.attr(this, arguments);
                }
                return this;
            },

            style:function(){
                var styles;
                if (arguments.length === 2) {
                    styles = {};
                    styles[arguments[0]] = arguments[1];
                } else {
                    styles = arguments[0];
                }
                this.renderer.style(this, styles);
                return this;
            }
        });
    }

    return Vml;
});
/**
 * Created by Yuqian on 2017/3/28.
 */
define('locale/localeText',['require','../utils/BaseUtils'],function (require) {

    var BaseUtils = require('../utils/BaseUtils');

    var _locale = 'en';

    var _textMap = {
        'startTime': 'start ',
        'finishTime': 'finish ',
        'duration': 'duration ',
        'progress': 'progress '
    };

    function localeText (key) {
        return _textMap[key] != null ? _textMap[key] : key;
    }

    /**
     * set locale by inner setting
     * @param {string} language - like 'zh-cn'
     */
    localeText.setLocale = function (language) {
        var lan = localeText.normalizeLocale(language);
        if (!lan || _locale === lan) {
            return
        }
        if (!/^en/.test(lan)) { // default
            try{
                var locale = require('./' + lan);
                localeText.setCustomLocale(locale);
            }catch(e){
                // 根据options.language加载不到对应js
            }
        }
    };

    /**
     * extend textMap by another Map
     * @param {Object} map - Key-Value object
     *
     * a problem: may conflict if set again
     */
    localeText.setCustomLocale = function (map) {
        if(BaseUtils.hasDefined(map)) {
            BaseUtils.extend(_textMap, map);
            _locale = map._locale;
        }
    };

    localeText.getLocale = function () {
        return _locale
    };

    localeText.getTextMap = function () {
        return _textMap;
    };
    
    localeText.normalizeLocale = function (key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    };

    return localeText

});

/**
 * Created by Yuqian on 2017/3/28.
 */
define('locale/zh-cn',['require'],function (require) {
    return {

        _locale: 'zh-cn',

        'startTime': '开始',
        'finishTime': '结束',
        'duration': '持续',
        'progress': '进度',

        // used by gantt levelText
        ganttLevels: [
            // 0
            // 2017年 | __上__
            ['yyyy[年]', 'N'],
            // 1
            // 2017年 | 上
            ['yyyy[年]', 'N'],
            // 2
            // 2017年 | 一季度
            ['yyyy[年]', 'QQQ'],
            // 3
            // 2017,上 | 01
            ['yyyy[,]N', 'MM'],
            // 4
            // 2017,一季度 | 1月
            ['yyyy[,]QQQ', 'MMM'],
            // 5
            // 2017,一季度 | 1月
            ['yyyy[,]QQQ', 'MMM'],
            // 6
            // 2017年1月 | 01周
            ['yyyy[年]MM[月]', 'www'],
            // 7
            // 2017年1月2日 | 一...日
            ['yyyy[年]MM[月]dd[日]', 'eeeeee'],
            // 8
            // 2017年1月 | 1...30
            ['yyyy[年]MM[月]', 'd'],
            // 9
            // 1月 | 1...30
            ['MMM', 'd'],
            // 10
            // 1月1日 | 上午
            ['MM[月]dd[日]', 'a'],
            // 11
            // 1月1日 | 0~6点
            ['MM[月]dd[日]', 'I'],
            // 12
            // 1月1日 | 1...24
            ['MM[月]dd[日]', 'H']
        ]
    }
});

/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/LatLng',['require','../../utils/BaseUtils'],function(require){
    var BaseUtils = require('../../utils/BaseUtils');

    var LatLng = function (lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== undefined) {
            this.alt = +alt;
        }
    };

    LatLng.prototype = {

        equals: function (obj, maxMargin) {
            if (!obj) { return false; }

            obj = LatLng.create(obj);

            var margin = Math.max(
                Math.abs(this.lat - obj.lat),
                Math.abs(this.lng - obj.lng));

            return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
        },

        toString: function (precision) {
            return 'LatLng(' +
                BaseUtils.formatNum(this.lat, precision) + ', ' +
                BaseUtils.formatNum(this.lng, precision) + ')';
        },

        distanceTo: function (other) {
            return L.CRS.Earth.distance(this, LatLng.create(other));
        },

        wrap: function () {
            return L.CRS.Earth.wrapLatLng(this);
        },

        clone: function () {
            return new LatLng(this.lat, this.lng, this.alt);
        }
    };

    LatLng.create = function(a, b, c){
        if (a instanceof LatLng) {
            return a;
        }
        if (BaseUtils.isArray(a) && typeof a[0] !== 'object') {
            if (a.length === 3) {
                return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
                return new LatLng(a[0], a[1]);
            }
            return null;
        }
        if (a === undefined || a === null) {
            return a;
        }
        if (typeof a === 'object' && 'lat' in a) {
            return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
        }
        if (b === undefined) {
            return null;
        }
        return new LatLng(a, b, c);
    };

    return LatLng;
});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/Projection',['require','../../utils/Point2D','../../utils/Bounds','./LatLng'],function(require){

    var Point = require('../../utils/Point2D');
    var Bounds = require('../../utils/Bounds');
    var LatLng = require('./LatLng');

    var Projection = {};

    Projection.LonLat = {
        project: function (latlng) {
            return new Point(latlng.lng, latlng.lat);
        },

        unproject: function (point) {
            return new LatLng(point.y, point.x);
        },

        bounds: Bounds.create([-180, -90], [180, 90])
    };

    Projection.SphericalMercator = {

        R: 6378137,
        MAX_LATITUDE: 85.0511287798,

        project: function (latlng) {
            var d = Math.PI / 180,
                max = this.MAX_LATITUDE,
                lat = Math.max(Math.min(max, latlng.lat), -max),
                sin = Math.sin(lat * d);

            return new Point(
                this.R * latlng.lng * d,
                this.R * Math.log((1 + sin) / (1 - sin)) / 2);
        },

        unproject: function (point) {
            var d = 180 / Math.PI;

            return new LatLng(
                (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
                point.x * d / this.R);
        },

        bounds: (function () {
            var d = 6378137 * Math.PI;
            return Bounds.create([-d, -d], [d, d]);
        })()
    };

    Projection.Mercator = {
        R: 6378137,
        R_MINOR: 6356752.314245179,

        bounds: Bounds.create([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

        project: function (latlng) {
            var d = Math.PI / 180,
                r = this.R,
                y = latlng.lat * d,
                tmp = this.R_MINOR / r,
                e = Math.sqrt(1 - tmp * tmp),
                con = e * Math.sin(y);

            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1E-10));

            return new Point(latlng.lng * d * r, y);
        },

        unproject: function (point) {
            var d = 180 / Math.PI,
                r = this.R,
                tmp = this.R_MINOR / r,
                e = Math.sqrt(1 - tmp * tmp),
                ts = Math.exp(-point.y / r),
                phi = Math.PI / 2 - 2 * Math.atan(ts);

            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
                con = e * Math.sin(phi);
                con = Math.pow((1 - con) / (1 + con), e / 2);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                phi += dphi;
            }

            return new LatLng(phi * d, point.x * d / r);
        }
    };

    return Projection;
});
/**
 * Created by eason on 2017/2/4.
 */
define('chart/map/Transformation',['require','../../utils/Point2D'],function(require){

    var Point = require('../../utils/Point2D');

    var Transformation = function(a, b, c, d){
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    };

    Transformation.prototype = {
        // @method transform(point: Point, scale?: Number)
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts real `L.Point` instances, not arrays.
        transform: function (point, scale) { // (Point, Number) -> Point
            return this._transform(point.clone(), scale);
        },

        // destructive transform (faster)
        _transform: function (point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },

        // @method untransform(point: Point, scale?: Number)
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts real `L.Point` instances, not arrays.
        untransform: function (point, scale) {
            scale = scale || 1;
            return new Point(
                (point.x / scale - this._b) / this._a,
                (point.y / scale - this._d) / this._c);
        }
    };

    return Transformation;
});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/CRS',['require','../../utils/Bounds','./LatLng','../../utils/BaseUtils','./Projection','./Transformation'],function(require){

    var Bounds = require('../../utils/Bounds');
    var LatLng = require('./LatLng');
    var BaseUtils = require('../../utils/BaseUtils');
    var Projection = require('./Projection');
    var Transformation = require('./Transformation');

    var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function (latlng, zoom) {
            var projectedPoint = this.projection.project(latlng),
                scale = this.scale(zoom);

            return this.transformation._transform(projectedPoint, scale);
        },

        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function (point, zoom) {
            var scale = this.scale(zoom),
                untransformedPoint = this.transformation.untransform(point, scale);

            return this.projection.unproject(untransformedPoint);
        },

        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function (latlng) {
            return this.projection.project(latlng);
        },

        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function (point) {
            return this.projection.unproject(point);
        },

        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function (zoom) {
            return 256 * Math.pow(2, zoom);
        },

        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function (scale) {
            return Math.log(scale / 256) / Math.LN2;
        },

        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function (zoom) {
            if (this.infinite) { return null; }

            var b = this.projection.bounds,
                s = this.scale(zoom),
                min = this.transformation.transform(b.min, s),
                max = this.transformation.transform(b.max, s);

            return Bounds.create(min, max);
        },

        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.

        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.

        // wrapLng: [min, max],
        // wrapLat: [min, max],

        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,

        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function (latlng) {
            var lng = this.wrapLng ? BaseUtils.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
                lat = this.wrapLat ? BaseUtils.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
                alt = latlng.alt;

            return new LatLng(lat, lng, alt);
        }
    };

    CRS.Simple = BaseUtils.extend({}, CRS, {
        projection: Projection.LonLat,
        transformation: new Transformation(1, 0, -1, 0),

        scale: function (zoom) {
            return Math.pow(2, zoom);
        },

        zoom: function (scale) {
            return Math.log(scale) / Math.LN2;
        },

        distance: function (latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng,
                dy = latlng2.lat - latlng1.lat;

            return Math.sqrt(dx * dx + dy * dy);
        },

        infinite: true
    });

    CRS.Earth = BaseUtils.extend({}, CRS, {
        wrapLng: [-180, 180],

        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see http://rosettacode.org/wiki/Haversine_formula
        R: 6371000,

        // distance between two geographical points using spherical law of cosines approximation
        distance: function (latlng1, latlng2) {
            var rad = Math.PI / 180,
                lat1 = latlng1.lat * rad,
                lat2 = latlng2.lat * rad,
                a = Math.sin(lat1) * Math.sin(lat2) +
                    Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

            return this.R * Math.acos(Math.min(a, 1));
        }
    });

    CRS.EPSG3857 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:3857',
        projection: Projection.SphericalMercator,

        transformation: (function () {
            var scale = 0.5 / (Math.PI * Projection.SphericalMercator.R);
            return new Transformation(scale, 0.5, -scale, 0.5);
        }())
    });

    CRS.EPSG900913 = BaseUtils.extend({}, CRS.EPSG3857, {
        code: 'EPSG:900913'
    });


    CRS.EPSG4326 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:4326',
        projection: Projection.LonLat,
        transformation: new Transformation(1 / 180, 1, -1 / 180, 0.5)
    });


    CRS.EPSG3395 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:3395',
        projection: Projection.Mercator,

        transformation: (function () {
            var scale = 0.5 / (Math.PI * Projection.Mercator.R);
            return new Transformation(scale, 0.5, -scale, 0.5);
        }())
    });

    return CRS;
});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/config',['require','../Constants','../utils/QueryUtils','../utils/BaseUtils','../chart/map/CRS','../dom/Browser'],function (require) {
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var CRS = require("../chart/map/CRS");
    var Browser = require("../dom/Browser");

    var colors = ['#63b2ee', '#76da91', '#f8cb7f', '#f89588', '#7cd6cf', '#9192ab', '#7898e1', '#efa666', '#eddd86', '#9987ce'];

    var defaultColors = [
        '#231815',
        '#727171',
        '#898989',
        '#B5B5B6',
        '#C9CACA'
    ];

    var defaultFontFamily = 'PingFang SC Light, Lantinghei SC-Extralight, Hiragino Sans GB W3, Microsoft Yahei Font, Helvetica, Arial, sans-serif';

    var MAP_CONFIG = {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: CRS.EPSG3857,

        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: undefined,

        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: undefined,

        // @option minZoom: Number = undefined
        // Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
        minZoom: undefined,

        // @option maxZoom: Number = undefined
        // Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
        maxZoom: undefined,

        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],

        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back when he tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: undefined,

        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: undefined,

        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: true,

        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,

        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: true,

        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: true,

        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608, // Precision limit of a 32-bit float

        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 0.5,

        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 0.5,

        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: true,

        // @option dragging: Boolean = true
        // Whether the map be draggable with mouse/touch or not.
        dragging: true,

        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default unless running on old Android devices.
        inertia: !Browser.android23,

        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400, // px/s^2

        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity, // px/s

        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,

        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,

        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0.0,

        // @section Mousewheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,

        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,

        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
    };

    function optionsFun() {

        var options = {

            pie:{
                plotOptions:{
                    rotatable: true,
                    startAngle: 0,
                    endAngle: 360,

                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: seriesValueTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    legend: disabledLegendFun()
                }
            },

            multiPie:{
                plotOptions:{
                    borderWidth: 1,
                    borderColor: 'rgb(255,255,255)',
                    rotatable: true,
                    gradual: 'lighter',
                    innerRadius: 0,
                    startAngle: 0,
                    endAngle: 360,
                    drilldown: true,

                    tooltip: nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,
                    legend: disabledLegendFun()
                }
            },

            treeMap:{
                plotOptions:{
                    borderWidth: 1,
                    borderColor: 'rgb(255,255,255)',
                    zoom: true,

                    tooltip: nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        align: 'top'
                    }
                },

                options:{
                    colors:colors,
                    legend: disabledLegendFun()
                }
            },

            bar:{
                plotOptions:{
                    categoryGap: '20%',
                    gap: '20%',

                    borderRadius: 0,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yCategoryAxisFun()]
                }
            },

            column:{
                plotOptions:{
                    categoryGap: '20%',
                    gap: '20%',

                    borderRadius: 0,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            line:{
                plotOptions:{
                    large: false,
                    connectNulls: false,
                    lineWidth: 2,
                    step: false,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            area:{
                plotOptions:{
                    large: false,
                    connectNulls: false,
                    lineWidth: 2,
                    step: false,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun(),

                    fillColor:true,
                    fillColorOpacity:0.15
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            gauge:{
                thermometer:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,

                        useHtml: false,

                        align: 'left',

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }
                    },

                    valueLabel: {
                        enabled: false,

                        useHtml: false,

                        align: 'left',

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },

                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }

                    },

                    needle: '#ffffff',
                    slotBackgroundColor: '#eeeeee',
                    thermometerLayout: 'vertical'
                },

                ring:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,

                        useHtml: false,

                        style: {
                            fontSize: 24,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }

                    },

                    valueLabel: {
                        enabled: false,

                        useHtml: false,

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }
                    },

                    clockwise: false,
                    paneBackgroundColor: '#eeeeee',
                    innerPaneBackgroundColor: '#f4f4f4'

                },

                pointer:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    seriesLabel: {
                        enabled: false,
                        align: Constants.BOTTOM,
                        useHtml: false,
                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}"
                        }
                    },

                    valueLabel: {
                        enabled: false,
                        useHtml: false,
                        backgroundColor: '#F5F5F7',
                        style: {
                            color: defaultColors[1],
                            fontSize: 10,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${SERIES}${VALUE}"
                        }
                    },

                    needle: '#E5715A',
                    hinge: '#656B6D',
                    hingeBackgroundColor: '#DCF2F9',
                    paneBackgroundColor: '#FCFCFC'
                },

                slot:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,
                        useHtml: false,
                        style: {
                            fontSize: 36,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold',
                            textShadow: '0px 2px 0px rgba(0,0,0,0.08)'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }
                    },

                    valueLabel: {
                        enabled: false,
                        useHtml: false,
                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }
                    },

                    needle: '#ffffff',
                    slotBackgroundColor: '#eeeeee'
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    gaugeAxis: [{
                        type: 'value',
                        showLabel: true,
                        step: 1,

                        enableTick: true,
                        tickColor: '#BBBBBB',
                        tickWidth: 1,

                        enableMinorTick: true,
                        minorTickColor: '#e2e2e2',
                        minorTickWidth: 1,

                        labelStyle: {
                            color: defaultColors[1],
                            fontFamily: defaultFontFamily,
                            fontSize: 10
                        }
                    }]
                }
            },

            radar:{
                plotOptions:{

                    fillColorOpacity: 0.15,

                    columnType: false,

                    marker: {
                        radius: 4.5
                    },

                    lineWidth: 2,

                    shape: 'circle',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    polar: {},

                    legend: disabledLegendFun(),

                    angleAxis: [angleAxisFun()],

                    radiusAxis: [radiusAxisFun()]
                }
            },

            scatter:{
                plotOptions:{
                    large: false,
                    lineWidth: 0,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    opacity: 1,

                    tooltip: seriesXYSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${X}${Y}${SIZE}"
                        },
                        "enabled": false,
                        "align": "outside"
                    }
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    rangeLegend: disabledRangeLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            bubble:{
                plotOptions:{
                    large: false,
                    displayNegative: true,
                    shadow: true,
                    minSize: 12,
                    maxSize: 60,
                    sizeBy: 'area',
                    opacity: 0.7,

                    tooltip: seriesXYSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${X}${Y}${SIZE}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    rangeLegend: disabledRangeLegendFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            funnel:{
                plotOptions:{
                    borderColor: "rgb(255,255,255)",
                    borderWidth: 1,

                    sort: true,
                    useSameSlantAngle: true,

                    dataLabels: {
                        "formatter": {
                            "identifier": "${VALUE}"
                        },
                        "enabled": false,
                        "connectorWidth": 1,
                        "align": "outside"
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle
                }
            },

            wordCloud:{
                plotOptions:{
                    "fontFamily": "Microsoft YaHei",
                    "maxRotation": 0,
                    "minRotation": 0,

                    tooltip:nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "enabled": false
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle,

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            structure:{
                plotOptions:{
                    layout:'vertical',
                    force:true,

                    lineColor:'rgb(156,156,156)',
                    lineOpacity:1,

                    borderWidth:1,
                    borderOpacity:1,

                    fillColorOpacity:1,

                    tooltip:nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "enabled": false
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle,

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            forceBubble:{
                plotOptions:{
                    large: false,
                    displayNegative: true,
                    shadow: true,
                    minSize: 12,
                    maxSize: 60,
                    sizeBy: 'area',
                    opacity: 1.0,

                    tooltip: normalTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "{SERIES}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    zoom: xyZoomFun(),

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            areaMap:{

                plotOptions:{
                    nullColor: '#cccccc',
                    opacity: 0.75,
                    borderColor: '#ffffff',
                    borderWidth: 1,
                    borderOpacity: 1,

                    tooltip: nameSeriesValueSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun(),

                    dTools: {
                        style: {
                            "fontFamily": defaultFontFamily,
                            "color": defaultColors[1],
                            "fontSize": 12,
                            "fontWeight": ""
                        },
                        currentColor: '#62b2ef',
                        backgroundColor: 'white',
                        enabled: false
                    }
                }
            },

            pointMap:{

                plotOptions:{
                    opacity: 1,

                    icon: {
                        iconUrl: '../../doc/example/marker-icon.png',
                        iconSize: [25, 41]
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}${SERIES}${VALUE}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: nameSeriesValueSizeTooltipFun()
                },

                options:{
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun(),

                    dTools: {
                        style: {
                            "fontFamily": defaultFontFamily,
                            "color": defaultColors[1],
                            "fontSize": 12,
                            "fontWeight": ""
                        },
                        currentColor: '#62b2ef',
                        backgroundColor: 'white',
                        enabled: false
                    }
                }
            },

            heatMap:{

                plotOptions:{
                    'maxOpacity':1,
                    'minOpacity':0,
                    'radius':15,
                    'blur':0.15
                },

                options:{

                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun()
                }
            },

            lineMap:{

                plotOptions:{
                    "lineWidth": 0.5,
                    "curveness": 0.3,
                    "mouseOverColor": "rgb(253,221,49)",
                    "opacity": 1
                },

                options: {
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun()
                }
            },

            gantt: {
                plotOptions: {
                    newLine: true,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${DURATION}${PROGRESS}"
                        },
                        "enabled": false
                    },

                    tooltip: normalTooltipFun()
                },

                options: {
                    processes: {
                        resize: true
                    },
                    levelBar: {
                        enabled: true
                    },
                    timeAxis: {
                        zoom: true,
                        showWeekends: true
                    },
                    colors: colors,
                    legend: disabledLegendFun()
                }
            }
        };


        options.MAP_CONFIG = MAP_CONFIG;
        return options;
    }


    function normalTooltipFun(){
        return {
            formatter: {
                identifier: "${CATEGORY}${SERIES}${VALUE}"
            },
            enabled: true,
            animation: true,
            follow: false,
            backgroundColor: 'rgba(0,0,0,0.5)',
            borderColor: null,
            borderWidth: 0,
            borderRadius: 2,
            shadow: true,
            hideDelay: 500,
            shared: false,
            padding: 5
        }
    }

    function disabledTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {enabled: false}}, true);
    }

    function seriesXYSizeTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${SERIES}${X}${Y}${SIZE}"}}, true);
    }

    function seriesValueTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${SERIES}${VALUE}"}}, true);
    }

    function nameSeriesValueTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${NAME}${SERIES}${VALUE}", shared:true}}, true);
    }

    function nameSeriesValueSizeTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${NAME}${SERIES}${VALUE}${SIZE}", shared:true}}, true);
    }

    function nullTitleFun() {
        return {
            align: 'center',
            backgroundColor: null,
            borderRadius: 0,
            floating: false,
            x: 0,
            y: 0,
            text: null,
            style: {
                color: defaultColors[1],
                fontSize: 18,
                fontFamily: defaultFontFamily
            },
            useHtml: false
        }
    }

    var gradualStyle = 'gradual';

    function xyZoomFun() {
        return {
            zoomType: 'xy',
            zoomTool: {
                enabled: false,
                resize: true
            }
        }
    }

    function rangeLegendFun() {
        return {
            visible: true,
            enabled: true,
            borderColor: defaultColors[4],
            borderWidth: 0,
            hiddenColor: defaultColors[4],
            hoverColor: '#293C55',
            style: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            position: 'right',
            floating: false,
            x: 0,
            y: 0,
            layout: 'vertical',
            continuous: true,
            margin: 10
        }
    }

    function disabledRangeLegendFun() {
        return QueryUtils.merge(rangeLegendFun(), {enabled:false}, true);
    }

    function disabledLegendFun() {
        return {
            visible: true,
            enabled: false,
            hiddenColor: defaultColors[4],
            hoverColor: '#293C55',
            borderRadius: 0,
            borderColor: defaultColors[4],
            borderWidth: 0,
            backgroundColor: null,
            style: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            position: 'right',
            floating: false,
            layout: 'vertical',
            x: 0,
            y: 0,
            shadow: false,
            margin: 10
        }
    }

    function xCategoryAxisFun() {
        return {
            type: 'category',
            position: 'bottom',
            onZero: false,
            reversed: false,
            title: {
                text: null,
                align: 'center',
                rotation: 0,
                useHtml: false,
                style: {
                    color: defaultColors[1],
                    fontFamily: defaultFontFamily,
                    fontSize: 12
                }
            },
            lineWidth: 0.5,
            lineColor: defaultColors[2],
            showArrow: false,
            enableTick: true,
            enableMinorTick: false,

            minorTickColor: defaultColors[2],
            minorTickWidth: 0.5,
            minorTickLength: 2,

            tickColor: defaultColors[2],
            tickWidth: 0.5,
            tickLength: 4,

            tickPadding: 4,
            gridLineWidth: 0,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function yValueAxisFun() {
        return {
            type: 'value',
            position: 'left',
            onZero: false,
            reversed: false,
            title: {
                text: null,
                align: 'center',
                rotation: 0,
                useHtml: false,
                style: {
                    color: defaultColors[1],
                    fontFamily: defaultFontFamily,
                    fontSize: 12
                }
            },
            lineWidth: 0,
            lineColor: defaultColors[2],
            showArrow: false,
            enableTick: false,
            enableMinorTick: false,

            minorTickColor: defaultColors[2],
            minorTickWidth: 0.5,
            minorTickLength: 2,

            tickColor: defaultColors[2],
            tickWidth: 0.5,
            tickLength: 4,

            tickPadding: 4,
            gridLineWidth: 1,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function xValueAxisFun() {
        return QueryUtils.merge(xCategoryAxisFun(), {type:'value'}, true);
    }

    function yCategoryAxisFun() {
        return QueryUtils.merge(yValueAxisFun(), {type:'category'}, true);
    }

    function angleAxisFun() {
        return {
            type: 'category',
            lineWidth: 0.5,
            lineColor: defaultColors[2],
            gridLineWidth: 1,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function radiusAxisFun() {
        return QueryUtils.merge(angleAxisFun(), {type:'value'}, true);
    }

    function drillTools(){
        return {
            style: {
                "fontFamily": defaultFontFamily,
                "color": defaultColors[1],
                "fontSize": 12,
                "fontWeight": ""
            },
            currentColor: '#62b2ef',
            backgroundColor: 'white',
            enabled: false
        }
    }

    return optionsFun;
});
/**
 * Created by eason on 2017/2/4.
 */
define('vans/VanChartLibrary',['require','../Constants'],function(require){
    var Constants = require('../Constants');

    var _registeredVanCharts = {};

    /**
     * 根据名字获得某种图表类型的function
     * @param name 图表名字
     */
    function get(name){
        return _registeredVanCharts[name] || _registeredVanCharts[Constants.VANCHART];
    }

    /**
     * 注册某种图表类型
     * @param name 图表的名字
     * @param VanChart 具体的类型
     */
    function register(name, VanChart){
        _registeredVanCharts[name] = VanChart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 15/6/17.
 */
define('vans/VanChart',['require','./../utils/BaseUtils','./../utils/QueryUtils','../dom/Evented','./VanChartLayout','./../ComponentLibrary','./../ChartLibrary','./../Constants','./../HammerHandler','./../vector/SvgRenderer','./../vector/VmlRenderer','../utils/Point2D','../locale/localeText','../locale/zh-cn','./../theme/config','./../theme/config','./VanChartLibrary'],function(require){

    var BaseUtils = require('./../utils/BaseUtils');
    var QueryUtils = require('./../utils/QueryUtils');
    var Evented = require('../dom/Evented');
    var VanChartLayout = require('./VanChartLayout');
    var ComponentLibrary = require('./../ComponentLibrary');
    var ChartLibrary = require('./../ChartLibrary');

    var Constants = require('./../Constants');
    var Handler = require('./../HammerHandler');

    var SvgRenderer = require('./../vector/SvgRenderer');
    var VmlRenderer = require('./../vector/VmlRenderer');

    var Point = require('../utils/Point2D');

    var localeText = require('../locale/localeText');

    require('../locale/zh-cn');

    // Cmen: 所有的默认间隙都是基于16px字体大小的,后期如果需要更改默认间隙,可以在BaseUtils里面设置DEFAULT_PADDING_FONTSIZE来调整
    // 考虑到缩放的影响,所有关于间隙的尺寸计算,都从对应的_FUN函数中获取根据缩放SCALE计算后的值。
    var PADDING = 8;
    var PADDING_FUN = function (){
        return BaseUtils.paddingConvertWithScale(PADDING);
    }

    var INTERACTIVE_COMPONENTS = [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.ANGLE_AXIS_COMPONENT];

    var VanChart = Evented.extend({
        vanChartType:'vanChart',
        initialize:function(option, dom, vancharts){

            localeText.setLocale(option.language);

            this.wrapDom = dom;
            this.width = BaseUtils.getDomWidth(dom);
            this.height = BaseUtils.getDomHeight(dom);

            // @Cmen：CHART-1130: 开启自适应插件时，resize的时候，会移除旧的dom，并生成新dom用于initChart
            // 而这时如果resize的频率比较高，就导致前面的initialize的dom已经不存在了，同样的resize方法也存在这个问题
            if(!this.width || !this.height) { return; }

            this.vancharts = vancharts;
            this.series = [];
            this.components = {};
            this._targets = {};

            this.animationCount = 0;

            this._changeDataState = false;
            this.fullScreenChart = null;//关联全屏以后的图表

            this.setOptions(option);

            this.handler = new Handler(this, dom);

            this._initDomLayout(this.wrapDom);

            this.update();
        },

        setOptions:function(option){

            option.series = option.series || [];//保证series不为空

            option.series.forEach(function(sery){
                sery.data = sery.data || [];
            });

            //坐标轴可能是数组
            this._mergeThemeConfig(option);

            if (option.plotOptions.inverted && option.dataSheet) {
                option.dataSheet.enabled = false;
            }

            this.options = option;

            if(this.fullScreenChart){
                this.fullScreenChart.setData(option);
            }
        },

        _initDomLayout:function(dom){
            this.dom = dom;
            this.renderer = BaseUtils.isSupportSVG() ? new SvgRenderer(dom, this) : new VmlRenderer(dom, this);
            this.renderer.onAdd();

            this.on({
                'animationStart':this._animationStart,
                'animationEnd':this._animationEnd
            })
        },

        _animationStart:function(){
            // console.log('series ani start, count reset to 0');

            //锁住fire的'animationEnd'
            this._animationStarted = true;
            this.animationCount = 0;

            this.removeMoreLabel();

            this.series.forEach(function(ser){
                ser._removeDataLabels();
                ser.render();
            });

            if (!this.animationCount) {
                this.fire('animationEnd');
            }
        },

        /**
         * 移除所有的MoreLabel
         * @return {[type]} [description]
         */
        removeMoreLabel: function () { 
            var moreLabel = this.getComponent(ComponentLibrary.MORELABEL_COMPONENT);
            moreLabel && moreLabel.removeAllMoreLabels(); 
        },

        _animationEnd:function(){

            if(!this.renderer){
                return; //has been removed
            }

            this._animationStarted = false;

            this.series.forEach(function(ser){
                ser._animateEnd();
            });

            this._consoleDone();
        },

        _removeChangeDataState: function (series) {
            if(this._changeDataState) {
                this._changeDataSeries = this._changeDataSeries || [];
                this._changeDataSeries.push(series);

                if (this._changeDataSeries.length >= this.series.length) {
                    //所有系列的动画完成,changeData的状态给改回来
                    this._changeDataState = false;
                    this._changeDataSeries = [];
                }
            }
        },

        _needShowMoreLabel:function () {
            var moreLabel = this.options.moreLabel;
            return this._changeDataState && moreLabel && moreLabel.enabled && !this.isLargeMode();
        },

        _clearMoreLabels: function () {
            this.series.forEach(function(ser){
                ser._clearMoreLabels();
            });
        },

        _initIntermediateState:function(){
            this.colorMap = {};
            this.orderMap = {};
            this.cateMap = {};
            this.scale = 1;
            this.timeQueue = this.clearTimeQueue();
            this.clipPool = {};
            this.axisSize = {
                'left':0, 'right':0, 'bottom':0, 'top':0
            };

            this.layerMap = this.layerIndex = null;
        },

        //外部调用接口，传入新的配置
        refresh:function(options){

            var lastLarge = !!(this.options && this.options.plotOptions && this.options.plotOptions.large),
                currentLarge = !!(options && options.plotOptions && options.plotOptions.large);

            if(lastLarge != currentLarge){
                this.series && this.series.forEach(function (ser) {
                    ser.remove();
                });
            }

            this.setOptions(options);

            this.update();
        },

        //刷新按钮在两个情况下会出现,1.排序以后 2.坐标轴缩放的时候
        //所以刷新要做的是两件事,1.重新按照原来的顺序排布 2.使所有系列可见,并且刷新坐标轴
        refreshRestore:function(){

            var vanchart = this, components = vanchart.components;

            INTERACTIVE_COMPONENTS.forEach(function(cName){
                components[cName] && vanchart._restoreCategoryAxisBasedSeries(components[cName]);
            });

            //仪表盘恢复
            var gaugeSeries = this.seriesOfType(Constants.GAUGE_CHART);
            if(gaugeSeries.length == this.series.length){
                this.series.sort(function(a, b){
                    return a.index - b.index;
                });
            }

            //饼图的排序恢复
            this.seriesOfType(Constants.PIE_CHART).forEach(function(sery){

                var map = sery.points.map(function(point){
                    return point.graphic;
                });

                var orderMap = {};
                sery.options.data.forEach(function(datum, i){
                    orderMap[datum.x] = i;
                });

                sery.points.sort(function(sliceA, sliceB){
                    return  orderMap[sliceA.x] - orderMap[sliceB.x];
                });

                sery.points.forEach(function(point, index){
                    point.graphic = map[index];
                });
            });

            //多层饼图恢复
            var multipie = this.seriesOfType(Constants.MULTIPIE_CHART);
            if(multipie.length){
                multipie[0].orderData(null)
            }


            //理论上来讲不用全部属性都刷新一遍，但是涉及到图例的交互，分别刷新就比较复杂
            //先保证效果对
            this.update();
        },

        //实现的思路应该是point的graphic的排序,而不应该去刷新属性
        orderData:function(){

            var vanchart = this, components = vanchart.components;

            INTERACTIVE_COMPONENTS.forEach(function(cName){
                components[cName] && vanchart._orderCategoryAxisBasedSeries(components[cName]);
            });

            var increaseOrder = this.orderType == Constants.ASCENDING;
            var para = increaseOrder ? 1 : -1;

            //仪表盘排序
            var gaugeSeries = this.seriesOfType(Constants.GAUGE_CHART);
            if(gaugeSeries.length == this.series.length){
                this.series.sort(function(serA, serB){
                    var totalA = serA.getSeryTotalValue();
                    var totalB = serB.getSeryTotalValue();
                    return (totalA - totalB) * para;
                });
            }

            //饼图的排序
            this.seriesOfType(Constants.PIE_CHART).forEach(function(sery){
                var map = sery.points
                    .filter(function (point) {
                        return point.visible;
                    })
                    .map(function(point){
                        return point.graphic;
                    });

                sery.points.sort(function(sliceA, sliceB){
                    return  increaseOrder ? sliceA.y - sliceB.y : sliceB.y - sliceA.y;
                });

                var index = 0;
                sery.points.forEach(function(point){
                    if (point.visible) {
                        point.graphic = map[index];
                        ++index;
                    }
                });
            });

            //多层饼图排序
            var multipie = this.seriesOfType(Constants.MULTIPIE_CHART);
            if(multipie && multipie.length){
                multipie[0].orderData(increaseOrder)
            }

            this.reRenderSeries();

            //这里的顺序不能换，zoom那边用了_sortedPoints
            INTERACTIVE_COMPONENTS.concat([ComponentLibrary.ZOOM_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.POLAR_COMPONENT]).forEach(function(cName){
                components[cName] && components[cName].render();
            });
        },

        /**
         * 分类轴刷新
         * @param  {[type]} axisComponent [description]
         * @return {[type]}               [description]
         */
        _restoreCategoryAxisBasedSeries:function(axisComponent){
            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex), series = axis.series;

                //缩放之后刷新，没有orderMap
                if(axis._isBaseAxis() && axis.isCategory() && this.orderMap && Object.keys(this.orderMap).length){

                    var order = this.orderMap[axis.componentType][axisIndex];
                    var keyIndexMap = {};
                    order.forEach(function(p, i){
                        keyIndexMap[p] = i;
                    });

                    var lastOrder = axis._dataDomain;
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i], normalData = true;

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexOf(lastOrder, point.getCategory())] = point.graphic;

                            if(!point.graphic){
                                normalData = false;
                            }
                        });

                        sery.points.forEach(function(point){
                            point.graphic = normalData ? lastOrderMap[keyIndexMap[point.getCategory()]] : point.graphic;

                            //折线图,雷达图，排序以后，图片标记点和形状的标记点不能兼容
                            sery.updatePointGraphic(point);
                        });
                    }
                }
            }
        },

        /**
         * 分类轴排序
         * @param  {[type]} axisComponent [description]
         * @return {[type]}               [description]
         */
        _orderCategoryAxisBasedSeries:function(axisComponent){

            var para = this.orderType == Constants.ASCENDING ? 1 : -1;

            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex);

                this.orderMap[axis.componentType] = this.orderMap[axis.componentType] || [];

                if(!this.orderMap[axis.componentType][axisIndex]){
                    this.orderMap[axis.componentType][axisIndex] = axis._dataDomain;
                }


                var series, valueMap = [], points, keyIndexMap = {} , newCategories = [];

                if(axis._isBaseAxis() && axis.isCategory()){

                    series = axis.series;
                    points = series[0].points;

                    var isMultiCateAxis = axis.isMultiCateAxis && axis.isMultiCateAxis();
                    isMultiCateAxis ? sortMultiCategoryAxis() : sortNormalCategoryAxis();

                    var lastOrder = axis.getOriginalCategories();
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i], normalData = true;

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexOf(lastOrder, point.getCategory())] = point.graphic;

                            if(!point.graphic){
                                normalData = false;
                            }
                        });

                        sery.points.forEach(function(point){
                            point.graphic = normalData ? lastOrderMap[keyIndexMap[point.getCategory()]] : point.graphic;
                            //折线图,雷达图，排序以后，图片标记点和形状的标记点不能兼容
                            sery.updatePointGraphic(point);
                        });
                    }

                    axis.setCategories(newCategories);  // 排序完成后更新坐标轴的domain
                }

                //普通的单层轴排序
                function sortNormalCategoryAxis(){

                    for(var i = 0, len = points.length; i < len; i++){
                        var point = points[i];
                        var total = 0;
                        point.points.forEach(function(point){
                            if(point.visible && point.series.visible){
                                total += Math.abs(point.getTargetValue());
                            }
                        });

                        valueMap.push({key:point.category, value:total});
                    }

                    valueMap.sort(function(a, b){return (a.value - b.value) * para});
                    
                    valueMap.forEach(function(p, i){
                        keyIndexMap[p.key] = i;
                        newCategories.push(p.key);
                    });
                }  

                // 多分类轴排序，保证倒数第二层分类顺序不变，对倒数第一层进行排序
                function sortMultiCategoryAxis(){
                    var valueArr = [];

                    for(var i = -1; ++i < points.length;){
                        var point = points[i];
                        var total = 0;
                        point.points.forEach(function (p){
                            if(p.visible && p.series.visible){
                                total += Math.abs(p.getTargetValue());
                            }
                        });

                        var categoryArray = point.options.categoryArray,
                            keyString = BaseUtils.encodeCategoryArray(categoryArray.slice(0, categoryArray.length - 1)),
                            cateString = BaseUtils.encodeCategoryArray(categoryArray);

                        var datum = {
                            key: keyString,
                            cate: cateString,
                            value: total
                        };

                        if(valueMap[keyString] == null){
                            valueMap[keyString] = valueArr.push([datum]) - 1;
                        }else{
                            valueArr[valueMap[keyString]].push(datum);
                        }
                    }

                    valueArr.forEach(function (cateArr){
                        cateArr.sort(function (a, b){
                            return (a.value - b.value) * para;
                        });
                    });

                    var keyIndex = 0;
                    valueArr.forEach(function (cateArr){
                        cateArr.forEach(function (cate){
                            keyIndexMap[cate.cate] = keyIndex;
                            newCategories.push(cate.cate);
                            keyIndex++;
                        })
                    });
                }


                
            }
        },


        /** 
         * 添加新系列 
         * @param options 
         */ 
        addSeries: function (serData){
            // todo 某些情况下，肯定需要判断添加到中间的位置

            // 对于新增的Seres，还需要将其默认的PlotOptions与vanchart.options.plotOptions合并一下
            var type = serData.type, option = this.options;

            var config = require('./../theme/config')();
            var defaultPlotOptions = config[type].plotOptions;

            QueryUtils.merge(option, config[type].options, false);
            if(option.plotOptions[type]){
                option.plotOptions[type] = QueryUtils.merge(option.plotOptions[type], defaultPlotOptions, false);
            }else{
                option.plotOptions = QueryUtils.merge(option.plotOptions, defaultPlotOptions, false);
            }

            option.series.push(serData);
        }, 

        /**
         * 监控刷新返回的变化数据处理：
         * 针对add, update, delete三个操作分别处理， 其中：
         *     1. add操作要分为vanChart.addSeries和series.addPoint
         *     2. delete和update，要先计算出其对应的索引，然后根据索引更新
         * @param  {[type]} options [变化的数据] example:{add:{...}, update:{...}, delete:{...}}
         * @return {[type]}         [description]
         */
        autoRefresh: function (options, index) {
            var addData = options.add || [],
                removeData = options.remove || [],
                updateData = options.update || [],
                additionalOption = options.option || {};
            var vanchart = this, option = vanchart.options, chartType = option.chartType;

            var seriesMap = {}, type;
            this.series.forEach(function(ser){
                type = ser.type;

                if(type == Constants.GAUGE_CHART){
                    type += (ser.gaugeType + (ser.options.thermometerLayout || ''));
                }

                if(type == Constants.RADAR_CHART){
                    type = ser.columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                }

                var sameNameArray = seriesMap[ser.name + type];
                if(sameNameArray){
                    sameNameArray.push(ser);
                } else {
                    sameNameArray = [ser];
                    seriesMap[ser.name + type] = sameNameArray;
                }
            });

            // 移除数据
            removeData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;

                if(ser) {
                    serData.data.forEach(function (datum){
                        var pos = ser.calculatePointIndex(datum);
                        BaseUtils.hasDefined(pos) && ser.removePoint(pos, false);
                    });
                    // 当已有系列的data的length为0时，series已移除，对应的sameNameArray也减1
                    if(ser.options.data.length === 0) {
                        sameNameArray && sameNameArray.splice(0,1);
                    }
                }
            });

            // 新增数据
            addData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;
                if(ser) {
                    serData.data.forEach(function (datum){
                        ser.addPoint(datum)
                    })
                } else {
                    vanchart.addSeries(serData);
                }
            });

            // 更新数据
            updateData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;

                if(ser) {
                    serData.data.forEach(function (datum){
                        var pos = ser.calculatePointIndex(datum);
                        BaseUtils.hasDefined(pos) && ser.updatePoint(pos, datum, false);
                    })
                }
            });

            // 监控刷新中，标题等数据可以会发生更新

            QueryUtils.merge(this.options, additionalOption, true);

            if(this.isMap()){
                this.options.xAxis = this.options.yAxis = this.options.zoom = undefined;
            }
            // 变化的数据更新到options之后，update统一刷新图表
            this.autoRefreshRender();

            if(this.fullScreenChart) {
                this.fullScreenChart.charts[index].autoRefreshRender();
            }

            // 创建独有的series的key
            function createSeriesKey(serData, index){
                type = serData.type || chartType;
                var seriesName = BaseUtils.pick(serData.name, 'Series' + index);

                var key = seriesName + type;
                if(type == Constants.GAUGE_CHART){
                    var style = serData.style || option.plotOptions.style;
                    var layout = serData.thermometerLayout || option.plotOptions.thermometerLayout || '';
                    key = seriesName + type + style + layout;
                }else if(type == Constants.RADAR_CHART){
                    var columnType = serData.columnType || option.plotOptions.columnType;
                    columnType = columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                    key = seriesName + columnType;
                }

                return key;
            }
        },

        /**
         * 监控刷新视图更新，为什么这么写：
         * 当chart和fullScreenChart关联起来之后，二者共用一个options，因此数据处理只需要在chart的autoRefresh里面进行
         * 而渲染则需要分开来，由于MoreLabel的渲染需要一些判断因此把这部分拿出来
         * @return {[type]} [description]
         */
        autoRefreshRender: function (){
            // 这里需要手动把这个属性设置成true
            if(this._changeDataState) {
                this._changeDataSeries = [];  //对于刷新间隔小于或等于持续时间的值变化提示,再次刷新的时候,需要手动把_changeDataSeries置空
            }
            
            this._changeDataState = true;

            this.update();
        },

        //图表整个的属性有改变的时候,至上而下的刷新所有组件.图表的属性.
        update:function(){

            this._initIntermediateState();

            var option = this.options, vanchart = this,
                seriesData = option.series, chartType = option.chartType;
            var name, Class;

            //构建坐标轴,范围图例等组件
            var Components = ComponentLibrary.getRegisteredComponents(), ComponentsOrder = ComponentLibrary.ComponentsOrder;

            for(var index = 0, cCount = ComponentsOrder.length; index < cCount; index++){
                name = ComponentsOrder[index]; Class = Components[name];

                if(name == ComponentLibrary.RANGE_LEGEND_COMPONENT && option[name]){
                    var rangeType = option[name].continuous ? ComponentLibrary.GradientRangeLegend : ComponentLibrary.INTERVAL_RANGE_LEGEND;

                    if(this.components[name] && this.components[name].type != rangeType){
                        this.components[name].remove();
                        this.components[name] = null;
                    }

                    Class = ComponentLibrary.get(rangeType);
                }

                if(Class){
                    var enabled = option[name] && (BaseUtils.hasNotDefined(option[name].enabled) || option[name].enabled);

                    if(!enabled && name == ComponentLibrary.TOOLBAR_COMPONENT){
                        enabled = true;
                        option[name] = {'enabled':true, 'hidden':false};
                    }

                    if(option[name] && enabled){

                        if(this.components[name]){
                            this.components[name].refresh(option[name], vanchart);
                        }else{
                            this.components[name] = new Class(option[name], name, vanchart);
                        }

                    }else if(this.components[name]){
                        this.components[name].remove();
                        this.components[name] = null;
                        delete this.components[name];
                    }
                }
            }

            var seriesMap = {}, type, series = [];
            vanchart.series.forEach(function(ser){
                type = ser.type;

                if(type == Constants.GAUGE_CHART){
                    type += (ser.gaugeType + (ser.options.thermometerLayout || ''));
                }

                if(type == Constants.RADAR_CHART){
                    type = ser.columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                }

                var sameNameArray = seriesMap[ser.name + type];
                if(sameNameArray){
                    sameNameArray.push(ser);
                } else {
                    sameNameArray = [ser];
                    seriesMap[ser.name + type] = sameNameArray;
                }
            });

            seriesData.forEach(function(serData, index){
                // @Cmen 这里注明为什么使用克隆的SerData， 之前直接使用serData的时候，refresh的时候，会对series.option和point.option进行扩展，
                // 这些扩展就会被映射到初始的SerData上面， 而在数据更新的时候，第二次refreshOption的时候，处理一些诸如markerColor的属性的时候，
                // 则不好判断该属性是后期扩展的还是在最开始的数据里就有的，因此就导致了某些属性无法更新
                // 理论上，绘图的时候，不应该修改原始的series数据，因此这里使用serData的拷贝，而更新数据则是基于原始的series.data进行的
                serData = BaseUtils.clone(serData);

                type = serData.type || chartType;
                var seriesName = BaseUtils.pick(serData.name, 'Series' + index);

                var Class = ChartLibrary.get(type), key = seriesName + type;
                if(type == Constants.GAUGE_CHART){
                    var style = serData.style || option.plotOptions.style;
                    var layout = serData.thermometerLayout || option.plotOptions.thermometerLayout || '';
                    Class = ChartLibrary.get(style);
                    key = seriesName + type + style + layout;
                }else if(type == Constants.RADAR_CHART){
                    var columnType = serData.columnType || option.plotOptions.columnType;
                    columnType = columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                    Class =  ChartLibrary.get(columnType);
                    key = seriesName + columnType;
                }

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;
                ser = ser ? ser.refresh(serData, index) : new Class(serData, vanchart, index);
                series.push(ser);
                sameNameArray && sameNameArray.splice(0,1);
            });

            for(var serKey in seriesMap){
                var sameNameArray = seriesMap[serKey];
                sameNameArray && sameNameArray.forEach(function (ser) {
                    ser && ser.remove();
                });
            }

            vanchart.series = series;

            var gaugeAxis = this.components[ComponentLibrary.GAUGE_AXIS_COMPONENT];
            if(gaugeAxis){
                gaugeAxis.initAttributesWithSeries();
            }

            var rangeLegend = this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT];
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            series.forEach(function(ser){
                // try in large mode
                if (ser.type === Constants.LINE_MAP && ser.options.large) {
                    return;
                }
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            vanchart.layoutComponentsAndCharts();
        },

        layoutComponentsAndCharts:function(){
            //计算百分比和标签，百分比会因为系列是否可见而每次都变化，从而导致标签的变化
            //还有像气泡图的半径也能在具体布局之前就推算出来

            this.hoverPoint = this.hoverSeries = null;

            VanChartLayout.PLANE_SYSTEM_LAYOUT(this);

            this.render();
        },

        //考虑padding的影响
        _getDefaultBounds:function(){
            var padding = (this.options && this.options.padding) || PADDING_FUN();
            var borderWidth = (this.options && this.options.borderWidth) || 0;
            padding = borderWidth + padding;

            return BaseUtils.makeBounds(padding, padding, Math.max(this.width - 2 * padding, 0), Math.max(this.height - padding, 0));
        },

        reRenderWholePlot:function(){
            VanChartLayout.reLayoutPlotBounds(this);

            VanChartLayout.calculateSeries(this);

            VanChartLayout.calculateSeriesShapes(this);

            this.render();
        },

        dealAxisZoom:function(downPos, upPos){
            var zoomType = this.options.zoom.zoomType,
                xAxis = this.components.xAxis,
                yAxis = this.components.yAxis;

            if(xAxis && zoomType.indexOf('x') !== -1){
                xAxis.axisZoom(downPos, upPos);
            }

            if(yAxis && zoomType.indexOf('y') !== -1){
                yAxis.axisZoom(downPos, upPos);
            }

            this.reRenderWholePlot();
        },

        //缩放等交互，闪烁动画中断
        clearAllEffects:function () {
            this.series.forEach(function(ser){
                ser.points.forEach(function (point) {
                    point.clearPointEffect();
                })
            });
        },

        drawAllEffects:function () {
            this.series.forEach(function(ser){
                ser._drawEffectPoints();
            });
        },

        _calculateZoomParas:function (downPos, upPos) {
            var plotBounds = this.bounds;
            var minX = Math.min(downPos.x, upPos.x) - plotBounds.x;
            var minY = Math.min(downPos.y, upPos.y) - plotBounds.y;

            var detX = Math.abs(downPos.x - upPos.x);
            var detY = Math.abs(downPos.y - upPos.y);

            var scale = Math.min(plotBounds.width/detX, plotBounds.height/detY);

            var wWidth = plotBounds.width / scale;
            var wHeight = plotBounds.height / scale;

            var shiftX = (plotBounds.width - wWidth)/2 - minX;
            var shiftY = (plotBounds.height - wHeight)/2 - minY;

            return {
                shiftX:shiftX,
                shiftY:shiftY,
                scale:scale
            };
        },

        //默认配置，主题配置的组合
        _mergeThemeConfig:function(option){
            var config = require('./../theme/config')();

            var merged = {}, vanchart = this;

            option.series.forEach(function(ser){
                var type = ser.type || option.chartType;
                var defaultPlotOptions = config[type].plotOptions;

                if(type == Constants.GAUGE_CHART){
                    var style = ser.style || (option.plotOptions.gauge && option.plotOptions.gauge.style) || option.plotOptions.style;
                    style = style == 'pointer_semi' ? 'pointer' : style;
                    defaultPlotOptions = config.gauge[style];

                    var gaugeLabelKey = ['seriesLabel', 'valueLabel', 'percentageLabel'];

                    gaugeLabelKey.forEach(function(key){
                        if(BaseUtils.hasDefined(ser[key])){
                            QueryUtils.merge(ser[key], defaultPlotOptions[key], false);
                        }
                    });
                }

                if(!merged[type]){
                    merged[type] = true;
                    QueryUtils.merge(option, config[type].options, false);
                    if(option.plotOptions[type]){
                        option.plotOptions[type] = QueryUtils.merge(option.plotOptions[type], defaultPlotOptions, false);
                    }else{
                        option.plotOptions = QueryUtils.merge(option.plotOptions, defaultPlotOptions, false);
                    }
                }
            });

            if(this.isMap()){
                option.xAxis = option.yAxis = option.zoom = undefined;

                BaseUtils.extend(option, config.MAP_CONFIG)
            }

            if(option.chartType == Constants.RADAR_CHART){
                option.polar = option.polar || {};
            }

            option.tooltip = option.tooltip || {};
        },

        getChartMinMaxValue:function(){

            var min = Number.MAX_VALUE, max = -min;

            this.series.forEach(function(ser){

                ser.points
                    .filter(function (point) {
                        return !point.isNull && !isNaN(point.getTargetValue());})
                    .forEach(function (point) {
                        var value = point.getTargetValue();
                        max = Math.max(max, value);
                        min = Math.min(min, value);
                    });

            });

            if(min > max){
                min = 0;
                max = 100;
            }

            return [min, max];
        },

        getParentDom:function(){
            return this.dom;
        },

        getDivParentDom:function(){
            return this.wrapDom;
        },

        isInverted: function () {
            return !!this.options.plotOptions.inverted;
        },

        setPlotBounds:function(newBounds){
            this.bounds = newBounds;
        },

        getPlotClipBounds:function(){
            var x = 0,  y = 0, width = this.bounds.width, height = this.bounds.height;
            var locationMap = {}, all = [];
            if(this.components.xAxis){
                all = all.concat(this.components.xAxis._axisList);
            }

            if(this.components.yAxis){
                all = all.concat(this.components.yAxis._axisList);
            }

            all.forEach(function(axis){
                var position = axis.getPosition();
                if(!axis.isOnZero() && !locationMap[position]){
                    locationMap[position] = axis.getLineWidth();
                }
            });

            y = locationMap[Constants.TOP] ? Math.ceil(locationMap[Constants.TOP]/2) : 0;
            height -= y;
            height = locationMap[Constants.BOTTOM] ? height - Math.ceil(locationMap[Constants.BOTTOM]/2 - 0.5) : height;

            x = locationMap[Constants.LEFT] ? Math.ceil(locationMap[Constants.LEFT]/2) : 0;
            width -= x;
            width = locationMap[Constants.RIGHT] ? width - Math.ceil(locationMap[Constants.RIGHT]/2) : width;

            //加1的原因，最后一根网格线
            return {
                x:x + this.bounds.x,
                y:y + this.bounds.y,
                width:Math.max(width + 1, 0),
                height:Math.max(height + 1, 0)
            };
        },

        getChartBounds:function(){
            return BaseUtils.makeBounds(0, 0, this.width, this.height);
        },

        xAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.xAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        yAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.yAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        polar:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.polar;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        angleAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.angleAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        radiusAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.radiusAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        gaugeAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.gaugeAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        getSharedAxis: function () {
            var axes = [this.xAxis(), this.yAxis(), this.angleAxis()];
            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                if (axis && axis.isCategory()) {
                    return axis;
                }
            }
            return null;
        },

        getComponent:function(type){
            return this.components[type];
        },

        setComponent:function (component, type) {
            this.components[type] = component;
        },

        /**
         * return color of previous name
         * or set new color and return
         * @param {string} [name] series item (or pie point) name
         * @returns {*}
         */
        getDefaultSeriesColor: function (name) {
            name += '';
            if (!this.colorMap[name]) {
                var colors = this.options.colors;
                var length = 0;
                for (var item in this.colorMap) {
                    ++length;
                }
                // return next color
                this.colorMap[name] = colors[length % colors.length];
            }

            return this.colorMap[name];
        },

        registerPointsPara:function(point){
            if(BaseUtils.hasDefined(point.category)){
                var cateMap = this.cateMap;
                var cateString = point.getCategory();
                cateMap[cateString] = cateMap[cateString] || [];
                cateMap[cateString].push(point);
                return cateMap[cateString];
            }
        },

        getValidPointsPara:function(category){

            var points = this.cateMap[category] || [];

            return points.filter(function (p) {
                return p.isVisible() && p.options.tooltip && p.options.tooltip.shared
            });
        },

        getSharedPoints:function (category) {
            var points = this.cateMap[category] || [];

            if(points && points.length){
                return points.filter(function (p) {
                    return p.options.tooltip && p.options.tooltip.shared
                });
            }

            return [];
        },

        showSharedTooltip:function (point, event) {
            if(!point){
                return;
            }
            var vanchart = this, valid = vanchart.getValidPointsPara(point.getCategory());

            var max = valid
                .reduce(function (prev, curr) {
                    if (!prev) {
                        return curr;
                    }
                    return (curr.getTargetValue() > prev.getTargetValue()) ? curr : prev;
                }, 0);

            // CHART-823
            // get first point(include invisible) among shared points
            vanchart.showTooltip(max, event, vanchart.getSharedPoints(point.getCategory())[0]);
        },

        showTooltip:function(point, event, fmtPoint){
            //缩放的时候不显示数据点提示
            if(this.handler.selectRect){
                return;
            }

            this.components[ComponentLibrary.TOOLTIP_COMPONENT].showWithPoint(point, event, fmtPoint)
        },

        hideTooltip:function(){
            this.hoverPoint = null;
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].hide();
        },

        /**
         * 工具栏提示
         * @param  {Object} icon    计算tooltip位置时做参考的toolbarIcon
         * @param  {String} content 提示文字内容
         */
        showToolbarTooltip: function (icon, content) {
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].showWithToolbarIcon(icon, content);
        },

        // set this chart's state, like enable/disable dom event
        set: function (opt) {
            if (('enable' in opt) && this.handler) {
                if (opt['enable']) {
                    this.handler.hammer.set({enable:true});
                } else {
                    this.handler.hammer.set({enable:false});
                    this.handler.removeAllChosen();
                }
            }
        },

        isMap:function(){
            return this.vanChartType == 'vanChartMap';
        },

        chartType:function(){
            return this.options.chartType;
        },

        isHeatMap:function(){
            return this.options.chartType == Constants.HEAT_MAP;
        },

        isAreaMap:function(){
            return this.options.chartType == Constants.AREA_MAP;
        },

        isForceBubble:function(){
            return this.vanChartType == 'vanChartForceBubble';
        },

        isLargeMode:function(){
            return this.options.plotOptions.large;
        },

        hasRangeLegend: function () {
            return !!this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT]
        },

        seriesOfType:function(type){
            return this.series.filter(function(ser){
                return ser.type == type;
            })
        },

        pointsOfType: function (type) {
            var allPoints = [];
            this.series.forEach(function (ser) {
                if(ser.type == type) {
                    allPoints = allPoints.concat(ser.points);
                }
            });
            return allPoints;
        },

        // ussage:
        // vanchart.setTimeout('foo', bar, 100);
        // setting new func for the same key will flush the previous func
        // vanchart.setTimeout('foo'); cancel the func
        //
        // attention: this function fire the delay=0 immediately, no setTimeout(fun, 0)
        //
        setTimeout: function (key, func, delay) {
            if (this.timeQueue[key]) {
                window.clearTimeout(this.timeQueue[key]);
            }
            if (delay) {
                this.timeQueue[key] = window.setTimeout(func, delay);
            } else {
                func && func();
                this.timeQueue[key] = null;
            }
        },

        // should remove all in the end
        clearTimeQueue: function () {
            var timeQueue = this.timeQueue || {};
            Object.keys(timeQueue).map(function (key) {
                window.clearTimeout(timeQueue[key]);
            });

            return {};
        },

        getSize: function () {
            if (!this._size || this._sizeChanged) {
                this._size = new Point(this.width, this.height);
                this._sizeChanged = false;
            }
            return this._size.clone();
        },

        /**
         * 判断是否在大数据的情况下进行缩放
         * @returns {boolean}
         */
        isZoomingWithLargeModel: function (){
            var totalDataLen = 0, series = this.options.series, i, data;
            for(i = -1; ++i < series.length;) {
                data = series[i].data;
                totalDataLen += data.length;
            }
            
            return totalDataLen > 100 && this._zooming;
        }
    });


    //view
    VanChart.include({

        render:function(){

            this.vancharts.endLoading();

            var vanchart = this, renderer = this.renderer;

            var clipBounds = this.getPlotClipBounds();
            if(!this.plotClip){
                this.plotClip = renderer.createClip(clipBounds);
            }else{
                renderer.updateClip(this.plotClip, clipBounds);
            }

            function createGroup(groupName){
                if(!vanchart[groupName]){
                    vanchart[groupName] = renderer.group().addClass(groupName).add();

                    if(vanchart.isMap()){
                        vanchart[groupName].addClass('map-component');
                    }
                }
            }

            ['backGroup', 'clipSeriesGroup', 'seriesGroup', 'seriesTextRenderGroup', 'frontGroup']
                .forEach(createGroup);

            renderer.clip(vanchart.clipSeriesGroup, vanchart.plotClip);
            renderer.clip(vanchart.seriesTextRenderGroup, vanchart.plotClip);

            this._addDivClipGroup(clipBounds);

            // 空数据时显示空数据提示，并且返回
            // 非空数据时移除存在的空数据提示，继续渲染操作
            if (this._isEmptyDataChart()) {
                this._showEmptyDataTip();
                window.console && console.log('done');
                return;
            } else {
                this.emptyDataGroup && this.emptyDataGroup.remove();
            }

            this._renderBackground();

            this.renderComponents();

            this.renderSeries();

        },

        _addDivClipGroup: function (clipBounds) {
            var vanchart = this;
            if (!vanchart.seriesTextDivGroup) {
                vanchart.seriesTextDivGroup = this.renderer.div().add();
            }
            // clip: rect(<top>, <right>, <bottom>, <left>);
            vanchart.seriesTextDivGroup.style({
                clip: 'rect(' + [
                    clipBounds.y,
                    clipBounds.x + clipBounds.width,
                    clipBounds.y + clipBounds.height,
                    clipBounds.x
                ].join('px ') + 'px)'
            });
        },

        _renderBackground:function(){
            var chartBounds = BaseUtils.makeBounds(0,0,this.width, this.height), plotBounds = this.bounds;

            var options = this.options, renderer = this.renderer;

            var chartConfig =  {
                backgroundColor:options.geo ? '' : options.backgroundColor,
                backgroundImage:options.geo ? '' : options.backgroundImage,
                borderColor:options.borderColor,
                borderWidth:options.geo ? 0 : options.borderWidth,
                borderRadius:options.borderRadius || 0,
                shadow:options.shadow
            };

            var plotConfig = {
                backgroundColor:options.plotBackgroundColor,
                backgroundImage:options.plotBackgroundImage,
                borderColor:options.plotBorderColor,
                borderWidth:options.plotBorderWidth,
                borderRadius:options.plotBorderRadius || 0,
                shadow:options.plotShadow
            };

            if (chartConfig.shadow) {
                chartBounds.width -= 5;
                chartBounds.height -= 5;
            }

            if(chartConfig.backgroundColor || chartConfig.backgroundImage || chartConfig.borderColor){
                this.chartBackgroundGroup = this.chartBackgroundGroup || renderer.group().addTo(this.backGroup);
            }else if(this.chartBackgroundGroup){
                this.chartBackgroundGroup.remove();
                this.chartBackgroundGroup = null;
            }

            if(plotConfig.backgroundColor || plotConfig.backgroundImage || plotConfig.borderColor){
                this.plotBackgroundGroup = this.plotBackgroundGroup || this.renderer.group().addTo(this.backGroup);
            }else if(this.plotBackgroundGroup){
                this.plotBackgroundGroup.remove();
                this.plotBackgroundGroup = null;
            }

            this._renderRectangleBackground(this.chartBackgroundGroup, chartConfig, chartBounds);
            this._renderRectangleBackground(this.plotBackgroundGroup, plotConfig, plotBounds);
        },

        renderComponents: function () {
            for(var c in this.components){
                this.components[c] && this.components[c].render();
            }
        },

        renderSeries:function(){

            this.getComponent(ComponentLibrary.TOOLTIP_COMPONENT).immediateHide();

            this.fire('animationStart');

            this._renderTrendLine();

        },

        /**
         * 判断是否为空数据图表
         * @return {Boolean} [description]
         */
        _isEmptyDataChart: function () {
            // 当且仅当系列为空且允许了空数据提示的时候才生效
            return this.series.length === 0 && this.options.emptyDataTip && this.options.emptyDataTip.enabled;
        },

         /** 
         * Chart-925:空数据时图表显示提示 
         * @private 
         */ 
        _showEmptyDataTip: function (){

            this._removeAll();

            this.emptyDataGroup && this.emptyDataGroup.remove();
 
            if(this.series.length){ 
                return; 
            } 
 
            var option = this.options, emptyDataTip = option.emptyDataTip;
            var PATTERN_GAP = 10, TEXT_GAP = 5;
 
            if(!emptyDataTip || !emptyDataTip.enabled) { 
                return; 
            } 
 
            var renderer = this.renderer, 
                plotBounds = {
                    width: this.width,
                    height: this.height
                } 
 
            // 空数据提示的图案-尺寸120px * 125px 
            var patternPathArray = [ 
                { 
                    d: "M108.5,47.4l-7.7,57.2c-10.7,9.4-25.9,15-41.4,15c-14.1,0.1-27.7-4.8-38.5-13.8l11.8-86.5c0.7-5.3,5.6-9,11-8.3c0,0,0.1,0,0.1,0L85.5,17L108.5,47.4z", 
                    fill: "#fff" 
                }, 
                { 
                    d: "M108.5,47.4l-16.4-2c-5.6-0.8-9.4-5.9-8.6-11.4L85.7,17L108.5,47.4z", 
                    fill: "#F4F4F4" 
                }, 
                { 
                    d: "M6.2,29.7C1.6,31.5-0.7,36.6,1,41.2L2.1,44l20,52.8l10.5-77L8.7,28.8L6.2,29.7z", 
                    fill: "#979797" 
                }, 
                { 
                    d: "M71.4,14.5C69.7,9.9,64.6,7.6,60,9.3l-7.6,2.9l19.3,2.7L71.4,14.5z", 
                    fill: "#979797" 
                }, 
                { 
                    d: "M53,74.6c-1.2,3.4-1,7.2,0.6,10.4l2.9-1.4c-0.9-2.5-0.8-5.3,0.1-7.8c1.6-4.2,4.2-5.2,4.2-5.2l-2.2-2.9C58.7,67.6,55,69.1,53,74.6z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M91.4,79.2c0-13.2-10.7-23.9-24-23.9c-13.2,0-24,10.7-24,23.9c0,13.2,10.7,23.9,24,23.9c4.7,0,9.2-1.4,13.2-3.9l6.4,7.6l2.7-2.2l-6.3-7.5C88.4,92.5,91.3,86,91.4,79.2z M67.4,98c-10.4,0-18.9-8.4-18.9-18.8s8.5-18.8,18.9-18.8s18.9,8.4,18.9,18.8C86.3,89.6,77.9,98,67.4,98C67.4,98,67.4,98,67.4,98z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M105.3,118.4l-8.9-10.2l-0.6-0.7l-2-2.4c-0.8-1-2.3-1.1-3.3-0.2c0,0,0,0,0,0l-3.1,2.7c-1,0.8-1.1,2.3-0.2,3.3c0,0,0,0,0,0l0.9,1.1l0.7,0.8l10,11.4c0.8,1,2.3,1.1,3.3,0.2c0,0,0,0,0,0l3.1-2.7C106,120.8,106.1,119.4,105.3,118.4z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M59.9,0c-21,0-40.6,10.9-51.5,28.8l24.3-9.2v-0.1c0.8-5.4,5.8-9.2,11.2-8.4l8.4,1.2l7.6-2.9c4.6-1.7,9.7,0.6,11.5,5.1l0.1,0.4l13,1.8l0.8,0.1l23.1,30.6l-0.1,0.9l-7.4,55c-1.7,1.4-3.5,2.8-5.3,4.1l0.6,0.7c1.6-1.2,3.1-2.3,4.6-3.6l0,0C113.1,93.1,120.1,77,120,60.1c0.2-33-26.5-60-59.7-60.1C60.2,0,60,0,59.9,0z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M59.5,118.2c-14,0.1-27.5-4.6-38.4-13.4c0.1-0.4,0.1-0.7,0.2-1.3l0.9-6.6l-20-52.5C0.7,49.6,0,55,0,60.4c-0.2,17.5,7.5,34.2,20.9,45.4l0,0c10.8,9,24.4,13.8,38.4,13.7c10.1,0,20.1-2.4,29.2-6.8l-0.7-0.8C79,116,69.3,118.2,59.5,118.2z", 
                    fill: "#DDDDDD" 
                } 
            ]; 
            var patternWidth = 120, patternHeight = 125; 
 
            var tipWidth = patternWidth, tipHeight = patternHeight + PATTERN_GAP; 
            var emptyDataGroup = this.emptyDataGroup = renderer.group().addTo(this.seriesGroup); 
 
            emptyDataTip.content = emptyDataTip.content || []; 
 
            // 先计算宽高，然后再排版绘制 
            var contentArray = emptyDataTip.content.map( function (contentObj){ 
                var text = contentObj.text, style = BaseUtils.convertToREMUseDefault16PX(contentObj.style); 
                var textDim = BaseUtils.getTextDimension(text, style, false); 
                tipWidth = Math.max(tipWidth, textDim.width); 
                return { 
                    text: contentObj.text, 
                    style: BaseUtils.convertToREMUseDefault16PX(contentObj.style), 
                    width: textDim.width, 
                    height: textDim.height 
                } 
            }); 
            // 绘制图案并设置水平居中 
            var patternGroup = renderer.group().attr("transform", "translate(" + ((tipWidth - patternWidth) / 2) +",0)").addTo(emptyDataGroup); 
            patternPathArray.forEach(function (pathData){ 
                var  path = renderer.path().addTo(patternGroup); 
                path.attr({ 
                    "d": pathData.d, 
                    "fill": pathData.fill 
                }) 
            }); 
            // 绘制文字并设置偏移 
            contentArray.forEach(function(contentObj, index, arr){ 
                var x = (tipWidth - contentObj.width) / 2, 
                    y = tipHeight; 
                tipHeight += contentObj.height + (index === arr.length - 1 ? 0 : TEXT_GAP); 
                var text = renderer.text().addTo(emptyDataGroup); 
                text 
                    .textContent(contentObj.text) 
                    .style(contentObj.style) 
                    .attr({ 
                        "dy": (0.85 * contentObj.height), 
                        "transform": "translate(" +x+","+y+")" 
                    }); 
            }); 
 
            var translateX = (plotBounds.width - tipWidth) / 2, 
                translateY = (plotBounds.height - tipHeight) / 2; 
 
            this.emptyDataGroup.attr("transform", "translate(" + translateX+","+ translateY +")"); 
        },

        /**
         * 移除所有的组件和背景等
         * @return {[type]} [description]
         */
        _removeAll: function (){
            // 移除除工具栏提示外的所有组件
            for(var c in this.components){
                if(c !== ComponentLibrary.TOOLTIP_COMPONENT) {
                    this.components[c] && this.components[c].remove();
                }
            }

            // 框架图LinkLine移除
            this.linkGroup && this.linkGroup.remove();
            this.linkGroup = null;

            // 移除背景
            this.chartBackgroundGroup && this.chartBackgroundGroup.remove();
            this.plotBackgroundGroup && this.plotBackgroundGroup.remove();
        },

        /**
         * 绘制图表背景(颜色,背景图,阴影等)
         * @param  {[type]} backgroundGroup [description]
         * @param  {[type]} option          [description]
         * @param  {[type]} bounds          [description]
         * @return {[type]}                 [description]
         */
        _renderRectangleBackground:function(backgroundGroup, option, bounds){

            if(!backgroundGroup){
                return;
            }

            var borderWidth = option.borderWidth || 0, renderer = this.renderer;
            var det = borderWidth / 2;
            var borderBounds = BaseUtils.rectSubPixelOpt(bounds.x + det, bounds.y + det, Math.max(bounds.width - borderWidth, 0), Math.max(bounds.height - borderWidth, 0), borderWidth);
            borderBounds.rx = borderBounds.ry = option.borderRadius;

            if(option.shadow){
                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds, 1);
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                width.forEach(function(w, i){
                    var key = 'shadowRect' + i;
                    backgroundGroup[key] = backgroundGroup[key] || renderer.rect().style({'fill':'none', 'stroke': 'black', 'stroke-width':width[i], 'stroke-opacity':opacity[i]}).addTo(backgroundGroup);

                    backgroundGroup[key].attr(shadowBounds).attr({'rx':option.borderRadius, 'ry':option.borderRadius,'transform':'translate(1, 1)'});
                });
            }

            if(option.backgroundColor && typeof option.backgroundColor == 'object'){

                //ie下面不用渐变了
                if(BaseUtils.isSupportSVG()){
                    var gradualOption = option.backgroundColor;
                    var attrs = {'x1':gradualOption.x1, 'y1':gradualOption.y1, 'x2':gradualOption.x2, 'y2':gradualOption.y2};
                    var stop1 = {'offset':'0%', 'stop-color':gradualOption.startColor};
                    var stop2 = {'offset':'100%', 'stop-color':gradualOption.endColor};

                    if(backgroundGroup.gradientFill){
                        renderer.updateColorGradient(backgroundGroup.gradientFill, attrs, [stop1,stop2]);
                    }else{
                        backgroundGroup.gradientFill = renderer.colorGradient(attrs, [stop1, stop2]);
                    }
                }else{
                    option.backgroundColor = option.backgroundColor.startColor;
                }
            }

            if(option.backgroundImage){
                backgroundGroup.backgroundImage = backgroundGroup.backgroundImage || renderer.image().addTo(backgroundGroup);
                backgroundGroup.backgroundImage.attr(bounds).attr('preserveAspectRatio', 'none').imageContent(option.backgroundImage);
            }

            if(option.backgroundColor || option.borderWidth){
                backgroundGroup.backgroundColor = backgroundGroup.backgroundColor || renderer.rect().addTo(backgroundGroup);
                backgroundGroup.backgroundColor.attr(borderBounds)
                    .style({'fill':option.backgroundColor ? (typeof option.backgroundColor == 'string' ? option.backgroundColor : "url(#" + BaseUtils.stamp(backgroundGroup.gradientFill) + ")") : 'none',
                        'stroke':option.borderColor, 'stroke-width':BaseUtils.pick(option.borderWidth, 0)});
            }
        },

        //渐变色图例，直接过滤，不用计算布局什么的
        filterRender: function () {
            for(var i = 0, len = this.series.length; i < len; i++){
                this.series[i].filterRender();
            }
        },

        cancelLegendHighlight:function(containerPoint){

            var legend = this.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            legend = legend || this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            if(legend){
                if(legend.highlighted && !BaseUtils.containsPoint(legend.bounds, containerPoint)){
                    legend.highlighted = false;
                    this.highlightTarget = null;
                    this._updateSeriesStyle();
                }
            }
        },

        makeLegendHighlight:function(target){
            this.highlightTarget = target;
            this._updateSeriesStyle();
        },

        _updateSeriesStyle:function(){
            this.series.forEach(function(ser){
                if(ser.isSupportLegendHighlight()){
                    if(ser.useCanvas()){
                        ser._canvasRender();
                    }else{
                        // 对于折线图和雷达图这类的，不要忘了使系列高亮
                        ser.drawSeries && ser.drawSeries();
                        ser.getDataToDraw()
                            .filter(function (point) {return point.isVisible();})
                            .forEach(function(point) {ser._updatePointGraphicStyle(point);});
                    }
                }
            });
        },

        //坐标轴缩放,拖拽缩放,点击图例等任何会导致绘图区图形变化的操作由这步完成
        reRenderSeries:function(){

            VanChartLayout.calculateSeries(this);

            VanChartLayout.calculateSeriesShapes(this);

            this.renderSeries();
        },

        _consoleDone:function () {

            var geo = this.options.geo;

            if(!geo || !geo.tileLayer){
                // phantomjs test
                window.console && console.log('done');
            }

        },

        removePointGraphics:function (p) {
            p && p.remove();
        },

        registerInteractiveTarget:function(data, elementWrapper){
            if(elementWrapper) {
                this._targets[BaseUtils.stamp(elementWrapper.node())] = data;
            }
            this.activeDataEvents(data);
        },

        activeDataEvents:function (data) {
            data._events = null;
            data.getEvents && data.on(data.getEvents(), data);
        },

        removeInteractiveTarget:function(data, elementWrapper){
            this._targets[BaseUtils.stamp(elementWrapper.node())] = null;
            data._events = null;
        },

        findInteractiveTarget:function(rawElement){
            return this._targets[BaseUtils.stamp(rawElement)];
        },

        resize:function(){

            var dom = this.wrapDom;
            this.width = BaseUtils.getDomWidth(dom);
            this.height = BaseUtils.getDomHeight(dom);

            // @Cmen：CHART-1130:同initialize
            if(!this.width || !this.height) { return; }

            this.clipPool = {};
            this.axisSize = {
                'left':0, 'right':0, 'bottom':0, 'top':0
            };

            this.renderer.resize();

            if(this.isMap()){
                this.mapRenderer.resize();
                this._onResize();
                this.components.geo.resize();
            }

            // BI-6380
            var multiPie = this.seriesOfType(Constants.MULTIPIE_CHART)[0];
            if (multiPie) {
                multiPie.chartInfo.radius = null;
            }

            this.layoutComponentsAndCharts();
        },

        remove:function(){
            // CHART-996
            // 框架图在label未画完时再次触发动态参数，render已经remove，抛bug
            // 那么问题来了，怎么就框架图发现了……框架图动画时间是不是最长的
            this._animationStarted = false;

            this.force && this.force.endTick(null).stop();
            this.force = null;
            this.clearAllEffects();
            this.clearTimeQueue();
            this.renderer && this.renderer.remove();
            this.handler && this.handler.destroy();

            this.mainRenderer && this.mainRenderer.remove();
            this.animationRenderer && this.animationRenderer.remove();
            this.mainRenderer = null;
            this.animationRenderer = null;
            if (this.largeSeries) {
                Object.keys(this.largeSeries).map(function (key) {
                    if (this.largeSeries[key]._canvas) {
                        this.largeSeries[key]._canvas.remove();
                    }
                    this.largeSeries[key] = null;
                }, this);
            }
            this.largeSeries = null;

            this.renderer = this.plotClip = this._leaflet = this.handler
                = this.chartBackgroundGroup = this.trendLineGroup = this.seriesGroup
                = this.clipSeriesGroup = this.seriesTextRenderGroup = this.seriesTextDivGroup =null;
        }

    });

    require('./VanChartLibrary').register(Constants.VANCHART, VanChart);

    return VanChart;
});
/**
 * Created by Yuqian on 2017/7/12.
 */

define('vector/canvasShape/AbstractShape',['require','../../utils/Class'],function (require) {

    var Class = require('../../utils/Class');

    return Class.extend({

        initialize: function (renderer) {
            this.renderer = renderer;
            this.ctx = renderer.ctx;
            this.cut = null;

            this._initialize(renderer);
        },

        setStyle: function (style) {
            for (var prop in this.style) {
                if (style.hasOwnProperty(prop)) {
                    this.style[prop] = style[prop];
                }
            }
            return this;
        },

        drawStyle: function () {
            var s = this.style;

            this.renderer.lineWidth(s.lineWidth);
            this.renderer.strokeStyle(s.strokeStyle);
            this.renderer.fillStyle(s.fillStyle);

            this.renderer.beginNewPath();

            return this
        },

        contain: function () {
        },

        animate: function () {
            if (!this.cut) {
                this.cut = this.renderer.animation.animate(this.style);
            }
            return this;
        },

        // mixin ?
        delay: function (time) {
            this.cut.delay(time);
            return this;
        },
        duration: function (time) {
            this.cut.duration(time);
            return this;
        },
        tween: function (key, v) {
            this.cut.tween(key, v);
            return this;
        },
        end: function (f) {
            this.cut.end(f);
            return this;
        },
        stop: function () {
            this.cut.stop();
            return this;
        },
        ease: function (easing) {
            this.cut.ease(easing);
            return this;
        },
        remove: function () {
            this.cut && this.cut.stop();
            this.needToRemove = true;
        }

    });

});

define('vector/canvasShape/library',['require'],function (require) {

    var shapes = {};

    return {
        register: function (name, Shape) {
            shapes[name] = Shape;
        },
        shapes: shapes
    }
});
/**
 * make icon shapes as images
 */
define('vector/canvasShape/icons',['require','./library','../../Constants'],function (require) {
    var library = require('./library');
    var Constants = require('../../Constants');

    var Attrs = ['lineWidth', 'strokeStyle', 'fillStyle'];

    var _icons = {};

    _icons[Constants.LOCATION] = 'iconLocation';

    function getShape (name) {
        return library.shapes[_icons[name]]
    }

    function render (name, fakeRenderer, s) {
        var Shape = getShape(name);
        if (!Shape) {
            return
        }

        var shape = new Shape(fakeRenderer);

        shape.setStyle({
            x: 0,
            y: 0,
            size: s.width,
            fillStyle: s.color
        });

        var ctx = fakeRenderer.ctx;

        var i = -1, k;
        while (k = Attrs[++i]) {
            ctx[k] = shape.style[k];
        }

        shape.draw();

        ctx.fill();
        ctx.stroke();

        fakeRenderer.shape = shape;
        fakeRenderer.ready = true;
    }

    return {
        render: render,
        all: _icons
    }

});
/**
 * Created by Yuqian on 2016/12/22.
 */

define('vector/canvasShape/Image',['require','./AbstractShape','./library','./icons'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');
    var icons = require('./icons');

    var ImageCollection = {};

    var I = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                url: null,
                x: null, // image center x
                y: null, // image center y
                width: 0,
                height: 0,
                radian: 0, // rotation center is IMAGE's center
                color: '' // for icon
            };

        },

        _load: function () {
            var s = this.style;
            var url = s.url;
            var key = url + s.color;
            if (!ImageCollection[key]) {

                if (icons.all[url]) {
                    ImageCollection[key] = this._loadIcon(url);
                } else {
                    ImageCollection[key] = this._loadImage(url);
                }

            }
            this._img = ImageCollection[key]
        },

        _loadImage: function (url) {

            var self = this;

            var img = {
                el: null,
                ready: false
            };
            img.el = new Image();
            img.el.crossOrigin = "Anonymous";
            img.el.onload = function () {
                img.ready = true;
                self.renderer.flush();
            };
            img.el.src = url;

            return img
        },

        _loadIcon: function (url) {
            var s = this.style;
            var width = s.width;
            var height = s.height;
            var dpr = this.renderer.dpr;
            var canvas = document.createElement(window.VAN_CANVAS);

            // document.body.append(canvas);
            // canvas.style.position = 'absolute';
            // canvas.style.right = '100px';
            // canvas.style.top = '100px';
            // canvas.style.background = '#888';
            // canvas.style.border = '1px solid #000';

            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            var ctx = canvas.getContext("2d");
            ctx.scale(dpr, dpr);

            var fakeRenderer = {
                el: canvas,
                ctx: ctx,
                ready: false
            };

            icons.render(url, fakeRenderer, s);

            return fakeRenderer

        },

        setStyle: function (style) {
            for (var prop in this.style) {
                if (style.hasOwnProperty(prop)) {
                    this.style[prop] = style[prop];
                }
            }
            !this._img && this._load();
            return this;
        },

        drawStyle: function () {
            return this;
        },

        draw: function () {
            var s = this.style;
            var x = s.x,
                y = s.y,
                width = s.width,
                height = s.height,
                radian = s.radian;
            if (this._img
                && this._img.ready
                && x != null
                && y != null) {

                if (radian) {
                    this.ctx.save();

                    this.ctx.translate(x, y);
                    this.ctx.rotate(radian);
                    this.ctx.drawImage(this._img.el, -width / 2, -height / 2, width, height);

                    this.ctx.restore();
                } else {
                    this.ctx.drawImage(this._img.el, x - width / 2, y - height / 2, width, height);
                }

            }

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x + s.width / 2;
            var dy = pos.y - s.y + s.height / 2;
            // todo, rotate
            return 0 < dx && dx < s.width && 0 < dy && dy < s.height
        }
    });

    library.register('image', I);

    return I
});
/**
 * Created by Yuqian on 2016/12/7.
 */

define('vector/canvasShape/Arc',['require','./AbstractShape','./library','../../utils/BaseUtils','../../dom/Browser'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');
    var BaseUtils = require('../../utils/BaseUtils');
    var isTouch = require('../../dom/Browser').touch;

    var MIN_HOVER_LINE_WIDTH = isTouch ? 10 : 2;

    var DOUBLE_PI = Math.PI * 2;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var sqrt = Math.sqrt;
    var normalRadian = BaseUtils.normalRadian;

    var Arc = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                r: null,
                startAngle: null,
                endAngle: null,
                lineWidth: null,
                strokeStyle: null, // color
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            if (!s.lineWidth) {
                return this;
            }

            ctx.moveTo(
                s.x + s.r * Math.cos(s.startAngle),
                s.y + s.r * Math.sin(s.startAngle)
            );
            ctx.arc(s.x, s.y, s.r, s.startAngle, s.endAngle);
            return this;
        },

        contain: function (pos) {
            var x = pos.x;
            var y = pos.y;
            var s = this.style;
            var width = max(s.lineWidth, MIN_HOVER_LINE_WIDTH);
            var dx = x - s.x;
            var dy = y - s.y;
            var delta = abs(sqrt(dx * dx + dy * dy) - s.r);
            if (delta > width) {
                return false;
            }
            var th = normalRadian(atan2(dy, dx));
            return (th + DOUBLE_PI - s.startAngle) % DOUBLE_PI <= s.endAngle - s.startAngle
        }

    });

    library.register('arc', Arc);

    return Arc

});
/**
 * Created by Yuqian on 2016/12/8.
 */

define('vector/canvasShape/Circle',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var DOUBLE_PI = 2 * Math.PI;

    var Circle = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                r: null,
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            ctx.moveTo(s.r + s.x, s.y);
            ctx.arc(s.x, s.y, s.r, 0, DOUBLE_PI);
            return this;
        },

        contain: function (pos) {
            var x = pos.x;
            var y = pos.y;
            var s = this.style;
            var dx = x - s.x;
            var dy = y - s.y;
            return s.r > Math.sqrt(dx * dx + dy * dy)
        }
    });

    library.register('circle', Circle);

    return Circle;

});

define('vector/canvasShape/IconLocation',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    function t (num) {
        return +(num.toFixed(3));
    }

    var IconLocation = AbstractShape.extend({
        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null,
                fillStyle: null, // color
                lineWidth: 1,
                strokeStyle: '#ffffff'
            };
        },

        setStyle: function (style) {
            AbstractShape.prototype.setStyle.apply(this, arguments);
            if (style.size) {
                var f = style.size / 40;

                this.R = 14.5 * f;
                this.r = 5.5 * f;
                this.ix = 20 * f;
                this.iy = this.R + 1;
                this.l = style.size - this.iy;
                this.a = Math.acos(this.R / this.l);
                this.dx = t(this.R * Math.sin(this.a));
                this.dy = t(this.R * Math.cos(this.a));
            }
            return this;
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var x = s.x, y = s.y;
            var R = this.R, r = this.r,
                ix = this.ix, iy = this.iy,
                l = this.l, a = this.a,
                dx = this.dx, dy = this.dy;

            var _x = x + ix, _y = y + iy;

            ctx.moveTo(_x, _y + l);
            ctx.lineTo(_x - dx, _y + dy);

            ctx.arc(_x, _y, R, Math.PI / 2 + a, Math.PI / 2 - a);

            ctx.lineTo(_x, _y + l);

            ctx.moveTo(_x + r, _y);
            ctx.arc(_x, _y, r, Math.PI * 2, 0, true);

            this.renderer.dirty = true;

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x + s.size / 2;
            var dy = pos.y - s.y + s.size / 2;
            return 0 < dx && dx < s.size && 0 < dy && dy < s.size
        }
    });

    library.register('iconLocation', IconLocation);

});
define('vector/canvasShape/Rect',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');


    var Rect = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                width: null,
                height: null,
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            ctx.rect(s.x, s.y, s.width, s.height);
            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x;
            var dy = pos.y - s.y;
            return 0 < dx && dx < s.width && 0 < dy && dy < s.height
        }
    });

    library.register('rect', Rect);

    return Rect;

});

define('vector/canvasShape/Diamond',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var abs = Math.abs;

    var Diamond = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null, // marker's R
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var R = s.size * Math.SQRT2;
            var x = s.x, y = s.y;
            ctx.moveTo(x - R, y);
            ctx.lineTo(x, y - R);
            ctx.lineTo(x + R, y);
            ctx.lineTo(x, y + R);
            ctx.lineTo(x - R, y);

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var x = s.x, y = s.y;
            var w = (s.size + s.lineWidth / 2) * Math.SQRT2,  h = w;
            var px = pos.x - x, py = pos.y - y;
            return abs(px * h) + abs(py * w) < h * w;
        }
    });

    library.register('diamond', Diamond);

    return Diamond;

});

define('vector/canvasShape/Triangle',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var SQRT3 = Math.sqrt(3);

    function sameSide (a, b, c, p) {

    }

    var Triangle = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null, // marker's R
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var R = s.size, x = s.x, y = s.y;

            var d = R / SQRT3;

            ctx.moveTo(x - R, y + d);
            ctx.lineTo(x, y - (2 * d));
            ctx.lineTo(x + R, y + d);
            ctx.lineTo(x - R, y + d);
            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var R = s.size + s.lineWidth / 2, x = s.x, y = s.y;
            var d = R / SQRT3;
            var ax = x - R, ay = y + d,
                bx = x + R, by = y + d,
                cx = x, cy = y - (2 * d);
            var px = pos.x, py = pos.y;

            var v0 = [cx - ax, cy - ay];
            var v1 = [bx - ax, by - ay];
            var v2 = [px - ax, py - ay];

            var dot00 = (v0[0] * v0[0]) + (v0[1] * v0[1]);
            var dot01 = (v0[0] * v1[0]) + (v0[1] * v1[1]);
            var dot02 = (v0[0] * v2[0]) + (v0[1] * v2[1]);
            var dot11 = (v1[0] * v1[0]) + (v1[1] * v1[1]);
            var dot12 = (v1[0] * v2[0]) + (v1[1] * v2[1]);

            var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);

            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

            return ((u >= 0) && (v >= 0) && (u + v < 1));
        }

    });

    library.register('triangle', Triangle);

    return Triangle;

});

define('vector/canvasShape/types',['require','./Image','./Arc','./Circle','./IconLocation','./Rect','./Diamond','./Triangle'],function (require) {

    require('./Image');
    require('./Arc');
    require('./Circle');
    require('./IconLocation');
    require('./Rect');
    require('./Diamond');
    require('./Triangle');

});
/**
 * Created by Yuqian on 2016/12/7.
 */

define('vector/Cut',['require','../utils/BezierEasing'],function (require) {

    var BezierEasing = require('../utils/BezierEasing');

    var interpolateNumber = function (a, b) {
        return function (pct) {
            return +a + (+b - +a) * pct;
        }
    };

    // todo, remove or revise
    var defaultTweenFun = function (target, key, value) {
        var interpolate = interpolateNumber(target[key], value);
        return function (pct) {
            target[key] = interpolate(pct);
        }
    };

    var Cut = function (targets) {
        if (!targets) {
            throw 'animation "targets" empty';
        } else if (targets.length == null) {
            this.targets = [targets];
        } else {
            this.targets = targets;
        }

        this._needsRemove = false;
        this._lastSectionTime = null;

        // a section's time length is a duration
        this._sections = [];

        this.onend = null;
    };

    Cut.prototype = {

        step: function (time) {

            if (!this._lastSectionTime) {
                this._lastSectionTime = time;
            }

            var t = time - this._lastSectionTime;
            var targets = this.targets;

            var section = this._sections[0];

            var pct = Math.min(t / section.time, 1);

            if (! pct > 0) {
                return;
            }

            if (section.easing) {
                pct = section.easing(pct);
            }

            var tweens = section.tweens;
            var len = targets.length;
            for (var i = 0; i < len; i++) {
                for (var k in tweens) {
                    if (!tweens.hasOwnProperty(k)) {
                        continue;
                    }
                    tweens[k][i](pct);
                }
            }

            if (pct === 1) {
                this._lastSectionTime = time;
                this._sections.shift();
                // one loop only
                if (this._sections.length === 0) {
                    this._needsRemove = true;
                    return 'end';
                }
            }
        },

        _fillTweens: function (f) {
            return this.targets.map(function (target, i) {
                return f(target, i);
            });
        },
        // TODO
        // empty loop now,
        // pause the animation
        delay: function (time) {
            this._sections.push({
                time: time,
                tweens: {}
            });
            return this;
        },
        // set section time length
        duration: function (time) {
            this._sections.push({
                time: time,
                tweens : {}
            });
            return this;
        },

        tween: function (key, f) {
            var len = this._sections.length;

            var tweens = this._sections[len - 1].tweens;

            if (typeof f === 'function') {
                tweens[key] = this._fillTweens(f);
            }
            // todo, remove or revise
            // f is plain value
            else {
                tweens[key] = this._fillTweens(function (target, i) {
                    return defaultTweenFun(target, key, f)
                })
            }

            return this;
        },

        attrTween: function (attrKey, f) {
            this.tween('attr' + attrKey, function (target, i) {
                // FIXME, it's not the init value
                var a = +target.getAttribute(attrKey);
                var interpolate = f(target, i, a);

                return function (pct) {
                    target.setAttribute(attrKey, interpolate(pct))
                };
            });
            return this;
        },

        attr: function (attrKey, v) {
            this.attrTween(attrKey, function (target, i, a) {
                if (typeof v === 'function') {
                    return interpolateNumber(a, v.call(null, target, i, a));
                }
                return interpolateNumber(a, v);
            });
            return this;
        },

        // callback when animation finished
        end: function (f) {
            this.onend = f;
            return this;
        },
        stop: function () {
            this._needsRemove = true;
            return this;
        },
        ease: function (easing) {
            var len = this._sections.length;

            this._sections[len - 1].easing =
                typeof easing == 'string' ? BezierEasing.css[easing] : easing;
            return this;
        }
    };

    return Cut;
});
/**
 * Created by Yuqian on 2016/12/5.
 */

define('vector/Animation',['require','./Cut'],function (require) {
    var Cut = require('./Cut');

    var requestAnimationFrame =
        (window.requestAnimationFrame
        || window.msRequestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame)
        || function (func) {
            setTimeout(func, 16);
        };

    // targets {Array}
    var Animation = function () {

        this._initTime = null;
        this._running = false;

        this._cuts = [];
        this._callback = [];

        this.onframe = null;
        this.onend = null;
    };

    Animation.prototype = {
        _update: function () {
            var time = new Date().getTime();// now
            var cuts = this._cuts;
            var len = cuts.length;

            if (!cuts.length) {
                return false;
            }

            // think: remove before/after step
            for (var i = 0; i < len;) {
                if (cuts[i]._needsRemove) {
                    cuts[i] = cuts[len - 1];
                    cuts.pop();
                    len--;
                }
                else {
                    i++;
                }
            }

            for (var i = 0; i < len; i++) {
                var e = cuts[i].step(time);
                if (e && cuts[i]['on' + e]) {
                    this._callback.push(cuts[i]['on' + e]);
                }
            }

            this.onframe && this.onframe();

            var i = -1, cb;
            while(cb = this._callback[++i]) {
                cb();
            }

            this._callback = [];

            return true;
        },

        _startLoop: function() {
            var self = this;

            function loop() {
                if (self._running) {

                    self._running = self._update();
                    requestAnimationFrame(loop);
                }
            }

            requestAnimationFrame(loop);

        },
        frame: function (f) {
            this.onframe = f;
            return this;
        },
        start: function () {
            if (!this._running) {
                this._running = true;
                this._startLoop();
            }
            return this;
        },
        stop: function () {
            this._running = false;
            return this;
        },
        clear: function () {
            this._running = false;
            this._cuts = [];
            return this;
        },
        animate: function (targets) {
            var cut = new Cut(targets);
            cut.animation = this;
            this._cuts.push(cut);

            this.start();

            return cut;
        }
    };

    return Animation

});

/**
 * Created by eason on 16/6/1.
 */

define('vector/CanvasRenderer',['require','./canvasShape/types','./canvasShape/library','../utils/BaseUtils','./Renderer','../Constants','./Animation','./ElementWrapper'],function(require){

    require('./canvasShape/types');

    var library = require('./canvasShape/library');

    var BaseUtils = require('../utils/BaseUtils');
    var Renderer = require('./Renderer');
    var Constants = require('../Constants');
    var Animation = require('./Animation');
    var ElementWrapper = require('./ElementWrapper');

    var strokeStatus = ['lineWidth', 'strokeStyle'];

    var count = 0;

    var FILTER_SIZE = 2;

    var BATCH = 4000;

    var BATCH_TIME = 50; // ms

    var ARRAY_CONSTRUCTOR = window['Uint8Array'] || window['Array'];

    var Canvas = Renderer.extend({

        _initContainer:function(){
            var dom = this.dom;
            var vanchart = this.vanchart;
            var config = this.config;

            var plotBounds = config || vanchart.bounds;
            var dpr = config && config.dpr || 1;

            this._container = new ElementWrapper(this._createCanvas(dom, plotBounds, dpr), this);
            this.ctx = this._container.node().getContext("2d");
            this.ctx.scale(dpr, dpr);

            this.elements = [];
            this.ctx.lineCap = "round";

            // todo,
            this.resetFilter();

            this.animation = new Animation().frame(this.flush.bind(this));
        },

        marker: function (name, s) {
            switch (name) {
                case Constants.LOCATION:
                    return this.iconLocation({
                        x: s.x,
                        y: s.y,
                        size: s.radius * 2,
                        fillStyle: s.color
                    });
                case Constants.SQUARE_HOLLOW:
                    return this.rect({
                        x: s.x - s.radius,
                        y: s.y - s.radius,
                        width : s.radius * 2,
                        height: s.radius * 2,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.SQUARE:
                    return this.rect({
                        x: s.x - s.radius,
                        y: s.y - s.radius,
                        width : s.radius * 2,
                        height: s.radius * 2,
                        fillStyle: s.color
                    });
                case Constants.DIAMOND_HOLLOW:
                    return this.diamond({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.DIAMOND:
                    return this.diamond({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: s.color
                    });
                case Constants.TRIANGLE_HOLLOW:
                    return this.triangle({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.TRIANGLE:
                    return this.triangle({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: s.color
                    });
                case Constants.CIRCLE_HOLLOW:
                    return this.circle({
                        x: s.x,
                        y: s.y,
                        r: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                default:
                case Constants.CIRCLE:
                    return this.circle({
                        x: s.x,
                        y: s.y,
                        r: s.radius,
                        fillStyle: s.color
                    });
            }
        },

        _create: function (Shape, style) {
            var el = new Shape(this);
            // el.point = style; // tmp for hover event
            el.rawElement = el; // tmp for hover event
            this.elements.push(el);
            style && el.setStyle(style);
            return el;
        },

        _createCanvas:function(dom, plotBounds, dpr){

            var canvas = document.createElement(window.VAN_CANVAS);
            var left = this.left = plotBounds.x,
                top = this.top = plotBounds.y,
                width = this.width = plotBounds.width,
                height = this.height = plotBounds.height;
            this.dpr = dpr;

            canvas.style.position = 'absolute';
            canvas.style.left = left + 'px';
            canvas.style.top = top + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;

            canvas.onselectstart = function(){return false};
            canvas.style['-webkit-user-select'] = 'none';
            canvas.style['user-select'] = 'none';
            canvas.style['pointer-events'] = 'none';
            canvas.style['-webkit-touch-callout'] = 'none';
            canvas.style['transform'] = 'translateZ(0)';

            dom.appendChild(canvas);

            //excanvas
            window.VanCanvasManager && VanCanvasManager.initElement(canvas);

            return canvas;
        },

        shouldFilter: function (x, y) {
            if (x < 0 || this.width < x ||
                y < 0 || this.height < y) {
                ++count;
                return true
            }
            x = x / FILTER_SIZE | 0;
            y = y / FILTER_SIZE | 0;
            var pos = y * this.width / FILTER_SIZE + x;
            if (this._cache[pos] ) {
                ++count;
                return true
            }
            this._cache[pos] = 1;
            return false
        },

        resetFilter: function () {
            // console.log('filtered:', count);
            count = 0;
            this._cache = new ARRAY_CONSTRUCTOR(Math.floor(this.width / FILTER_SIZE * this.height / FILTER_SIZE));  // IE下面用Array需要传整数
        },

        flush: function () {

            BaseUtils.cancelAnimFrame(this._frame);
            this.clearAll();

            var elements = this.elements;
            var len = elements.length;

            var exists = [];
            for (var i = 0; i < len; i++) {
                if (!elements[i].needToRemove) {
                    exists.push(elements[i]);
                    // elements[i].drawStyle().draw();
                }
            }
            this.elements = exists;
            // console.log('to draw:', exists.length);

            this.flushIdx = 0;

            this._adaptFlush();
        },

        _nextBatch: function () {
            if (this.flushIdx < this.elements.length) {
                this._frame = BaseUtils.requestAnimFrame(this._adaptFlush, this);
            }
        },

        _flush: function () {
            // console.time('flush');

            this.ctx.beginPath();

            var elements = this.elements;
            var len = elements.length;

            var i = this.flushIdx;
            var to = Math.min(this.flushIdx + BATCH, len);

            for (; i < to; i++) {
                elements[i].drawStyle().draw();
            }

            this._fillStyle && this.ctx.fill();
            this._strokeStyle && this.ctx.stroke();

            this.flushIdx = i;
            this._nextBatch();
            // console.timeEnd('flush');
        },

        _adaptFlush: function () {
            // console.time('flush');

            this._time = +new Date();

            this.ctx.beginPath();

            var elements = this.elements;
            var len = elements.length;

            var i = this.flushIdx - 1;

            while (++i < len) {
                elements[i].drawStyle().draw();
                if (i && !(i % 500)) {
                    var t = +new Date();
                    if (t - this._time > BATCH_TIME) {
                        break;
                    }
                }
            }

            this._fillStyle && this.ctx.fill();
            this._strokeStyle && this.ctx.stroke();
            this.flushIdx = i;
            this._nextBatch();
            // console.timeEnd('flush');

        },

        clearAll:function(){
            this.ctx.clearRect(0, 0, this.width, this.height);
        },

        beginNewPath: function () {
            if (this.needStroke || this.needFill) {
                this._fillStyle && this.ctx.fill();
                this._strokeStyle && this.ctx.stroke();
                this.ctx.beginPath();

                this.ctx.lineWidth = this._lineWidth;
                this.ctx.strokeStyle = this._strokeStyle;
                this.ctx.fillStyle = this._fillStyle;

                this.needStroke = this.needFill = false;
            }
        },

        lineWidth: function (lineWidth) {
            // lineWidth: Zero, negative, Infinity and NaN values are ignored.
            if (lineWidth && lineWidth !== this._lineWidth) {
                this._lineWidth = lineWidth;
                this.needStroke = true;
            }
        },

        strokeStyle: function (strokeStyle) {
            if (strokeStyle !== this._strokeStyle) {
                this._strokeStyle = strokeStyle;
                this.needStroke = true;
            }
        },

        fillStyle: function (fillStyle) {
            if (fillStyle !== this._fillStyle) {
                this._fillStyle = fillStyle;
                this.needFill = true;
            }
        },

        remove: function () {
            this.animation.clear();
            this.ctx = null;
            this._container.remove();
        },

        addBubbleSeries:function(series){
            var ctx = this.ctx;
            ctx.save();

            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];

                if(point.visible && !point.isNull){

                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = this.getPointOpacity(point);

                    ctx.beginPath();
                    ctx.arc(point.posX, point.posY, point.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            ctx.restore();
        },

        getPointOpacity:function(point){
            var series = point.series, target = series.vanchart.highlightTarget;
            if(target){
                var key = series.name;
                return (key == target || point._rangeItem == target) ? 1 : 0.3;
            }
            return point.opacity;
        },

        addScatterSeries:function(series){
            var ctx = this.ctx;
            ctx.save();
            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];
                if(point.visible && !point.isNull){
                    var marker = point.options.marker, markerType = marker.symbol;
                    var radius = isNaN(marker.radius) ? 4.5 : marker.radius;
                    var color = marker.fillColor || point.color;

                    ctx.translate(point.posX, point.posY);
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = this.getPointOpacity(point);

                    this._drawMarker(ctx, markerType, radius);

                    ctx.translate(-point.posX, -point.posY);
                }
            }
            ctx.restore();
        },

        addSeries:function(series){
            if(series.visible){
                series.type == Constants.SCATTER_CHART ?
                    this.addScatterSeries(series) : this.addBubbleSeries(series);
            }

        },

        _drawMarker:function(ctx, markerType, R){

            if(markerType.indexOf(Constants.CIRCLE) != -1){

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }else if(markerType.indexOf(Constants.SQUARE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, -R);
                ctx.lineTo(R, -R);
                ctx.lineTo(R, R);
                ctx.lineTo(-R, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.DIAMOND) != -1){

                R = R * 2 / Math.sqrt(2);
                ctx.beginPath();
                ctx.moveTo(-R, 0);
                ctx.lineTo(0, -R);
                ctx.lineTo(R, 0);
                ctx.lineTo(0, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.TRIANGLE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, R/Math.sqrt(3));
                ctx.lineTo(0, -(2 * Math.sqrt(3) / 3) * R);
                ctx.lineTo(R, R/Math.sqrt(3));
                ctx.closePath();

            }else{
                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);
            }
            if(markerType.indexOf('hollow') == -1){
                //满填充
                ctx.fill();
            }else{
                ctx.fillStyle = 'white';
                ctx.lineWidth = 2;

                ctx.fill();
                ctx.stroke();
            }
        }
    });

    Canvas.addShape = function (name, Shape) {
        Canvas.prototype[name] = function (style) {
            return this._create(Shape, style);
        }
    };

    for (var name in library.shapes) {
        if (library.shapes.hasOwnProperty(name)) {
            Canvas.addShape(name, library.shapes[name]);
        }
    }

    return Canvas;
});

define('chart/map/LineMapLayer',['require','../../utils/BaseUtils','../../dom/DomUtils','../../utils/ColorUtils','../../Constants','../../vector/Layer','../../dom/Browser'],function (require) {

    var BaseUtils = require('../../utils/BaseUtils');
    var DomUtils = require('../../dom/DomUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var LINE_MAP = require('../../Constants').LINE_MAP;
    var Layer = require('../../vector/Layer');
    var Browser = require('../../dom/Browser');

    var SQRT2 = Math.SQRT2;

    var isSupportSVG = BaseUtils.isSupportSVG();

    var INIT_TIME = 800;
    var INIT_EASE = 'ease-in-out-quad';

function lineMap(mainRenderer, animationRenderer, leafletMap) {

    var _data = [];

    function data (data) {
        _data = data;
        return this;
    }

    function clear () {
        _data = [];
        return this;
    }

    function redraw(highlightTarget) {
        draw(true, highlightTarget);
    }

    function draw (redraw, highlightTarget) {
        var len = _data.length;

        if (len && _data[0] && _data[0].series.options.large) {
            _data[0].refreshPointColor();
            var seriesColor = ColorUtils.mixColorWithAlpha(_data[0].color, _data[0].opacity);
        }

        _data.map(function (p) {
            var series = p.series;
            var large = series.options.large;
            var visible = p.visible && series.visible;
            var staged = p.graphic;
            var options = p.options;

            var fLng = options.from.lnglat[0], fLat = options.from.lnglat[1];
            var tLng = options.to.lnglat[0], tLat = options.to.lnglat[1];

            if (fLng === tLng && fLat === tLat) {
                return;
            }

            var from = leafletMap.latLngToContainerPoint([fLat, fLng]);
            var to = leafletMap.latLngToContainerPoint([tLat, tLng]);

            p.ax = from.x;
            p.ay = from.y;
            p.bx = to.x;
            p.by = to.y;
            p.curveness = options.curveness;
            p.curveness === 0 && (p.curveness = 0.01);

            if (visible) {
                if (large) {
                    mainRenderer.ctx.globalCompositeOperation = 'lighter';
                    p._color = seriesColor;
                } else {
                    var opacity = p.opacity;
                    if (highlightTarget) {
                        opacity *= (p.series.name == highlightTarget || p._rangeItem == highlightTarget) ? 1 : 0.3;
                    }
                    p._color = ColorUtils.mixColorWithAlpha(p.color, opacity);
                }
            }

            // enter/update/exit process
            if (visible && !staged) {
                var arc, ani;

                // enter
                p.graphic = mainRenderer.arc();
                p.graphic.point = p;

                arc = mapShapeStyle(p.graphic, p);

                if (isSupportSVG && !redraw && !large && series.options.animation && p.options.lineWidth) {
                    p.graphic.style['endAngle'] = arc[3];

                    ani = p.graphic.animate()
                        .duration(INIT_TIME)
                        .ease(INIT_EASE)
                        .tween('endAngle', arc[4]);
                }

                if (isSupportSVG && !large && visible && p.options.effect && p.options.effect.enabled) {
                    var indexInSeries = series.points.indexOf(p);
                    if (ani) {
                        ani.end(singleEffect.bind(this, p, len, indexInSeries));
                    } else {
                        singleEffect(p, len, indexInSeries);
                    }
                }

            } else if (visible && staged) {

                //update
                mapShapeStyle(p.graphic, p);

                // effect depends on graphic
                // so update graphic = update effect

            } else if (!visible && staged) {

                // exit
                p.graphic.needToRemove = true;
                p.graphic = null;

                removeEffect(p);
            }

        });

    }

    function removeEffect(p) {
        // stop effect animation
        if (p._effect) {
            p._effect.stop();
            p._effect = null;
        }

        // After effect stopped, those last frame dots are left.
        // So remove them manually.
        // Ques:
        // Can those dots be removed automatically?
        if (p._symbol) {
            p._symbol.map(function (dot) {
                dot.needToRemove = true;
            });
            p._symbol = null;
        }
    }

    // animation handle plain value now
    // so make an ugly helper...
    function mapShapeStyle(graphic, p) {
        var arc = BaseUtils.computeArc(p.ax, p.ay, p.bx, p.by, p.curveness);
        graphic.setStyle({
            x: arc[0],
            y: arc[1],
            r: arc[2],
            startAngle: arc[3],
            endAngle: arc[4],
            lineWidth: p.options.lineWidth,
            strokeStyle: p._color
        });
        return arc;
    }

    function stop () {
        animationRenderer.clearAll();
    }

    function singleEffect(p, len, i) {
        if (!p.graphic) {
            return
        }
        var period = p.options.effect.period || 2000;
        p._effect = animationRenderer.animation
            .animate(p.graphic.style)
            .delay(period / 5 * i / len) //
            .duration(period)
            .tween('track', function (target) {
                return drawEffect(target, p)
            })
            .end(singleEffect.bind(this, p, len, i));
    }

    function drawEffect (g, p) {
        var begin = g.startAngle;
        var end = g.endAngle;
        var length = (end - begin) / 3;
        var distance = end - begin + length;
        var options = p.options.effect;

        if (options.symbol) {
            var url = options.symbol;
            var width = options.width;
            var height = options.height;
            var dpr = window.devicePixelRatio || 1;

            if (!p._symbol) {
                p._symbol = [];
                p._symbol[0] = animationRenderer.image({
                    url: url,
                    width: width,
                    height: height
                });
            }

            return function (t) {
                var style = drawSymbol(distance * t, g.x, g.y, g.r, g.startAngle, g.endAngle, length, url, width, height, dpr);
                p._symbol[0].setStyle(style || {x: null});
            }
        }

        var d = 1.4; // px
        var maxR = 1.5; // px

        return function (t) {
            // Remove old tail dots.
            // Instead of move old dots,
            // we create new dots every time.
            p._symbol && p._symbol.map(function (dot) {
               dot.needToRemove = true;
            });
            p._symbol = drawTail(distance * t, g.x, g.y, g.r, g.startAngle, g.endAngle, length, maxR, d, p.color);
        }
    }

    function drawSymbol(progress, ox, oy, r, begin, end, length, url, width, height, dpr) {
        var base = progress - length + begin;
        if (progress + begin > end) { return }
        var th = length + base;
        var x = r * Math.cos(th) + ox;
        var y = r * Math.sin(th) + oy;

        return {
            x: x,
            y: y,
            radian: Math.PI + th
        }

    }

    function drawTail (progress, ox, oy, r, begin, end, length, maxR, d, color) {

        var from = progress > length ? 0 : length - progress;
        var to = progress + begin < end ? length : length - (progress + begin - end);

        var base = progress - length + begin;

        var dots = [];
        for (var pos = to; pos > from; pos -= d / r) {
            var th = pos + base;
            var x = r * Math.cos(th) + ox;
            var y = r * Math.sin(th) + oy;
            var ratio = pos / length;

            dots.push(animationRenderer.circle({
                x: x,
                y: y,
                r: ratio * maxR,
                fillStyle: color
            })
            );
        }

        return dots;
    }

    return {
        data: data,
        clear: clear,
        draw: draw,
        redraw: redraw,
        stop: stop,
        removeEffect: removeEffect
    }
}

var LineMapLayer = Layer.extend({

    options: {
        mainRenderer: null,
        animationRenderer: null,
        vanchart: null
    },

    initialize: function (options) {
        BaseUtils.setOptions(this, options);
    },

    setData: function (pairs) {
        this._pairs = pairs;
        return this._draw(); //todo, ->redraw
    },

    addData: function (pair) {
        this._pairs.push(pair);
        return this._draw();
    },

    setOptions: function (options) {
        BaseUtils.setOptions(this, options);
        if (this._lineMap) {
            this._updateOptions();
        }
        return this._draw();
    },

    redraw: function () {
        this._lineMap.redraw(this.options.vanchart.highlightTarget);

        this.options.mainRenderer.flush();
        return this;
    },

    removeEffect: function (p) {
        if (this._lineMap) {
            this._lineMap.removeEffect(p);
        }
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._lineMap) {
            this._initRenderer();
        }

        map.on('moveend', this._reset, this);

        if (map.options.zoomAnimation && Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }

        map.on(this._events, this);

        this._reset();
    },

    onRemove: function (map) {
        if (this.options.pane) {
            this.getPane().removeChild(this._canvas);
            this.getPane().removeChild(this._animCanvas);
        }else{
            map.getPanes().overlayPane.removeChild(this._canvas);
            map.getPanes().overlayPane.removeChild(this._animCanvas);
        }

        map.off('moveend', this._reset, this);

        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }

        map.off(this._events, this);
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    _initRenderer: function () {
        var canvas = this._canvas = this.options.mainRenderer._container.node();
        var animCanvas = this._animCanvas = this.options.animationRenderer._container.node();

        var originProp = DomUtils.TRANSFORM_ORIGIN;
        canvas.style[originProp] = animCanvas.style[originProp] = '50% 50%';

        var animated = this._map.options.zoomAnimation && Browser.any3d;
        var zoomStyle = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');
        var layerStyle = 'leaflet-linemap-layer leaflet-layer ';
        DomUtils.addClass(canvas, layerStyle + zoomStyle);
        DomUtils.addClass(animCanvas, layerStyle + zoomStyle);

        this._lineMap = lineMap(this.options.mainRenderer, this.options.animationRenderer, this._map);
    },

    _updateOptions: function () {

    },

    _reset: function () {
        this._lineMap.stop();
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        DomUtils.setPosition(this._canvas, topLeft);
        DomUtils.setPosition(this._animCanvas, topLeft);

        this._draw();

        // todo,
        // flash sometimes, don't know why
        //
        // var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        // var size = this._map.getSize();
        //
        // var mainRenderer = this.options.mainRenderer;
        // var animationRenderer = this.options.animationRenderer;
        //
        // if (mainRenderer.left !== topLeft.x ||
        //     mainRenderer.top !== topLeft.y ||
        //     mainRenderer.width !== size.x ||
        //     mainRenderer.height !== size.y) {
        //
        //     this._lineMap.stop();
        //
        //     mainRenderer.setPosition(topLeft.x, topLeft.y);
        //     mainRenderer.setSize(size.x, size.y);
        //
        //     animationRenderer.setPosition(topLeft.x, topLeft.y);
        //     animationRenderer.setSize(size.x, size.y);
        //
        //     this._draw();
        // }
    },

    _draw: function () {
        if (!(this._map && this._pairs && this._pairs.length)) {
            this.options.mainRenderer.flush();
            return;
        }

        this._lineMap.data(this._pairs).draw();

        this.options.mainRenderer.flush();
    },

    _animateZoom: function (e) {
        this._lineMap.stop();
        var scale = this._map.getZoomScale(e.zoom),
            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        if (DomUtils.setTransform) {
            // todo, use our own functions
            // this.options.animationRenderer.left =
            //     this.options.mainRenderer.left = offset.x;
            // this.options.animationRenderer.top =
            //     this.options.mainRenderer.top = offset.y;
            DomUtils.setTransform(this._canvas, offset, scale);
            DomUtils.setTransform(this._animCanvas, offset, scale);

        } else {
            var trans = BaseUtils.makeTranslate(offset) + ' scale(' + scale + ')';
            this._canvas.style[DomUtils.TRANSFORM] = trans;
            this._animCanvas.style[DomUtils.TRANSFORM] = trans;
        }
    },

    _events: {
        tap: function (ev) {
            var point = this.hoverPoint;
            point && point._onPointTap(ev); // fire('tap') no effect?
        },
        mousemove: function (ev) {

            var mainRenderer = this.options.mainRenderer;
            var vanchart = this.options.vanchart;
            var self = this;

            var elements = mainRenderer.elements, el, len = mainRenderer.elements.length;

            var target,
                pos = ev.containerPoint;

            // find target element
            while(el = elements[--len]) {
                if (el.contain(pos)) {
                    target = el;
                    break;
                }
            }

            var targetPoint = target && target.point;
            var large = targetPoint && targetPoint.series.options.large;

            if (targetPoint) {
                // found target
                vanchart.showTooltip(targetPoint, ev);
                vanchart.handler.cursor('pointer');

                // has hover color and needs to change
                if (targetPoint.mouseOverColor && !large &&
                    targetPoint !== self.hoverPoint) {

                    // change target element color
                    target.style.strokeStyle = target.point.mouseOverColor;
                }

            } else {
                if (!vanchart.hoverPoint) {
                    vanchart.hideTooltip();
                }
                vanchart.handler.cursor('');
            }

            // different from last
            if (!large && self.hoverPoint != targetPoint) {
                if (self.hoverPoint) {
                    // recover
                    self.hoverPoint.graphic.style.strokeStyle = self.hoverPoint._color;
                }

                self.hoverPoint = targetPoint;
                vanchart.hoverPoint = targetPoint;
                mainRenderer.flush();
            }
        }
    }

});

return function (options) {
    return new LineMapLayer(options);
};

});

/**
 * Created by Yuqian on 2017/7/7.
 */
define('chart/map/CanvasLayer',['require','../../utils/BaseUtils','../../dom/DomUtils','../../utils/ColorUtils','../../Constants','../../vector/Layer','../../dom/Browser'],function (require) {
    var BaseUtils = require('../../utils/BaseUtils');
    var DomUtils = require('../../dom/DomUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var Constants = require('../../Constants');
    var Layer = require('../../vector/Layer');
    var Browser = require('../../dom/Browser');

    return Layer.extend({

        options: {
            renderer: null,
            vanchart: null
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        setOptions: function (options) {
            BaseUtils.setOptions(this, options);
            this._draw();
        },

        onAdd: function (map) {
            this._map = map;

            this._initRenderer();

            map.on('moveend', this._reset, this);

            if (map.options.zoomAnimation && Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }

            map.on(this._events, this);

            this._reset();
        },

        onRemove: function (map) {
            if (this.options.pane) {
                this.getPane().removeChild(this._canvas);
            }else{
                map.getPanes().overlayPane.removeChild(this._canvas);
            }

            map.off('moveend', this._reset, this);

            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }

            map.off(this._events, this);
        },

        setData: function (points) {
            this._points = points;
            this._draw();
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        _initRenderer: function () {
            var canvas = this._canvas = this.options.renderer._container.node();

            var originProp = DomUtils.TRANSFORM_ORIGIN;
            canvas.style[originProp] = '50% 50%';

            var animated = this._map.options.zoomAnimation && Browser.any3d;
            var zoomStyle = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');
            var layerStyle = 'leaflet-linemap-layer leaflet-layer ';
            DomUtils.addClass(canvas, layerStyle + zoomStyle);

        },

        _reset: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            DomUtils.setPosition(this._canvas, topLeft);
            this._draw();
        },

        _draw: function () {
            if (this._map && this._points && this._points.length) {
                this._drawPoints(this._points);
            }

            this.options.renderer.flush();
        },

        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

            DomUtils.setTransform(this._canvas, offset, scale);
        },

        _events: {
            tap: function (ev) {
                var point = this.hoverPoint;
                point && point._onPointTap(ev);
            },
            mousemove: function (ev) {

                var renderer = this.options.renderer;
                var vanchart = this.options.vanchart;
                var self = this;

                var elements = renderer.elements, el, len = renderer.elements.length;

                var target,
                    pos = ev.containerPoint;

                // find target element
                while(el = elements[--len]) {
                    if (el.contain(pos)) {
                        target = el;
                        break;
                    }
                }

                var targetPoint = target && target.point;
                var large = targetPoint && targetPoint.series.options.large;

                if (targetPoint) {
                    // found target
                    vanchart.showTooltip(targetPoint, ev);
                    vanchart.handler.cursor('pointer');

                    // // has hover color and needs to change
                    // if (targetPoint.mouseOverColor && !large &&
                    //     targetPoint !== self.hoverPoint) {
                    //
                    //     // change target element color
                    //     target.style.color = target.point.mouseOverColor;
                    // }

                } else {
                    if (!vanchart.hoverPoint) {
                        vanchart.hideTooltip();
                    }
                    vanchart.handler.cursor('');
                }

                // different from last
                if (self.hoverPoint != targetPoint) {
                    // if (self.hoverPoint) {
                    //     // recover
                    //     self.hoverPoint.graphic.style.color = self.hoverPoint._color;
                    // }

                    self.hoverPoint = targetPoint;
                    // renderer.flush();
                }
            }
        }

    });

});

/**
 * Created by Yuqian on 2017/7/11.
 */
define('chart/map/CanvasMapLayer',['require','./CanvasLayer','../../utils/BaseUtils','../../utils/ColorUtils','../../Constants'],function (require) {
    var CanvasLayer = require('./CanvasLayer');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var Constants = require('../../Constants');

    var DET = 30;
    var LOCATION_RADIUS = 20;

    return CanvasLayer.extend({

        _drawPoints: function (points) {
            var vanchart = this.options.vanchart,
                renderer = this.options.renderer;

            var hasRangelegend = vanchart.hasRangeLegend();

            var width = renderer.width;
            var height = renderer.height;

            var len = points.length, i = len;

            // todo
            renderer.elements = [];

            // 倒过来筛，因为后面的覆盖前面
            while (i--) {
                var p = points[i];
                var latlng = p.getLatLng();

                var pos = vanchart.latLngToContainerPoint(latlng);
                var x = pos.x, y = pos.y;

                if (x < -DET || width + DET < x || y < -DET || height + DET < y
                    || !hasRangelegend && renderer.shouldFilter(x, y)) {
                    if (p.graphic) {
                        p.graphic.needToRemove = true;
                        // todo, remove from canvas but save in point
                        p.graphic = null;
                    }
                    continue
                }

                p.x = pos.x;
                p.y = pos.y;

                if (p.graphic) {
                    renderer.elements.push(p.graphic);

                    var y = p.y;
                    var marker = p.options.marker;
                    if (marker) {
                        var symbol = marker.symbol,
                            radius = marker.radius;
                        // todo, remove this condition
                        if (symbol === Constants.LOCATION) {
                            y -= LOCATION_RADIUS;
                        }
                    }
                    p.graphic.setStyle({
                        x: p.x,
                        y: y
                    });
                } else {
                    p.graphic = this._getGraphic(p, renderer);
                    p.graphic.point = p;
                }
            }

            var left = null;
            var right = null;
            var array = renderer.elements;
            for (left = 0, right = length - 1; left < right; left += 1, right -= 1)
            {
                var temporary = array[left];
                array[left] = array[right];
                array[right] = temporary;
            }


            renderer.resetFilter();

        },

        _getGraphic: function (p, renderer) {
            if (p.series.type === Constants.SCATTER_CHART) {
                var marker = p.options.marker,
                    symbol = marker.symbol,
                    radius = marker.radius,
                    color = marker.fillColor || p.color;

                if (symbol === Constants.LOCATION) {
                    return renderer.image({
                        url: Constants.LOCATION,
                        x: p.x,
                        y: p.y - LOCATION_RADIUS,
                        width: LOCATION_RADIUS * 2,
                        height: LOCATION_RADIUS * 2,
                        color: p.color
                    })
                }

                return renderer.marker(symbol, {
                    x: p.x,
                    y: p.y,
                    radius: radius,
                    color: color
                })
            } else {
                // bubble
                return renderer.circle({
                    x: p.x,
                    y: p.y,
                    r: p.radius,
                    fillStyle: ColorUtils.mixColorWithAlpha(p.color, p.opacity)
                })
            }
        }

    });
});
/*
 * heatmap.js v2.0.5 | JavaScript Heatmap Library
 *
 * Copyright 2008-2016 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.
 * Dual licensed under MIT and Beerware license
 *
 * :: 2016-09-05 01:16
 */
;(function (name, context, factory) {

    // Supports UMD. AMD, CommonJS/Node.js and browser context
    if (typeof module !== "undefined" && module.exports) {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define('chart/map/heatmap',factory);
    } else {
        context[name] = factory();
    }

})("h337", this, function () {

// Heatmap Config stores default values and will be merged with instance config
    var HeatmapConfig = {
        defaultRadius: 40,
        defaultRenderer: 'canvas2d',
        defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
        defaultMaxOpacity: 1,
        defaultMinOpacity: 0,
        defaultBlur: .85,
        defaultXField: 'x',
        defaultYField: 'y',
        defaultValueField: 'value',
        plugins: {}
    };
    var Store = (function StoreClosure() {

        var Store = function Store(config) {
            this._coordinator = {};
            this._data = [];
            this._radi = [];
            this._min = 10;
            this._max = 1;
            this._xField = config['xField'] || config.defaultXField;
            this._yField = config['yField'] || config.defaultYField;
            this._valueField = config['valueField'] || config.defaultValueField;

            if (config["radius"]) {
                this._cfgRadius = config["radius"];
            }
        };

        var defaultRadius = HeatmapConfig.defaultRadius;

        Store.prototype = {
            // when forceRender = false -> called from setData, omits renderall event
            _organiseData: function(dataPoint, forceRender) {
                var x = dataPoint[this._xField];
                var y = dataPoint[this._yField];
                var radi = this._radi;
                var store = this._data;
                var max = this._max;
                var min = this._min;
                var value = dataPoint[this._valueField] || 1;
                var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

                if (!store[x]) {
                    store[x] = [];
                    radi[x] = [];
                }

                if (!store[x][y]) {
                    store[x][y] = value;
                    radi[x][y] = radius;
                } else {
                    store[x][y] += value;
                }
                var storedVal = store[x][y];

                if (storedVal > max) {
                    if (!forceRender) {
                        this._max = storedVal;
                    } else {
                        this.setDataMax(storedVal);
                    }
                    return false;
                } else if (storedVal < min) {
                    if (!forceRender) {
                        this._min = storedVal;
                    } else {
                        this.setDataMin(storedVal);
                    }
                    return false;
                } else {
                    return {
                        x: x,
                        y: y,
                        value: value,
                        radius: radius,
                        min: min,
                        max: max
                    };
                }
            },
            _unOrganizeData: function() {
                var unorganizedData = [];
                var data = this._data;
                var radi = this._radi;

                for (var x in data) {
                    for (var y in data[x]) {

                        unorganizedData.push({
                            x: x,
                            y: y,
                            radius: radi[x][y],
                            value: data[x][y]
                        });

                    }
                }
                return {
                    min: this._min,
                    max: this._max,
                    data: unorganizedData
                };
            },
            _onExtremaChange: function() {
                this._coordinator.emit('extremachange', {
                    min: this._min,
                    max: this._max
                });
            },
            addData: function() {
                if (arguments[0].length > 0) {
                    var dataArr = arguments[0];
                    var dataLen = dataArr.length;
                    while (dataLen--) {
                        this.addData.call(this, dataArr[dataLen]);
                    }
                } else {
                    // add to store
                    var organisedEntry = this._organiseData(arguments[0], true);
                    if (organisedEntry) {
                        // if it's the first datapoint initialize the extremas with it
                        if (this._data.length === 0) {
                            this._min = this._max = organisedEntry.value;
                        }
                        this._coordinator.emit('renderpartial', {
                            min: this._min,
                            max: this._max,
                            data: [organisedEntry]
                        });
                    }
                }
                return this;
            },
            setData: function(data) {
                var dataPoints = data.data;
                var pointsLen = dataPoints.length;


                // reset data arrays
                this._data = [];
                this._radi = [];

                for(var i = 0; i < pointsLen; i++) {
                    this._organiseData(dataPoints[i], false);
                }
                this._max = data.max;
                this._min = data.min || 0;

                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            removeData: function() {
                // TODO: implement
            },
            setDataMax: function(max) {
                this._max = max;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setDataMin: function(min) {
                this._min = min;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setCoordinator: function(coordinator) {
                this._coordinator = coordinator;
            },
            _getInternalData: function() {
                return {
                    max: this._max,
                    min: this._min,
                    data: this._data,
                    radi: this._radi
                };
            },
            getData: function() {
                return this._unOrganizeData();
            }/*,

           TODO: rethink.

           getValueAt: function(point) {
           var value;
           var radius = 100;
           var x = point.x;
           var y = point.y;
           var data = this._data;

           if (data[x] && data[x][y]) {
           return data[x][y];
           } else {
           var values = [];
           // radial search for datapoints based on default radius
           for(var distance = 1; distance < radius; distance++) {
           var neighbors = distance * 2 +1;
           var startX = x - distance;
           var startY = y - distance;

           for(var i = 0; i < neighbors; i++) {
           for (var o = 0; o < neighbors; o++) {
           if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
           if (data[startY+i] && data[startY+i][startX+o]) {
           values.push(data[startY+i][startX+o]);
           }
           } else {
           continue;
           }
           }
           }
           }
           if (values.length > 0) {
           return Math.max.apply(Math, values);
           }
           }
           return false;
           }*/
        };


        return Store;
    })();

    var Canvas2dRenderer = (function Canvas2dRendererClosure() {

        var _getColorPalette = function(config) {
            var gradientConfig = config.gradient || config.defaultGradient;
            var paletteCanvas = document.createElement(window.VAN_CANVAS);

            if(paletteCanvas.getContext){
                var paletteCtx = paletteCanvas.getContext('2d');

                paletteCanvas.width = 256;
                paletteCanvas.height = 1;

                var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
                for (var key in gradientConfig) {
                    gradient.addColorStop(key, gradientConfig[key]);
                }

                paletteCtx.fillStyle = gradient;
                paletteCtx.fillRect(0, 0, 256, 1);

                return paletteCtx.getImageData(0, 0, 256, 1).data;
            }

            return {};
        };

        var _getPointTemplate = function(radius, blurFactor) {
            var tplCanvas = document.createElement(window.VAN_CANVAS);
            var tplCtx = tplCanvas.getContext('2d');
            var x = radius;
            var y = radius;
            tplCanvas.width = tplCanvas.height = radius*2;
            tplCanvas.blur = blurFactor;

            if (blurFactor === 1) {
                tplCtx.beginPath();
                tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
                tplCtx.fillStyle = 'rgba(0,0,0,1)';
                tplCtx.fill();
            } else {
                var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                tplCtx.fillStyle = gradient;
                tplCtx.fillRect(0, 0, 2*radius, 2*radius);
            }

            return tplCanvas;
        };

        var _prepareData = function(data) {
            var renderData = [];
            var min = data.min;
            var max = data.max;
            var radi = data.radi;
            var data = data.data;

            var xValues = Object.keys(data);
            var xValuesLen = xValues.length;

            while(xValuesLen--) {
                var xValue = xValues[xValuesLen];
                var yValues = Object.keys(data[xValue]);
                var yValuesLen = yValues.length;
                while(yValuesLen--) {
                    var yValue = yValues[yValuesLen];
                    var value = data[xValue][yValue];
                    var radius = radi[xValue][yValue];
                    renderData.push({
                        x: xValue,
                        y: yValue,
                        value: value,
                        radius: radius
                    });
                }
            }

            return {
                min: min,
                max: max,
                data: renderData
            };
        };


        function Canvas2dRenderer(config) {
            var container = config.container;
            var shadowCanvas = this.shadowCanvas = document.createElement(window.VAN_CANVAS);
            var canvas = this.canvas = config.canvas || document.createElement(window.VAN_CANVAS);

            //excanvas
            window.VanCanvasManager && VanCanvasManager.initElement(canvas);
            window.VanCanvasManager && VanCanvasManager.initElement(shadowCanvas);

            var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

            var computed = config.container.currentStyle || getComputedStyle(config.container) || {};

            canvas.className = 'heatmap-canvas';

            this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));
            this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));

            this.shadowCtx = shadowCanvas.getContext('2d');
            this.ctx = canvas.getContext('2d');

            // @TODO:
            // conditional wrapper

            canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

            container.style.position = 'relative';
            container.appendChild(canvas);

            this._palette = _getColorPalette(config);
            this._templates = {};

            this._setStyles(config);
        };

        Canvas2dRenderer.prototype = {
            renderPartial: function(data) {
                if (data.data.length > 0) {
                    if(this.ctx.getImageData){
                        this._drawAlpha(data);
                        this._colorize();
                    }else{
                        this._drawPoints(data);
                    }
                }
            },
            renderAll: function(data) {
                // reset render boundaries
                this._clear();
                if (data.data.length > 0) {
                    var data = _prepareData(data);
                    if(this.ctx.getImageData){
                        this._drawAlpha(data);
                        this._colorize();
                    }else{
                        this._drawPoints(data);
                    }
                }
            },

            _drawPoints:function(data){
                var min = this._min = data.min, max = this._max = data.max;
                var data = data.data || [], dataLen = data.length;
                var blur = 1 - this._blur, ctx = this.ctx;
                while(dataLen--) {
                    var point = data[dataLen], radius = +point.radius;
                    var value = Math.min(point.value, max);
                    var x = +point.x, y = +point.y;

                    var templateAlpha = (value-min)/(max-min);
                    templateAlpha = isNaN(templateAlpha) ? 1 : templateAlpha;

                    ctx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

                    var gradient = ctx.createRadialGradient(x, y, radius*blur, x, y, radius);

                    var gradientConfig = this._gradientConfig;
                    for (var key in gradientConfig) {
                        gradient.addColorStop(+key, gradientConfig[key]);
                    }

                    ctx.fillStyle = gradient;

                    ctx.beginPath();

                    ctx.moveTo(x, y);

                    ctx.arc(x, y, radius, 0, Math.PI * 2, false);

                    ctx.fill();
                }
            },

            _updateGradient: function(config) {
                this._palette = _getColorPalette(config);
            },
            updateConfig: function(config) {
                if (config['gradient']) {
                    this._updateGradient(config);
                }
                this._setStyles(config);
            },
            setDimensions: function(width, height) {
                this._width = width;
                this._height = height;
                this.canvas.width = this.shadowCanvas.width = width;
                this.canvas.height = this.shadowCanvas.height = height;
            },
            _clear: function() {
                this.shadowCtx.clearRect(0, 0, this._width, this._height);
                this.ctx.clearRect(0, 0, this._width, this._height);
            },
            _setStyles: function(config) {
                this._blur = (config.blur === 0)?0:(config.blur || config.defaultBlur);

                this._gradientConfig = config.gradient || config.defaultGradient;

                if (config.backgroundColor) {
                    this.canvas.style.backgroundColor = config.backgroundColor;
                }

                this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
                this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;


                this._opacity = (config.opacity || 0) * 255;
                this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
                this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
                this._useGradientOpacity = !!config.useGradientOpacity;
            },
            _drawAlpha: function(data) {
                var min = this._min = data.min;
                var max = this._max = data.max;
                var data = data.data || [];
                var dataLen = data.length;
                // on a point basis?
                var blur = 1 - this._blur;

                while(dataLen--) {

                    var point = data[dataLen];

                    var x = point.x;
                    var y = point.y;
                    var radius = point.radius;
                    // if value is bigger than max
                    // use max as value
                    var value = Math.min(point.value, max);
                    var rectX = x - radius;
                    var rectY = y - radius;
                    var shadowCtx = this.shadowCtx;

                    var tpl;
                    if (!this._templates[radius] || this._templates[radius].blur !== blur) { // @BI-8874
                        this._templates[radius] = tpl = _getPointTemplate(radius, blur);
                    } else {
                        tpl = this._templates[radius];
                    }
                    // value from minimum / value range
                    // => [0, 1]
                    var templateAlpha = (value-min)/(max-min);
                    // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData
                    shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

                    shadowCtx.drawImage(tpl, rectX, rectY);

                    // update renderBoundaries
                    if (rectX < this._renderBoundaries[0]) {
                        this._renderBoundaries[0] = rectX;
                    }
                    if (rectY < this._renderBoundaries[1]) {
                        this._renderBoundaries[1] = rectY;
                    }
                    if (rectX + 2*radius > this._renderBoundaries[2]) {
                        this._renderBoundaries[2] = rectX + 2*radius;
                    }
                    if (rectY + 2*radius > this._renderBoundaries[3]) {
                        this._renderBoundaries[3] = rectY + 2*radius;
                    }
                }
            },
            _colorize: function() {
                var x = this._renderBoundaries[0];
                var y = this._renderBoundaries[1];
                var width = this._renderBoundaries[2] - x;
                var height = this._renderBoundaries[3] - y;
                var maxWidth = this._width;
                var maxHeight = this._height;
                var opacity = this._opacity;
                var maxOpacity = this._maxOpacity;
                var minOpacity = this._minOpacity;
                var useGradientOpacity = this._useGradientOpacity;

                if (x < 0) {
                    x = 0;
                }
                if (y < 0) {
                    y = 0;
                }
                if (x + width > maxWidth) {
                    width = maxWidth - x;
                }
                if (y + height > maxHeight) {
                    height = maxHeight - y;
                }

                var img = this.shadowCtx.getImageData(x, y, width, height);
                var imgData = img.data;
                var len = imgData.length;
                var palette = this._palette;


                for (var i = 3; i < len; i+= 4) {
                    var alpha = imgData[i];
                    var offset = alpha * 4;


                    if (!offset) {
                        continue;
                    }

                    var finalAlpha;
                    if (opacity > 0) {
                        finalAlpha = opacity;
                    } else {
                        if (alpha < maxOpacity) {
                            if (alpha < minOpacity) {
                                finalAlpha = minOpacity;
                            } else {
                                finalAlpha = alpha;
                            }
                        } else {
                            finalAlpha = maxOpacity;
                        }
                    }

                    imgData[i-3] = palette[offset];
                    imgData[i-2] = palette[offset + 1];
                    imgData[i-1] = palette[offset + 2];
                    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

                }

                img.data = imgData;
                this.ctx.putImageData(img, x, y);

                this._renderBoundaries = [1000, 1000, 0, 0];

            },
            getValueAt: function(point) {
                var value;
                var shadowCtx = this.shadowCtx;
                var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
                var data = img.data[3];
                var max = this._max;
                var min = this._min;

                value = (Math.abs(max-min) * (data/255)) >> 0;

                return value;
            },
            getDataURL: function() {
                return this.canvas.toDataURL();
            }
        };


        return Canvas2dRenderer;
    })();


    var Renderer = (function RendererClosure() {

        var rendererFn = false;

        if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
            rendererFn = Canvas2dRenderer;
        }

        return rendererFn;
    })();


    var Util = {
        merge: function() {
            var merged = {};
            var argsLen = arguments.length;
            for (var i = 0; i < argsLen; i++) {
                var obj = arguments[i]
                for (var key in obj) {
                    merged[key] = obj[key];
                }
            }
            return merged;
        }
    };
// Heatmap Constructor
    var Heatmap = (function HeatmapClosure() {

        var Coordinator = (function CoordinatorClosure() {

            function Coordinator() {
                this.cStore = {};
            };

            Coordinator.prototype = {
                on: function(evtName, callback, scope) {
                    var cStore = this.cStore;

                    if (!cStore[evtName]) {
                        cStore[evtName] = [];
                    }
                    cStore[evtName].push((function(data) {
                        return callback.call(scope, data);
                    }));
                },
                emit: function(evtName, data) {
                    var cStore = this.cStore;
                    if (cStore[evtName]) {
                        var len = cStore[evtName].length;
                        for (var i=0; i<len; i++) {
                            var callback = cStore[evtName][i];
                            callback(data);
                        }
                    }
                }
            };

            return Coordinator;
        })();


        var _connect = function(scope) {
            var renderer = scope._renderer;
            var coordinator = scope._coordinator;
            var store = scope._store;

            coordinator.on('renderpartial', renderer.renderPartial, renderer);
            coordinator.on('renderall', renderer.renderAll, renderer);
            coordinator.on('extremachange', function(data) {
                scope._config.onExtremaChange &&
                scope._config.onExtremaChange({
                    min: data.min,
                    max: data.max,
                    gradient: scope._config['gradient'] || scope._config['defaultGradient']
                });
            });
            store.setCoordinator(coordinator);
        };


        function Heatmap() {
            var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
            this._coordinator = new Coordinator();
            if (config['plugin']) {
                var pluginToLoad = config['plugin'];
                if (!HeatmapConfig.plugins[pluginToLoad]) {
                    throw new Error('Plugin \''+ pluginToLoad + '\' not found. Maybe it was not registered.');
                } else {
                    var plugin = HeatmapConfig.plugins[pluginToLoad];
                    // set plugin renderer and store
                    this._renderer = new plugin.renderer(config);
                    this._store = new plugin.store(config);
                }
            } else {
                this._renderer = new Renderer(config);
                this._store = new Store(config);
            }
            _connect(this);
        };

        // @TODO:
        // add API documentation
        Heatmap.prototype = {
            addData: function() {
                this._store.addData.apply(this._store, arguments);
                return this;
            },
            removeData: function() {
                this._store.removeData && this._store.removeData.apply(this._store, arguments);
                return this;
            },
            setData: function() {
                this._store.setData.apply(this._store, arguments);
                return this;
            },
            setDataMax: function() {
                this._store.setDataMax.apply(this._store, arguments);
                return this;
            },
            setDataMin: function() {
                this._store.setDataMin.apply(this._store, arguments);
                return this;
            },
            configure: function(config) {
                this._config = Util.merge(this._config, config);
                this._renderer.updateConfig(this._config);
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            repaint: function() {
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            getData: function() {
                return this._store.getData();
            },
            getDataURL: function() {
                return this._renderer.getDataURL();
            },
            getValueAt: function(point) {

                if (this._store.getValueAt) {
                    return this._store.getValueAt(point);
                } else  if (this._renderer.getValueAt) {
                    return this._renderer.getValueAt(point);
                } else {
                    return null;
                }
            }
        };

        return Heatmap;

    })();


// core
    var heatmapFactory = {
        create: function(config) {
            return new Heatmap(config);
        },
        register: function(pluginKey, plugin) {
            HeatmapConfig.plugins[pluginKey] = plugin;
        }
    };

    return heatmapFactory;
});
/**
 * Created by eason on 2017/3/13.
 */
define('chart/map/HeatMapOverlay',['require','./heatmap','../../vector/Layer','../../dom/DomUtils','../../utils/Point2D','../../utils/BaseUtils','./LatLng'],function(require){

    var h337 = require('./heatmap');

    var Layer = require('../../vector/Layer');
    var DomUtils = require('../../dom/DomUtils');
    var Point = require('../../utils/Point2D');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('./LatLng');

    var MOBILE_TOOLTIP_TIMER,
        MOBILE_TOOLTIP_DELAY = 4000;

    var HeatMapOverlay = Layer.extend({

        initialize: function (config) {
            this.cfg = config;
            this._el = DomUtils.create('div', 'leaflet-zoom-hide');
            this._el.style.zIndex = 201;
            this._data = [];
            this._max = 1;
            this._min = 0;
            this.cfg.container = this._el;
        },

        onAdd: function (map) {
            var size = map.getSize();

            this._map = map;

            this._width = size.x;
            this._height = size.y;

            this._el.style.width = size.x + 'px';
            this._el.style.height = size.y + 'px';
            this._el.style.position = 'absolute';

            this._origin = this._map.layerPointToLatLng(new Point(0, 0));

            map.getPanes().overlayPane.appendChild(this._el);

            if (!this._heatmap) {
                this._heatmap = h337.create(this.cfg);
            }

            // this resets the origin and redraws whenever
            // the zoom changed or the map has been moved
            map.on('moveend', this._reset, this);

            map.on(this._events, this);
            this._draw();
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        onRemove: function (map) {
            // remove layer's DOM elements and listeners
            map.getPanes().overlayPane.removeChild(this._el);

            map.off('moveend', this._reset, this);
            map.off(this._events, this);
        },
        _draw: function() {
            if (!this._map) { return; }

            var mapPane = this._map.getPanes().mapPane;
            var point = mapPane._leaflet_pos;

            // reposition the layer

            if(BaseUtils.isSupportSVG()){
                this._el.style[HeatMapOverlay.CSS_TRANSFORM] = 'translate(' +
                    -Math.round(point.x) + 'px,' +
                    -Math.round(point.y) + 'px)';
            }else{
                this._el.style.left = -Math.round(point.x) + 'px';
                this._el.style.bottom = Math.round(point.y) + 'px';
            }

            this._update();
        },
        _update: function() {
            var bounds, zoom, scale;
            var generatedData = { max: this._max, min: this._min, data: [] };

            bounds = this._map.getBounds();
            zoom = this._map.getZoom();
            scale = Math.pow(2, zoom);

            if (this._data.length === 0) {
                if (this._heatmap) {
                    this._heatmap.setData(generatedData);
                }
                return;
            }


            var latLngPoints = [];
            var radiusMultiplier = this.cfg.scaleRadius ? scale : 1;
            var localMax = 0;
            var localMin = 0;
            var valueField = this.cfg.valueField;
            var len = this._data.length;

            while (len--) {
                var entry = this._data[len];
                var value = entry[valueField];
                var latlng = entry.latlng;


                // we don't wanna render points that are not even on the map ;-)
                if (!bounds.contains(latlng)) {
                    continue;
                }
                // local max is the maximum within current bounds
                localMax = Math.max(value, localMax);
                localMin = Math.min(value, localMin);

                var point = this._map.latLngToContainerPoint(latlng);
                var latlngPoint = { x: Math.round(point.x), y: Math.round(point.y) };
                latlngPoint[valueField] = value;

                var radius;

                if (entry.radius) {
                    radius = entry.radius * radiusMultiplier;
                } else {
                    radius = (this.cfg.radius || 2) * radiusMultiplier;
                }
                latlngPoint.radius = radius;
                latLngPoints.push(latlngPoint);
            }
            if (this.cfg.useLocalExtrema) {
                generatedData.max = localMax;
                generatedData.min = localMin;
            }

            generatedData.data = latLngPoints;

            this._heatmap.setData(generatedData);
        },
        setData: function(data) {
            this._max = data.max || this._max;
            this._min = data.min || this._min;
            var lnglatField = this.cfg.lnglatField || 'lnglat';
            var valueField = this.cfg.valueField || 'value';

            // transform data to latlngs
            var data = data.data;
            var len = data.length;
            var d = [];

            while (len--) {
                var entry = data[len].options;
                var latlng = new LatLng(entry[lnglatField][1], entry[lnglatField][0]);
                var dataObj = { latlng: latlng };
                dataObj[valueField] = entry[valueField];
                if (entry.radius) {
                    dataObj.radius = entry.radius;
                }
                d.push(dataObj);
            }
            this._data = d;

            this._draw();
        },
        // experimential... not ready.
        addData: function(pointOrArray) {
            if (pointOrArray.length > 0) {
                var len = pointOrArray.length;
                while(len--) {
                    this.addData(pointOrArray[len]);
                }
            } else {
                var lnglatField = this.cfg.lnglatField || 'lnglat';
                var valueField = this.cfg.valueField || 'value';
                var entry = pointOrArray;
                var latlng = new LatLng(entry[lnglatField][1], entry[lnglatField][0]);
                var dataObj = { latlng: latlng };

                dataObj[valueField] = entry[valueField];
                this._max = Math.max(this._max, dataObj[valueField]);
                this._min = Math.min(this._min, dataObj[valueField]);

                if (entry.radius) {
                    dataObj.radius = entry.radius;
                }
                this._data.push(dataObj);
                this._draw();
            }
        },
        _reset: function () {
            this._origin = this._map.layerPointToLatLng(new Point(0, 0));

            var size = this._map.getSize();
            if (this._width !== size.x || this._height !== size.y) {
                this._width  = size.x;
                this._height = size.y;

                this._el.style.width = this._width + 'px';
                this._el.style.height = this._height + 'px';

                this._heatmap._renderer.setDimensions(this._width, this._height);
            }
            this._draw();
        },

        _events: {
            tap: function (ev) {  // todo, 移动端点击触发Tap特别费劲
                var vanchart = this._map;

                // 移动端需要考虑showToolTip
                if(BaseUtils.hasTouch()){
                    vanchart.fire('mousemove', ev);

                    if(vanchart.hoverPoint){
                        clearTimeout(MOBILE_TOOLTIP_TIMER);
                        MOBILE_TOOLTIP_TIMER = setTimeout(function () {
                            vanchart.hideTooltip();
                        }, MOBILE_TOOLTIP_DELAY)
                    }
                }

                vanchart.hoverPoint && vanchart.hoverPoint._onPointTap(ev);
            },
            mousemove: function (ev) {
                var vanchart = this._map;
                var closestPoint = vanchart.handler._getCanvasClosestPoint(ev.containerPoint);
                if(closestPoint){
                    if(!closestPoint._events){
                        closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                    }
                    vanchart.showTooltip(closestPoint, ev);
                    vanchart.hoverPoint = closestPoint;
                } else  {
                    vanchart.hideTooltip();
                }
            }
        }
    });

    HeatMapOverlay.CSS_TRANSFORM = (function() {
        var div = document.createElement('div');
        var props = [
            'transform',
            'WebkitTransform',
            'MozTransform',
            'OTransform',
            'msTransform'
        ];

        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (div.style[prop] !== undefined) {
                return prop;
            }
        }
        return props[0];
    })();


    return HeatMapOverlay;
});
/**
 * Created by eason on 2017/2/7.
 */
define('chart/map/Icon',['require','../../utils/Class','../../utils/BaseUtils','../../utils/Point2D','../../dom/Browser','../../dom/DomUtils'],function(require){

    var Class = require('../../utils/Class');
    var BaseUtils = require('../../utils/BaseUtils');
    var Point = require('../../utils/Point2D');
    var Browser = require('../../dom/Browser');
    var DomUtils = require('../../dom/DomUtils');

    var Icon = Class.extend({

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function (oldIcon) {
            return this._createIcon('icon', oldIcon);
        },

        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function (oldIcon) {
            return this._createIcon('shadow', oldIcon);
        },

        _createIcon: function (name, oldIcon) {
            var src = this._getIconUrl(name);

            if (!src) {
                if (name === 'icon') {
                    throw new Error('iconUrl not set in Icon options (see the docs).');
                }
                return null;
            }

            var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
            this._setIconStyles(img, name);

            return img;
        },

        _setIconStyles: function (img, name) {
            var options = this.options;
            var sizeOption = options[name + 'Size'];

            if (typeof sizeOption === 'number') {
                sizeOption = [sizeOption, sizeOption];
            }

            var size = Point.create(sizeOption),
                anchor = Point.create(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
                    size && size.divideBy(2, true));

            img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

            // 现在的图片点击会触发focus导致显示outline，找了一下也没找到为什么
            // 因此直接在这里设置outline为0，即使onfocus也不会显示高亮边框
            img.style.outline = "0";

            if (anchor) {
                img.style.marginLeft = (-anchor.x) + 'px';
                img.style.marginTop  = (-anchor.y) + 'px';
            }

            if (size) {
                img.style.width  = size.x + 'px';
                img.style.height = size.y + 'px';
            }
        },

        _createImg: function (src, el) {
            el = el || document.createElement('img');
            el.src = src;
            return el;
        },

        _getIconUrl: function (name) {
            return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
        }
    });


    Icon.Default = Icon.extend({

        options: {
            iconUrl:       'marker-icon.png',
            iconRetinaUrl: 'marker-icon-2x.png',
            shadowUrl:     'marker-shadow.png',
            iconSize:    [25, 41],
            iconAnchor:  [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize:  [41, 41]
        },

        _getIconUrl: function (name) {
            if (!Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
                Icon.Default.imagePath = this._detectIconPath();
            }

            // @option imagePath: String
            // `Icon.Default` will try to auto-detect the absolute location of the
            // blue icon images. If you are placing these images in a non-standard
            // way, set this option to point to the right absolute path.
            return (this.options.imagePath || Icon.Default.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },

        _detectIconPath: function () {
            var el = DomUtils.create('div',  'leaflet-default-icon-path', document.body);
            var path = DomUtils.getStyle(el, 'background-image') ||
                DomUtils.getStyle(el, 'backgroundImage');	// IE8

            document.body.removeChild(el);

            return path.indexOf('url') === 0 ?
                path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
        }
    });


    return Icon;
});
/**
 * Created by eason on 2017/1/20.
 */
define('vector/shape/LayerGroup',['require','./../Layer','../../utils/BaseUtils'],function(require){

    var Layer = require('./../Layer');
    var BaseUtils = require('../../utils/BaseUtils');

    var LayerGroup = Layer.extend({

        initialize: function (layers) {
            this._layers = {};

            var i, len;

            if (layers) {
                for (i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            }
        },

        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function (layer) {
            var id = this.getLayerId(layer);

            this._layers[id] = layer;

            if (this._map) {
                this._map.addLayer(layer);
            }

            return this;
        },

        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function (layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);

            if (this._map && this._layers[id]) {
                this._map.removeLayer(this._layers[id]);
            }

            delete this._layers[id];

            return this;
        },

        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        hasLayer: function (layer) {
            return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
        },

        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function () {
            for (var i in this._layers) {
                this.removeLayer(this._layers[i]);
            }
            return this;
        },

        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function (methodName) {
            var args = Array.prototype.slice.call(arguments, 1),
                i, layer;

            for (i in this._layers) {
                layer = this._layers[i];

                if (layer[methodName]) {
                    layer[methodName].apply(layer, args);
                }
            }

            return this;
        },

        onAdd: function (map) {
            for (var i in this._layers) {
                map.addLayer(this._layers[i]);
            }
        },

        onRemove: function (map) {
            for (var i in this._layers) {
                map.removeLayer(this._layers[i]);
            }
        },

        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },

        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function (id) {
            return this._layers[id];
        },

        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function () {
            var layers = [];

            for (var i in this._layers) {
                layers.push(this._layers[i]);
            }
            return layers;
        },

        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function (zIndex) {
            return this.invoke('setZIndex', zIndex);
        },

        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function (layer) {
            return BaseUtils.stamp(layer);
        }
    });


    return LayerGroup;
});
/**
 * Created by eason on 2017/2/8.
 */

define('vector/shape/Path',['require','./../Layer','../../dom/Browser','../../utils/BaseUtils'],function(require){

    var Layer = require('./../Layer');
    var Browser = require('../../dom/Browser');
    var BaseUtils = require('../../utils/BaseUtils');

    var INIT_TIME = 1200;
    var INIT_EASE = 'cubic-out';
    var EXIT_TIME = 300;
    var EXIT_EASE = 'ease';
    var RESHOW_TIME = 1000;
    var RESHOW_EASE = INIT_EASE;

    var Path = Layer.extend({

        onAdd: function () {
            this._path = this._renderer.path().style(this.options);
            this._reset();
            this._path.add();
        },

        onRemove: function () {
            this._path.remove();
        },

        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function () {
            if (this._map) {
                this._reset();
            }
            return this;
        },

        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function (style) {

            //path 只存样式信息
            this.options = style || this.options;

            if (this._renderer) {
                this._path.style(this.options);
            }

            return this;
        },

        initAnimate:function () {
            this._path.style({'fill-opacity':0})
                .animate({
                    style:this.options,
                    duration:INIT_TIME,
                    ease:INIT_EASE});
        },

        exitAnimate:function (vanchart, animate) {
            var geo = vanchart.getCurrentGeo();
            animate == false ? this._path.style(geo.defaultAreaStyle())
                : this._path.animate({
                    style:geo.defaultAreaStyle(),
                    duration: EXIT_TIME,
                    ease:EXIT_EASE})
        },

        reShowAnimate:function () {
            this._path.style({'fill-opacity':0})
                .animate({
                style:this.options,
                duration:RESHOW_TIME,
                ease:RESHOW_EASE});
        },

        _onMouseState:function (isChosen,duration,ease,style) {
            style.filter = "none";  // todo 这里的动画应该用不到filter吧，不禁用的话，和effect的attr.filter就冲突导致闪烁变白
            this._path .animate({
                duration:duration,
                ease:ease,
                style:style
            });
        },

        _reset: function () {
            // defined in children classes
            this._project();
            this._update();
        },

        _clickTolerance: function () {
            // used when doing hit detection for Canvas layers
            return (this.options['stroke-width'] ? this.options['stroke-width'] / 2 : 0) + (Browser.touch ? 10 : 0);
        },

        node:function(){
            return this._path.node();
        }

    });

    return Path;

});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/LatLngBounds',['require','./LatLng'],function(require){

    var LatLng = require('./LatLng');

    var LatLngBounds = function (corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
        if (!corner1) { return; }

        var latlngs = corner2 ? [corner1, corner2] : corner1;

        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    };

    LatLngBounds.prototype = {

        extend: function (obj) {
            var sw = this._southWest,
                ne = this._northEast,
                sw2, ne2;

            if (obj instanceof LatLng) {
                sw2 = obj;
                ne2 = obj;

            } else if (obj instanceof LatLngBounds) {
                sw2 = obj._southWest;
                ne2 = obj._northEast;

                if (!sw2 || !ne2) { return this; }

            } else {
                return obj ? this.extend(LatLng.create(obj) || LatLngBounds.create(obj)) : this;
            }

            if (!sw && !ne) {
                this._southWest = new LatLng(sw2.lat, sw2.lng);
                this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
                sw.lat = Math.min(sw2.lat, sw.lat);
                sw.lng = Math.min(sw2.lng, sw.lng);
                ne.lat = Math.max(ne2.lat, ne.lat);
                ne.lng = Math.max(ne2.lng, ne.lng);
            }

            return this;
        },

        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
        pad: function (bufferRatio) {
            var sw = this._southWest,
                ne = this._northEast,
                heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

            return new LatLngBounds(
                new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
                new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },

        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function () {
            return new LatLng(
                (this._southWest.lat + this._northEast.lat) / 2,
                (this._southWest.lng + this._northEast.lng) / 2);
        },

        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function () {
            return this._southWest;
        },

        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function () {
            return this._northEast;
        },

        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function () {
            return new LatLng(this.getNorth(), this.getWest());
        },

        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function () {
            return new LatLng(this.getSouth(), this.getEast());
        },

        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function () {
            return this._southWest.lng;
        },

        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function () {
            return this._southWest.lat;
        },

        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function () {
            return this._northEast.lng;
        },

        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function () {
            return this._northEast.lat;
        },

        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.

        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
            if (typeof obj[0] === 'number' || obj instanceof LatLng) {
                obj = LatLng.create(obj);
            } else {
                obj = LatLngBounds.create(obj);
            }

            var sw = this._southWest,
                ne = this._northEast,
                sw2, ne2;

            if (obj instanceof LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else {
                sw2 = ne2 = obj;
            }

            return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
                (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
        },

        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            var sw = this._southWest,
                ne = this._northEast,
                sw2 = bounds.getSouthWest(),
                ne2 = bounds.getNorthEast(),

                latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
                lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

            return latIntersects && lngIntersects;
        },

        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            var sw = this._southWest,
                ne = this._northEast,
                sw2 = bounds.getSouthWest(),
                ne2 = bounds.getNorthEast(),

                latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
                lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

            return latOverlaps && lngOverlaps;
        },

        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
        },

        // @method equals(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
        equals: function (bounds) {
            if (!bounds) { return false; }

            bounds = LatLngBounds.create(bounds);

            return this._southWest.equals(bounds.getSouthWest()) &&
                this._northEast.equals(bounds.getNorthEast());
        },

        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function () {
            return !!(this._southWest && this._northEast);
        },

        isSame: function () {
            var sw = this._southWest, ne = this._northEast;
            return sw.lat === ne.lat && sw.lng === ne.lng
        }
    };

    LatLngBounds.create = function(a, b){
        if (a instanceof LatLngBounds) {
            return a;
        }
        return new LatLngBounds(a, b);
    };

    return LatLngBounds;
});
/**
 * Created by eason on 2017/2/14.
 */
define('utils/PathGenerator',['require','./vMap','../Constants'],function(require){

    var vMap = require('./vMap');
    var Constants = require('../Constants');

    var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
    var abs = Math.abs;

    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }

    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }

    function d3_identity(d) {
        return d;
    }

    function d3_true() {
        return true;
    }

    var svg = {};
    function d3_zero() {
        return 0;
    }
    svg.arc = function() {
        var toCenter = true;
        var closePath = true;
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) {
                rc = r1, r1 = r0, r0 = rc;
            }
            if (da >= τε) {
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            }
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) {
                    p1 *= -1;
                }
                if (r1) {
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                }
                if (r0) {
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
                }
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (x1 != null) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    } else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    } else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                } else if(toCenter){
                    path.push("L", x2, ",", y2);
                }
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) {
                    path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                }
                if (toCenter) {
                    path.push("L", x2, ",", y2);
                }
                if (x3 != null) {
                    path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
                }
            }
            if(closePath) {
                path.push("Z");
            }
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }

        arc.toCenter = function(v){
            if (!arguments.length) {
                return toCenter;
            }
            toCenter = !!v;
            return arc;
        };

        arc.closePath = function(v){
            if (!arguments.length) {
                return closePath;
            }
            closePath = !!v;
            return arc;
        };

        arc.innerRadius = function(v) {
            if (!arguments.length) {
                return innerRadius;
            }
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) {
                return outerRadius;
            }
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) {
                return cornerRadius;
            }
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) {
                return padRadius;
            }
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) {
                return startAngle;
            }
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) {
                return endAngle;
            }
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) {
                return padAngle;
            }
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
            cx0 = cx1, cy0 = cy1;
        }
        return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
    }

    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }

    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }

    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) {
                segment();
            }
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) {
                return x;
            }
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) {
                return y;
            }
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) {
                return defined;
            }
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) {
                return interpolateKey;
            }
            if (typeof _ === "function") {
                interpolateKey = interpolate = _;
            } else {
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            }
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) {
                return tension;
            }
            tension = _;
            return line;
        };
        return line;
    }

    svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = new vMap({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        }
        if (n > 1) {
            path.push("H", p[0]);
        }
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("V", (p = points[i])[1], "H", p[0]);
        }
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("H", (p = points[i])[0], "V", p[1]);
        }
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
            points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) {
            return d3_svg_lineLinear(points);
        }
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) {
            return d3_svg_lineLinear(points);
        }
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfπ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length){
                segment();
            }
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length){
                return x1;
            }
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) {
                return x0;
            }
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) {
                return x1;
            }
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) {
                return y1;
            }
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length){
                return y0;
            }
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length){
                return y1;
            }
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) {
                return defined;
            }
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) {
                return interpolateKey;
            }
            if (typeof _ === "function") {
                interpolateKey = interpolate = _;
            } else {
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            }
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length){
                return tension;
            }
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };

    svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) { return source; }
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) { return target; }
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) { return projection; }
            projection = x;
            return diagonal;
        };
        return diagonal;
    };

    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }

    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }

    svg.getMarkerPath = function(markerType, radius){
        switch(markerType){
            case Constants.CIRCLE:
            case Constants.CIRCLE_HOLLOW:
                return svg.arc().outerRadius(radius)({startAngle:0, endAngle:2 * Math.PI});

            case Constants.SQUARE:
            case Constants.SQUARE_HOLLOW:
                var leftTop = -radius + ',' + -radius;
                var rightTop = radius + ',' + -radius;
                var rightBottom = radius + ',' + radius;
                var leftBottom = -radius + ',' + radius;
                return 'M' + leftTop + 'L' + rightTop + 'L' + rightBottom + 'L' + leftBottom + 'Z';

            case Constants.DIAMOND:
            case Constants.DIAMOND_HOLLOW:
                radius = radius * 2 / Math.sqrt(2);
                var left = -radius + ',' + 0;
                var top = 0 + ',' + -radius;
                var right = radius + ',' + 0;
                var bottom = 0 + ',' + radius;
                return 'M' + left + 'L' + top + 'L' + right + 'L' + bottom + 'Z';

            case Constants.TRIANGLE:
            case Constants.TRIANGLE_HOLLOW:
                var sqrt3 = Math.sqrt(3);
                var left = -2 * radius / sqrt3  + ',' + radius;
                var top = 0 + ',' + -radius;
                var right = 2 * radius / sqrt3  + ',' + radius;
                return 'M' + left + 'L' + top + 'L' + right + 'Z';
            case Constants.STAR:
                radius *= 1.4;
                var r = getr(radius);
                var d = '';
                var i = -1;
                while (++i < 5) {
                    var th = i * deg2rad(72),
                        al = th + deg2rad(36);

                    var a = getPos(th, radius, 3);
                    var b = getPos(al, r, 3);

                    var cmd = i ? 'L' : 'M';
                    d += cmd + a[0] + ',' + a[1];
                    d += 'L' + b[0] + ',' +b[1];
                }
                d += 'z';
                return d;
            case Constants.LOCATION:
                // todo,
                // (40 x 40)
                return 'M14.8-24.2C14.8-32.3,8.3-39,0.1-39s-14.8,6.5-14.8,14.6c0,3.2,1,6.3,2.9,8.9L0,0l11.9-15.5l0,0  C13.8-18,14.8-21.1,14.8-24.2z M0-18.1c-3.2,0-5.8-2.6-5.8-5.8s2.6-5.8,5.8-5.8s5.8,2.7,5.8,5.9S3.2-18.1,0-18.1L0-18.1z';
            default:
                return ''
        }
    };

    function deg2rad (deg) {return deg / 180 * Math.PI}

    function getr (R) {
        return R * Math.sin(deg2rad(18)) / (Math.sin(deg2rad(36)) + Math.sin(deg2rad(18)) * Math.cos(deg2rad(36)) )
    }

    function getPos (th, r, l){
        return [
            (Math.sin(th) * r).toFixed(l),
            (-Math.cos(th) * r).toFixed(l)
        ]
    }

    return svg;
});
/**
 * Created by eason on 2017/4/10.
 */

define('vector/shape/CircleMarker',['require','./Path','../../utils/BaseUtils','../../chart/map/LatLng','../../chart/map/LatLngBounds','../../utils/PathGenerator','../../Constants'],function(require){

    var Path = require("./Path");
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('../../chart/map/LatLng');
    var Bounds = require('../../chart/map/LatLngBounds');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');

    var CircleMarker = Path.extend({

        initialize: function (latlng, options, radius) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
            this._radius = radius;
            this._circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);
        },

        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function (latlng) {
            this._latlng = LatLng.create(latlng);
            this.redraw();
            return this.fire('move', {latlng: this._latlng});
        },

        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function () {
            return this._latlng;
        },

        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function (radius) {
            this._radius = radius;
            return this.redraw();
        },

        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function () {
            return this._radius;
        },

        initAnimate:function (point) {
            this._animate(500, point.delayTime)
        },

        reShowAnimate:function () {
            this._animate(300);
        },

        _animate:function (duration, delayTime) {
            this._path.attr({'d' : this._circle.outerRadius(0)()})
                .animate({
                    delay:delayTime || 0,
                    ease:'bounce',
                    duration:duration,
                    attr:{'d': this._circle.outerRadius(this._radius)()}
                })
        },

        exitAnimate:function (vanchart, animate) {
            var layer = this, group = vanchart._pointLayer;
            animate == false ? group.removeLayer(layer)
                : this._path.animate({
                    ease:'back-in',
                    duration:300,
                    attr:{'d' : this._circle.outerRadius(0)()}
                }).remove().each('end', function () {group.removeLayer(layer);});
        },

        _onMouseState:function(isChosen, duration, ease, style){
            var radius = this._radius + (isChosen ? 1 : 0);
            this._path
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({ease:ease, duration:duration, style:style, attr:{'d': this._circle.outerRadius(radius)()}});
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
        },

        _updateBounds: function () {
            var r = this._radius,
                r2 = this._radiusY || r,
                w = this._clickTolerance(),
                p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },

        _update: function () {
            if (this._map) {
                this._updatePath();
            }
        },

        _updatePath: function () {
            this._path.attr({
                'd': this._circle.outerRadius(this._radius)(),
                'transform': BaseUtils.makeTranslate(this._point)
            });
            this.setStyle();
        },

        _empty: function () {
            return !this._renderer._bounds.intersects(this._pxBounds);
        }
    });

    return CircleMarker;
});
/**
 * Created by eason on 2017/2/7.
 */
define('chart/map/Marker',['require','./../../vector/Layer','./Icon','../../utils/BaseUtils','./LatLng','../../dom/DomUtils','../../vector/Transition','../../dom/Browser','../../utils/BezierEasing'],function(require){

    var Layer = require('./../../vector/Layer');
    var Icon = require('./Icon');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('./LatLng');
    var DomUtils = require('../../dom/DomUtils');
    var Transition = require('../../vector/Transition');
    var Browser = require('../../dom/Browser');
    var BezierEasing = require('../../utils/BezierEasing');

    var Marker = Layer.extend({

        // @section
        // @aka Marker options
        options: {
            // @option icon: Icon = *
            // Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
            icon: new Icon.Default(),

            // Option inherited from "Interactive layer" abstract class
            interactive: true,

            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,

            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,

            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            title: '',

            // @option alt: String = ''
            // Text for the `alt` attribute of the icon image (useful for accessibility).
            alt: '',

            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,

            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,

            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,

            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,

            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: 'markerPane',

            // FIXME: shadowPane is no longer a valid option
            nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
        },

        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */

        initialize: function (latlng, options) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
        },

        onAdd: function (map) {
            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

            if (this._zoomAnimated) {
                map.on('zoomanim', this._animateZoom, this);
            }

            this._initIcon();
            this.update();
        },

        onRemove: function (map) {

            if (this._zoomAnimated) {
                map.off('zoomanim', this._animateZoom, this);
            }

            this._removeIcon();
        },

        getEvents: function () {
            return {
                zoom: this.update,
                viewreset: this.update
            };
        },

        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function () {
            return this._latlng;
        },

        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function (latlng) {
            var oldLatLng = this._latlng;
            this._latlng = LatLng.create(latlng);
            this.update();

            // @event move: Event
            // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
            return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
        },

        update: function () {

            if (this._icon) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }

            return this;
        },

        initAnimate: function (point) {
            var marker = this, lastTranslate;
            // initMarker的时候获取的translate不一定是最终的translate,比如说上钻的时候，会先创建marker，然后zoom的时候更新marker
            // 所以动画中使用的translate应该是实时计算得到的
            function getTranslate(){
                var trans;
                if(Browser.ie3d || !Browser.any3d){
                    trans = marker._icon ? BaseUtils.makeTranslate(marker._icon._leaflet_pos) : lastTranslate;
                } else {
                    trans = marker._icon ? BaseUtils.makeTranslate3d(marker._icon._leaflet_pos) : lastTranslate;
                }
                lastTranslate = trans;
                return trans;
            }

            function tween() {
                return function (t) {
                    return getTranslate() + 'scale(' + t + ')';
                }
            }

            var useFilterRender = point.series.vanchart.useFilterRender;

            // 这边exit的已经移除了，所以useFilterRender的时候，也会initAnimate
            if(useFilterRender){
                this._icon.style.transform =  getTranslate() + 'scale(1)';
            } else {
                this._icon.style.transform = getTranslate() + 'scale(0.01)';
                this._icon.style["transform-origin"] =  "bottom";

                new Transition(this._icon)
                    .delay(point.delayTime || 0)
                    .ease('back-out')
                    .duration(600)
                    .styleTween('transform', tween)
            }
        },

        exitAnimate:function (vanchart) {
            var group = vanchart._pointLayer;
            group.removeLayer(this);
        },

        _onMouseState:function (isChosen) {
            var options = this.options.icon.options, width = options.iconSize[0], height = options.iconSize[1];
            var diff = isChosen ? 2 : 0;
            new Transition(this._icon)
                .ease(BezierEasing.custom["ease-out-back"])
                .duration(300)
                .style({'margin-left':(-width/2-diff)+'px','margin-top':(-height/2-diff)+'px',width:(width+diff*2)+'px',height:(height+2*diff)+'px'});
        },

        _initIcon: function () {
            var options = this.options,
                classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

            var icon = options.icon.createIcon(this._icon),
                addIcon = false;

            // if we're not reusing the icon, remove the old one and init new one
            if (icon !== this._icon) {
                if (this._icon) {
                    this._removeIcon();
                }
                addIcon = true;

                if (options.title) {
                    icon.title = options.title;
                }
                if (options.alt) {
                    icon.alt = options.alt;
                }
            }

            DomUtils.addClass(icon, classToAdd);

            if (options.keyboard) {
                icon.tabIndex = '0';
            }

            this._icon = icon;

            if (addIcon) {
                this.getPane().appendChild(this._icon);
            }
        },

        _removeIcon: function () {

            DomUtils.remove(this._icon);

            this._icon = null;
        },

        _setPos: function (pos) {
            DomUtils.setPosition(this._icon, pos);

            if (this._shadow) {
                DomUtils.setPosition(this._shadow, pos);
            }

            this._zIndex = pos.y + this.options.zIndexOffset;

            this._resetZIndex();
        },

        _updateZIndex: function (offset) {
            this._icon.style.zIndex = this._zIndex + offset;
        },

        _animateZoom: function (opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

            this._setPos(pos);
        },

        _resetZIndex: function () {
            this._updateZIndex(0);
        },

        node:function(){
            return this._icon;
        },

        setStyle:function(){

        }
    });

    return Marker;
});
/**
 * Created by eason on 2017/4/10.
 */

define('vector/shape/ScatterMarker',['require','./Path','../../utils/BaseUtils','../../chart/map/LatLng','../../utils/PathGenerator','../../Constants','../../utils/BezierEasing'],function(require){

    var Path = require('./Path');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('../../chart/map/LatLng');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');
    var BezierEasing = require('../../utils/BezierEasing');

    var ScatterMarker = Path.extend({

        initialize: function (latlng, options, marker) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
            this._marker = marker;
        },

        setLatLng: function (latlng) {
            this._latlng = LatLng.create(latlng);
            this.redraw();
            return this.fire('move', {latlng: this._latlng});
        },

        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function () {
            return this._latlng;
        },

        initAnimate:function (point) {
            this._animate(point.delayTime);
        },

        reShowAnimate:function () {
            this._animate();
        },

        _animate:function (delayTime) {
            var self = this, lastTranslate;

            function getTranslate(){
                var translate = self._point ? BaseUtils.makeTranslate(self._point) : lastTranslate;
                lastTranslate = translate;
                return translate;
            }

            function translateTween(){
                return function (t){
                     return getTranslate() + 'scale('+t+')';
                }
            }

            this._path.attr({'transform' : BaseUtils.makeTranslate(this._point) + 'scale(0.01)'})
                .animate({
                    delay: delayTime || 0,
                    ease: 'back-out',
                    duration: 300,
                    attrTween: {
                        "transform" : translateTween
                    }
                });
        },

        exitAnimate:function (vanchart, animate) {
            var layer = this, group = vanchart._pointLayer;
            animate == false ? group.removeLayer(layer)
                : this._path.animate({
                    ease:'back-in',
                    duration:300,
                    attr:{'transform' : BaseUtils.makeTranslate(this._point) + 'scale(0)'}
                }).remove().each('end', function () {group.removeLayer(layer);});
        },


        _onMouseState:function(isChosen){
            var markerType = this._marker.symbol || "circle";
            var radius = this._marker.radius || 4.5;
            radius = radius + (isChosen ? 2 : 0);

            this._path
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:300,
                    ease:BezierEasing.custom["ease-out-back"],
                    attr:{'d':PathGenerator.getMarkerPath(markerType, radius)}
                })
        },


        _getMarkerPath:function(){
            var markerType = this._marker.symbol || "circle";
            var r = this._marker.radius || 4.5;
            return PathGenerator.getMarkerPath(markerType, r);
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },

        _update: function () {
            if (this._map) {
                this._updatePath();
            }
        },

        _updatePath: function () {
            this._path.attr({
                'd':this._getMarkerPath(),
                'transform':BaseUtils.makeTranslate(this._point)
            });
        },

        _empty: function () {
            return !this._renderer._bounds.intersects(this._pxBounds);
        }

    });

    return ScatterMarker;
});
/**
 * Created by eason on 2017/4/10.
 */
define('vector/shape/TextLayer',['require','../../vector/Layer','../../chart/map/LatLng','../../utils/BaseUtils','../../utils/ColorUtils','../../dom/DomUtils','../Transition','../../utils/BezierEasing'],function(require){

    var Layer = require('../../vector/Layer');
    var LatLng = require('../../chart/map/LatLng');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var DomUtils = require('../../dom/DomUtils');
    var Transition = require('../Transition');
    var BezierEasing = require('../../utils/BezierEasing');

    var GAP = 4;

    var Text = Layer.extend({

        initialize: function (latlng, dataPoint) {
            this._latlng = LatLng.create(latlng);
            this._dataPoint = dataPoint;
        },

        setStyle:function(latlng){

            this._latlng = latlng;

            this.onRemove();

            this.onAdd();
        },

        beforeAdd: function (map) {
            this._renderer = map.getMapRenderer(this);
        },

        _fontSizeState:function (isChosen, duration, ease) {
            var scale = isChosen ? 'translate(0,0)scale(1.1)' : 'translate(0,0)scale(1)';

            new Transition(this._text)
                .ease(ease)
                .duration(duration)
                .style({transform:scale});
        },

        _transformState:function (isChosen) {
            var top = this._point.y - (isChosen ? 2 : 0);

            new Transition(this._text)
                .ease(BezierEasing.custom["ease-out-back"])
                .duration(300)
                .style({top:top+'px'});
        },

        onAdd: function () {

            //地图上的标签都用html显示
            this._text = document.createElement('div');
            this._text.style.position = 'absolute';
            this._text.style.zIndex = 1001;
            this._text.style['pointer-events'] = 'none';
            this.getPane().appendChild(this._text);

            var dataPoint = this._dataPoint, labelContent = dataPoint.labelContent,  marker = dataPoint.options.marker, chartType = dataPoint.series.type;
            var centerX = 0, startY = -dataPoint.labelDim.height/2;

            if(chartType == 'scatter' || chartType == 'pointMap'){
                if(marker && !BaseUtils.isImageMarker(marker.symbol)){
                    var radius = marker.radius || 4.5;
                    startY = - radius - dataPoint.labelDim.height;
                }else{
                    var iconHeight = marker ? marker.height : dataPoint.options.icon.iconSize[1];
                    startY = -iconHeight/2 - dataPoint.labelDim.height;
                }
            }

            startY -= GAP;//标签和图片的间隔

            for(var i = 0, count = labelContent.length; i < count; i++){
                var label = labelContent[i];

                var labelDim = label.dim;
                var labelText = label.text;
                var labelStyle = label.style;

                var div = document.createElement('div');
                div.innerHTML = labelText;
                div.style.zIndex = 1001;
                div.style.position = 'absolute';
                div.style.left = -labelDim.width/2 + 'px';
                div.style.top = startY + 'px';
                div.style.overflow = 'hidden';
                div.style.whiteSpace = 'nowrap';

                for(var fontStyle in labelStyle){
                    //ie789的color属性只能是16进制的值
                    if(fontStyle == 'color' && labelStyle.color != 'inherit'){
                        div.style.color = ColorUtils.colorToHex(labelStyle.color);
                    }else {
                        div.style[fontStyle] = labelStyle[fontStyle];
                    }
                }
                this._text.appendChild(div);

                startY += (labelDim.height + 2);
            }

            this._reset();
        },

        onRemove: function () {
            DomUtils.remove(this._text);
        },

        getEvents: function () {
            return {
                zoomend: this._project,
                moveend: this._update,
                viewreset: this._reset
            };
        },

        _reset: function () {
            // defined in children classes
            this._project();
            this._update();
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },

        _update: function () {
            if (this._map) {
                this._text.style.left = this._point.x + 'px';
                this._text.style.top = this._point.y + 'px';
            }
        }
    });

    return Text;

});
/**
 * Created by eason on 2017/2/7.
 */

define('chart/map/PosAnimation',['require','../../dom/Evented','../../dom/DomUtils','../../utils/BaseUtils'],function(require){

    var Evented = require('../../dom/Evented');
    var DomUtils = require('../../dom/DomUtils');
    var BaseUtils = require('../../utils/BaseUtils');


    var PosAnimation = Evented.extend({

        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function (el, newPos, duration, easeLinearity) {
            this.stop();

            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

            this._startPos = DomUtils.getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();

            // @event start: Event
            // Fired when the animation starts
            this.fire('start');

            this._animate();
        },

        // @method stop()
        // Stops the animation (if currently running).
        stop: function () {
            if (!this._inProgress) { return; }

            this._step(true);
            this._complete();
        },

        _animate: function () {
            // animation loop
            this._animId = BaseUtils.requestAnimFrame(this._animate, this);
            this._step();
        },

        _step: function (round) {
            var elapsed = (+new Date()) - this._startTime,
                duration = this._duration * 1000;

            if (elapsed < duration) {
                this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
                this._runFrame(1);
                this._complete();
            }
        },

        _runFrame: function (progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
                pos._round();
            }

            DomUtils.setPosition(this._el, pos);

            // @event step: Event
            // Fired continuously during the animation.
            this.fire('step');
        },

        _complete: function () {
            BaseUtils.cancelAnimFrame(this._animId);

            this._inProgress = false;
            // @event end: Event
            // Fired when the animation ends.
            this.fire('end');
        },

        _easeOut: function (t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });

    return PosAnimation;
});
/**
 * Copyright (c) 2010-2016, Vladimir Agafonkin
 Copyright (c) 2010-2011, CloudMade
 All rights reserved.

 Redistribution and use in source and binary forms, with or without modification, are
 permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this list of
 conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice, this list
 of conditions and the following disclaimer in the documentation and/or other materials
 provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

/**
 * Created by eason on 2017/1/18.
 */
define('vans/VanChartBaseMap',['require','./VanChart','../utils/BaseUtils','../dom/DomUtils','../Constants','../dom/Evented','../dom/Browser','../utils/Point2D','../utils/Bounds','../chart/map/LatLng','../chart/map/LatLngBounds','../chart/map/PosAnimation'],function(require){

    var VanChart = require('./VanChart');

    var BaseUtils = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var Constants = require('../Constants');

    var Evented = require('../dom/Evented');
    var Browser = require('../dom/Browser');
    var Point = require('../utils/Point2D');
    var Bounds = require('../utils/Bounds');
    var LatLng = require('../chart/map/LatLng');
    var LatLngBounds = require('../chart/map/LatLngBounds');
    var PosAnimation = require('../chart/map/PosAnimation');

    var DEFAULT_ZOOM_LEVEL = 6;

    var VanChartMap = VanChart.extend({

        // @section Methods for modifying map state

        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function (center, zoom, options) {

            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(LatLng.create(center), zoom, this.options.maxBounds);
            options = options || {};

            this._stop();

            if (this._loaded && !options.reset && options !== true) {

                if (options.animate !== undefined) {
                    options.zoom = BaseUtils.extend({animate: options.animate}, options.zoom);
                    options.pan = BaseUtils.extend({animate: options.animate, duration: options.duration}, options.pan);
                }

                // try animating pan or zoom
                var moved = (this._zoom !== zoom) ? this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

                if (moved) {
                    // prevent resize handler call, the view will refresh after animation anyway
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }

            // animation didn't start, just reset the map view
            this._resetView(center, zoom);

            return this;
        },

        // @method setZoom(zoom: Number, options: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function (zoom, options) {
            if (!this._loaded) {
                this._zoom = zoom;
                return this;
            }
            return this.setView(this.getCenter(), zoom, {zoom: options});
        },

        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function (delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
        },

        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function (delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
        },

        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function (latlng, zoom, options) {
            var scale = this.getZoomScale(zoom),
                viewHalf = this.getSize().divideBy(2),
                containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

                centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

            return this.setView(newCenter, zoom, {zoom: options});
        },

        _getBoundsCenterZoom: function (bounds, options) {

            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : LatLngBounds.create(bounds);

            var paddingTL = Point.create(options.paddingTopLeft || options.padding || [0, 0]),
                paddingBR = Point.create(options.paddingBottomRight || options.padding || [0, 0]),

                zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

            zoom = isFinite(zoom) ? zoom : DEFAULT_ZOOM_LEVEL;  //@Cmen:CHART-995

            zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

                swPoint = this.project(bounds.getSouthWest(), zoom),
                nePoint = this.project(bounds.getNorthEast(), zoom),
                center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

            return {
                center: center,
                zoom: zoom
            };
        },

        // @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function (bounds, options) {

            var _bounds = LatLngBounds.create(bounds);

            if (!_bounds.isValid()) {
                throw new Error('Bounds are not valid.');
            }

            if (_bounds.isSame()) {
                return this.setView(bounds[0], DEFAULT_ZOOM_LEVEL, options);
            } else {
                var target = this._getBoundsCenterZoom(_bounds, options);
                return this.setView(target.center, target.zoom, options);
            }
        },

        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function (options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
        },

        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function (center, options) { // (LatLng)
            return this.setView(center, this._zoom, {pan: options});
        },

        // @method panBy(offset: Point): this
        // Pans the map by a given number of pixels (animated).
        panBy: function (offset, options) {
            offset = Point.create(offset).round();
            options = options || {};

            if (!offset.x && !offset.y) {
                return this.fire('moveend');
            }
            // If we pan too far, Chrome gets issues with tiles
            // and makes them disappear or appear in the wrong place (slightly offset) #2602
            if (options.animate !== true && !this.getSize().contains(offset)) {
                this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
                return this;
            }

            if (!this._panAnim) {
                this._panAnim = new PosAnimation();

                this._panAnim.on({
                    'step': this._onPanTransitionStep,
                    'end': this._onPanTransitionEnd
                }, this);
            }

            // don't fire movestart if animating inertia
            if (!options.noMoveStart) {
                this.fire('movestart');
            }

            // animate pan unless animate: false specified
            if (options.animate !== false) {
                DomUtils.addClass(this._mapPane, 'leaflet-pan-anim');

                var newPos = this._getMapPanePos().subtract(offset).round();
                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire('move').fire('moveend');
            }

            return this;
        },

        // @method setMaxBounds(bounds: Bounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            if (!bounds.isValid()) {
                this.options.maxBounds = null;
                return this.off('moveend', this._panInsideMaxBounds);
            } else if (this.options.maxBounds) {
                this.off('moveend', this._panInsideMaxBounds);
            }

            this.options.maxBounds = bounds;

            if (this._loaded) {
                this._panInsideMaxBounds();
            }

            return this.on('moveend', this._panInsideMaxBounds);
        },

        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function (bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(),
                newCenter = this._limitCenter(center, this._zoom, LatLngBounds.create(bounds));

            if (!center.equals(newCenter)) {
                this.panTo(newCenter, options);
            }

            this._enforcingBounds = false;
            return this;
        },

        // @method invalidateSize(options: Zoom/Pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.

        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function (options) {
            if (!this._loaded) { return this; }

            options = BaseUtils.extend({
                animate: false,
                pan: true
            }, options === true ? {animate: true} : options);

            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;

            var newSize = this.getSize(),
                oldCenter = oldSize.divideBy(2).round(),
                newCenter = newSize.divideBy(2).round(),
                offset = oldCenter.subtract(newCenter);

            if (!offset.x && !offset.y) { return this; }

            if (options.animate && options.pan) {
                this.panBy(offset);

            } else {
                if (options.pan) {
                    this._rawPanBy(offset);
                }

                this.fire('move');

                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(BaseUtils.bind(this.fire, this, 'moveend'), 200);
                } else {
                    this.fire('moveend');
                }
            }

            // @section Map state change events
            // @event resize: ResizeEvent
            // Fired when the map is resized.
            return this.fire('resize', {
                oldSize: oldSize,
                newSize: newSize
            });
        },

        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function () {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
                this.fire('viewreset');
            }
            return this._stop();
        },

        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function () {

            DomUtils.remove(this._mapPane);

            DomUtils.remove(this._controlContainer);

            if (this._loaded) {
                // @section Map state change events
                // @event unload: Event
                // Fired when the map is destroyed with [remove](#map-remove) method.
                this.fire('unload');
            }

            for (var i in this._layers) {
                this._layers[i].remove();
            }

            VanChart.prototype.remove.call(this);
            return this;
        },

        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a children of `container`, or
        // as a children of the main map pane if not set.
        createPane: function (name, container) {
            var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
                pane = DomUtils.create('div', className, container || this._mapPane);

            if (name) {
                this._panes[name] = pane;
            }
            return pane;
        },

        // @section Methods for Getting Map State

        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function () {
            this._checkIfLoaded();

            if (this._lastCenter && !this._moved()) {
                return this._lastCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },

        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function () {
            return this._zoom;
        },

        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function () {
            var bounds = this.getPixelBounds(),
                sw = this.unproject(bounds.getBottomLeft()),
                ne = this.unproject(bounds.getTopRight());

            return new LatLngBounds(sw, ne);
        },

        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function () {
            return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
        },

        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function () {
            return this.options.maxZoom === undefined ?
                (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
                this.options.maxZoom;
        },

        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
            bounds = LatLngBounds.create(bounds);
            padding = Point.create(padding || [0, 0]);

            var zoom = this.getZoom() || 0,
                min = this.getMinZoom(),
                max = this.getMaxZoom(),
                nw = bounds.getNorthWest(),
                se = bounds.getSouthEast(),
                size = this.getSize().subtract(padding),
                boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
                snap = Browser.any3d ? this.options.zoomSnap : 1;

            var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
            zoom = this.getScaleZoom(scale, zoom);

            if (snap) {
                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
            }

            return Math.max(min, Math.min(max, zoom));
        },

        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function (center, zoom) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },

        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function () {
            this._checkIfLoaded();
            return this._pixelOrigin;
        },

        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function (zoom) {
            return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
        },

        // @section Other Methods

        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function (pane) {
            return typeof pane === 'string' ? this._panes[pane] : pane;
        },

        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function () {
            return this._panes;
        },

        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function () {
            return this._container;
        },


        // @section Conversion Methods

        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function (toZoom, fromZoom) {
            // TODO replace with universal implementation after refactoring projections
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
        },

        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function (scale, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            var zoom = crs.zoom(scale * crs.scale(fromZoom));
            return isNaN(zoom) ? Infinity : zoom;
        },

        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function (latlng, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(LatLng.create(latlng), zoom);
        },

        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function (point, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(Point.create(point), zoom);
        },

        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function (point) {
            var projectedPoint = Point.create(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },

        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function (latlng) {
            var projectedPoint = this.project(LatLng.create(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },

        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function (latlng) {
            return this.options.crs.wrapLatLng(LatLng.create(latlng));
        },

        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function (latlng1, latlng2) {
            return this.options.crs.distance(LatLng.create(latlng1), LatLng.create(latlng2));
        },

        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function (point) { // (Point)
            return Point.create(point).subtract(this._getMapPanePos());
        },

        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function (point) { // (Point)
            return Point.create(point).add(this._getMapPanePos());
        },

        // @method containerPointToLatLng(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function (point) {
            var layerPoint = this.containerPointToLayerPoint(Point.create(point));
            return this.layerPointToLatLng(layerPoint);
        },

        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function (latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(LatLng.create(latlng)));
        },

        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function (e) {
            return DomUtils.getMousePos(e, this._container);
        },

        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function (e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },

        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function (e) { // (MouseEvent)
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },

        _initContainer: function (id) {
            var container = this._container = DomUtils.get(id);

            !this.bindIEDragCursor() && DomUtils.addClass(container, 'leaflet-grab');
        },

        /**
         * IE下绑定地图鼠标光标drag&dragging
         * @returns {boolean}
         */
        bindIEDragCursor: function (){
            var _bind = false, option = this.options;
            if(Browser.ie && option.cursor){
                var type = this._mapDragged ? "dragging" : "drag";
                this._container.style.cursor = "url("+option.cursor[type]+"), auto";
                _bind = true;
            }
            return _bind;
        },

        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function (control) {
            control.addTo(this);
            return this;
        },

        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function (control) {
            control.remove();
            return this;
        },

        _initControlPos: function () {
            var corners = this._controlCorners = {},
                l = 'leaflet-',
                container = this._controlContainer =
                    DomUtils.create('div', l + 'control-container', this._container);

            function createCorner(vSide, hSide) {
                var className = l + vSide + ' ' + l + hSide;

                corners[vSide + hSide] = DomUtils.create('div', className, container);
            }

            createCorner('top', 'left');
            createCorner('bottom', 'right');
        },

        // private methods that modify map state

        // @section Map state change events
        _resetView: function (center, zoom) {
            DomUtils.setPosition(this._mapPane, new Point(0, 0));

            var loading = !this._loaded;
            this._loaded = true;
            zoom = this._limitZoom(zoom);

            this.fire('viewprereset');

            var zoomChanged = this._zoom !== zoom;
            this
                ._moveStart(zoomChanged)
                ._move(center, zoom)
                ._moveEnd(zoomChanged);

            // @event viewreset: Event
            // Fired when the map needs to redraw its content (this usually happens
            // on map zoom or load). Very useful for creating custom overlays.
            this.fire('viewreset');

            // @event load: Event
            // Fired when the map is initialized (when its center and zoom are set
            // for the first time).
            if (loading) {
                this.fire('load');
            }
        },

        _moveStart: function (zoomChanged) {
            // @event zoomstart: Event
            // Fired when the map zoom is about to change (e.g. before zoom animation).
            // @event movestart: Event
            // Fired when the view of the map starts changing (e.g. user starts dragging the map).
            if (zoomChanged) {
                this.fire('zoomstart');
            }
            return this.fire('movestart');
        },

        _move: function (center, zoom, data) {
            if (zoom === undefined) {
                zoom = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom;

            this._zoom = zoom;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);

            // @event zoom: Event
            // Fired repeatedly during any change in zoom level, including zoom
            // and fly animations.
            if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
                this.fire('zoom', data);
            }

            // @event move: Event
            // Fired repeatedly during any movement of the map, including pan and
            // fly animations.
            return this.fire('move', data);
        },

        _moveEnd: function (zoomChanged) {
            // @event zoomend: Event
            // Fired when the map has changed, after any animations.
            if (zoomChanged) {
                this.drawAllEffects();
                var vanchart = this;
                // 关于下面这个定时器的由来，有必要细说一下：
                // 之前地图这边的标签，为了保证不重叠，在画之前会进行一次冲突计算，对于冲突的点的标签，则不显示
                // 而每次zoom的时候，其实只是针对已有的标签进行位置更新，这就导致了最开始可能冲突的点等缩放到一定大小的zoom之后，可能就不冲突了，
                // 因此之前被隐藏的标签，就应该被重新显示出来。于是每次moveEnd即zoomChanged的时候，都会重新计算冲突标签和renderLabel
                // 2017-08-03 更新： 在地图钻取(多层级)，当一次上钻的等级差>1的时候，会连续两次zoom&setView，第二次则取消第一次动画，直接更新
                // 导致了validPoints不能及时更新(vanchartMap.layoutComponentsAndCharts里geo.doLayout原本有animateZoom的时候，这里结束validPoints应该已经更新了)，
                // 因此导致关于标签位置的计算会抛错（层级坐标改变，对应的标签尚未改变）故在这里加一个定时器，保证标签更新的时候，对应的坐标系和点都是正确的
                this.validPoints && this.setTimeout("zoom_label_update", function (){
                    vanchart._updateNormalLabel();
                }, 350);
                this.fire('zoomend');
            }

            // @event moveend: Event
            // Fired when the center of the map stops changing (e.g. user stopped
            // dragging the map).
            return this.fire('moveend');
        },

        _stop: function () {
            BaseUtils.cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
                this._panAnim.stop();
            }
            return this;
        },

        _rawPanBy: function (offset) {
            DomUtils.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },

        _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom();
        },

        _panInsideMaxBounds: function () {
            if (!this._enforcingBounds) {
                this.panInsideBounds(this.options.maxBounds);
            }
        },

        _checkIfLoaded: function () {
            if (!this._loaded) {
                throw new Error('Set map center and zoom first.');
            }
        },

        _onResize: function () {
            BaseUtils.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = BaseUtils.requestAnimFrame(
                function () { this.invalidateSize({debounceMoveend: true}); }, this);
        },

        _performZoom: function () {
            var map = this,
                zoom = map.getZoom(),
                snap = this.options.zoomSnap || 0;

            map._stop(); // stop panning and fly animations if any

            // map the delta with a sigmoid function to -4..4 range leaning on -1..1
            var d2 = this._delta / (this.options.wheelPxPerZoomLevel * 4),
                d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
                d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
                delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

            this._delta = 0;
            this._startTime = null;

            if (!delta) { return; }

            if (map.options.scrollWheelZoom === 'center') {
                map.setZoom(zoom + delta);
            } else {
                map.setZoomAround(this._lastMousePos, zoom + delta);
            }
        },

        // @section Other Methods

        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function (callback, context) {
            if (this._loaded) {
                callback.call(context || this, {target: this});
            } else {
                this.on('load', callback, context);
            }
            return this;
        },

        _getMapPanePos: function () {
            return DomUtils.getPosition(this._mapPane) || new Point(0, 0);
        },

        _moved: function () {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
        },

        _getTopLeftPoint: function (center, zoom) {
            var pixelOrigin = center && zoom !== undefined ?
                this._getNewPixelOrigin(center, zoom) :
                this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
        },

        _getNewPixelOrigin: function (center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },

        _latLngToNewLayerPoint: function (latlng, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return this.project(latlng, zoom)._subtract(topLeft);
        },

        _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return Bounds.create([
                this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
            ]);
        },

        // layer point of the current center
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },

        // offset of the specified place to the current center in pixels
        _getCenterOffset: function (latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },

        // adjust center for view to get inside bounds
        _limitCenter: function (center, zoom, bounds) {

            if (!bounds) { return center; }

            var centerPoint = this.project(center, zoom),
                viewHalf = this.getSize().divideBy(2),
                viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                offset = this._getBoundsOffset(viewBounds, bounds, zoom);

            // If offset is less than a pixel, ignore.
            // This prevents unstable projections from getting into
            // an infinite loop of tiny offsets.
            if (offset.round().equals([0, 0])) {
                return center;
            }

            return this.unproject(centerPoint.add(offset), zoom);
        },

        // adjust offset for view to get inside bounds
        _limitOffset: function (offset, bounds) {
            if (!bounds) { return offset; }

            var viewBounds = this.getPixelBounds(),
                newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },

        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
            var projectedMaxBounds = Bounds.create(
                this.project(maxBounds.getNorthEast(), zoom),
                this.project(maxBounds.getSouthWest(), zoom)
                ),
                minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
                maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

                dx = this._rebound(minOffset.x, -maxOffset.x),
                dy = this._rebound(minOffset.y, -maxOffset.y);

            return new Point(dx, dy);
        },

        _rebound: function (left, right) {
            return left + right > 0 ?
            Math.round(left - right) / 2 :
            Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },

        _limitZoom: function (zoom) {
            var min = this.getMinZoom(),
                max = this.getMaxZoom(),
                snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
                if(Browser.any3d){
                    zoom = Math.round(zoom / snap) * snap;
                } else {
                    zoom = (zoom / snap) * snap;
                    zoom = zoom > this._zoom ? Math.ceil(zoom) : Math.floor(zoom); // zoom = 5.5, this._zoom = 6; IE8下snap为1，math.round(5.5) = 6，不变
                }
            }
            return Math.max(min, Math.min(max, zoom));
        },

        _onPanTransitionStep: function () {
            this.fire('move');
        },

        _onPanTransitionEnd: function () {
            DomUtils.removeClass(this._mapPane, 'leaflet-pan-anim');
            this.fire('moveend');
        },

        _tryAnimatedPan: function (center, options) {
            // difference between the new and current centers in pixels
            var offset = this._getCenterOffset(center)._floor();

            // don't animate too far unless animate: true specified in options
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

            this.panBy(offset, options);

            return true;
        },

        _nothingToAnimate: function () {
            return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
        },

        _tryAnimatedZoom: function (center, zoom, options) {
            // @Cmen地图缩放的时候移除MoreLabel, 写在这个感觉不好，但除了这里也没找到好的地方
            this.removeMoreLabel();

            if (this._animatingZoom) { return true; }

            options = options || {};

            // don't animate if disabled, not supported or zoom difference is too large
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
                Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

            // offset is the pixel coords of the zoom origin relative to the current center
            var scale = this.getZoomScale(zoom),
                offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

            // don't animate if the zoom origin isn't within one screen from the current center, unless forced
            if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

            BaseUtils.requestAnimFrame(function () {
                this
                    ._moveStart(true)
                    ._animateZoom(center, zoom, true);
            }, this);

            return true;
        },

        _animateZoom: function (center, zoom, startAnim, noUpdate) {
            if (startAnim) {
                this._animatingZoom = true;

                // remember what center/zoom to set after animation
                this._animateToCenter = center;
                this._animateToZoom = zoom;

                DomUtils.addClass(this._mapPane, 'leaflet-zoom-anim');
            }

            // @event zoomanim: ZoomAnimEvent
            // Fired on every frame of a zoom animation
            this.fire('zoomanim', {
                center: center,
                zoom: zoom,
                noUpdate: noUpdate
            });

            // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
            setTimeout(BaseUtils.bind(this._onZoomTransitionEnd, this), 250);
        },

        _onZoomTransitionEnd: function () {
            if (!this._animatingZoom) { return; }

            DomUtils.removeClass(this._mapPane, 'leaflet-zoom-anim');

            this._animatingZoom = false;

            this._move(this._animateToCenter, this._animateToZoom);

            // This anim frame should prevent an obscure iOS webkit tile loading race condition.
            BaseUtils.requestAnimFrame(function () {
                this._moveEnd(true);
            }, this);
        },

        addLayer: function (layer) {
            var id = BaseUtils.stamp(layer);
            if (this._layers[id]) { return this; }
            this._layers[id] = layer;

            layer._mapToAdd = this;

            if (layer.beforeAdd) {
                layer.beforeAdd(this);
            }

            this.whenReady(layer._layerAdd, layer);

            return this;
        },

        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function (layer) {
            var id = BaseUtils.stamp(layer);

            if (!this._layers[id]) { return this; }

            if (this._loaded) {
                layer.onRemove(this);
            }

            delete this._layers[id];

            if (this._loaded) {
                this.fire('layerremove', {layer: layer});
                layer.fire('remove');
            }

            layer._map = layer._mapToAdd = null;

            return this;
        },

        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function (layer) {
            return !!layer && (BaseUtils.stamp(layer) in this._layers);
        },

        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },

        _addZoomLimit: function (layer) {
            if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
                this._zoomBoundLayers[BaseUtils.stamp(layer)] = layer;
                this._updateZoomLevels();
            }
        },

        _removeZoomLimit: function (layer) {
            var id = BaseUtils.stamp(layer);

            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }
        },

        _updateZoomLevels: function () {
            var minZoom = Infinity,
                maxZoom = -Infinity,
                oldZoomSpan = this._getZoomSpan();

            for (var i in this._zoomBoundLayers) {
                var options = this._zoomBoundLayers[i].options;

                minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
                maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }

            this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

            if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
                this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
                this.setZoom(this._layersMinZoom);
            }
        }
    });

    return VanChartMap;
});


/**
 * Created by eason on 2017/4/10.
 */

define('vans/VanChartMap',['require','../vector/SvgRenderer','../vector/VmlRenderer','../vector/CanvasRenderer','./VanChartLayout','../ChartLibrary','../ComponentLibrary','../chart/map/LineMapLayer','../chart/map/CanvasMapLayer','../chart/map/HeatMapOverlay','../chart/map/Icon','../utils/QueryUtils','../utils/BaseUtils','../dom/DomUtils','../dom/Browser','../Constants','../utils/BoundsManager','../chart/map/CRS','../utils/Point2D','../chart/map/LatLng','../vector/shape/LayerGroup','../vector/shape/CircleMarker','../chart/map/Marker','../vector/shape/ScatterMarker','../vector/shape/TextLayer','./VanChartBaseMap','./VanChartLibrary','./VanChartLibrary','./VanChartLibrary','./VanChartLibrary'],function(require){

    var SvgRenderer = require('../vector/SvgRenderer');
    var VmlRenderer = require('../vector/VmlRenderer');
    var CanvasRenderer = require('../vector/CanvasRenderer');

    var VanChartLayout = require('./VanChartLayout');
    var ChartLibrary = require('../ChartLibrary');
    var ComponentLibrary = require('../ComponentLibrary');
    var lineMapLayer = require('../chart/map/LineMapLayer');
    var CanvasMapLayer = require('../chart/map/CanvasMapLayer');
    var HeatMapOverlay = require('../chart/map/HeatMapOverlay');
    var Icon = require('../chart/map/Icon');

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var Browser = require('../dom/Browser');
    var Constants = require('../Constants');
    var BoundsManager = require('../utils/BoundsManager');

    var CRS = require('../chart/map/CRS');
    var Point = require('../utils/Point2D');
    var LatLng = require('../chart/map/LatLng');
    var LayerGroup = require('../vector/shape/LayerGroup');
    var CircleMarker = require('../vector/shape/CircleMarker');
    var Marker = require('../chart/map/Marker');
    var ScatterMarker = require('../vector/shape/ScatterMarker');
    var TextLayer = require('../vector/shape/TextLayer');

    var VanChartBaseMap = require("./VanChartBaseMap");

    var PINCH_SCALE = 1,  // 默认的pinch是的缩放比例,pinchstart的时候会自动重置为1，主要用来和pinch.scale比较
        PINCH_SCALE_INTERVAL = 0.1;  // pinch时与上一次缩放的scale的差值,大于该值的时候才会触发地图缩放

    var VanChartMap = VanChartBaseMap.extend({

        vanChartType:'vanChartMap',

        _initDomLayout: function (dom) {

            var options = this.options;

            this._initContainer(dom);
            this._initLayout();

            this.on(this.getEvents(), this);

            this.dom = this._controlCorners['topleft'];

            if (options.maxBounds) {
                this.setMaxBounds(options.maxBounds);
            }

            if (options.zoom !== undefined) {
                this._zoom = this._limitZoom(options.zoom);
            }

            if (options.center && options.zoom !== undefined) {
                this.setView(LatLng.create(options.center), options.zoom, {reset: true});
            }

            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;

            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
            this._zoomAnimated = DomUtils.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

            // zoom transitions run with the same duration for all layers, so if one of transitionend events
            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
            if (this._zoomAnimated) {
                // this._createAnimProxy();
                // L.DomEvent.on(this._proxy, DomUtils.TRANSITION_END, this._catchTransitionEnd, this);
            }

            VanChartBaseMap.prototype._initDomLayout.call(this, this._controlCorners['topleft']);
        },

        setOptions:function(options){

            VanChartBaseMap.prototype.setOptions.call(this, options);

            options = this.options;

            if(options.backgroundImage || options.backgroundColor || options.borderWidth){
                BaseUtils.setDomBackground(this.wrapDom, {
                    backgroundImage:options.backgroundImage,
                    backgroundColor:options.backgroundColor,
                    borderColor:options.borderColor,
                    borderWidth:options.borderWidth,
                    borderRadius:options.borderRadius,
                    shadow:options.shadow
                });
            }


            if(this.layerIndex === 0){
                return;
            }

            //钻取以后的刷新用最原始的数据
            if(this.layerMap && this.layerMap.length){

                this.series.forEach(function(ser){
                    ser.remove();
                });

                this.components.geo.remove();

                this.series = this.layerMap[0].series;
                this.components.geo = this.layerMap[0].geo;
            }

            if(this.options.initDrillPath && this.options.initDrillPath.length > 1){
                this.series.forEach(function(ser){
                    ser.remove();
                });
                this.series = [];
            }
        },

        getMapRenderer:function(){

            var dom = this._panes['overlayPane'];

            if(!this.mapRenderer){
                this.mapRenderer = BaseUtils.isSupportSVG() ? new SvgRenderer(dom, this) : new VmlRenderer(dom, this);
                this.addLayer(this.mapRenderer);
            }

            return this.mapRenderer;
        },

        getEvents:function(){

            return {
                'mousemove':this._onMouseMove,

                'scroll':this._onScroll,

                'panstart':this._onPanStart,

                'panmove':this._onPanMove,

                'panend':this._onPanEnd,

                'wheel':this._onWheelScroll,

                'pinchstart': this._pinchStart,

                'pinchmove':this._onPinch,

                'zoom':this._onZoom
            };
        },

        registerInteractiveTarget: function (data, elementWrapper) {
            VanChartBaseMap.prototype.registerInteractiveTarget.call(this, data, elementWrapper);
            data.addEventParent(this);
        },

        _zoomEnabled:function(){
            return this.options.geo.zoom;
        },

        _onMouseMove:function(ev){
            this.cancelLegendHighlight(ev.containerPoint);
        },

        _onScroll: function () {
            this._container.scrollTop  = 0;
            this._container.scrollLeft = 0;
        },

        //mark the start of drag
        _onPanStart:function(event){

            if(this._zoomEnabled()){

                this._initPos = DomUtils.getPosition(this._mapPane);

                this._startPoint = event.containerPoint;

                // 拖拽地图的时候移除MoreLabel
                this.removeMoreLabel();

                // 抓取开始，使用抓取中手型dragging,绑定在this._container即可
                this._mapDragged = true;
                this.bindIEDragCursor();

                this._stop();
            }
        },

        _onPanMove:function(event){

            if(this._zoomEnabled()){

                BaseUtils.cancelAnimFrame(this._animRequest);

                var offset = event.containerPoint.subtract(this._startPoint);
                this._newPos = this._initPos.add(offset);
                this._animRequest = BaseUtils.requestAnimFrame(function(){

                    DomUtils.setPosition(this._mapPane, this._newPos);

                }, this, true);

                DomUtils.addClass(document.body, 'leaflet-dragging');

            }

        },

        _onPanEnd: function () {

            if(this._zoomEnabled()){

                this.fire('moveend');
                // 抓取结束，恢复正常手型drag
                this._mapDragged = false;
                this.bindIEDragCursor();

                DomUtils.removeClass(document.body, 'leaflet-dragging');

                var pos = this._getMapPanePos();
                if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
                    // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
                    this._resetView(this.getCenter(), this.getZoom());
                }

            }

        },


        _pinchStart: function(){
            PINCH_SCALE = 1;
        },

        _onPinch:function(e){
            var eventScale = e.scale, map = this, pointCenterArray = [];
            if(!this._zoomEnabled()){
                return;
            }
            // 手势缩放比例过小时地图不进行缩放
            if(Math.abs(PINCH_SCALE - eventScale) < PINCH_SCALE_INTERVAL) {
                return;
            }

            var zoomType = PINCH_SCALE > eventScale ? -1 : 1;  // 判断是放大还是缩小

            // @Cmen=CHART-839:钻取地图-->移动端手势缩放自动钻取
            // 注：只有点地图和区域地图支持钻取，且chartType不能用做判断的标准，比如组合地图的时候chartType为areaMap，里面可能就包含lineMap
            map.series.forEach(function (ser){
                var isPointMap = ser.type === Constants.POINT_MAP,
                    isAreaMap  = ser.type === Constants.AREA_MAP;
                if(isPointMap || isAreaMap ) {
                    var points = ser.points;
                    points.forEach(function (point) {
                        var layers = point.layers || [];
                        layers.forEach(function (layer) {
                            var center = isPointMap ? point.getLatLng() : (layer.getCenter ? layer.getCenter() : null);  // 区域地图如果其坐标未定义，layer.getCenter不可用
                            center && pointCenterArray.push({
                                point : point,
                                distance : map.latLngToContainerPoint(center).distanceTo(e.containerPoint)
                            })
                        })
                    });
                }
            });

            pointCenterArray.sort(function (p1, p2){
                return p1.distance - p2.distance;
            });

            this.hoverPoint = pointCenterArray.length && pointCenterArray[0].point;


            this._pinchZoom = map._limitZoom(map.getZoom() + zoomType * Math.abs(eventScale - 1));
            this._pinchCenter = e.center;

            if (!this._pinchStartTime) {
                this._pinchStartTime = +new Date();
            }

            var debounce = this.options.wheelDebounceTime;
            var left = Math.max(debounce - (+new Date() - this._pinchStartTime), 0);

            // 现在这样感觉定时器就没有必要了，但是也不影响，就留着吧
            clearTimeout(this._pinchTimer);
            this._pinchTimer = setTimeout(function(){
                map._stop(); // stop panning and fly animations if any
                map._pinchStartTime = null;
                map.setZoomAround(Point.create(map._pinchCenter),  map._pinchZoom);
            }, left);


            PINCH_SCALE = eventScale;
        },

        _onWheelScroll:function(e){

            if(!this._zoomEnabled()){
                return;
            }

            e = e.srcEvent;
            var delta = DomUtils.getWheelDelta(e);

            var debounce = this.options.wheelDebounceTime;

            this._delta = BaseUtils.pick(this._delta, 0);
            this._delta += delta;
            this._lastMousePos = this.mouseEventToContainerPoint(e);

            if (!this._startTime) {
                this._startTime = +new Date();
            }

            var left = Math.max(debounce - (+new Date() - this._startTime), 0);

            clearTimeout(this._timer);
            this._timer = setTimeout(BaseUtils.bind(this._performZoom, this), left);

            DomUtils.stop(e);
        },

        //地图暂时好像不需要做什么
        _animationEnd:function(){
            this._animationStarted = false;
            this._consoleDone();

            this.drawAllEffects();
        },

        _animationStart:function(){
            //锁住fire的'animationEnd'
            this._animationStarted = true;
            // this.animationCount = 0;   地图这边动画在renderSeries里面就已经开始了

            var vanchart = this;

            // 这里考虑渐变色图例加闪烁动画，如果图表在renderSeries时，没有动画，是否理解执行animationEnd,
            // 实验结果证明，这样高频率的绑定effect动画，会造成视觉上的抖动。因此这里在animationStart和animationEnd之间
            // 给予250毫秒的间隔，当诸如拖动渐变色图例这样的高频渲染情况下，节约性能
            if (!this.animationCount) {
                this.setTimeout("chart_animation_end", function (){
                    vanchart.fire('animationEnd');
                }, 250)
            }
        },

        _initLayout: function () {
            var container = this._container;

            this._fadeAnimated = !this.options.toPhantom && this.options.fadeAnimation && Browser.any3d;

            DomUtils.addClass(container, 'leaflet-container' +
                (Browser.touch ? ' leaflet-touch' : '') +
                (Browser.retina ? ' leaflet-retina' : '') +
                (Browser.ielt9 ? ' leaflet-oldie' : '') +
                (Browser.safari ? ' leaflet-safari' : '') +
                (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

            var position = DomUtils.getStyle(container, 'position');

            if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                container.style.position = 'relative';
            }

            this._initPanes();

            this._initControlPos();
        },

        _initPanes: function () {
            var panes = this._panes = {};

            this._mapPane = this.createPane('mapPane', this._container);
            DomUtils.setPosition(this._mapPane, new Point(0, 0));

            // @pane tilePane: HTMLElement = 200
            // Pane for `GridLayer`s and `TileLayer`s
            this.createPane('tilePane');
            // @pane overlayPane: HTMLElement = 400
            // Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
            this.createPane('overlayPane');
            // @pane markerPane: HTMLElement = 600
            // Pane for `Icon`s of `Marker`s
            this.createPane('markerPane');

            if (!this.options.markerZoomAnimation) {
                DomUtils.addClass(panes.markerPane, 'leaflet-zoom-hide');
            }
        },

        layoutComponentsAndCharts:function(){

            this.initLayerInfo();

            var vanchart = this;
            vanchart.bounds = vanchart._getDefaultBounds();

            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in vanchart.components) {
                    vanchart.components[c].doLayout();
                }
            }, this);

            this.reRenderSeries();
        },

        filterRender:function(){
            /**
             * 这里之前的考虑是，渐变色图例拖拽，exit的动画会覆盖update的样式设置，倒是render的结果出错，
             * 然后和郑大姐讨论得出的结论是尝试在这里把renderer.isAnimation设为false，即下面renderSeries里面的动画都不执行
             * 按理说应该可以保证不覆盖，看了一下点地图好像的确没问题，今天检查了区域地图，拖得快的情况下，还是会覆盖，导致区域地图的颜色刷不出来
             * 可见即使设置noAnimation, ele.animate的结束也要比JS慢一大拍
             * 如此一来，那么只能用这种及其丑陋的写法+判断了：
             * 这里设置useFilterRender为true，所有关于layer的动画，在useFilterRender时，都直接更新属性或样式，否则则正常执行动画
             * @type {boolean}
             */
            this.useFilterRender = true;
            this.renderSeries();
            this.useFilterRender = false;
        },

        _updateSeriesStyle:function(){

            this.validPoints.forEach(function(point){

                if(!point.layers || !point.visible){
                    return ;//removed
                }

                var style = point.series._getDynamicStyle(point);

                point.layers.forEach(function(layer){

                    layer.setStyle(style);

                });

            });

        },

        reRenderWholePlot:function(){
            var legend = this.components[ComponentLibrary.LEGEND_COMPONENT];
            legend && legend.render();
            this.reRenderSeries();
        },

        //地图需要在当前层级上刷新
        refreshRestore:function(){
            this._initIntermediateState();

            for(var component in this.components){
                this.components[component].refresh();
            }

            this.series.forEach(function(ser, index){
                ser.refresh(ser.options, index);
            });

            var rangeLegend = this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT];
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            this.series.forEach(function(ser){
                // try in large mode
                if (ser.type === Constants.LINE_MAP && ser.options.large) {
                    return;
                }
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            this.layoutComponentsAndCharts();
        },

        reRenderSeries:function(){

            this.hoverPoint = this.hoverSeries = null;

            this.calculateMapSeries();

            this.render();
        },

        calculateMapSeries:function(){
            var vanchart = this;
            vanchart.hoverPoint = null; vanchart.hoverSeries = null;

            var bubbleSeries = vanchart.seriesOfType(Constants.BUBBLE_CHART);
            VanChartLayout.calculateBubbleRadius(bubbleSeries);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.BUBBLE_CHART), Constants.BUBBLE_CHART);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.SCATTER_CHART), Constants.SCATTER_CHART);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.POINT_MAP), Constants.BUBBLE_CHART);

            //计算百分比和标签相关
            var nameMap = {}, nullNameMap = {}, series = this.series;
            for(var i = 0, count = series.length; i < count; i++){
                var total = 0, ser = series[i], type = ser.type, points = ser.points;
                points.forEach(function(point){
                    total = BaseUtils.accAdd(total, Math.abs(point.getTargetValue()));
                });

                points.forEach(function(point){
                    point.percentage = Math.abs(point.getTargetValue()/total);
                    var key = point.options.lnglat ?  point.options.lnglat.join('-') : point.name;
                    key = key + type;

                    var usedMap = point.isNull ? nullNameMap : nameMap;
                    usedMap[key] = usedMap[key] || [];
                    usedMap[key].push(point);
                });
            }

            // todo
            // dev 里重新写一下
            // 1. linemap 省略计算
            // 2. 不要影响其他
            for(var name in nameMap){
                var allPoints = nameMap[name].concat(nullNameMap[name] || []);

                allPoints.forEach(function(point){
                    if(point.series.type === Constants.LINE_MAP){
                        return;
                    }

                    point.points = allPoints;//points参数

                    // @eason:
                    // 1. meaningless nesting loop
                    // 2. this search from end to beginning thoroughly without a break?
                    if(!point.options.drilldown){//设置drilldown
                        for(var i = allPoints.length - 1; i >= 0; i--){
                            if(allPoints[i].options.drilldown){
                                point.options.drilldown = allPoints[i].options.drilldown;
                                point.geo = allPoints[i].geo;
                            }
                        }
                    }

                    point.series.calculateLabelInfo(point);
                });
            }

            this.validPoints = this._getMapPoints();
        },

        //这里要删除的是过滤掉的数据点
        //2.点地图的时候，相同经纬度的只画其中一个(普通图例的时候，气泡图要全部画出来，因为半径不一样)
        //3.没有经纬度，或者feature对应的点,这属于无效数据
        _getMapPoints:function(){
            var vanchart = this;
            var keyMap = {}, validPoints = [];
            var geo = vanchart.getCurrentGeo();
            var isNormalLegend = this.getComponent(ComponentLibrary.LEGEND_COMPONENT);

            vanchart.series.forEach(function(ser, seriesIndex){

                var points = ser.points, type = ser.type;

                if(type === Constants.LINE_MAP ){ 
                    return; 
                } 

                for(var i = 0, len = points.length; i < len; i++){
                    var point = points[i];

                    if(!vanchart.isMapPointVisible(point)){
                        vanchart.removePointGraphics(point);
                        continue;
                    }

                    //第一个系列有drilldown的空数据应该是造出来的
                    if(seriesIndex === 0 && point.isNull && point.options.drilldown){
                        continue;
                    }

                    var features = geo.getFeaturesByName(point.name, type);

                    if(features || point.options.lnglat){

                        var key = type == Constants.AREA_MAP ? point.name : geo.getDataPointLngLat(point, features && features[0]).join('-');

                        if(!keyMap[key] || (isNormalLegend && type == Constants.BUBBLE_CHART)){

                            validPoints.push(point);

                            keyMap[key] = true;
                        }else{
                            vanchart.removePointGraphics(point,type, false); // 这里不要动画
                        }
                    }
                }
            });
            return validPoints;
        },

        isMapPointVisible:function(point){
            var hasRangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

            if(hasRangeLegend && point.points && point.points.length){
                point = point.points[0];
            }

            if(point.isNull){

                //空数据的时候，对于图片类型的点地图，图形是可见的
                //对于areaMap，有drilldown也是可见的
                var type = point.series.type;
                var marker = point.options.marker;
                var isImageMarker = marker && BaseUtils.isImageMarker(marker.symbol);

                var nullVisibility = type == Constants.AREA_MAP ? point.options.drilldown : (type == Constants.POINT_MAP || isImageMarker);

                return point && point.visible && point.series.visible && nullVisibility;
            }

            return point.isVisible();
        },

        initLayerInfo:function(){

            if(this.layerMap){
                //新的options进来的时候调用
                return;
            }

            this.layerMap = []; this.layerIndex = 0;

            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);
            var series = this.series;
            this.layerMap = [{series:series, geo:geo, layerIndex:this.layerIndex, drillUpDataPoint:(series[0] && series[0].points[0])}];

            var drillPath = this.options.initDrillPath;
            if(drillPath && drillPath.length > 1){
                for (var i = 1; i < drillPath.length; i++) {
                    var name = drillPath[i];

                    var point = null;
                    for (var j = 0; j < series.length; j++) {
                        var points = series[j].points;

                        for (var k = 0; k < points.length; k++) {
                            if (points[k].options.drilldown && points[k].options.drilldown.geo.name == name) {
                                point = points[k];
                                break;
                            }
                        }

                        if (point) {
                            break;
                        }
                    }
                    if(point){

                        this._createChildSeriesWhenLoaded(point);

                        this.layerMap[this.layerIndex].drillUpDataPoint = point;

                        this.series = series = point.childSeries;
                        var rangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
                        if(rangeLegend){
                            rangeLegend.initAttributesWithSeries();
                        }

                        series.forEach(function(ser){
                            for(var i = 0, len = ser.points.length; i < len; i++){
                                ser.points[i].refreshPointColor();
                            }
                        });

                        this.layerIndex++;

                        geo = point.geo;

                        this.layerMap[this.layerIndex] = {geo:geo, series:series, layerIndex:this.layerIndex};

                        this.setComponent(geo, ComponentLibrary.GEO_COMPONENT);
                    }
                }
            }
        },

        _createChildSeriesWhenLoaded:function(point){
            if(point.childSeries){
                return;
            }
            var childSeries = [], vanchart = this;
            vanchart.parentPoint = point;

            point.options.drilldown.series.forEach(function(sery, index){
                var classType = sery.type || vanchart.options.chartType;
                var Class = ChartLibrary.get(classType);
                childSeries.push(new Class(sery, vanchart, index));
            });

            point.childSeries = childSeries;
        },

        drillDown:function(dataPoint){
            var lastLayer = this.layerMap[this.layerIndex - 1];
            if(dataPoint.options.drilldown && dataPoint.options.drilldown.series && (!lastLayer || lastLayer.drillUpDataPoint != dataPoint)){

                this._createChildSeriesWhenLoaded(dataPoint);

                this.layerMap[this.layerIndex].drillUpDataPoint = dataPoint;

                this._setNewGeoAndSeries(dataPoint.geo, dataPoint.childSeries, this.layerIndex + 1);
            }
        },

        drillUp:function(iconData){
            var vanchart = this;

            if(iconData.series == vanchart.series){
                return;
            }

            this._setNewGeoAndSeries(iconData.geo, iconData.series, iconData.layerIndex);
        },

        _setNewGeoAndSeries:function(geo, series, newLayerIndex){

            var vanchart = this;

            //先要删除上一层的所有的layer
            for(var i = 0, len = vanchart.series.length; i < len; i++){
                var ser = vanchart.series[i], type = ser.type, points = ser.points;
                points.forEach(function(point){
                    vanchart.removePointGraphics(point, type);
                });
            }
            this._canvasMapLayer && this._canvasMapLayer.setData([]);

            vanchart.series = series;

            var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            series.forEach(function(ser){
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            var lastGeo = this.layerMap[this.layerIndex] ? this.layerMap[this.layerIndex].geo : undefined;

            this.layerMap[newLayerIndex] = {geo:geo, series:series, layerIndex:newLayerIndex, drillUpDataPoint:(series[0] && series[0].points[0])};

            this.layerIndex = newLayerIndex;

            this.layerMap = this.layerMap.slice(0, newLayerIndex + 1);

            lastGeo && lastGeo.remove();

            this.setComponent(geo, ComponentLibrary.GEO_COMPONENT);

            this.layoutComponentsAndCharts()
        },

        cancelLegendHighlight:function(containerPoint){
            var highlightTarget = this.highlightTarget;
            VanChartBaseMap.prototype.cancelLegendHighlight.call(this, containerPoint);
            if (this._lineMapLayer && highlightTarget) {
                this._lineMapLayer.redraw();
            }
        },

        makeLegendHighlight:function(target){
            VanChartBaseMap.prototype.makeLegendHighlight.call(this, target);
            if (this._lineMapLayer) {
                this._lineMapLayer.redraw();
            }
        },

        getEffectLayer:function () {
            var vanchart = this;

            if(!vanchart._effectLayer){
                vanchart._effectLayer = new LayerGroup().addTo(vanchart);
            }

            return vanchart._effectLayer;
        },

        renderSeries:function(){
            this.removeMoreLabel();
            this.animationCount = 0;  // renderSeries即动画开始

            this.getComponent(ComponentLibrary.TOOLTIP_COMPONENT).immediateHide();

            //换一个简单的逻辑实现，先把区块都画一遍，用空值的颜色，再把数据点的样子画出来
            var vanchart = this, series = vanchart.series, geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);

            this._pointLayer = this._pointLayer || new LayerGroup().addTo(this);

            vanchart.seriesOfType(Constants.SCATTER_CHART)
                .concat(vanchart.seriesOfType(Constants.BUBBLE_CHART))
                .forEach(function (ser) {
                    vanchart.activeDataEvents(ser);
                });

            var largeTypes = [Constants.SCATTER_CHART, Constants.BUBBLE_CHART];

            this.largeSeries = largeTypes.reduce(function (obj, type) {
                obj[type] = obj[type] || {visible: true, type: type};
                obj[type].points = [];
                return obj
            }, this.largeSeries || {});

            var largeSeries = this.largeSeries;
            var markerSymbolChanged = this._isMarkerSymbolChanged();

            this.validPoints.forEach(function(point){
                // todo heatMap之前没有validPoints现在要值变化提示，加了validPoints这边又报错
                if(point.series.type == Constants.HEAT_MAP) { 
                    return; 
                }

                var visible = vanchart.isMapPointVisible(point);
                var type = point.series.type;

                // FIXME
                // wow!!!
                // dirty again

                // large mode
                if (point.series.options.large && largeSeries[type]) {
                    if (!visible) { return }
                    // todo series as patch
                    largeSeries[type].points.push(point);

                } else {
                    // normal mode
                    point.graphic && point.graphic.remove();point.graphic = null;//last is large mode
                    if (visible) {

                        var options = point.series.getStyle(point);
                        var features = geo.getFeaturesByName(point.name, type);

                        features = point.options.lnglat ? ['null'] : features;

                        var animate = vanchart.renderer.isAnimation;
                        if (point.layers && point.layers[0]._map) {
                            var reshow = point.series.reShowPoint(point);

                            point.layers.forEach(function (layer, index) {
                                markerSymbolChanged && vanchart._updateLayerMarker(layer, point);  // @BI-GIS地图切换点样式无效

                                layer.setLatLng && layer.setLatLng(point.getLatLng(features[index]));
                                layer.setStyle(options);

                                animate && reshow && layer.initAnimate && layer.initAnimate(point);

                                vanchart.registerInteractiveTarget(point, layer);
                            });
                        } else {
                            point.layers = [];
                            features.forEach(function (feature) {
                                var layer;
                                if (type == Constants.AREA_MAP) {
                                    layer = geo.getLayerByFeature(feature);
                                    layer.setStyle(options);
                                } else {
                                    layer = vanchart.createPointLayer(feature, point, options);
                                }

                                point.layers.push(layer);
                                animate && layer.initAnimate && layer.initAnimate(point);

                                vanchart.registerInteractiveTarget(point, layer);
                            });
                        }

                    } else {
                        vanchart.removePointGraphics(point, type);
                    }
                }
            });

            this._renderHeatMap();

            this._renderLineMap();

            this._renderMapOnCanvas(largeSeries);

            vanchart.updateLabel();


            this.fire('animationStart');


        },

        _onZoom:function(){

            var vanchart = this, hoverPoint = vanchart.hoverPoint, zoomLevel = vanchart.getZoom();

            //检查是否要做自动下钻,如果下钻成功,则直接返回
            if(hoverPoint && hoverPoint.geo){
                var zoomListener = hoverPoint.geo.getZoomListener();
                if(zoomListener && zoomListener <= zoomLevel){
                    vanchart.drillDown(hoverPoint);
                    return ;
                }
            }

            var lastLayer = vanchart.layerMap[vanchart.layerIndex - 1];
            if(lastLayer && lastLayer.geo.getZoomListener() > zoomLevel){
                vanchart.drillUp(lastLayer);
            }
        },

        updateLabel:function(){
            var needShowMoreLabel = this._needShowMoreLabel();
            if(!needShowMoreLabel || this.layerIndex > 0){
                this._updateNormalLabel();
                return;
            }

            var vanchart = this;

            vanchart._updateNormalLabel();

            // renderSeries的时候，地图这时如果正好在animateZoom
            // 那么就导致showMoreLabel计算的位置，和animateZoom结束后不对应，，从而发生数据点与提示位置偏移
            // 这里hack一下，350毫秒后才_updateMoreLabels（250ms内animateZoom就结束了），保证此时点的位置已经是最终的位置
            needShowMoreLabel && this.setTimeout("map_label_timer", function (){
                vanchart._updateMoreLabels();
            }, 350);

            vanchart._changeDataState = false;
        },

        _updateMoreLabels: function () {
            var vanchart = this;

            this.validPoints && this.validPoints
                .filter(function (point) {
                    return point.series.type != Constants.LINE_CHART; 
                })
                .forEach(function(point){
                    var latlng = point.getLatLng();

                    if(vanchart.isMapPointVisible(point) && latlng) {

                        var pixels = vanchart.latLngToLayerPoint(latlng);
                        var y = pixels.y, centerYFun = null;

                        var serType = point.series.type;

                        if(serType == Constants.POINT_MAP){
                            y -= point.options.icon.iconSize[1]/2;
                        }

                        // 区域地图和点地图这边绘制的时候，只取points[0]存在validPoints里面，因此要遍历所有point.points
                        if(serType == Constants.AREA_MAP || serType === Constants.POINT_MAP) {
                            var points = point.points;
                            points.length && points.forEach( function (p){
                                p.series._showMoreLabel(p, pixels.x, y); 
                            }) 
                        } else if(serType != Constants.LINE_MAP) {  // 流向地图不画
                            point.series._showMoreLabel(point, pixels.x, y); 
                        } 
                    }
                });
        },

        _removeNormalLabels: function () {
            var labelPoints = this.validPoints.concat(this._getHeatMapPoints());
            var textG = this._textGroup;

            labelPoints.forEach(function(point){
                if(point.textLayers){
                    point.textLayers.forEach(function(layer){
                        textG.removeLayer(layer);
                    });
                    point.textLayers = null;
                }
            });
        },

        _updateNormalLabel:function(){
            this._fixConflictLabel();

            var vanchart = this, geo = vanchart.getCurrentGeo();
            var labelPoints = this.validPoints.concat(this._getHeatMapPoints());

            this._textGroup = this._textGroup || new LayerGroup().addTo(vanchart);
            var textG = this._textGroup;

            labelPoints.forEach(function(point){

                var type = point.series.type;

                var features = geo.getFeaturesByName(point.name, type);
                features = point.options.lnglat ? ['null'] : features;

                var enabled = point.options.dataLabels && point.options.dataLabels.enabled;

                if(enabled && point.labelPos && point.labelContent && features){

                    features.forEach(function(feature, index){
                        if(point.labelPos[index]){
                            point.textLayers = point.textLayers || [];
                            if(point.textLayers[index]){
                                point.textLayers[index].setStyle(point.getLatLng(feature));
                            }else{
                                point.textLayers[index] = new TextLayer(point.getLatLng(feature),  point).addTo(vanchart._textGroup);
                            }
                        }
                    });

                }else if(point.textLayers){
                    point.textLayers.forEach(function(layer){
                        textG.removeLayer(layer);
                    });
                    point.textLayers = null;
                }
            });
        },

        _fixConflictLabel:function(){
            var vanchart = this, manager = new BoundsManager();
            var geo = vanchart.getCurrentGeo(), labelPoints = this.validPoints.concat(this._getHeatMapPoints());

            labelPoints.forEach(function(point){

                var type = point.series.type;
                point.labelPos = null;

                if(!vanchart.isMapPointVisible(point)){
                    return;
                }

                if((type == Constants.AREA_MAP) && point.labelContent){
                    var features = geo.getFeaturesByName(point.name, type);

                    features.forEach(function(feature, index){
                        point.labelPos = point.labelPos || [];
                        if(feature.properties.center){
                            var labelBounds = vanchart._getTextBounds(point, feature);
                            point.labelPos[index] = labelBounds;
                            manager.addBounds(labelBounds);
                        }else{
                            point.labelPos[index] = null;
                        }
                    });

                    if(point.labelPos && !point.labelPos.filter(function(p){return !!p}).length){
                        point.labelPos = null;
                    }
                }
            });

            labelPoints.forEach(function(point){

                if(point.labelContent && vanchart.isMapPointVisible(point)){
                    var type = point.series.type;
                    var features = geo.getFeaturesByName(point.name, type);
                    features = point.options.lnglat ? ['null'] : features;
                    if(features){
                        features.forEach(function(feature, index){
                            if(!point.labelPos || !point.labelPos[index]){
                                var labelBounds = vanchart._getTextBounds(point, feature);
                                if(!manager.isOverlapped(labelBounds)){
                                    point.labelPos = point.labelPos || [];
                                    point.labelPos[index] = labelBounds;
                                    manager.addBounds(labelBounds);
                                }else{
                                    point.labelPos = point.labelPos || [];
                                    point.labelPos[index] = null;
                                }
                            }

                            if(point.labelPos && !point.labelPos.filter(function(p){return !!p}).length){
                                point.labelPos = null;
                            }
                        });
                    }
                }
            });
        },

        _getTextBounds:function(point, feature){
            var vanchart = this;
            var latlng = point.getLatLng(feature);
            var pixels = vanchart.latLngToContainerPoint(latlng);
            var y = pixels.y, seriesType = point.series.type;
            var marker = point.options.marker, icon = point.options.icon;
            if(seriesType == Constants.AREA_MAP || seriesType == Constants.BUBBLE_CHART || seriesType == Constants.HEAT_MAP){
                y -= point.labelDim.height/2
            }else if(marker && !BaseUtils.isImageMarker(marker.symbol)){
                var radius = marker.radius || 4.5;
                y -= (radius + point.labelDim.height);
            }else{
                var iconHeight = icon ? icon.iconSize[1] : marker.height;
                y -= (iconHeight/2 + point.labelDim.height);
            }
            return BaseUtils.makeBounds([pixels.x, y], point.labelDim);
        },

        createPointLayer:function(feature, point, options){
            var type = point.series.type;
            var latlng = point.getLatLng(feature);

            var layer;

            switch (type){
                case Constants.BUBBLE_CHART:
                    layer = new CircleMarker(latlng, options, point.radius).addTo(this._pointLayer);
                    break;
                case Constants.POINT_MAP:
                    layer = new Marker(latlng, {icon:new Icon(point.options.icon)}).addTo(this._pointLayer);
                    break;
                case Constants.SCATTER_CHART:
                    var marker = point.options.marker;
                    var isImageMarker = BaseUtils.isImageMarker(marker.symbol);
                    if(isImageMarker){
                        options = {icon:new Icon({iconSize: [marker.width, marker.height], iconUrl: marker.symbol})}
                    }

                    layer = isImageMarker ? new Marker(latlng, options) : new ScatterMarker(latlng, options, point.options.marker);
                    layer.addTo(this._pointLayer);
            }

            return layer;
        },

        getCurrentGeo:function(){
            return this.layerMap ? this.layerMap[this.layerMap.length - 1].geo : this.components.geo;
        },

        _getHeatMapPoints:function(){
            var heatMapSeries = this.seriesOfType(Constants.HEAT_MAP);
            var vanchart = this;
            var points = [], geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            if(heatMapSeries && heatMapSeries.length){
                for(var i = 0, len = heatMapSeries.length; i < len; i++){
                    heatMapSeries[i].points.forEach(function(point){
                        if(!point.options.lnglat){
                            var feature = geo.getFeaturesByName(point.name, Constants.HEAT_MAP);
                            point.options.lnglat = geo.getDataPointLngLat(point, feature && feature[0]);
                        }
                        if(!point.isNull && point.visible && point.options.lnglat){
                            points.push(point);
                        }else{
                            vanchart.removePointGraphics(point, Constants.HEAT_MAP);
                        }
                    });
                }
            }
            return points;
        },

        _renderHeatMap:function(){

            var heatMapSeries = this.seriesOfType(Constants.HEAT_MAP);
            var rangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

            if(!heatMapSeries || !heatMapSeries.length || !rangeLegend){
                return;
            }

            var data = {
                'min':rangeLegend._getMin(),
                'max':rangeLegend._getMax(),
                'data':this._getHeatMapPoints()
            };

            var options = heatMapSeries[0].options;
            var config = {
                'maxOpacity':options.maxOpacity,
                'minOpacity':options.minOpacity,
                'radius':options.radius,
                'blur':options.blur,
                'gradient':rangeLegend._getGradient(),
                'valueField':'value'
            };
            if(!this._heatMapOverlay){
                this._heatMapOverlay = new HeatMapOverlay(config).addTo(this);
            } else {
                this._heatMapOverlay._heatmap.configure(config);   // @BI-8870&&BI-8874
            }

            this._heatMapOverlay.setData(data);
        },

        removePointGraphics:function(point, type, animate){
            if(point) {
                type = type || point.series.type;

                var vanchart = this;

                if (type === Constants.LINE_MAP) {
                    this._lineMapLayer.removeEffect(point);
                    point.remove();
                }

                if (point.layers) {
                    point.layers.forEach(function (layer) {
                        vanchart.removeInteractiveTarget(point, layer);
                        // removeLayer等写在exitAnimate.end中了
                        var useFilterRender = vanchart.useFilterRender;
                        layer.exitAnimate && layer.exitAnimate(vanchart, useFilterRender ? !useFilterRender : animate);
                    });
                    if (type != Constants.AREA_MAP) {
                        point.layers = null;
                    }

                    var textG = this._textGroup;
                    if (point.textLayers) {
                        point.textLayers.forEach(function (layer) {
                            textG.removeLayer(layer);
                        });
                        point.textLayers = null;
                        point.labelPos = null;
                    }

                    point.clearPointEffect();
                }
            }
        },

        _renderLineMap: function () {
            var lineMapSeries = this.seriesOfType(Constants.LINE_MAP);

            var data = lineMapSeries.reduce(function (accum, seriesItems) {
                return accum.concat(seriesItems.points);
            }, []);

            if (!lineMapSeries.length || !data.length) {
                this._lineMapLayer && this._lineMapLayer.setData([]);
                return;
            }

            if (!this._lineMapLayer) {
                var vanchart = this;
                var size = this.getSize();
                var options = {
                    width: size.x,
                    height: size.y,
                    x: 0,
                    y: 0,
                    dpr: window.devicePixelRatio || 1
                };
                var mainRenderer = this.mainRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                var animationRenderer = this.animationRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                mainRenderer.onAdd();
                animationRenderer.onAdd();

                this._lineMapLayer = lineMapLayer({
                    mainRenderer: mainRenderer,
                    animationRenderer: animationRenderer,
                    vanchart: vanchart
                }).addTo(this);
            }

            this._lineMapLayer.setData(data);
        },

        _renderMapOnCanvas: function (largeSeries) {

            var data = largeSeries[Constants.SCATTER_CHART].points.concat(
                largeSeries[Constants.BUBBLE_CHART].points
            );

            if (!this._canvasMapLayer) {
                var vanchart = this;
                var size = this.getSize();
                var options = {
                    width: size.x,
                    height: size.y,
                    x: 0,
                    y: 0,
                    dpr: window.devicePixelRatio || 1
                };
                var mainRenderer = this.mapCanvasRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                mainRenderer.onAdd();

                this._canvasMapLayer = new CanvasMapLayer({
                    renderer: mainRenderer,
                    vanchart: vanchart
                }).addTo(this);
            }

            this._canvasMapLayer.setData(data);
        },

        /**
         * 判断marker.symbol是否发生改变
         * @returns {boolean}
         * @private
         */
        _isMarkerSymbolChanged: function (){
            var marker = this.options.plotOptions.marker, symbol = marker && marker.symbol;
            var changed = this._lastMarkerSymbol !== symbol;

            this._lastMarkerSymbol = symbol;
            return changed;
        },

        /**
         * 更新Marker.symbol
         * todo 暂时好像只需要更新一下symbol
         * @private
         */
        _updateLayerMarker: function (layer, point){
            var newMarker = point.options.marker,
                layerMarker = layer._marker;
            if(newMarker && layerMarker && layerMarker.symbol){
                layer._marker.symbol = newMarker.symbol;
                layer._updatePath && layer._updatePath();
            }
        }
    });

    require('./VanChartLibrary').register(Constants.POINT_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.AREA_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.LINE_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.HEAT_MAP, VanChartMap);

    return VanChartMap;
});
/**
 * Created by eason on 2017/2/20.
 */
define('utils/QuadTree',[],function(){

    function d3_geom_pointX(d) {
        return d[0];
    }

    function d3_geom_pointY(d) {
        return d[1];
    }

    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }

    var abs = Math.abs;

    function quadtree(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) {
                        x1_ = d.x;
                    }
                    if (d.y < y1_) {
                        y1_ = d.y;
                    }
                    if (d.x > x2_) {
                        x2_ = d.x;
                    }
                    if (d.y > y2_) {
                        y2_ = d.y;
                    }
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) {
                        x1_ = x_;
                    }
                    if (y_ < y1_) {
                        y1_ = y_;
                    }
                    if (x_ > x2_) {
                        x2_ = x_;
                    }
                    if (y_ > y2_) {
                        y2_ = y_;
                    }
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) {
                y2_ = y1_ + dx;
            } else {
                x2_ = x1_ + dy;
            }
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) {
                    return;
                }
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) {
                    x1 = xm;
                }else {
                    x2 = xm;
                }

                if (below) {
                    y1 = ym;
                }else {
                    y2 = ym;
                }
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else {
                data.forEach(root.add);
            }
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) {
                return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
            }
            if (_ == null) {
                x1 = y1 = x2 = y2 = null;
            } else {
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            }
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) {
                return x1 == null ? null : [ x2 - x1, y2 - y1 ];
            }

            if (_ == null) {
                x1 = y1 = x2 = y2 = null;
            } else {
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            }

            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) {
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            }
            if (children[1]) {
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            }
            if (children[2]) {
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            }
            if (children[3]) {
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
            }
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) {
                return;
            }
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) {
                    switch (i & 3) {
                        case 0:
                            find(node, x1, y1, xm, ym);
                            break;

                        case 1:
                            find(node, xm, y1, x2, ym);
                            break;

                        case 2:
                            find(node, x1, ym, xm, y2);
                            break;

                        case 3:
                            find(node, xm, ym, x2, y2);
                            break;
                    }
                }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }

    return quadtree;
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/ForceLayout',['require','../utils/QuadTree','../utils/Timer','../utils/BaseUtils'],function(require){

    var quadtree = require('../utils/QuadTree');
    var Timer = require('../utils/Timer');
    var BaseUtils = require('../utils/BaseUtils');

    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;

    var forceLayout = function() {
        var force = {}, size = [ 1, 1 ], alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;

        var _scale = 1, _eachTick, _startTick, _endTick, _events, _targets = {};

        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                alpha = 0;
                _endTick && _endTick();
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i] * _scale) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) {
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }

            _eachTick && _eachTick({alpha:alpha});
        };
        force.nodes = function(x) {
            if (!arguments.length) {
                return nodes;
            }
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) {
                return links;
            }
            links = x;
            return force;
        };

        force.eachTick = function(x){
            if (!arguments.length) {
                return _eachTick;
            }
            _eachTick = x;
            return force;
        };

        force.endTick = function (x) {
            if (!arguments.length) {
                return _endTick;
            }
            _endTick = x;
            return force;
        };

        force.size = function(x) {
            if (!arguments.length) {
                return size;
            }
            size = x;
            return force;
        };
        force.scale = function(x) {
            if (!arguments.length) {
                return _scale;
            }
            _scale = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) {
                return linkDistance;
            }
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) {
                return linkStrength;
            }
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) {
                return friction;
            }
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) {
                return charge;
            }
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) {
                return Math.sqrt(chargeDistance2);
            }
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) {
                return gravity;
            }
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) {
                return Math.sqrt(theta2);
            }
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) {
                return alpha;
            }
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                } else {
                    alpha = 0;
                }
            } else if (x > 0) {
                alpha = x;
                Timer(force.tick);
            }
            return force;
        };
        //有集聚动画
        force.start = function() {
            force.preparePara();
            return force.resume();
        };
        //模拟集聚，没有动画
        force.simulateForce = function () {
            force.preparePara();

            force.alpha(0.1);
            while(force.alpha() >= 0.005) {
                force.tick();
            }

            _endTick && _endTick();
            return force;
        };
        //ie下，简单模拟
        force.simpleSimulateForce = function () {
            force.preparePara();

            var start = 0.1, end = 0.005;
            var padding = 2, clusterPadding = 2;
            var paddingAlpha = 0.5;
            var gravity = 0.02;
            var friction = 0.9;

            for(var alpha = start; alpha >= end; alpha -= (alpha > 0.07 ? 0.001 : 0.0005)){

                var n = nodes.length, i, o, k, x, y;

                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) {
                        while (++i < n) {
                            o = nodes[i];
                            o.x += (x - o.x) * k;
                            o.y += (y - o.y) * k;
                        }
                    }
                }
                i = -1;
                while (++i < n) {
                    o = nodes[i];
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }

                nodes.forEach(function(d){
                    //集聚
                    var cluster = d.series.cluster;

                    if (cluster && cluster != d){
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;
                        if (l != r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            cluster.x += x;
                            cluster.y += y;
                        }
                    }});

                for(var i = 0; i < n; i++){
                    var d = nodes[i];

                    for(var j = 0; j < n; j++){
                        var point = nodes[j];

                        if (point !== d) {
                            var x = d.x - point.x,
                                y = d.y - point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + point.radius + (d.series.cluster === point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * paddingAlpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                point.x += x;
                                point.y += y;
                            }
                        }
                    }
                }
            }

            _endTick && _endTick();
            return force;
        };
        force.preparePara = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") {
                    o.source = nodes[o.source];
                }
                if (typeof o.target == "number") {
                    o.target = nodes[o.target];
                }
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) {
                    o.x = position("x", w);
                }
                if (isNaN(o.y)) {
                    o.y = position("y", h);
                }
                if (isNaN(o.px)) {
                    o.px = o.x;
                }
                if (isNaN(o.py)) {
                    o.py = o.y;
                }
            }
            distances = [];
            if (typeof linkDistance === "function") {
                for (i = 0; i < m; ++i){
                    distances[i] = +linkDistance.call(this, links[i], i);
                }
            }else {
                for (i = 0; i < m; ++i){
                    distances[i] = linkDistance;
                }
            }
            strengths = [];
            if (typeof linkStrength === "function") {
                for (i = 0; i < m; ++i) {
                    strengths[i] = +linkStrength.call(this, links[i], i);
                }
            } else {
                for (i = 0; i < m; ++i) {
                    strengths[i] = linkStrength;
                }
            }
            charges = [];
            if (typeof charge === "function") {
                for (i = 0; i < n; ++i) {
                    charges[i] = +charge.call(this, nodes[i], i);
                }
            }else {
                for (i = 0; i < n; ++i) {
                    charges[i] = charge;
                }
            }
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = [];
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l) {
                    if (!isNaN(x = candidates[j][dimension])) {
                        return x;
                    }
                }
                return Math.random() * size;
            }
            return force;
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.registerDragTarget = function(data, elementWrapper){
            if(!_events){
                _events = getEvents();
            }
            _targets[BaseUtils.stamp(elementWrapper.node())] = data;
        };
        force.dragFire = function (ev, container) {
            if(!_events){
                return;
            }

            var srcEvent = ev.srcEvent, type = ev.type || srcEvent.type;
            var isPan = type === 'panstart' || type === 'panmove' || type === 'panend';

            var target;
            if(isPan && force.panTarget){
                target = force.panTarget;
            } else {
                var src = srcEvent.target || srcEvent.srcElement;
                target = findDragTarget(_targets, src, container);
            }

            if(target && _events[type]){
                _events[type](target, force, ev);
                return target;
            }
        };
        return force;
    };

    function findDragTarget(_targets, src, container){
        var target;
        while (src) {
            target = _targets[BaseUtils.stamp(src)];

            if (target) {
                return target;
            }

            if(src === container){
                return null;
            }

            src = src.parentNode;
        }
    }

    function getEvents() {
        return {
            'mouseover':d3_layout_forceMouseover,
            'mouseout':d3_layout_forceMouseout,
            'panstart':d3_layout_forceDragstart,
            'panmove':d3_layout_forceDragmove,
            'panend':d3_layout_forceDragend
        }
    }

    function d3_layout_forceDragmove(d, force, ev) {
        var transX = ev.containerPoint.x - force.currentPoint.x,
            transY = ev.containerPoint.y - force.currentPoint.y;
        force.currentPoint = ev.containerPoint;

        d.px += transX; d.py += transY;
        force.resume();
    }
    function d3_layout_forceDragstart(d, force, ev) {
        d.fixed |= 2;
        force.panTarget = d;
        force.currentPoint = ev.containerPoint;
    }
    function d3_layout_forceDragend(d, force) {
        d.fixed &= ~6;
        force.panTarget = null;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x; d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }

    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) {
                    continue;
                }
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }

    return forceLayout;
});
/**
 * Created by eason on 16/8/29.
 */

define('vans/VanChartForceBubble',['require','./VanChart','./../utils/BaseUtils','./../Constants','./ForceLayout','../utils/QuadTree','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var BaseUtils = require('./../utils/BaseUtils');
    var Constants = require('./../Constants');
    var ForceLayout = require('./ForceLayout');
    var QuadTree = require('../utils/QuadTree');

    var padding = 2, clusterPadding = 4;
    var BUBBLE_UPDATE_TIME = 500;

    var VanChartForceBubble = VanChart.extend({

        vanChartType:'vanChartForceBubble',

        renderSeries:function(){
            VanChart.prototype.renderSeries.call(this);
            var vanchart = this, plotBounds = vanchart.bounds;
            var nodes = this.nodes = []; this.maxRadius = 0;
            var isAnimation = vanchart.renderer.isAnimation;

            vanchart.force && vanchart.force.stop();
            vanchart.force = vanchart.force || ForceLayout();

            this.series.forEach(function(ser){
                var cluster;
                ser.points.forEach(function(point){
                    if(point.isVisible()){
                        // 自动刷新和图例交互都要用之前聚集好的位置，
                        // 初始_posX为undefined,ForceLayout里面会给point.x个随机值0-w
                        point.x = point._posX;
                        point.y = point._posY;
                        if(isAnimation) {
                            vanchart.force.registerDragTarget(point, point.graphic);
                        }
                        nodes.push(point);
                        vanchart.maxRadius = Math.max(vanchart.maxRadius, point.radius);
                        cluster = cluster || point;
                        cluster = point.radius > cluster.radius ? point : cluster;
                    }
                });
                ser.cluster = cluster;
            });

            vanchart.force.nodes(nodes)
                    .size([plotBounds.width, plotBounds.height])
                    .gravity(0.05).charge(0).eachTick(eachTick);

            BaseUtils.isSupportSVG()
                ? (isAnimation ? vanchart.force.start() : vanchart.force.simulateForce())
                : vanchart.force.endTick(_simpleSimulateEnd).simpleSimulateForce();

            function eachTick(e){
                if(vanchart._animationStarted && e.alpha < 0.05){
                    VanChart.prototype._animationEnd.bind(vanchart)();
                }
                var clusterFuc = cluster(10 * e.alpha * e.alpha);
                var collideFuc = collide(0.5, nodes, vanchart.maxRadius);

                nodes.forEach(function(point){
                    clusterFuc(point);
                });

                nodes.forEach(function(point){
                    collideFuc(point);
                });

                vanchart._updateGraphics();
            }

            function _simpleSimulateEnd() {
                vanchart._updateGraphics();
                VanChart.prototype._animationEnd.bind(vanchart)();
            }
        },

        _updateGraphics: function() {
            var vanchart = this;
            vanchart.nodes && vanchart.nodes.forEach(function (point) {
                point._posX = point.x;
                point._posY = point.y;

                vanchart._calculateLabelPos(point);

                //这边不能create。因为自动刷新init渲染过程中不能有标签
                point.textGraphic && point.textGraphic
                    .interrupt(Constants.SELECT_ANIMATION)
                    .attr('transform', BaseUtils.makeTranslate(point.series._labelTrans(point)));

                point.graphic.attr(point.series.getPointUpdateAnimationAttr(point));
            })
        },

        _animationEnd:function() {

        },

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, plotBounds = vanchart.bounds;

            vanchart.force && vanchart.force.stop();

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            vanchart.nodes.forEach(function(node){

                node.radius *= scale;

                var x = node.x + shiftX;
                var y = node.y + shiftY;

                x -= plotBounds.width/2;
                y -= plotBounds.height/2;

                node.x = x * scale + plotBounds.width/2 - shiftX;
                node.y = y * scale + plotBounds.height/2 - shiftY;

                vanchart._calculateLabelPos(node);
                vanchart._updatePointTextGraphic(node);

                var series = node.series, attrs = series.getPointUpdateAnimationAttr(node);

                node.graphic.animate({
                    duration:BUBBLE_UPDATE_TIME,
                    ease:'back-out',
                    attr: attrs
                });

            });

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        refreshRestore:function(){
            this.scale = 1;
            this.update();
        },

        _calculateLabelPos:function(node){
            if(node.labelContent && node.labelDim){
                var radius = node.radius;
                if((node.labelDim.width > 2 * radius) || (node.labelDim.height > 2 * radius)){
                    node.labelPos = null;
                }else{
                    node.labelPos = {
                        x:-node.labelDim.width/2 + node.x,
                        y:-node.labelDim.height/2 + node.y
                    }
                }
            }
        },

        orderData:function(){

        },

        _updatePointTextGraphic:function(point){
            if(point.textGraphic){
                if(point.labelPos){
                    point.textGraphic.attr('transform', BaseUtils.makeTranslate(point.series._labelTrans(point)));
                }else{
                    point.textGraphic.remove();
                    point.textGraphic = null;
                }
            }else{
                point.series._createTextGraphic(point);
            }
        }
    });

    // Move d to be adjacent to the cluster node.
    function cluster(alpha) {
        return function(d) {
            var cluster = d.series.cluster;
            if (!cluster || cluster === d) {return;}
            var x = d.x - cluster.x,
                y = d.y - cluster.y,
                l = Math.sqrt(x * x + y * y),
                r = d.radius + cluster.radius;
            if (l != r && l) {
                l = (l - r) / l * alpha;
                d.x -= x *= l;
                d.y -= y *= l;
                cluster.x += x;
                cluster.y += y;
            }
        };
    }

    // Resolves collisions between d and all other circles.
    function collide(alpha, nodes, maxRadius) {
        var quadtree = QuadTree(nodes);
        return function(d) {
            var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
            quadtree.visit(function(quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== d)) {
                    var x = d.x - quad.point.x,
                        y = d.y - quad.point.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + quad.point.radius + (d.series.cluster === quad.point.series.cluster ? padding : clusterPadding);
                    if (l < r && l) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        quad.point.x += x;
                        quad.point.y += y;
                    }
                }
                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            });
        };
    }

    require('./VanChartLibrary').register(Constants.FORCE_BUBBLE_CHART, VanChartForceBubble);
    return VanChartForceBubble;
});
/**
 * Created by eason on 2017/2/14.
 */
define('utils/Scale',['require','./BaseUtils','./Interpolator','./vMap'],function(require){

    var BaseUtils = require('./BaseUtils');

    var Interpolator = require('./Interpolator');
    var vMap = require('./vMap');

    function scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }

    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }

    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }

    function bisect(a, x, lo, hi) {
        if (arguments.length < 3) {
            lo = 0;
        }
        if (arguments.length < 4) {
            hi = a.length;
        }
        while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (d3_ascending(a[mid], x) > 0){
                hi = mid;
            }else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function d3_scale_linearRebind(scale, linear) {
        return BaseUtils.rebind(scale, linear, "range", "rangeRound", "interpolate");
    }

    function d3_scale_linear(domain, range, interpolate, uninterpolate) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            return rescale();
        };

        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(Interpolator.interpolateRound);
        };

        scale.interpolate = function(x) {
            if (!arguments.length) {
                return interpolate;
            }
            interpolate = x;
            return rescale();
        };

        scale.uninterpolate = function(x) {
            if (!arguments.length) {
                return uninterpolate;
            }
            uninterpolate = x;
            return rescale();
        };

        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, uninterpolate);
        };
        return rescale();
    }

    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) {
                return base;
            }
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }

    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            var range = [], length = domain.length;
            for(var i = 0; i < length; i++){
                range.push(start + step * i);
            }
            return range;
        }
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            domain = [];
            index = new vMap();
            var i = -1, n = x.length, xi;
            while (++i < n) {
                if (!index.has(xi = x[i])) {
                    index.set(xi, domain.push(xi));
                }
            }
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2,
                0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2),
                0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            if (arguments.length < 3) {
                outerPadding = padding;
            }
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse){
                range.reverse();
            }
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            if (arguments.length < 3) {
                outerPadding = padding;
            }
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) {
                range.reverse();
            }
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }

    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) {
                return [ x0, x1 ];
            }
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [ y, y + 1 / kx ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }

    function linear() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], Interpolator.interpolateNumber, Interpolator.uninterpolateNumber);
    }

    function log() {
        return d3_scale_log(linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    }

    function quantize() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    }

    function ordinal(){
        return d3_scale_ordinal([], {t: "range", a: [ [] ]});
    }

    return {
        linear:linear,
        quantize:quantize,
        log:log,
        quantize:quantize,
        ordinal:ordinal
    };
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/CloudLayout',['require','./../utils/BaseUtils'],function(require){
    var BaseUtils = require('./../utils/BaseUtils');

    var cloudRadians = Math.PI / 180,
        cw = 1 << 11 >> 5,
        ch = 1 << 11;

    return function() {

        var size = [256, 256],
            text = cloudText,
            font = cloudFont,
            fontSize = cloudFontSize,
            fontStyle = cloudFontNormal,
            fontWeight = cloudFontNormal,
            rotate = cloudRotate,
            padding = cloudPadding,
            spiral = archimedeanSpiral,
            path = null,
            simpleLayout = !BaseUtils.isSupportSVG(),
            renderFun = null,
            words = [],
            timeInterval = Infinity,
            timer = null,
            random = Math.random,
            cloud = {},
            canvas = cloudCanvas;

        cloud.canvas = function(_) {
            return arguments.length ? (canvas = functor(_), cloud) : canvas;
        };

        cloud.start = function() {
            var contextAndRatio = getContext(canvas()),
                board = imageShape() ? imageDataArray(contextAndRatio, stepInterval)
                    : (simpleLayout ? [] :zeroArray((size[0] >> 5) * size[1])),
                bounds = null,
                n = words.length,
                i = -1,
                tags = [],
                data = words.map(function(d, i) {
                    d.text = text.call(this, d, i);
                    d.font = font.call(this, d, i);
                    d.style = fontStyle.call(this, d, i);
                    d.weight = fontWeight.call(this, d, i);
                    d.rotate = rotate.call(this, d, i);
                    d.size = ~~fontSize.call(this, d, i);
                    d.padding = padding.call(this, d, i);
                    return d;
                }).sort(function(a, b) { return b.size - a.size; });

            if(!imageShape()) {
                stepInterval();
            }

            function stepInterval(temp){
                if(simpleLayout){
                    simpleStep(temp)
                } else {

                    if (timer) {
                        clearInterval(timer);
                    }
                    timer = setInterval(step, 0);
                    step(temp);
                }
            }


            return cloud;

            function step(temp) {
                board = temp ? temp : board;
                var start = Date.now();
                while (Date.now() - start < timeInterval && ++i < n && timer) {
                    var d = data[i];
                    d.x = (size[0] * (random() + .5)) >> 1;
                    d.y = (size[1] * (random() + .5)) >> 1;
                    cloudSprite(contextAndRatio, d, data, i, simpleLayout);

                    function oncePlace() {
                        if (d.hasText && place(board, d, bounds)) {
                            tags.push(d);
                            if (bounds) {cloudBounds(bounds, d);}
                            else {bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];}
                            // Temporary hack
                            d.x -= size[0] >> 1;
                            d.y -= size[1] >> 1;
                            return true;
                        }
                        return false;
                    }

                    if(!oncePlace()){//没找到放得下的地方再找一次
                        oncePlace();
                    }
                }
                if (i >= n) {
                    cloud.stop();
                    renderFun(tags);
                }
            }

            //ie8 simpleLayout
            function simpleStep(temp) {
                while (++i < n) {
                    var d = data[i];
                    d.x = (size[0] * (random() + .5)) >> 1;
                    d.y = (size[1] * (random() + .5)) >> 1;

                    var dim = BaseUtils.getTextDimension(d.text, {'fontSize':d.size + 'px', 'fontFamily':d.fontFamily}, false);
                    d.height = dim.height;
                    d.y0 = -d.height >> 1;
                    d.y1 = -d.y0;
                    d.width = dim.width;
                    d.x0 = -d.width >> 1;
                    d.x1 = -d.x0;
                    if (place(board, d, bounds)) {
                        tags.push(d);
                        if (bounds) {
                            bounds.push({x:d.x, y:d.y, x0:d.x0, y0:d.y0, x1:d.x1, y1:d.y1});
                        } else {
                            bounds = [{x:d.x, y:d.y, x0:d.x0, y0:d.y0, x1:d.x1, y1:d.y1}];
                        }
                        d.x -= size[0] >> 1;
                        d.y -= size[1] >> 1;
                        d.x -= d.width >> 1;
                        d.y -= d.height >> 1;
                    }
                }
                if (i >= n) {
                    cloud.stop();
                    renderFun(tags);
                }
            }
        };

        cloud.stop = function() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
            return cloud;
        };

        function imageShape() {
            return path && !simpleLayout;
        }

        function imageDataArray(contextAndRatio, complete) {

            var c = contextAndRatio.context,
                ratio = contextAndRatio.ratio;

            var width = (size[0] >> 5)/ratio, height = size[1]/ratio;
            c.clearRect(0, 0, width, height);

            var img = new Image();
            img.onload = function(){
                c.drawImage(img, 0, 0, width, height);
                var data = c.getImageData(0, 0, width, height).data;

                c.clearRect(0, 0, width, height);

                var len = data.length, board = [];
                for(var i = 0; i < len; i+=4){
                    board[i/4] = data[i+3] ? 0 : 1;
                }

                complete(board);

            };

            //先给src会导致onload不会执行，比如图片缓存，或者是js由于某些原因被阻塞
            img.src = path;
        }

        function getContext(canvas) {
            canvas.width = canvas.height = 1;

            var context = canvas.getContext("2d");

            var ratio = simpleLayout ? 1 : Math.sqrt(context.getImageData(0, 0, 1, 1).data.length >> 2);
            canvas.width = (cw << 5) / ratio;
            canvas.height = ch / ratio;

            context.fillStyle = context.strokeStyle = "red";
            context.textAlign = "center";

            return {context: context, ratio: ratio};
        }

        function collideRectsArray(a, array) {
            var minx_a = a.x + a.x0, maxx_a = a.x + a.x1, miny_a = a.y + a.y0, maxy_a = a.y + a.y1;
            for(var i = 0,len = array.length;i<len;i++){
                var b = array[i];
                var minx_b = b.x + b.x0, maxx_b = b.x + b.x1, miny_b = b.y + b.y0, maxy_b = b.y + b.y1;
                var minx = Math.max(minx_a, minx_b),
                    maxx = Math.min(maxx_a, maxx_b),
                    miny = Math.max(miny_a, miny_b),
                    maxy = Math.min(maxy_a, maxy_b);
                if(minx < maxx && miny < maxy){
                    return true;
                }
            }

            return false;
        }

        function place(board, tag, bounds) {
            var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
                startX = tag.x,
                startY = tag.y,
                maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
                s = spiral(size),
                dt = random() < .5 ? 1 : -1,
                t = -dt,
                dxdy,
                dx,
                dy;

            while (dxdy = s(t += dt)) {
                dx = ~~dxdy[0];
                dy = ~~dxdy[1];

                if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) {break;}

                tag.x = startX + dx;
                tag.y = startY + dy;

                if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
                    tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) {continue;}

                if(simpleLayout){
                    if(!bounds || !collideRectsArray(tag, bounds)){
                        return true;
                    }
                }
                // TODO only check for collisions within current bounds.
                //有图形的时候第一个词也要判断是否在里面cloudCollide
                else if ((!bounds && !path) || !cloudCollide(tag, board, size[0])) {
                    if (!bounds || collideRects(tag, bounds)) {
                        var sprite = tag.sprite,
                            w = tag.width >> 5,
                            sw = size[0] >> 5,
                            lx = tag.x - (w << 4),
                            sx = lx & 0x7f,
                            msx = 32 - sx,
                            h = tag.y1 - tag.y0,
                            x = (tag.y + tag.y0) * sw + (lx >> 5),
                            last;
                        for (var j = 0; j < h; j++) {
                            last = 0;
                            for (var i = 0; i <= w; i++) {
                                board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                            }
                            x += sw;
                        }
                        delete tag.sprite;
                        return true;
                    }
                }
            }
            return false;
        }

        cloud.timeInterval = function(_) {
            return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
        };

        cloud.words = function(_) {
            return arguments.length ? (words = _, cloud) : words;
        };

        cloud.path = function (_) {
            return arguments.length ? (path = _, cloud) : path;
        };

        cloud.renderFun = function (_) {
            return arguments.length ? (renderFun = _, cloud) : renderFun;
        };

        cloud.size = function(_) {
            return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
        };

        cloud.font = function(_) {
            return arguments.length ? (font = functor(_), cloud) : font;
        };

        cloud.fontStyle = function(_) {
            return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
        };

        cloud.fontWeight = function(_) {
            return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
        };

        cloud.rotate = function(_) {
            return arguments.length ? (rotate = functor(_), cloud) : rotate;
        };

        cloud.text = function(_) {
            return arguments.length ? (text = functor(_), cloud) : text;
        };

        cloud.spiral = function(_) {
            return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
        };

        cloud.fontSize = function(_) {
            return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
        };

        cloud.padding = function(_) {
            return arguments.length ? (padding = functor(_), cloud) : padding;
        };

        cloud.random = function(_) {
            return arguments.length ? (random = _, cloud) : random;
        };

        return cloud;
    };

    function cloudText(d) {
        return d.text;
    }

    function cloudFont() {
        return "serif";
    }

    function cloudFontNormal() {
        return "normal";
    }

    function cloudFontSize(d) {
        return Math.sqrt(d.value);
    }

    function cloudRotate() {
        return (~~(Math.random() * 6) - 3) * 30;
    }

    function cloudPadding() {
        return 1;
    }

// Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.
    function cloudSprite(contextAndRatio, d, data, di, simpleLayout) {
        if (d.sprite) {return;}
        var c = contextAndRatio.context,
            ratio = contextAndRatio.ratio;

        c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
        var x = 0,
            y = 0,
            maxh = 0,
            n = data.length;
        --di;
        while (++di < n) {
            d = data[di];
            c.save();
            c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
            var w = c.measureText(d.text + "m").width * ratio,
                h = d.size << 1;
            if (d.rotate) {
                var sr = Math.sin(d.rotate * cloudRadians),
                    cr = Math.cos(d.rotate * cloudRadians),
                    wcr = w * cr,
                    wsr = w * sr,
                    hcr = h * cr,
                    hsr = h * sr;
                w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
                h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
            } else {
                w = (w + 0x1f) >> 5 << 5;
            }
            if (h > maxh) {maxh = h;}
            if (x + w >= (cw << 5)) {
                x = 0;
                y += maxh;
                maxh = 0;
            }
            if (y + h >= ch && !simpleLayout) {break;}
            c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
            if (d.rotate) {c.rotate(d.rotate * cloudRadians);}
            c.fillText(d.text, 0, 0);
            if (d.padding && !simpleLayout) {c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);}
            c.restore();
            d.width = w;
            d.height = h;
            d.xoff = x;
            d.yoff = y;
            d.x1 = w >> 1;
            d.y1 = h >> 1;
            d.x0 = -d.x1;
            d.y0 = -d.y1;
            d.hasText = true;
            x += w;
        }
        if(simpleLayout){return}
        var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
            sprite = [];
        while (--di >= 0) {
            d = data[di];
            if (!d.hasText) {continue;}
            var w = d.width,
                w32 = w >> 5,
                h = d.y1 - d.y0;
            // Zero the buffer
            for (var i = 0; i < h * w32; i++) {sprite[i] = 0;}
            x = d.xoff;
            if (x == null) {return;}
            y = d.yoff;
            var seen = 0,
                seenRow = -1;
            for (var j = 0; j < h; j++) {
                for (var i = 0; i < w; i++) {
                    var k = w32 * j + (i >> 5),
                        m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
                    sprite[k] |= m;
                    seen |= m;
                }
                if (seen) {seenRow = j;}
                else {
                    d.y0++;
                    h--;
                    j--;
                    y++;
                }
            }
            d.y1 = d.y0 + seenRow;
            d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
        }
    }

// Use mask-based collision detection.
    function cloudCollide(tag, board, sw) {
        sw >>= 5;
        var sprite = tag.sprite,
            w = tag.width >> 5,
            lx = tag.x - (w << 4),
            sx = lx & 0x7f,
            msx = 32 - sx,
            h = tag.y1 - tag.y0,
            x = (tag.y + tag.y0) * sw + (lx >> 5),
            last;
        for (var j = 0; j < h; j++) {
            last = 0;
            for (var i = 0; i <= w; i++) {
                if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
                    & board[x + i]) {return true;}
            }
            x += sw;
        }
        return false;
    }

    function cloudBounds(bounds, d) {
        var b0 = bounds[0],
            b1 = bounds[1];
        if (d.x + d.x0 < b0.x) {b0.x = d.x + d.x0;}
        if (d.y + d.y0 < b0.y) {b0.y = d.y + d.y0;}
        if (d.x + d.x1 > b1.x) {b1.x = d.x + d.x1;}
        if (d.y + d.y1 > b1.y) {b1.y = d.y + d.y1;}
    }

    function collideRects(a, b) {
        return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
    }

    function archimedeanSpiral(size) {
        var e = size[0] / size[1];
        return function(t) {
            return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
        };
    }

    function rectangularSpiral(size) {
        var dy = 4,
            dx = dy * size[0] / size[1],
            x = 0,
            y = 0;
        return function(t) {
            var sign = t < 0 ? -1 : 1;
            // See triangular numbers: T_n = n * (n + 1) / 2.
            switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
                case 0:  x += dx; break;
                case 1:  y += dy; break;
                case 2:  x -= dx; break;
                default: y -= dy; break;
            }
            return [x, y];
        };
    }

// TODO reuse arrays?
    function zeroArray(n) {
        var a = [],
            i = -1;
        while (++i < n) {a[i] = 0;}
        return a;
    }

    function cloudCanvas() {
        var canvas = document.createElement(window.VAN_CANVAS);

        window.VanCanvasManager && VanCanvasManager.initElement(canvas);

        return canvas;
    }

    function functor(d) {
        return typeof d === "function" ? d : function() { return d; };
    }

    var spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
    };
});
/**
 * Created by Mitisky on 16/11/30.
 */

define('vans/VanChartWordCloud',['require','./VanChart','./../Constants','./../utils/BaseUtils','../utils/Scale','./CloudLayout','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var Constants = require('./../Constants');
    var BaseUtils = require('./../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var CloudLayout = require('./CloudLayout');

    var SHOW_TIME = 800;//所有词依次出现总时间

    var VanChartWordCloud = VanChart.extend({

        vanChartType:'vanChartWordCloud',

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, series = vanchart.series;

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            series.forEach(function(ser){
                ser.points.forEach(function(point){

                    if(point.word){

                        var x = point.word.x, y = point.word.y;

                        point.word.x = (x + shiftX) * scale  - shiftX;
                        point.word.y = (y + shiftY) * scale - shiftY;
                        point.word.size *= scale;

                        ser._drawUpdatePoints(point);
                    }
                });

            });

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        _getTranslate:function(){
            var plotBounds = this.bounds;
            return[plotBounds.x + plotBounds.width / 2, plotBounds.y + plotBounds.height / 2];
        },

        _animationStart:function () { 
            this._animationStarted = true; 
            this.animationCount = 0; 
 
            this.removeMoreLabel(); 
        }, 

        renderSeries:function(){

            this.fire('animationStart');

            var vanchart = this, renderer = vanchart.renderer, plotOptions = vanchart.options.plotOptions;
            var bounds = vanchart.bounds, width = bounds.width, height = bounds.height;
            var minR = plotOptions.minRotation, maxR = plotOptions.maxRotation;
            var fontFamily = plotOptions.fontFamily, minFontSize = plotOptions.minFontSize, maxFontSize = plotOptions.maxFontSize;

            var allPoints = vanchart.pointsOfType(Constants.WORD_CLOUD_CHART)
                .filter(function (p) {return !p.isNull;})
                .sort(function (pointA, pointB) {return Math.abs(pointB.value) - Math.abs(pointA.value);});

            if(allPoints.length === 0){
                return;
            }

            minFontSize = BaseUtils.hasDefined(minFontSize) ? minFontSize : 10;
            maxFontSize = BaseUtils.hasDefined(maxFontSize) ? maxFontSize : vanchart._calculateNiceMaxFontSize(width, height, allPoints[0].name, fontFamily);
            vanchart.minFontSize = Math.min(parseFloat(minFontSize), parseFloat(maxFontSize));
            vanchart.maxFontSize = Math.max(parseFloat(minFontSize), parseFloat(maxFontSize));

            var sizeScale = Scale.linear()
                .domain([Math.abs(allPoints[allPoints.length - 1].value), Math.abs(allPoints[0].value)]).range([vanchart.minFontSize, vanchart.maxFontSize]);

            var layout = CloudLayout()
                .size([width, height])
                .words(
                    allPoints.filter(function (p) {return p.visible;}).map(function(p) {
                    var word = {text: p.name, size: sizeScale(Math.abs(p.value)) * vanchart.scale, point: p, fontFamily: fontFamily};
                    p.word = word;
                    return word;
                }))
                .path(plotOptions.path)
                .padding(5)
                .rotate(function() { return minR + Math.random() * (maxR - minR); })
                .font(fontFamily)
                .fontSize(function(p) { return p.size; })
                .renderFun(draw);

            layout.start();

            function draw(words) {

                if(!vanchart.group){
                    vanchart.group = renderer.group().addTo(vanchart.clipSeriesGroup);
                }
                vanchart.group.attr('transform', BaseUtils.makeTranslate(vanchart._getTranslate()));

                var series = vanchart.seriesOfType(Constants.WORD_CLOUD_CHART);
                if(series && series.length){
                    var ser = series[0];

                    vanchart.registerInteractiveTarget(ser, vanchart.group);

                    ser._removeDataLabels();

                    var each = SHOW_TIME/parseFloat(words.length), delayTime = 0;
                    allPoints.forEach(function (point) {
                        var word = point.word;
                        if(words.indexOf(word) != -1){
                            point.delayTime = delayTime;
                            delayTime += each;
                        }
                        if(word) {//visible==false的时候没有word
                            point.labelDim = BaseUtils.getTextDimension(word.text, {
                                'fontSize': word.size + 'px',
                                'fontFamily': word.fontFamily
                            }, false);
                        }
                        ser.drawPoint(point);
                    });

                    vanchart.setTimeout('effect', function(){
                        allPoints.forEach(function (point) {
                            ser.drawPointEffect(point);
                        });
                    }, 800);
                }
                window.console && console.log('done');
            }
        },

        _consoleDone:function () {
        },

        _calculateNiceMaxFontSize: function (width, height, text, fontFamily) {
            var range = {'min':0, 'max':100}, validInterval = function () {return (range.max - range.min) > 2;};
            var style = {'fontSize':range.max + 'px', 'fontFamily': fontFamily};
            var maxDim = BaseUtils.getTextDimension(text, style, false);

            while(validInterval() && (maxDim.width > width || maxDim.height > height)){

                var middle = Math.ceil(range.min + (range.max - range.min)/2);//二分法
                style.fontSize = middle + 'px';
                var middleDim = BaseUtils.getTextDimension(text, style, false);
                if(middleDim.width > width || middleDim.height > height){
                    range.max = middle;
                    maxDim = middleDim;
                } else {
                    range.min = middle;
                }
            }

            return validInterval() ? range.max : range.min;
        }

    });

    require('./VanChartLibrary').register(Constants.WORD_CLOUD_CHART, VanChartWordCloud);

    return VanChartWordCloud;
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/TreeMapLayout',['require','../utils/BaseUtils'],function(require){
    var BaseUtils = require('../utils/BaseUtils');

    var hierarchyLayout = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [ root ], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value) {
                        node.value = 0;
                    }
                    node.children = childs;
                } else {
                    if (value) {
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    }
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) {
                    childs.sort(sort);
                }
                if (value && (parent = node.parent)) {
                    parent.value += node.value;
                }
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) {
                return sort;
            }
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) {
                return children;
            }
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) {
                return value;
            }
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) {
                        node.value = 0;
                    }
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) {
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    }
                    if (parent = node.parent) {
                        parent.value += node.value;
                    }
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        BaseUtils.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [ node ];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0) {
                    nodes.push(children[n]);
                }
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [ node ], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n) {
                    nodes.push(children[i]);
                }
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    
    var treeLayout = function() {
        var hierarchy = hierarchyLayout().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) {
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            } else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) {
                        left = node;
                    }
                    if (node.x > right.x) {
                        right = node;
                    }
                    if (node.depth > bottom.depth) {
                        bottom = node;
                    }
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [ root0 ]
            }, queue = [ root1 ], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) {
                return separation;
            }
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) {
                return nodeSize ? null : size;
            }
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) {
                return nodeSize ? size : null;
            }
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    var treemapLayout = function() {
        var hierarchy = hierarchyLayout(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) {
                    continue;
                }
                if (r < rmin) {
                    rmin = r;
                }
                if (r > rmax) {
                    rmax = r;
                }
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) {
                    v = rect.dy;
                }
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) {
                    v = rect.dx;
                }
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies) {
                hierarchy.revalue(root);
            }
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) {
                stickies = nodes;
            }
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) {
                return size;
            }
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) {
                return padding;
            }
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ],
                padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) {
                return round != Number;
            }
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) {
                return sticky;
            }
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) {
                return ratio;
            }
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length){
                return mode;
            }
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }

    return{
        treeLayout: treeLayout,
        treemapLayout: treemapLayout
    }
});
/**
 * Created by Mitisky on 16/8/10.
 */
define('dom/EventObject',['require','../dom/Evented'],function(require){

    var Evented = require('../dom/Evented');

    var EventObject = Evented.extend({

        initialize: function (events) {
            this.events = events;
        },

        getEvents: function () {
            return this.events
        }
    });

    return EventObject;
});

/**
 * Created by shine on 2017/1/10.
 */
define('vans/VanChartStructure',['require','./VanChart','./../Constants','./../utils/BaseUtils','./../utils/BezierEasing','./../utils/BoundsManager','./TreeMapLayout','./ForceLayout','../utils/Scale','../utils/PathGenerator','../dom/EventObject','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var Constants = require('./../Constants');
    var BaseUtils = require('./../utils/BaseUtils');
    var BezierEasing = require('./../utils/BezierEasing');
    var BoundsManager = require('./../utils/BoundsManager');
    var TreeLayout = require('./TreeMapLayout').treeLayout;
    var ForceLayout = require('./ForceLayout');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    var EventObject = require('../dom/EventObject');

    var LINK_TIME = 1200;
    var NODE_TIME = 300;
    var UPDATE_TIME = 500;
    var LINK_EASE = BezierEasing.css['ease-in-quad'];
    var NODE_EASE = BezierEasing.css['swing'];

    var LABEL_GAP = 2;

    function nodeRadius(node, maxLevel) {
        return node.radius = node.options.radius ? node.options.radius : (9 + (maxLevel - node.level) * 3)/2;
    }

    function forceDelayTimeArray(maxLevel) {
        if(maxLevel === 0){
            return [0];
        }
        var array = [], level = 0, temp = 0, length = 2 - Math.pow(2, -(maxLevel - 1));
        while (level <= maxLevel){
            array[level] = LINK_TIME * BezierEasing.calculateQuadInT(temp/length);
            temp += Math.pow(2, -level);
            level++;
        }
        return array;
    }

    function treeDelayTimeArray(maxLevel) {
        if(maxLevel === 0){
            return [0];
        }
        var array = [], level = 0;
        while (level <= maxLevel){
            array[level] = LINK_TIME * BezierEasing.calculateQuadInT(level/maxLevel);
            level++;
        }
        return array;
    }

    function strokeWidth(edge, maxLevel) {
        return maxLevel - edge.source.level;
    }

    var VanChartStructure =  VanChart.extend({

        vanChartType:'vanChartStructure',

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, plotBounds = vanchart.bounds,
                isHorizontal = vanchart._horizontalLayout(),
                isRadial = vanchart._radialLayout();

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            vanchart.nodes.forEach(function(node){

                var x = node.posX + shiftX;
                var y = node.posY + shiftY;

                x -= plotBounds.width/2;
                y -= plotBounds.height/2;

                node.posX = x * scale + plotBounds.width/2 - shiftX;
                node.posY = y * scale + plotBounds.height/2 - shiftY;
                node.x = isHorizontal ? node.posY : node.posX;
                node.y = isHorizontal ? node.posX : node.posY;
                node.radius *= scale;

                node.labelPos = vanchart._labelPos(node);

                var nodeAttrs = vanchart._nodeAttrs(node),
                    textAttrs = {transform:BaseUtils.makeTranslate(node.labelPos)};

                var trans = 'translate('+ node.posX +','+ node.posY +')';

                node.graphic.animate({
                    duration:UPDATE_TIME,
                    attr:{'transform':trans}
                });

                node.graphic.nodeGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:nodeAttrs
                });

                node.textGraphic && node.textGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:textAttrs
                })
            });

            vanchart.edges.forEach(function (edge) {
                var edgeAttrs = isRadial ? vanchart._forceLinkAttrs(edge) : {d:vanchart._treeLinkPath(edge)};
                edge.linkGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:edgeAttrs
                });
            });

            if(vanchart._forceDragEnabled()) {
                vanchart.force.scale(scale);
            }

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        renderSeries:function(){
            this.fire('animationStart');

            var vanchart = this, renderer = vanchart.renderer, plotBounds = vanchart.bounds;
            var series = vanchart.seriesOfType(Constants.STRUCTURE_CHART);

            if(!(vanchart.nodes && series && series.length)){
                return;
            }

            vanchart.layout = vanchart.options.plotOptions.layout;
            vanchart.animation = vanchart.options.plotOptions.animation;
            vanchart.lineWidth = vanchart.options.plotOptions.lineWidth;
            if(BaseUtils.hasNotDefined(vanchart.lineWidth)){
                vanchart.lineWidth = null;
            }

            if(!vanchart.linkGroup){
                vanchart.linkGroup = renderer.group().addTo(vanchart.clipSeriesGroup);
                vanchart.nodeGroup = renderer.group().addTo(vanchart.clipSeriesGroup);
            }

            vanchart.linkGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            vanchart.nodeGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            vanchart.groupTrans = null;
            vanchart.registerInteractiveTarget(series[0], vanchart.linkGroup);

            if(vanchart._radialLayout()) {
                vanchart._forceRenderer();
            } else {
                vanchart._treeRenderer();
            }

            if (!this.animationCount) {
                this.fire('animationEnd');
            }
        },

        _animationStart:function(){
            //锁住fire的'animationEnd'
            this._animationStarted = true;
            this.animationCount = 0;

            this.removeMoreLabel();

            this.series.forEach(function(ser){
                ser._removeDataLabels();
            });
        },

        _forceDragEnabled:function () {
            return this.animation && this._radialLayout() && this.options.plotOptions.force;
        },

        _treeDragEnabled:function () {
            return this.animation && !this._radialLayout() && this.options.plotOptions.force;
        },

        _verticalLayout:function () {
            return this.layout === 'vertical';
        },

        _horizontalLayout:function () {
            return this.layout === 'horizontal';
        },

        _radialLayout:function () {
            return this.layout === 'radial';
        },

        _validPosition:function (pos, minGap, maxGap, max) {
            return Math.min(max - maxGap, Math.max(pos, minGap));
        },

        _forceRenderer:function () {
            var vanchart = this, plotBounds = vanchart.bounds;

            var nodes = vanchart.nodes, edges = vanchart.edges, maxLevel = vanchart.maxLevel;

            var maxLength = Math.min(plotBounds.width, plotBounds.height)/4;
            function linkDistance(edge) {
                return maxLength * Math.pow(2, -edge.source.level);
            }

            var centerX = plotBounds.width/2, centerY = plotBounds.height/2;
            function initTick() {
                tick(true);
            }

            function tick(init) {
                //init决定根是否在中心位置
                var diffX = init ? vanchart.ancestor.x - centerX : 0, diffY = init ? vanchart.ancestor.y - centerY : 0;
                nodes.forEach(function (node) {
                    node.x -= diffX; node.y -= diffY;
                    node.labelPos = vanchart._labelPos(node);

                    nodeRadius(node, vanchart.maxLevel);
                    var left = node.radius, right = node.radius,
                        top = node.radius, bottom = node.radius;

                    if (node.hasValidDataLabel()) {
                        left = Math.max(left, node.x - node.labelPos.x);
                        right = Math.max(right, node.labelPos.x + node.labelDim.width - node.x);
                        top = Math.max(top, node.y - node.labelPos.y);
                        bottom = Math.max(bottom, node.labelPos.y + node.labelDim.height - node.y);
                    }

                    node.x = vanchart._validPosition(node.x, left, right, plotBounds.width);
                    node.y = vanchart._validPosition(node.y, top, bottom, plotBounds.height);
                    node.labelPos = vanchart._labelPos(node);

                    node.posX = node.x; node.posY = node.y;

                    node.graphic && node.graphic
                        .attr('transform', BaseUtils.makeTranslate(node));
                    node.textGraphic && node.textGraphic
                        .attr('transform', BaseUtils.makeTranslate(node.labelPos));
                });

                edges.forEach(function (edge) {
                    edge.linkGraphic && edge.linkGraphic
                        .attr("x1", edge.source.x)
                        .attr("y1", edge.source.y)
                        .attr("x2", edge.target.x)
                        .attr("y2", edge.target.y);

                });

            }

            vanchart.force && vanchart.force.stop();
            vanchart.force = ForceLayout().nodes(nodes).links(edges)
                .size([plotBounds.width, plotBounds.height])
                .linkDistance(linkDistance).gravity(0).charge(-150)
                .eachTick(initTick)
                .simulateForce();

            var delayTimeArray = forceDelayTimeArray(maxLevel);

            vanchart._rendererNodes(delayTimeArray);

            vanchart._renderLabels(delayTimeArray);

            vanchart._renderForceLink(delayTimeArray);

            vanchart.force.eachTick(dragTick);
            function dragTick() {
                tick(false);
            }
        },

        _renderForceLink:function (delayTimeArray) {
            var vanchart = this, renderer = vanchart.renderer;

            vanchart.edges.forEach(function (edge) {
                edge.linkGraphic && edge.linkGraphic.remove();
                edge.linkGraphic = null;

                var attrs = vanchart._forceLinkAttrs(edge);
                var plotOptions = vanchart.options.plotOptions,
                    styles = {
                        'fill':'none',
                        'stroke': plotOptions.lineColor,
                        'stroke-opacity': plotOptions.lineOpacity,
                        'stroke-width': vanchart.lineWidth == null ? strokeWidth(edge, vanchart.maxLevel) : vanchart.lineWidth
                    };

                edge.linkGraphic = renderer.line(attrs).style(styles).addTo(vanchart.linkGroup);
                edge.linkGraphic.datum(edge);

                if(vanchart.animation){
                    var sourceDelay = delayTimeArray[edge.source.level],
                        targetDelay = delayTimeArray[edge.target.level];

                    var st = sourceDelay/LINK_TIME,
                        tt = targetDelay/LINK_TIME,
                        sx = LINK_EASE(st),
                        tx = LINK_EASE(tt);

                    var tScale = Scale.linear().domain([0,1]).range([st, tt]),
                        xScale = Scale.linear().domain([sx, tx]).range([0, 1]);

                    edge.linkGraphic
                        .attr('x2', attrs.x1)
                        .attr('y2', attrs.y1)
                        .animate({
                            delay:sourceDelay,
                            ease:'linear',
                            duration:targetDelay - sourceDelay,
                            attrTween:{
                                'x2':function () {return function (t) {return attrs.x1 + (attrs.x2 - attrs.x1) * xScale(LINK_EASE(tScale(t)));}},
                                'y2':function () {return function (t) {return attrs.y1 + (attrs.y2 - attrs.y1) * xScale(LINK_EASE(tScale(t)));}}
                            }
                        });
                }
            });
        },

        _forceLinkAttrs:function (edge) {
            return {x1: edge.source.x, x2: edge.target.x, y1: edge.source.y, y2: edge.target.y}
        },

        _treeRenderer:function () {
            var vanchart = this, plotBounds = vanchart.bounds;
            var maxLevel = vanchart.maxLevel;

            var size =  vanchart._verticalLayout() ? [plotBounds.width, plotBounds.height]
                : [plotBounds.height, plotBounds.width];

            var tree = TreeLayout().size(size);

            var nodes = tree.nodes(vanchart.ancestor).reverse();

            vanchart._adjustTreeSize(tree, size, nodes, maxLevel);

            var delayTimeArray = treeDelayTimeArray(maxLevel);

            vanchart._rendererNodes(delayTimeArray);

            vanchart._renderLabels(delayTimeArray);

            vanchart._renderTreeLink();
        },

        //调整一下,不切断节点&显示全标签
        _adjustTreeSize: function (tree, size, nodes, maxLevel) {
            var vanchart = this, isVertical = vanchart._verticalLayout();
            var left = 0, right = size[0], top = 0, bottom = size[1];

            nodes.forEach(function (node) {
                var radius = nodeRadius(node, maxLevel);
                radius += (node.options.borderWidth || 0);
                var dataLabels = node.options.dataLabels, labelDim = node.labelDim;
                if(dataLabels && dataLabels.enabled) {
                    var width = labelDim.width, height = labelDim.height, out = dataLabels.align == Constants.OUTSIDE;
                    if(isVertical) {
                        left = Math.min(left, node.x - width / 2);
                        right = Math.max(right, node.x + width / 2);
                        top = Math.min(top, node.y - (out ? height + LABEL_GAP + radius : height / 2));
                        bottom = Math.max(bottom, node.y + (out ? 0 : height / 2));
                    } else {
                        left = Math.min(left, node.x - (out ? 0 : height / 2));
                        right = Math.max(right, node.x + (out ? radius + LABEL_GAP + height : height / 2));
                        top = Math.min(top, node.y - width / 2);
                        bottom = Math.max(bottom, node.y + width / 2);
                    }
                }
                left = Math.min(left, node.x - radius);
                right = Math.max(right, node.x + radius);
                top = Math.min(top, node.y - radius);
                bottom = Math.max(bottom, node.y + radius);
            });

            left = -left; right = right - size[0];top = -top;bottom = bottom - size[1];
            size = [size[0] - left - right, size[1] - top - bottom];

            tree.size(size);
            tree.nodes(vanchart.ancestor).reverse();

            nodes.forEach(function (node) {
                node.x = node.x + left;
                node.y = node.y + top;
            });
        },

        _treeLinkPath: function (link) {
            var vanchart = this, maxLevel = vanchart.maxLevel;

            var diagonalFun = vanchart._verticalLayout() ? function (d) {return [d.x, d.y];}
                : function (d) {return [d.y, d.x];};

            if(vanchart.lineWidth){
                var diagonal = PathGenerator.diagonal()
                    .projection(diagonalFun);
                return diagonal(link);
            }

            var source = link.source, target = link.target,
                width = strokeWidth(link, maxLevel), gap = width/2;

            var sx = source.x, sy = source.y,
                tx = target.x, ty = target.y, m = (sy + ty) / 2;
            var sx1 = sx - gap, tx1 = Math.min(tx - 0.25, tx - gap + 0.5),
                sx2 = sx + gap, tx2 = Math.max(tx + 0.25, tx + gap - 0.5);

            var p = [{x:sx1, y:sy},{x:sx1, y:m},{x:tx1, y:m},{x:tx1, y:ty},
                {x:tx2, y:ty},{x:tx2, y:m},{x:sx2, y:m},{x:sx2, y:sy}];

            p = p.map(diagonalFun);

            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3]
                + "L" + p[4] + "C" + p[5]  + " " + p[6] + " " + p[7];
        },

        _renderTreeLink:function () {
            var vanchart = this, renderer = vanchart.renderer, plotBounds = vanchart.bounds;

            var plotOptions = vanchart.options.plotOptions, styles;
            if(vanchart.lineWidth == null){
                styles = {
                    'fill': plotOptions.lineColor,
                    'fill-opacity': plotOptions.lineOpacity
                }
            } else {
                styles = {
                    'fill':'none',
                    'stroke':plotOptions.lineColor,
                    'stroke-opacity':plotOptions.lineOpacity,
                    'stroke-width':vanchart.lineWidth
                }
            }

            var minx = plotBounds.width, miny = plotBounds.height, maxx = 0, maxy = 0;
            vanchart.edges.forEach(function (link) {
                link.linkGraphic && link.linkGraphic.remove();
                link.linkGraphic = null;

                link.linkGraphic = renderer.path().addTo(vanchart.linkGroup);
                link.linkGraphic.attr('d', vanchart._treeLinkPath(link)).style(styles);

                link.linkGraphic.datum(link);

                var source = link.source, target = link.target;
                minx = Math.min(minx, source.posX);miny = Math.min(miny, source.posY);maxx = Math.max(maxx, source.posX);maxy = Math.max(maxy, source.posY);
                minx = Math.min(minx, target.posX);miny = Math.min(miny, target.posY);maxx = Math.max(maxx, target.posX);maxy = Math.max(maxy, target.posY);
            });

            var lineWidth = vanchart.lineWidth || 1,
                isHorizontal = vanchart.layout === Constants.HORIZONTAL_LAYOUT;

            if(vanchart.animation && BaseUtils.isSupportSVG()){
                // @CHART-1379
                var attrs = {
                    'x':minx - (isHorizontal ? 0 : lineWidth / 2),
                    'y':miny - (isHorizontal ? lineWidth / 2 : 0),
                    'width':(maxx - minx) + (isHorizontal ? 0 : lineWidth),
                    'height':(maxy - miny) + (isHorizontal ? lineWidth : 0)
                };

                if(!vanchart.linkGroup.clipG){
                    vanchart.linkGroup.clipG = renderer.createClip(attrs);
                    renderer.clip(vanchart.linkGroup, vanchart.linkGroup.clipG);
                }else{
                    renderer.updateClip(vanchart.linkGroup.clipG, attrs);
                }

                var clipKey = vanchart._verticalLayout() ? 'height' : 'width';
                var endAttr = {};endAttr[clipKey] = attrs[clipKey];

                vanchart.linkGroup.clipG.rect
                    .attr(clipKey, 0)
                    .animate({
                        ease:LINK_EASE,
                        duration:LINK_TIME,
                        attr:endAttr
                    });
            }
        },

        //with node.x node.y delayTime
        _rendererNodes:function (delayArray) {
            var vanchart = this, renderer = vanchart.renderer, maxLevel = vanchart.maxLevel;

            vanchart.nodes.forEach(function (node) {
                node._events = null;
                node.graphic && node.graphic.remove();
                node.graphic = null;

                var radius = nodeRadius(node, maxLevel), delay = delayArray[node.level];

                node.posX = parseInt(vanchart._horizontalLayout() ? node.y : node.x);
                node.posY = parseInt(vanchart._horizontalLayout() ? node.x : node.y);

                var attrs = vanchart._nodeAttrs(node),
                    style = node.series.getStyle(node);

                node.graphic = renderer.group()
                    .attr('transform', 'translate('+ node.posX +','+ node.posY +')')
                    .addTo(vanchart.nodeGroup);

                if(node.options.image){
                    node.graphic.nodeGraphic = renderer.image(attrs).imageContent(node.options.image).addTo(node.graphic)
                }else {
                    node.graphic.nodeGraphic = renderer.circle(attrs).style(style).addTo(node.graphic);
                }

                function createNodeEventObject() {
                    var nodeEventObject = new EventObject(vanchart.getEvents());
                    nodeEventObject.vanchart = vanchart;
                    return nodeEventObject;
                }

                function registerTarget(object, graphic) {
                    graphic && vanchart.registerInteractiveTarget(object, graphic);
                }

                registerTarget(node, node.graphic);
                registerTarget(createNodeEventObject(), node.graphic.nodeGraphic);

                node.graphic
                    .attr('transform', 'translate('+ node.posX +','+ node.posY +') scale(0.01)')
                    .animate([{
                        delay:delay,
                        ease:NODE_EASE,
                        duration:NODE_TIME/2,
                        attr:{'transform': 'translate('+ node.posX +','+ node.posY +') scale(1.5)'}
                    },{
                        ease:NODE_EASE,
                        duration:NODE_TIME/2,
                        attr:{'transform': 'translate('+ node.posX +','+ node.posY +') scale(1)'}
                    }]);

                if(vanchart._forceDragEnabled()) {
                    vanchart.force.registerDragTarget(node, node.graphic);
                }

            });

        },

        _nodeAttrs:function (node) {
            var radius = node.radius;
            return node.options.image ? {'preserveAspectRatio':'none', 'x':-radius, 'y':-radius, 'width':radius*2, 'height':radius*2}
                : {'cx':0, 'cy':0, 'r':radius}
        },

        _labelPos:function (node) {
            if(!node.labelDim){
                return;
            }
            var dataLabels = node.options.dataLabels;
            var dim = node.labelDim, alignInside = dataLabels.align == Constants.INSIDE;
            return alignInside ? {x: node.posX - dim.width / 2, y: node.posY - dim.height / 2}
                : {x: node.posX - dim.width / 2, y: node.posY - node.radius - LABEL_GAP - dim.height};
        },

        _animationEnd:function () {
            this._animationStarted = false;
            this._consoleDone();
        },

        _renderLabels:function (delayArray) {
            var manager = new BoundsManager(), vanchart = this;
            var needShowMoreLabel = this._needShowMoreLabel();

            vanchart.nodes && vanchart.nodes.forEach(function (node) {
                node.textGraphic && node.textGraphic.remove();
                node.textGraphic = null;

                var dataLabels = node.options.dataLabels, series = node.series;

                if (dataLabels && dataLabels.enabled) {
                    var pos = vanchart._labelPos(node);

                    if (dataLabels.autoAdjust) {
                        pos = series._calculateAutoLabelPos(node, pos, vanchart._horizontalLayout(), manager);
                    }

                    if (pos) {
                        node.labelPos = pos;
                        manager.addBounds(BaseUtils.makeBounds(node.labelPos, node.labelDim));
                    }

                    series._createTextGraphic(node);

                    // 定时在节点绘制之后渲染moreLabel
                    if(needShowMoreLabel) {
                        setTimeout(function (){
                            series._showMoreLabel(node);
                        }, delayArray[node.level])
                    }

                    node.textGraphic.style('opacity', 0).animate({
                        delay:delayArray[node.level],
                        duration:0,
                        style:{opacity:1}
                    })
                }
            });
        },

        _onPanStart:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            vanchart.groupTrans = vanchart.groupTrans || vanchart.bounds;

            vanchart.currentPoint = ev.containerPoint;
        },

        _onPanMove:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            var transX = ev.containerPoint.x - vanchart.currentPoint.x,
                transY = ev.containerPoint.y - vanchart.currentPoint.y;

            vanchart.groupTrans.x += transX;
            vanchart.groupTrans.y += transY;
            vanchart.currentPoint = ev.containerPoint;

            var trans = BaseUtils.makeTranslate(vanchart.groupTrans);
            vanchart.linkGroup.attr('transform', trans);
            vanchart.nodeGroup.attr('transform', trans);
            if (vanchart.ancestor.series.textGraphicGroup) {
                vanchart.ancestor.series.textGraphicGroup.attr('transform', trans);
            }
        },

        _onPanEnd:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            vanchart.handler.panTarget = null;
        },

        getEvents: function(){
            var vanchart = this;

            return vanchart._treeDragEnabled() ? {
                    'panstart':vanchart._onPanStart,
                    'panmove':vanchart._onPanMove,
                    'panend':vanchart._onPanEnd
                } : {};
        }

    });

    require('./VanChartLibrary').register(Constants.STRUCTURE_CHART, VanChartStructure);

    return VanChartStructure;
});
/**
 * Created by Yuqian on 2017/2/22.
 */

/*
 Copyright (c) JS Foundation and other contributors

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 https://github.com/moment/moment
 */

define('dateUnits/dateFormat',['require'],function (require) {

    var defaultValues = {

        duration: {
            year: 'years',
            month: 'months',
            day: 'days',
            hour: 'hours',
            minute: 'minutes',
            second: 'seconds'
        },

        halfYears: ['H1', 'H2'],
        quarters: 'Q1_Q2_Q3_Q4'.split('_'),
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        meridiem: ['am', 'pm'],
        qDay: '0h~6h_6h~12h_12h~18h_18h~24h'.split('_')
    };

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w{1,3}|wo|W[o|W]?|Q{2,3}|Qo?|[yY]{2,6}|gg(ggg?)?|GG(GGG?)?|e{2,6}|E|a|A|hh?|HH?H?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    var durationTokenFunctions = {};

    function zeroFill (number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        // if (ordinal) {
        //     formatTokenFunctions[ordinal] = function () {
        //         return this.localeData().ordinal(func.apply(this, arguments), token);
        //     };
        // }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    function formatDate (m, format) {
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    // according to Wang Jun's doc
    // 1.222 -> 1.22; 1.20 -> 1.2
    function decimalAdjust(value, exp) {
        // Shift
        value = value.toString().split('e');
        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
        // Shift back
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    }

    // default format like: '25.5hours'
    function defaultDurationFormatFunc(token, d) {
        return decimalAdjust(d.get(token), -2) + defaultValues.duration[token]
    }

    function formatDuration (d, token) {

        if (durationTokenFunctions[token] == null) {
            if (typeof defaultValues.duration[token] === 'string') {
                durationTokenFunctions[token] = defaultDurationFormatFunc.bind(null, token);
            } else { // function
                durationTokenFunctions[token] = defaultValues.duration[token]
            }
        }

        return durationTokenFunctions[token](d)
    }

    function setLocale (config) {

        // if we had to change the locale after load
        // clear and re-init following cache
        // formatFunctions = {};
        // formatTokenFunctions = {};
        // durationTokenFunctions = {};

        for (var prop in config) {
            if (prop.charAt(0) === '_') {
                continue
            }
            if (prop === 'base') {
                config.base(addFormatToken, defaultValues);
            } else {
                defaultValues[prop] = config[prop];
            }
        }
    }

    // format according to
    // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
    //
    // custom:
    // half year = N
    // 1/4 day = I
    // HHH

    var add = addFormatToken;

    // year
    add('y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    add(0, ['yy', 2], 0, function () {
        return this.year() % 100;
    });
    add(0, ['yyyy',   4],       0, 'year');
    add('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    add(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    add(0, ['YYYY',   4],       0, 'year');

    // useful?
    add(0, ['yyyyy',  5],       0, 'year');
    add(0, ['yyyyyy', 6, true], 0, 'year');

    // half year
    add('N', 0, 0, function () {
        return defaultValues.halfYears[this.halfYear() - 1]
    });

    // quarter
    add('Q', ['QQ', 2], 0, 'quarter');
    add('QQQ', 0, 0, function () {
        return defaultValues.quarters[this.quarter() - 1];
    });

    // month
    add('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    add('MMM', 0, 0, function () {
        return defaultValues.monthsShort[this.month()]
    });
    add('MMMM', 0, 0, function () {
        return defaultValues.months[this.month()]
    });

    // week of year
    add('w', ['ww', 2], 0, 'week');
    add('www', 0, 0, function () {
        return 'Week' + this.week();
    });

    // week day
    add('e', ['ee', 2], 0, 'day');
    add('eee', 0, 0, function () {
        return defaultValues.weekdaysShort[this.day()]
    });
    add('eeee', 0, 0, function () {
        return defaultValues.weekdays[this.day()]
    });
    add('eeeeee', 0, 0, function () {
        return defaultValues.weekdaysMin[this.day()]
    });

    // date
    add('d', ['dd', 2], 0, 'date');

    // am/pm
    add('a', 0, 0, function () {
        return defaultValues.meridiem[this.meridiem() - 1]
    });

    // 1/4 day
    add('I', 0, 0, function () {
        return defaultValues.qDay[this.qDay() - 1];
    });

    // hour
    add('H', ['HH', 2], 0, 'hour');
    // custom format
    add('HHH', 0, 0, function () {
        return this.hour() + 'h'
    });

    // minute
    add('m', ['mm', 2], 0, 'minute');

    // second
    add('s', ['ss', 2], 0, 'second');

    return {
        // addFormatToken: addFormatToken,
        formatDate: formatDate,
        formatDuration: formatDuration,
        setLocale: setLocale
    };
});

/**
 * Created by Yuqian on 2017/3/2.
 */

define('dateUnits/dateDuration',['require','./dateFormat'],function (require) {

    var formatDuration = require('./dateFormat').formatDuration;

    var SECOND = 1000,
        MINUTE = 60 * SECOND,
        HOUR = 60 * MINUTE,
        DAY = 24 * HOUR,
        WEEK = 7 * DAY,

        // not accurate
        YEAR = 365 * DAY,
        MONTH = 30 * DAY,
        QUARTER = 3 * MONTH;

    /**
     * read a millisecond, get x unit duration
     * @param dur
     * @constructor
     */
    var Duration = function (dur) {
        this._ms = +dur;
    };

    var proto = Duration.prototype = {

        valueOf: function () {
            return this._ms
        },

        as: function (units) {
            return formatDuration(this, units)
        },

        get: function (units) {
            var result = this._ms;
            switch (units) {
                case 'millisecond': break;
                case 'second': result /= SECOND ; break;
                case 'hour': result /= HOUR; break;
                case 'minute': result /= MINUTE; break;
                case 'day': result /= DAY; break;
                case 'month': result /= MONTH; break;
                case 'year': result /= YEAR; break;
                default: throw new Error('Unknown unit ' + units);
            }
            return result
        }
    };

    var duration = function (dur) {
        return new Duration(dur)
    };

    return duration

});

/**
 * Created by Yuqian on 2017/2/13.
 */

define('dateUnits/dateUnits',['require','./dateFormat','./dateDuration'],function (require) {

    var dateFormat = require('./dateFormat');
    var duration = require('./dateDuration');
    var formatDate = dateFormat.formatDate;

    // change locale:
    // dateUnits.locale(require('./locale/zh-cn'));

    var DAY = 864e5;

    var aliasList = ["year", "month", "halfYear", "quarter", "week", "day", "date", "meridiem", "qDay", "hour", "minute", "second", "millisecond"];
    var ALIAS = {};

    aliasList.map(function (unit) {
        ALIAS[unit + 's'] = unit;
    });

    /**
     *
     * @param num
     * @param from
     * @param to
     * @returns {{
     * c: number,  c circles
     * r: number   r remainder
     * }}
     */
    function getCR (num, from, to) {
        var c = Math.floor((num - from) / (to - from + 1));
        var r = num - (to - from + 1) * c;
        return {
            c: c,
            r: r
        }
    }

    function isLeapYear (year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function daysInYear (year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#First_week
    // 4 Jan is always in the first week
    function firstWeekOffset (year) {
        var jan4Day = new Date(year, 0, 4).getDay() || 7;
        return 4 - jan4Day;
    }

    function weeksInYear (year) {
        var weekOffset = firstWeekOffset(year),
            weekOffsetNext = firstWeekOffset(year + 1);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    /**
     * get local date unit
     * @param date
     * @constructor
     */
    var DateUnits = function (date) {
        this._d = date;
    };

    var proto = DateUnits.prototype = {

        valueOf: function () {
            return +this._d
        },

        year: function (year) {
            if (year != null) {
                this._d.setFullYear(year);
                return this
            }
            return this._d.getFullYear()
        },

        /**
         * month from 0
         * @returns {number|Object}
         */
        month: function (month) {
            if (month != null) {
                this._d.setMonth(month);
                return this
            }
            return this._d.getMonth()
        },

        /**
         * get 1 or 2 (h1 or h2)
         * @returns {number|Object}
         */
        halfYear: function (h) {
            if (h != null) {
                var o = getCR(h, 1, 2);
                o.c && (this.year(this.year() + o.c));
                this.month(o.r === 1 ? 0 : 6);
                return this
            }
            return this.month() < 6 ? 1 : 2
        },

        /**
         * quarter 1, 2, 3, 4
         * @returns {number|Object}
         */
        quarter: function (q) {
            if (q != null) {
                var o = getCR(q, 1, 4);
                o.c && (this.year(this.year() + o.c));
                this.month((o.r - 1) * 3);
                return this
            }
            return Math.ceil((this.month() + 1) / 3)
        },

        dayOfYear: function () {
            return Math.floor((this._d - new Date(this.year(), 0, 1)) / DAY) + 1;
        },

        /**
         * 1-53 week of year
         * https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
         * @returns {{week: number, year: number}}
         */
        // moving to 'doy, dow' version may be better
        // doy = 1, dow = 4 now
        weekOfYear: function () {
            var week = Math.floor(
                (this.dayOfYear() - (this.day() || 7) + 10) / 7
            );
            var year = this.year();

            if (week < 1) {
                year -= 1;
                week = weeksInYear(year);
            } else
            if (week > weeksInYear(year)) {
                week = week - weeksInYear(year);
                year += 1;
            }

            return {
                week: week,
                year: year
            }
        },

        week: function () {
            return this.weekOfYear().week
        },

        day: function (day) {
            if (day != null) {
                var diff = day - (this.day() || 7);
                this._d.setDate(this.date() + diff);
                return this
            }
            return this._d.getDay()
        },

        date: function (date) {
            if (date != null) {
                this._d.setDate(date);
                return this
            }
            return this._d.getDate()
        },

        /**
         * 1 for a.m.; 2 for p.m.
         * @returns {number|Object}
         */
        meridiem: function (m) {
            if (m != null) {
                var o = getCR(m, 1, 2);
                o.c && (this.date(this.date() + o.c));
                this.hours(o.r === 1 ? 0 : 12);
                return this
            }
            return this.hours() < 12 ? 1 : 2
        },

        /**
         * 1 for 0~6; 2 for 6~12; 3 for 12~18; 4 for 18~24
         * @param q
         * @returns {number|object}
         */
        qDay: function (q) {
            if (q != null) {
                var o = getCR(q, 1, 4);
                o.c && (this.date(this.date() + o.c));
                this.hour((o.r - 1) * 6);
                return this
            }
            return Math.ceil((this.hour() + 1) / 6)
        },

        hour: function (h) {
            if (h != null) {
                this._d.setHours(h);
                return this
            }
            return this._d.getHours()
        },

        minute: function (min) {
            if (min != null) {
                this._d.setMinutes(min);
                return this
            }
            return this._d.getMinutes()
        },

        second: function (s) {
            if (s != null) {
                this._d.setSeconds(s);
                return this
            }
            return this._d.getSeconds()
        },

        millisecond: function (ms) {
            if (ms != null) {
                this._d.setMilliseconds(ms);
                return this
            }
            return this._d.getMilliseconds();
        },

        startOf: function (units) {
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'halfYear':
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'day':
                case 'date':
                    this.hours(0);
                /* falls through */
                case 'hour':
                case 'meridiem':
                case 'qDay':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
            }

            if (units === 'week') {
                this.day(1);
            } else
            if (['quarter', 'halfYear', 'meridiem', 'qDay'].indexOf(units) !== -1) {
                this[units](this[units]());
            }

            return this
        },

        endOf: function (units) {
            if (!units || units === 'millisecond') {
                return this;
            }
            return this.add(1, units).startOf(units).add(-1, 'millisecond')
        },
        
        add: function (number, period) {
            period = ALIAS[period] || period;

            if (period === 'halfYear') {
                this.add(number * 6, 'month');
            } else
            if (period === 'quarter') {
                this.add(number * 3, 'month');
            } else
            if (period === 'week') {
                this.add(number * 7, 'date');
            } else
            if (period === 'meridiem') {
                this.add(number * 12, 'hour');
            } else
            if (period === 'qDay') {
                this.add(number * 6, 'hour');
            } else {
                if (period === 'day') {
                    period = 'date';
                }
                var now = this.get(period);
                this[period](now + number);
            }

            return this
        },

        isWeekend: function () {
            var d = this.day();
            return d === 6 || d === 0
        }

    };

    // alias
    aliasList.map(function (unit) {
        proto[unit + 's'] = proto[unit];
    });

    proto.get = function (unit) {
        return this[unit]();
    };

    proto.format = function (inputString) {
        return formatDate(this, inputString);
    };

    var dateUnits = function (date) {
        var dateObject;
        if (date instanceof DateUnits) {
            dateObject = new Date(date._d);
        } else
        if (date) { // loose check
            dateObject = new Date(date);
        } else {
            dateObject = new Date();
        }
        return new DateUnits(dateObject)
    };

    dateUnits.isLeapYear = isLeapYear;
    dateUnits.daysInYear = daysInYear;
    dateUnits.firstWeekOffset = firstWeekOffset;
    dateUnits.weeksInYear = weeksInYear;
    dateUnits.setLocale = dateFormat.setLocale;
    dateUnits.duration = duration;

    return dateUnits
});

/**
 * Created by eason on 16/2/19.
 * 数据点的抽象
 */
define('chart/Point',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary','../dom/Evented'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var Evented = require('../dom/Evented');

    var NEGATIVE_COLOR = 'rgb(138, 138, 138)';

    var Point = Evented.extend({

        vanChartType: 'point',

        initialize:function(options, series){
            this.series = series;

            this.refresh(options || {});
        },

        refresh:function(options){
            var series = this.series, vanchart = series.vanchart;

            //确定标记点颜色用
            this.originalColor = options.color;this.originalMarkerFillColor = options.marker && options.marker.fillColor;

            options = this.options = BaseUtils.createOptions(options, [series.options]);

            var isSeriesAcc = series.isSeriesAccumulated();
            var category = series.type == Constants.BAR_CHART ? options.y : options.x;
            var seriesName = series.name;

            this.category = isSeriesAcc ? seriesName : category;
            this.seriesName = isSeriesAcc ? category : seriesName;
            this.value = this.getTargetValue();
            this.name = BaseUtils.pick(this.options.x, this.options.name);

            // point.categoryArray为数组
            this.categoryArray = BaseUtils.isArray(options.categoryArray) ?
                options.categoryArray.map(function (cate){  return cate; }) :
                [this.category];
            this.categoryArrayStr = BaseUtils.encodeCategoryArray(this.categoryArray);  // 缓存起来，不用每次都重新算了

            //shine:y不能用value，因为value有可能是size（bubble chart）
            this.x = options.x;
            this.y = options.y;    // 之前的版本计算百分比之类的都是用的y作为targetKey取值，现在 把y去掉，导致百分比之类的计算出错
            this.size = options.size;

            this.visible = true;
            this.isNull = series.isNullValue(this);
            this.points = isSeriesAcc ? series.points : vanchart.registerPointsPara(this);

            // try to eliminate properties in large mode
            // if (series.options.large) {
            //     return;
            // }
            // 点地图大数据模式需要geo

            if(options.drilldown && options.drilldown.geo){
                var Geo = ComponentLibrary.get(ComponentLibrary.GEO_COMPONENT);
                this.geo = new Geo(options.drilldown.geo, ComponentLibrary.GEO_COMPONENT, vanchart);
            }
            BaseUtils.calculateFontSizeWithScale(options.dataLabels && options.dataLabels.style);
            BaseUtils.calculateFontSizeWithScale(options.tooltip && options.tooltip.style);

            //@deprecated H5兼容,暂时不能删
            this.jsonHyperlink = options.jsonHyperlink;
            this.drillUpLink = options.drillUpLink;

            //todo 下周移动端发布以后删掉，暂时需要兼容
            this.hyperlink = options.hyperlink;
            this.options.onClick = this.options.onClick || this.options.click;
        },

        //根据范围图例的值来计算颜色
        refreshPointColor:function(){
            var point = this, options = point.options, series = point.series, vanchart = series.vanchart;
            if (!series.isTreeSeries()) {
                //点的颜色：colors，范围图例，系列条件属性配色，点条件属性配色
                //标记点的颜色取的顺序：colors配色、plotOptions的标记点的颜色、范围图例、条件属性系列配色、条件属性系列标记点颜色、条件属性数据点的配色、条件属性数据点的标记点的配色

                var _opacity = options.opacity, _markerOpacity = options.opacity;
                var colorKey;
                if(series.type == Constants.STRUCTURE_CHART){
                    colorKey = this.level;
                }else{
                    // 这边的options.name再createOptions的时候就跳过了？
                    colorKey = series.isSeriesAccumulated() ? BaseUtils.pick(options.x, options.name, series.options.name) : series.name;
                }
                //默认配色
                var _color = vanchart.getDefaultSeriesColor(colorKey);
                var _markerColor = _color;

                if(options.marker){
                    options.marker = BaseUtils.clone(options.marker);
                    _markerColor = options.marker.fillColor || _markerColor;
                }

                // 范围图例
                // large lineMap cannot use range
                if (!(series.type === Constants.LINE_MAP && series.options.large)) {
                    var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
                    if (rangeLegend) {
                        _color = rangeLegend.getColorWithSize(this.getTargetValue(), series.options.large);
                        _markerColor = _color;
                        this.visible = !!_color;
                    }
                }

                //系列条件属性配色
                _markerColor = series.originalColor || _markerColor;
                _markerColor = series.originalMarkerFillColor || _markerColor;

                //点条件属性配色
                _color = this.originalColor || series.originalColor || _color;
                _markerColor = this.originalColor || _markerColor;
                _markerColor = this.originalMarkerFillColor || _markerColor;

                //负气泡、bands等特殊的。
                if((series.type == Constants.BUBBLE_CHART || series.type == Constants.FORCE_BUBBLE_CHART) && !rangeLegend) {
                    if(point.getTargetValue() < 0 && point.options.displayNegative){
                        _color = NEGATIVE_COLOR;
                    } else if(point.getTargetValue() < 0){
                        _color = null;
                    }
                }

                if(_color){
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(_color, _opacity);
                    _color = hexAlpha.hex;
                    _opacity = hexAlpha.alpha;
                }

                if(_markerColor){
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, _markerOpacity);
                    _markerColor = hexAlpha.hex;
                    _markerOpacity = hexAlpha.alpha;
                }

                var marker = options.marker;
                if(marker) {
                    marker.fillColor = _markerColor;
                    marker.fillColorOpacity = _markerOpacity;
                    marker.radius = isNaN(marker.radius) ? 4.5 : marker.radius;
                    marker.symbol = marker.symbol || (series.marker && series.marker.symbol) || '';
                }

                if(_color){
                    this.color = _color;
                    this.opacity = _opacity;
                    this.mouseOverColor = this.options.mouseOverColor || ColorUtils.getHighLightColor(_color);
                    this.clickColor = ColorUtils.getClickColor(_color);
                    this.clickOpacity = _opacity * 0.95;
                }

                this.borderColor = this.options.borderColor;
                this.borderOpacity = this.options.borderOpacity;
            }
        },

        getTargetValue:function(){
            //兼容值可能是字符串的情况
            var value = this.options[this.series.getTargetKey()];

            if(isNaN(+value)){

                return this.series.isNullValue(this) ? 0 : value;

            }else{
                return +value;
            }
        },

        getLatLng:function(feature){
            var lnglat = this.options.lnglat;

            if(!lnglat){
                var geo = this.series.vanchart.getCurrentGeo();

                if(!feature){
                    feature = geo.getFeaturesByName(this.name, this.series.type);
                    feature = feature && feature[0];
                }

                if(feature){
                    lnglat = geo.getDataPointLngLat(this, feature);
                }
            }

            return lnglat ? [lnglat[1], lnglat[0]] : null;
        },

        getStackPointPreSufPoint:function (point) {

            var series = point.series, stackKey = [series.type, series.stack, point.category].join('-');

            var preP, sufP, find = false;
            for(var dataIndex = 0, dataCount = point.points.length; dataIndex < dataCount; dataIndex++){
                var p = point.points[dataIndex], ser = p.series, key = [ser.type, ser.stack, p.category].join('-');
                if(p == point){
                    find = true;
                } else if(key == stackKey && p.isVisible()){
                    if(find){
                        sufP = p;
                        break;
                    } else {
                        preP = p;
                    }
                }
            }
            return {pre:preP, suf:sufP};
        },

        _mapPointOnMouseState:function (isChosen, duration, ease, style) {
            var point = this, series = point.series, vanchart = series.vanchart;
            if(vanchart.isMapPointVisible(point) && point.layers){

                point.layers && point.layers.forEach(function(layer){
                    layer._onMouseState(isChosen, duration, ease, style);
                });

            }
        },

        /**
         * 获取point的分类，这里的分类指的是其对应的id，用于识别这个点，同时也是分类轴上的domain的取值。
         * !!!注意，使用tooltip的时候，其分类仍旧是point.category
         * @return {[type]} [description]
         */
        getCategory: function(){
            var series = this.series, isMultiCategoryBased = series.isMultiCategoryAxisBased();
            return isMultiCategoryBased ? this.categoryArrayStr : this.category;
        }
    });


    Point.include({

        _onPointMouseOver: function (ev) {

            var point = this, options = point.options, series = this.series, vanchart = series.vanchart, renderer = vanchart.renderer;
            var hoverPoint = vanchart.hoverPoint, hoverSeries = vanchart.hoverSeries,
                hoverPoints = vanchart.hoverPoints, sharedAxis = vanchart.getSharedAxis();

            if(hoverPoint === point){
                return;
            }
            var share = options.tooltip && options.tooltip.shared && point.points && sharedAxis && point.series.supportTooltipShared();
            var hoverSameCategory = hoverPoints && hoverPoints.length && point.getCategory() == hoverPoints[0].getCategory();
            if(share && hoverSameCategory && series.defaultMarker){
                // 折线图默认标记点 数据点提示共享 同一个分类里鼠标移动。
                // 不return掉，会一直over-create-default-marker then out-delete-default-marker
                return;
            }

            if (series.isTreeSeries()) {
                series.vanchart.showTooltip(point, ev);
                series.fire('pointMouseOver', point);
                return;
            }

            hoverPoint && hoverPoint.fire('mouseout', ev);

            if (share) {
                var valid = vanchart.getValidPointsPara(point.getCategory());

                //out要在over之前。否则，over series.createDefaultMarker then out delete
                // todo 共享数据点提示时，鼠标移至另一个分类下是，要将之前的hoverPoints的高亮去掉
                if (hoverPoints && hoverPoints.length && hoverPoints[0] != valid[0]) {
                    hoverPoints[0]._onPointMouseOut.call(hoverPoints[0], ev);

                    if(!point.series.defaultMarker && hoverPoints[0].series.defaultMarker){
                        //折线图无标记点的时候移到柱形图上
                        hoverPoints[0].points.forEach(function (p) {
                             p.series.fire('pointMouseOut', p);
                        });
                    }
                }

                var max = valid
                    .reduce(function (prev, curr) {
                        curr.series._onPointMouseOver.call(curr, curr);  //  这里的作用是让同类别的所有点触发mouseOver事件，因此传入的应该是对应的curr点！

                        if (!prev) {
                            return curr;
                        }
                        return (curr.getTargetValue() > prev.getTargetValue()) ? curr : prev;
                    }, 0);

                if(sharedAxis && valid.length){
                    sharedAxis.drawHighlightBackground(valid);
                }

                series.vanchart.showSharedTooltip(point, ev);

                vanchart.hoverPoints = valid;   // todo 这里记得更新一下hoverPoints，鼠标移除绘图区时清除highLight时会用到

            }else{

                series.vanchart.showTooltip(point, ev);

                series.fire('pointMouseOver', point);

                if(hoverSeries != point.series){
                    hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                    point.series.fire('mouseover', ev);
                }

                vanchart.hoverSeries = point.series;
                vanchart.hoverPoint = point;

            }
        },

        _onPointMouseMove:function(ev){
            var point = this, options = point.options, series = this.series, vanchart = series.vanchart, sharedAxis = vanchart.getSharedAxis();
            var share = options.tooltip && options.tooltip.shared && point.points && sharedAxis && point.series.supportTooltipShared();

            share ? vanchart.showSharedTooltip(vanchart.hoverPoints && vanchart.hoverPoints[0], ev)
                : vanchart.showTooltip(vanchart.hoverPoint, ev);
        },

        _onPointMouseOut: function (ev) {
            var point = this, tooltip = point.options.tooltip;
            var series = this.series, vanchart = series.vanchart, sharedAxis = vanchart.getSharedAxis();

            if (series.isTreeSeries()) {
                series.fire('pointMouseOut', point);
                return;
            }

            if (tooltip && tooltip.shared && point.points && point.points.length && sharedAxis) {
                point.points.forEach(function (point) {
                    //有图形||折线图无标记点时移除绘图区
                    var fire = point.graphic || (point.series.defaultMarker && !BaseUtils.containsPoint(vanchart.bounds, ev.containerPoint));

                    fire && point.series.fire('pointMouseOut', point);

                    point.series.fire('seriesUnChosen', ev);

                });
            } else {

                point.series.fire('pointMouseOut', point);

            }

            series.vanchart.hideTooltip();
        },

        _onPointTap: function (ev) {
            var point = this, options = point.options, series = this.series, vanchart = series.vanchart;

            var visible = vanchart.isMap() ? vanchart.isMapPointVisible(point) : point.isVisible();
            if(!visible){
                return;
            }

            if (series.isTreeSeries()) {
                series.onPointTap(point);
            }

            //触发超链
            var srcEvent = ev.srcEvent;
            var touch = srcEvent.touches && (srcEvent.touches.length ? srcEvent.touches[0] : srcEvent.changedTouches[0]);
            if(touch){//移动端clientY，clientX不在event上
                srcEvent.clientX = touch.clientX;
                srcEvent.clientY = touch.clientY;
            }

            point.onClick(srcEvent);

            //移动端的时候触发选中效果
            if(BaseUtils.hasTouch()){
                point.fire('mouseover', ev);
            }

            vanchart.drillDown && vanchart.drillDown(point);

        },

        hasValidDataLabel:function(){
            var point = this;
            var hasLabel = point.labelPos && !isNaN(point.labelPos.x) && !isNaN(point.labelPos.y) && point.options.dataLabels && point.options.dataLabels.enabled;
            return point.series.visible && !point.isNull && point.visible && hasLabel;
        },

        clearPointEffect:function(){
            var point = this;
            clearInterval(point.effectInterval);
            point.effectGraphic && point.effectGraphic.remove();
            point.effectGraphic = null;
        },

        isVisible: function () {
            var point = this;
            return point && point.visible && point.series.visible && !point.isNull;
        },

        getEffectTime: function () {
            var point = this;
            if(BaseUtils.isSupportSVG() && point.isVisible() && point.options.effect && point.options.effect.enabled){
                return point.series._getEffectTime(point);
            }
            return 0;
        },

        hasEffect:function(){
            return this.getEffectTime() > 0;
        },

        //dataLabels for gauge
        autoLabelColor: function (dataLabels) {
            var point = this;
            var options = point.options, series = point.series, dataLabels = dataLabels || options.dataLabels, align = dataLabels.align;
            var useSeriesColor = align == Constants.TOP || align == Constants.BOTTOM || align == Constants.OUTSIDE;

            if(series.type == Constants.BUBBLE_CHART || series.type == Constants.TREEMAP_CHART || series.type == Constants.FORCE_BUBBLE_CHART || series.columnType){
                useSeriesColor = false;
            } else if(series.type == Constants.SCATTER_CHART || series.type == Constants.POINT_MAP){
                useSeriesColor = true;
            }

            return useSeriesColor ? (options.marker && options.marker.fillColor || point.color) : '#ffffff'
        },

        _onPointPress:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPress.call(point, ev);
            }
        },

        _onPointPressUp:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPressUp.call(point, ev);

                hoverPoint._onPointTap(ev);
            }
        },


        onClick:function(ev){
            var point = this, options = point.options;
            var clickFunc = options.onClick;
            if(clickFunc){
                BaseUtils.getFormatterFunction(clickFunc).call(point, ev);
            }
        },

        getEvents: function(){
            return {
                'mouseover':this._onPointMouseOver,
                'mouseout':this._onPointMouseOut,
                'mousemove':this._onPointMouseMove,
                'tap':this._onPointTap,
                'press':this._onPointPress,
                'pressup':this._onPointPressUp
            }
        },

        remove:function(){
            this.visible = false;
            this.graphic && this.graphic.remove();
            this.textGraphic && this.textGraphic.remove();
            this.leadLine && this.leadLine.remove();
            this.moreLabelG && this.moreLabelG.remove();

            this.clearPointEffect();

            this.graphic = this.textGraphic = this.moreLabelG = this.leadLine = null;
        },


        // FIXME
        // itself is removed from parent.children
        // thus the name 'clearChild' is confused
        clearChild: function(){
            var point = this;
            if(point.parent){
                var childs = point.parent.children;
                 childs && childs.splice(BaseUtils.indexOf(childs, point), 1);
            }
            if(point.children) {
                var len = point.children.length;
                while (--len > -1) {
                    point.children[len].clearChild();
                }
            }
            point.remove();
        },

        getTooltipRect:function(){
            var tooltip = this.series.vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);
            if(tooltip){
                return tooltip._tooltipRect;
            }
        }

    });

    return Point;
});

/**
 * Created by eason on 2017/3/6.
 * 标签内容的计算，从series里拿出来
 */

define('component/FormattedText',['require','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var LABEL_NAME_VALUE_GAP = 0.02;
    var isSupportSVG = BaseUtils.isSupportSVG();

    //format
    var SERIES = '{SERIES}', CATEGORY = '{CATEGORY}', X = '{X}', Y = '{Y}', NAME = '{NAME}', SIZE = '{SIZE}', DESCRIPTION = '{DESCRIPTION}';

    var VALUE = '{VALUE}', PERCENT = '{PERCENT}', ARRIVALRATE = '{ARRIVALRATE}', FROM = '{FROM.NAME}', TO = '{TO.NAME}';

    var PROCESSES = '{PROCESSES}', STARTTIME = '{STARTTIME}', FINISHTIME = '{FINISHTIME}', DURATION = '{DURATION}',
        PROGRESS = '{PROGRESS}', LEVEL = '{LEVEL}';

    var propMap = {};
    ["name", "category", "value", "processes", "startTime", "finishTime", "duration", "progress", "level", "arrivalRate"]
        .map(function (prop) {
            var key = '{' + prop.toUpperCase() + '}';
            propMap[key] = [prop, prop + 'Format'];
        });
    propMap[SERIES] = ['seriesName', 'seriesFormat'];
    propMap[PERCENT] = ['percentage', 'percentFormat'];

    var TOOLTIP_CATEGORY_STYLE =  '<span style="font-size:' + (isSupportSVG ? '1rem' : '16px') + ';font-family:Verdana;color:white;">';
    var TOOLTIP_SERIES_STYLE ='<span style="font-size:' + (isSupportSVG ? '0.875rem' : '14px') + ';font-family:Verdana;color:white">';
    var TOOLTIP_VALUE_STYLE = '<span style="font-size:' + (isSupportSVG ? '0.875rem' : '14px') + ';font-family:Verdana;font-weight:bold;color:white">';

    var LABEL_GAP = 2;

    function _getXYSizeString(point, formatter, identifier) {
        var options = point.options;
        var xString = BaseUtils.format(options.x, formatter.XFormat);
        var yString = BaseUtils.format(options.y, formatter.YFormat);
        var sizeString = options.size == '-' ? '-' : BaseUtils.format(options.size, formatter.sizeFormat);

        var text = '';

        if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1){
            text = '(';
            if(identifier.indexOf(X) != -1){
                text += xString;
                if(identifier.indexOf(Y) != -1){
                    text = text + ',' + yString;
                }
                text += ')';
            } else {
                text += yString;
                text += ')';
            }
            text += Constants.BLANK_VALUE_PERCENTAGE;
        }

        if(identifier.indexOf(SIZE) != -1 && sizeString != '-'){
            text += sizeString;
        }
        return text;
    }

    function calculateTextDim(labelContent, point){

        var outsideDim = labelContent && (labelContent.nameLabelContent || labelContent.valueLabelContent);

        if(outsideDim && point.series.type == 'funnel'){

            return calculateFunnelOutSideTextDim(point, labelContent);

        }else{
            var width = 0, height = 0;
            if(labelContent && labelContent.length){

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var dim = labelContent[i].dim;

                    width = Math.max(width, dim.width);

                    height += dim.height;
                }

                height += (count - 1) * LABEL_GAP;
            }

            return {width:width, height:height};

        }
    }

    function calculateFunnelOutSideTextDim(point, labelContent){

        var width = 0, height = 0, gapWidth = 0;

        if(labelContent.nameLabelContent){
            var dim = labelContent.nameLabelContent.dim;
            width += dim.width;
            height = Math.max(height, dim.height);
        }

        if(labelContent.valueLabelContent){
            var dim = labelContent.valueLabelContent.dim;
            width += dim.width;
            height = Math.max(height, dim.height);
        }

        if(labelContent.nameLabelContent && labelContent.valueLabelContent){
            var funnel = point.series, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;
            gapWidth = plotBounds.width * LABEL_NAME_VALUE_GAP;
            width += gapWidth;
        }

        return {
            width:width,
            height:height,
            nameValueGap:gapWidth
        };
    }

    function calculateSingleLineLabelContent(formatter, data){

        if(!formatter){
            return '';
        }

        if(typeof formatter == 'object'){
            var content = '';
            var label = formatter.identifier;
            var categoryString = BaseUtils.format(BaseUtils.pick(data.category, ''), formatter.categoryFormat);
            var seriesString = BaseUtils.format(BaseUtils.pick(data.seriesName, ''), formatter.seriesFormat);

            if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){
                if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                    content += (categoryString + ' ' + seriesString);
                }else if(label.indexOf(CATEGORY) != -1){
                    content += categoryString;
                }else{
                    content += seriesString;
                }
            }

            if(!data.isNull && label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                if(!BaseUtils.isEmpty(content)){
                    content += ':';
                }

                var valueString = BaseUtils.format(data[data.series.getTargetKey()], formatter.valueFormat);
                var percentString = BaseUtils.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                    content += (valueString + ' ' + percentString);
                }else if(label.indexOf(VALUE) != -1){
                    content += valueString;
                }else{
                    content += percentString;
                }
            }
            return content;
        }else{
            return BaseUtils.getFormatterFunction(formatter).call(data);
        }
    }

    function createMultiLineLabelContent(formatter, data){
        if(!formatter){
            return [];
        }

        if(typeof formatter == 'object'){
            var content = [];

            var label = formatter.identifier;
            var categoryString = BaseUtils.format(data.category, formatter.categoryFormat);
            var seriesString = BaseUtils.format(data.seriesName, formatter.seriesFormat);
            var valueString = BaseUtils.format(data.value, formatter.valueFormat);
            var percentString = BaseUtils.format(data.percentage, formatter.percentFormat);

            if(label.indexOf(CATEGORY) != -1){
                content.push(categoryString);
            }

            if(label.indexOf(SERIES) != -1){
                content.push(seriesString)
            }

            if(label.indexOf(VALUE) != -1){
                content.push(valueString);
            }

            if(label.indexOf(PERCENT) != -1){
                content.push(percentString);
            }

            return content;
        }else{
            return [BaseUtils.getFormatterFunction(formatter).call(data)];
        }
    }

    //标签
    function dataLabelGenerator(){
        function valid(point, dataLabels){
            dataLabels = dataLabels || point && point.options && point.options.dataLabels;

            return dataLabels && dataLabels.enabled && dataLabels.formatter && point.isVisible();
        }

        function calculateLabel(point, dataLabels){

            // 如果判断不通过直接return的话，那么图表里再计算的时候，都要判断过滤一下points，找了一下发现有点多，没敢那么改，怕出岔子
            if(!valid(point, dataLabels)){
                point.labelDim = { width: 0, height: 0 };   
                point.labelContent = [];
                return ;
            }

            dataLabels = dataLabels || point.options.dataLabels;

            var formatter = dataLabels.formatter;

            point.labelContent = typeof formatter == 'object' ? calculateNormalLabel(point, dataLabels) : calculateCustomLabel(point, dataLabels);

            point.labelDim = calculateTextDim(point.labelContent, point);
        }

        function defaultValueStyle(point, dataLabels){
            dataLabels = dataLabels || point.options.dataLabels;

            return dataLabels.style || BaseUtils.calculateFontSizeWithScale({
                fontSize:'0.75rem',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,0.15)',

                color: point.autoLabelColor(dataLabels)
            });
        }

        function calculateCustomLabel(point, dataLabels){

            dataLabels = dataLabels || point.options.dataLabels;

            var formatter = dataLabels.formatter, text = "";
            try{
                //用户自定义的，里面极有可能有抛错，如window.FR.contentFormat
                text = BaseUtils.getFormatterFunction(formatter).call(point);
            } catch (e){

            }

            var style = dataLabels.style || defaultValueStyle(point);
            var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);

            if(dataLabels.useHtml){
                dim.width = isNaN(parseFloat(dataLabels.labelWidth)) ? dim.width : parseFloat(dataLabels.labelWidth);
                dim.height = isNaN(parseFloat(dataLabels.labelHeight)) ? dim.height : parseFloat(dataLabels.labelHeight);
            }

            return [{text:text, style:style, dim:dim}];
        }

        function defaultCategoryStyle(point, dataLabels){
            // var shadowOpacity = position === Constants.OUTSIDE ? 0.1 : 0.15;
            dataLabels = dataLabels || point.options.dataLabels;

            return dataLabels.style || BaseUtils.calculateFontSizeWithScale({
                color: point.autoLabelColor(dataLabels),
                fontSize:'0.75rem',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0, 0.15)',
                fontWeight:'bold'
            });
        }

        function calculateNormalLabel(point, dataLabels){

            var series = point.series, type = series.type;

            if(series.vanchart.isMap()){
                return calculateMapLabel(point, dataLabels);
            }

            if(type == Constants.BUBBLE_CHART || type == Constants.SCATTER_CHART){
                return bubbleLabelContent(point);
            }else if(type == Constants.FUNNEL_CHART){
                return funnelLabelContent(point);
            }else{
                return defaultLabelContent(point, dataLabels);
            }
        }

        function bubbleLabelContent(point){

            var dataLabels = point.options.dataLabels, formatter = dataLabels.formatter, identifier = formatter.identifier;
            var content = [];

            if(identifier.indexOf(DESCRIPTION) != -1){
                var descriptionStyle = dataLabels.style || defaultCategoryStyle(point);
                var descriptionDim = BaseUtils.getTextDimension(point.options.description, descriptionStyle, dataLabels.useHtml);

                content.push({text:point.options.description, style:descriptionStyle, dim:descriptionDim});
            }

            if(identifier.indexOf(SERIES) != -1){
                var seriesString = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                var seriesStyle = dataLabels.style || defaultCategoryStyle(point);
                var seriesDim = BaseUtils.getTextDimension(seriesString, seriesStyle, dataLabels.useHtml);

                content.push({ text:seriesString, style:seriesStyle, dim:seriesDim});
            }

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1){
                var text = _getXYSizeString(point, formatter, identifier);
                var style = dataLabels.style || defaultValueStyle(point);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);
                content.push({text:text, style:style, dim:dim });
            }

            return content;
        }

        function funnelLabelContent(point) {
            var dataLabels = point.options.dataLabels, formatter = dataLabels.formatter, identifier = formatter.identifier;

            if(dataLabels.align == Constants.INSIDE) {
                return defaultLabelContent(point);
            }

            var funnel = point.series, content = [];
            if(identifier.indexOf(NAME) != -1){
                var nameString = BaseUtils.format(point.name, formatter.nameFormat);
                var nameStyle = defaultCategoryStyle(point);
                var nameDim = BaseUtils.getTextDimension(nameString, nameStyle, dataLabels.useHtml);

                content.nameLabelContent = {text:nameString, style:nameStyle, dim:nameDim};

                if(!funnel.maxNameLabelWidth){
                    funnel.maxNameLabelWidth = 0;
                }
                funnel.maxNameLabelWidth = Math.max(funnel.maxNameLabelWidth, nameDim.width);
            }

            if(identifier.indexOf(VALUE) != -1 || identifier.indexOf(PERCENT) != -1 || identifier.indexOf(ARRIVALRATE) != -1){
                var items = [];
                if(identifier.indexOf(VALUE) != -1){
                    items.push(BaseUtils.format(point.value, formatter.valueFormat));
                }
                if(identifier.indexOf(PERCENT) != -1){
                    items.push(BaseUtils.format(point.percentage, formatter.percentFormat));
                }
                if(identifier.indexOf(ARRIVALRATE) != -1){
                    items.push(BaseUtils.format(point.arrivalRate, formatter.arrivalRateFormat));
                }

                var text = items.join(Constants.BLANK_VALUE_PERCENTAGE);
                var style = defaultValueStyle(point);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);

                content.valueLabelContent = {text:text, style:style, dim:dim};

                if(!funnel.maxValueLabelWidth) {
                    funnel.maxValueLabelWidth = 0;
                }

                funnel.maxValueLabelWidth = Math.max(funnel.maxValueLabelWidth, dim.width);
            }
            return content;
        }

        function defaultLabelContent(point, dataLabels) {
            dataLabels = dataLabels || point.options.dataLabels;
            var series = point.series, formatter = dataLabels.formatter, identifier = formatter.identifier;

            var names = [NAME, CATEGORY, SERIES], values = [VALUE, PERCENT, ARRIVALRATE, LEVEL];

            var cateStyleFun = defaultCategoryStyle, valueStyleFun = defaultValueStyle;

            // adjust the sequence and style here
            if (series.type === Constants.TREEMAP_CHART) {
                values.unshift(names.shift());
                valueStyleFun = cateStyleFun;
            } else if (series.type === Constants.GANTT_CHART) {
                names = [];
                values = [PROCESSES, SERIES, STARTTIME, FINISHTIME, DURATION, PROGRESS];
            }

            var content = [];
            addContent(content, getContentItems(names), cateStyleFun);
            addContent(content, getContentItems(values), valueStyleFun);

            function getContentItems(items) {
                return items.map(fmtStr).filter(clean);
            }

            function fmtStr(item) {
                if (identifier.indexOf(item) !== -1) {
                    var propKey = propMap[item][0];
                    var fmtKey = propMap[item][1];
                    var value = series._formatValue ? series._formatValue(point, propKey) : point[propKey];
                    var fmt = formatter[fmtKey] || series._getLabelFormatFn && series._getLabelFormatFn(propKey);

                    var str = BaseUtils.format(value, fmt);

                    return series._postLabel ? series._postLabel(str, propKey) : str;
                }
                return null
            }

            function clean(item) { return item !== null; }

            function addContent(content, items, styleFun) {
                if (!items.length) {
                    return;
                }
                var text = items.join(Constants.BLANK_VALUE_PERCENTAGE);
                var style = styleFun(point, dataLabels);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);
                content.push({text: text, style: style, dim: dim });
            }

            return content;
        }

        function calculateMapLabel(point, dataLabels){

            if(!point || point.isNull || !dataLabels || !dataLabels.enabled){
                return {};
            }

            var formatter =  dataLabels.formatter, useHtml = dataLabels.useHtml;
            var chartType = point.series.type;

            var labelPosition = (chartType == Constants.SCATTER_CHART || chartType == Constants.POINT_MAP) ? Constants.OUTSIDE : Constants.INSIDE;

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(NAME) != -1){
                    var text = BaseUtils.format(point.name, formatter.nameFormat);
                    var style = defaultCategoryStyle(point, dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

                var line = '';
                var hasSeries = label.indexOf(SERIES) != -1, hasValue = label.indexOf(VALUE) != -1 || label.indexOf(SIZE) != -1, hasPercent = label.indexOf(PERCENT) != -1;
                var seriesLabel = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                var valueLabel = BaseUtils.format(point.getTargetValue(), formatter.valueFormat);
                var percentLabel = BaseUtils.format(point.percentage, formatter.percentFormat);
                if(hasSeries){
                    line += seriesLabel;
                    if(hasValue || hasPercent){
                        line += ':'
                    }
                }

                if(hasValue){
                    line += valueLabel;
                    if(hasPercent){
                        line += ' '
                    }
                }

                if(hasPercent){
                    line += percentLabel;
                }

                if(line){
                    var style = defaultValueStyle(point, dataLabels);
                    var dim = BaseUtils.getTextDimension(line, style, useHtml);
                    content.push({text:line, style:style, dim:dim});
                }
            }
            return content;
        }

        return calculateLabel;
    }


    function tooltipGenerator(){

        function valid(point){
            var tooltip = point.options.tooltip;
            return tooltip && tooltip.enabled && point.isVisible();
        }

        function shareValid(point){
            var tooltip = point.options.tooltip;
            return valid(point) && tooltip.shared;
        }

        function calculateTooltipContent(point){

            var series = point.series, type = series.type, tooltip = point.options.tooltip, formatter = tooltip.formatter;

            if(!(valid(point) || tooltip.shared )){
                return '';
            }


            if(typeof formatter !== 'object') {
                try{
                    //用户自定义的，里面极有可能有抛错，如window.FR.contentFormat
                    return BaseUtils.getFormatterFunction(formatter).call(point);
                } catch (e){
                    return '';
                }
            }

            var contentFn;
            switch (type) {
                case Constants.BUBBLE_CHART:
                case Constants.SCATTER_CHART:
                    contentFn = series.vanchart.isMap() ? defaultTooltipContent : bubbleTooltipContent;
                    break;
                case Constants.TREEMAP_CHART:
                    contentFn = treeMapTooltipContent;
                    break;
                case Constants.GANTT_CHART:
                    contentFn = ganttTooltipContent;
                    break;
                case Constants.LINE_MAP:
                    contentFn = lineMapTooltipContent;
                    break;
                default:
                    contentFn = defaultTooltipContent;
            }

            return contentFn(point, tooltip);
        }


        function bubbleTooltipContent(point, tooltip){
            var series = point.series, formatter = tooltip.formatter;
            var style = tooltip.style, identifier = formatter.identifier;

            var content = '';

            content += _createBubbleTooltipSeriesLine(point, identifier, style, formatter);

            content += _createBubbleTooltipXYSizeLine(point, identifier, style, formatter);

            return content;
        }

        //提示的第一行：气泡的系列
        function _createBubbleTooltipSeriesLine(data, identifier, style, formatter){
            var content = '';

            if(identifier.indexOf(SERIES) != -1){

                var seriesString = BaseUtils.format(data.seriesName, formatter.seriesFormat);
                seriesString = _escapeString(seriesString);
                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        }

        // //提示的第二行：气泡的X、Y、SIZE
        function _createBubbleTooltipXYSizeLine(data, identifier, style, formatter){
            var content = '';
            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1) {
                var text = _getXYSizeString(data, formatter, identifier);
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + text + '</span>';
            }

            return content;
        }

        function treeMapTooltipContent(point, tooltip){
            var style = tooltip.style, formatter = tooltip.formatter, identifier = formatter.identifier;

            var content = '';

            if (tooltip.shared) {
                if (identifier.indexOf(NAME) != -1) {
                    var p, d = point, points = [point.name];
                    while ((p = d.parent) && p.depth) {
                        d = p;
                        points.unshift(p.name);
                    }
                    content += (style ? '<span>' : TOOLTIP_CATEGORY_STYLE) + points.join(' / ') + '</span><br>';
                }
                content += _createSeriesLine(point, identifier, style, formatter);
            } else {

                content += _createCategoryLine(point, identifier, style, formatter);

                content += _createSeriesLine(point, identifier, style, formatter);
            }

            return content;
        }

        function ganttTooltipContent (point, tooltip) {
            var style = tooltip.style, formatter = tooltip.formatter, identifier = formatter.identifier;
            var series = point.series;

            var names = [PROCESSES, SERIES, STARTTIME, FINISHTIME, DURATION, PROGRESS];

            var content = '';

            function fmtStr(item) {
                if (identifier.indexOf(item) !== -1) {
                    var propKey = propMap[item][0];
                    var fmtKey = propMap[item][1];
                    var value = series._formatValue ? series._formatValue(point, propKey) : point[propKey];
                    var fmt = formatter[fmtKey] || series._getTooltipFormatFn && series._getTooltipFormatFn(propKey);

                    var str = BaseUtils.format(value, fmt);

                    return series._postTooltip ? series._postTooltip(str, propKey) : str;

                }
                return null
            }

            names.map(function (item) {
                var str = fmtStr(item);
                if (str != null) {
                    content += (style ? '<span>' : TOOLTIP_SERIES_STYLE) + str + '</span><br>';
                }
            });

            return content
        }


        function defaultTooltipContent(point, tooltip){
            var series = point.series, vanchart = series.vanchart, points = point.points;

            var formatter = tooltip.formatter, identifier = formatter.identifier, style = tooltip.style;

            var content = '';

            if(tooltip.shared && points && points.length){
                //当有地图的时候,不可见的点的数据点提示也要展示
                var hasMap = vanchart.isMap(), hasRangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

                content += _createCategoryLine(point, identifier, style, formatter);

                //todo 这里points的过滤比较乱，没有统一地图的过滤
                points
                    .filter(shareValid)
                    .forEach(function(p){
                        var dotColor = (hasMap && hasRangeLegend) ? points[0].color : p.color;

                        var tooltip = p.options.tooltip;

                        content += '<span style="font-size:' + (isSupportSVG ? '0.75rem' : '12px') + ';font-style:normal; color: ' + dotColor + ';opacity:' + p.opacity + '">'+'&#9679  '+'</span>';

                        // CHART-867
                        // 共享设置只有formatter不同
                        // 其他取第一个系列
                        content += _createSeriesLine(p, identifier, style, tooltip.formatter);

                        content += '<br />';
                    });

            }else{

                content += _createCategoryLine(point, identifier, style, formatter);
                content += _createSeriesLine(point, identifier, style, formatter);

            }

            return content;
        }

        function _createCategoryLine(point, label, style, formatter){
            var content = '', type = point.series.type;


            if (type === Constants.MULTIPIE_CHART) {
                if (label.indexOf(SERIES) != -1) {
                    content = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                }
            }else{
                if (label.indexOf(CATEGORY) != -1) {
                    content = BaseUtils.format(point.category, formatter.categoryFormat);
                }

                if (label.indexOf(NAME) != -1 && type !== Constants.WORD_CLOUD_CHART) {
                    content = BaseUtils.format(point.name, formatter.nameFormat);
                }
            }

            if(content){
                content = _escapeString(content);
                content = (style ? '<span>' : TOOLTIP_CATEGORY_STYLE) + content +'</span>';
                content += '<br />';
            }

            return content;
        }
        
        function _escapeString(string) {
            if(string){
                return string.replace(/</g,"&lt").replace(/>/g, "&gt");
            }
            return string;
        }

        function _createSeriesLine(point, label, style, formatter){
            var content = '', type = point.series.type;

            var pointValue = point.isNull ? "" : point.value,
                pointPercent = point.isNull ? "" : point.percentage;  //@chart-1091:对于为Null且需要显示的数据点，其对应的数据点提示中的value和percent应该为""

            if(type === Constants.STRUCTURE_CHART && pointValue === "-"){
                pointValue = ""; // @CHART-1379
            }

            var valueString = BaseUtils.format(pointValue, formatter.valueFormat);
            var percentString = BaseUtils.format(pointPercent, formatter.percentFormat);
            var levelString = BaseUtils.format(point.level, formatter.levelFormat);
            var textString;

            var valuesMap = {};
            valuesMap[SIZE] = valueString;
            valuesMap[VALUE] = valueString;
            valuesMap[PERCENT] = percentString;
            valuesMap[LEVEL] = levelString;

            if (type === Constants.MULTIPIE_CHART || type === Constants.WORD_CLOUD_CHART) {
                if (label.indexOf(NAME) != -1) {
                    textString = BaseUtils.format(point.name, formatter.nameFormat);
                }
            }else {
                if (label.indexOf(SERIES) != -1) {
                    textString = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                }
            }

            var valueArray = [VALUE, PERCENT, LEVEL];

            if(type == Constants.BUBBLE_CHART || type == Constants.SCATTER_CHART){
                valueArray = [SIZE, PERCENT, LEVEL];
            }

            var valuesString = valueArray
                .filter(function (k) { return label.indexOf(k) !== -1 && !BaseUtils.isEmpty(valuesMap[k])})
                .map(function (k) { return valuesMap[k] })
                .join('  ');

            if (textString && valuesString) {
                textString += ':';
            }

            textString = _escapeString(textString);
            if (textString) {
                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + textString +'</span>';
            }
            if (valuesString) {
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + valuesString +'</span>';
            }

            return content;
        }

        function lineMapTooltipContent (point, tooltip){
            if(!tooltip || !tooltip.enabled){
                return;
            }
            var formatter = tooltip.formatter, content = '';
            if(typeof formatter == 'object'){
                var style = tooltip.style, label = formatter.identifier;

                content += _lineMapCreateCategoryLine(point, label, style, formatter);
                content += _lineMapCreateSeriesLine(point, label, style, formatter);

            }else{
                content = BaseUtils.getFormatterFunction(formatter).call(point);
            }

            return content;
        }

        function _lineMapCreateCategoryLine (point, label, style, formatter) {
            var content = '';

            if(label.indexOf(SERIES) != -1){

                var seriesString = BaseUtils.format(point.seriesName, formatter.seriesFormat);

                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        }

        function _lineMapCreateSeriesLine (point, label, style, formatter){
            var content = '';

            var hasTag = function (tag) {
                return label.indexOf(tag) !== -1
            };

            var names = [];
            var options = point.options;
            if (hasTag(FROM)) {
                options.from.name && names.push(options.from.name);
            }
            if (hasTag(TO)) {
                options.to.name && names.push(options.to.name);
            }
            if (names.length) {
                content += (style ? '<span>' : TOOLTIP_SERIES_STYLE) + names.join('→') + '</span>&nbsp;';
            }

            var values = [];
            if (hasTag(VALUE)) {
                var valueString = BaseUtils.format(point[point.series.getTargetKey()], formatter.valueFormat);
                valueString && values.push(valueString);
            }
            if (hasTag(PERCENT)) {
                var percentString = BaseUtils.format(point.percentage, formatter.percentFormat);
                percentString && values.push(percentString);
            }
            if (values.length) {
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + values.join('&nbsp;&nbsp;') + '</span>';
            }

            return content;
        }

        return calculateTooltipContent;
    }


    return {
        calculateSingleLineLabelContent:calculateSingleLineLabelContent,
        createMultiLineLabelContent:createMultiLineLabelContent,
        calculateTextDim:calculateTextDim,
        dataLabelGenerator:dataLabelGenerator(),
        tooltipGenerator:tooltipGenerator()
    }

});
/**
 * Created by eason on 16/2/19.
 * 系列的抽象
 */
define('chart/Series',['require','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../Constants','./Point','../dom/Evented','../utils/BezierEasing','../utils/PathGenerator','../ComponentLibrary','../vector/CanvasRenderer','../component/FormattedText','../utils/Timer'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');
    var BezierEasing = require('../utils/BezierEasing');
    var PathGenerator = require('../utils/PathGenerator');
    var ComponentLibrary = require('../ComponentLibrary');
    var CanvasRenderer = require('../vector/CanvasRenderer');
    var FormattedText = require('../component/FormattedText');
    var Timer = require('../utils/Timer');

    var ANIMATION_TIME = 600;
    var EASE_TYPE = 'quad-out';

    var Series = Evented.extend({

        initialize:function(options, vanchart, index){

            this.vanchart = vanchart;

            this.points = [];

            this.refresh(options, index);
        },

        refresh:function(options, index){

            var vanchart = this.vanchart, type = options.type || vanchart.options.chartType;
            var plotOptions = vanchart.options.plotOptions;
            var queryList = [options, plotOptions[type], plotOptions];

            this.minSize = QueryUtils.queryList(queryList, 'minSize');
            this.maxSize = QueryUtils.queryList(queryList, 'maxSize');

            //标记点颜色确认需要
            this.originalColor = options.color;this.originalMarkerFillColor = options.marker && options.marker.fillColor;

            this.interpolate = this._getSeriesInterpolate(queryList);

            options = this.options = BaseUtils.createOptions(options, [plotOptions[type], plotOptions]);

            this.type = type;//不能写在prototype里，pointMap，heatMap，areaMap用的一个series
            this.stack = options.stack;
            this.index = index; this.className = 'vancharts-series-' + index;
            this.name = BaseUtils.pick(options.name, Constants.BLANK_VALUE_PERCENTAGE);
            this.visible = BaseUtils.pick(options.visible, true);  // 理解有误，应该是默认就为true的，不应该使用之前的visible
            this.state = this.visible ? Constants.STATE_SHOW : Constants.STATE_DROPPED;

            var hexAlpha;
            if (!this.isSeriesAccumulated() && this.type != Constants.STRUCTURE_CHART) {
                var color = this.options.color || vanchart.getDefaultSeriesColor(this.name);
                var opacity = options.opacity;
                hexAlpha = ColorUtils.getStandardColorAndOpacity(color, opacity);

                color = hexAlpha.hex;
                opacity = hexAlpha.alpha;

                var fillColor = this.options.fillColor;
                fillColor = fillColor === true ? color : fillColor;
                var fillColorOpacity = +options.fillColorOpacity;
                fillColorOpacity = isNaN(fillColorOpacity) ? this._getDefaultFillColorOpacity() : fillColorOpacity;

                hexAlpha = ColorUtils.getStandardColorAndOpacity(fillColor, fillColorOpacity);
                fillColor = hexAlpha.hex;
                fillColorOpacity = hexAlpha.alpha;

                //shine:clone原因：
                // 1.散点图无标记点类型时，各个系列循环不同标记点，需要clone一份，再改symbol。
                // 2.marker的color和alpha都会改变
                var marker = options.marker = BaseUtils.clone(options.marker);
                if (BaseUtils.hasDefined(marker)) {
                    var colorAlpha = this._getMarkerColorAlpha();
                    marker.fillColor = colorAlpha.markerColor;
                    marker.fillColorOpacity = colorAlpha.markerOpacity;

                    if(this.type == Constants.SCATTER_CHART && BaseUtils.isNullMarker(marker)){
                        options.marker.symbol = BaseUtils.getDefaultMarkerSymbol(index);
                    }
                }


                this.color = color; this.opacity = opacity;
                this.fillColor = fillColor; this.fillColorOpacity = fillColorOpacity;
                this.marker = marker;
            }

            if(BaseUtils.hasDefined(this.options.startAngle)){
                var startAngle = this.options.startAngle,
                    endAngle = this.options.endAngle;
                if(startAngle > endAngle){
                    startAngle -= 360;
                }else if(startAngle === endAngle){
                    endAngle = startAngle + 360;
                }
                this.startAngle = BaseUtils.toRadian(startAngle);
                this.endAngle = BaseUtils.toRadian(endAngle);
            }

            //bind Axis
            this._bindAxis();

            if (this._loadData) {
                var data = this._loadData(options.data);
            } else {
                var data = options.data || [];
            }

            // so dirty...
            if (!this.isTreeSeries()) {
                this._dealData(data);
            }

            return this;
        },

        _dealData: function (data) {
            var newPoints = [], series = this, pointsMap = {};
            var vanchart = this.vanchart, type = this.type;
            this.points.forEach(function(point){
                // todo
                // _getPointKey: point here, data[i] below?
                var key = series._getPointKey(point);
                pointsMap[key] = pointsMap[key] || [];
                pointsMap[key].push(point);
            });

            for(var i = 0, len = data.length; i < len; i++){
                var key = series._getPointKey(data[i]), pointArray = pointsMap[key];
                var point = null;
                if(pointArray){

                    for(var j = 0, count = pointArray.length; j < count; j++){
                        if((point = pointArray[j])){
                            pointArray[j] = null;
                            break;
                        }
                    }

                    if(point){
                        //clear states
                        point._lastValue = point.options[series.getTargetKey()];
                        point._lastPercent = point.percentage;
                        point._lastArrivalRate = point.arrivalRate;
                        point.drillSeries = null;
                        point.geo = null;
                        //set new data
                        point.refresh(data[i]);
                    }
                }

                if(!point){
                    point = new Point(data[i], this);
                }

                newPoints.push(point);
            }

            for(var key in pointsMap){
                pointsMap[key] && pointsMap[key].forEach(function(p){
                    vanchart.removePointGraphics(p, type);
                });
            }

            if(this.options.sort){
                //漏斗图的数据是有序的
                newPoints= newPoints.filter(function (point) {return !point.isNull;})
                    .sort(function (pointA, pointB) {
                        return Math.abs(pointB.getTargetValue()) - Math.abs(pointA.getTargetValue());
                    })
            }

            this.points = newPoints;
        },

        _getPointKey: function (point) {
            // 系列基于多分类轴时，使用字符串格式的categoryArray
            if(this.isMultiCategoryAxisBased()){
                return BaseUtils.encodeCategoryArray(point.categoryArray);
            }

            return point.x;
        },

        /**
         * @Cmen:判断系列是否基于多分类轴:
         * 之前的想法是，直接使用vanchart.isMultiCategoryBased()来判断图表是否基于多分类轴
         * 这种判断是不准确的，baseAxis应该是相对于系列而言的，尤其是多坐标轴的时候
         * @returns {boolean}
         */
        isMultiCategoryAxisBased: function (){
            var baseAxisType = this.getBaseAxisType();
            var axis = this.vanchart[baseAxisType](this.options[baseAxisType]);

            return axis && axis.isMultiCateAxis && axis.isMultiCateAxis();
        },

        //不在options的原因：radar和columnRadar不同
        _getDefaultFillColorOpacity: function () {
            return 1;
        },

        getStackAxis:function(){
            return this[this.getTargetKey() + 'Axis'];
        },

        isNullValue:function(point){
            var originValue = point.options[point.series.getTargetKey()];
            return  originValue == '-' || BaseUtils.hasNotDefined(originValue);
        },

        _getMarkerColorAlpha: function () {

            var vanchart = this.vanchart, options = this.options;
            var plotOptions = vanchart.options.plotOptions, _options = plotOptions[this.type];
            var plotOptionsMarker = (_options && _options.marker) || plotOptions.marker;
            var opacity = options.opacity, seriesMarker = options.marker;

            var _markerColor = (seriesMarker && seriesMarker.fillColor) ||
                this.options.color ||
                (plotOptionsMarker && plotOptionsMarker.fillColor) ||
                vanchart.getDefaultSeriesColor(this.name);

            var _markerOpacity = opacity;

            if(BaseUtils.hasDefined(_markerColor)){
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, opacity);
                _markerColor = hexAlpha.hex;
                _markerOpacity = hexAlpha.alpha;
            }

            return{
                markerColor:_markerColor,
                markerOpacity:_markerOpacity
            }
        },

        _bindAxis:function(){
            var series = this,
                seriesOptions = series.options,
                vanchart = series.vanchart;

            series._getAxisTypes().forEach(function(axisType){

                if(vanchart[axisType]){
                    var targetAxis = vanchart[axisType](seriesOptions[axisType]);
                    if(targetAxis){
                        targetAxis.series.push(series);
                        series[axisType] = targetAxis;
                    }
                }

            });
        },

        supportTooltipShared:function(){
            return this.xAxis || this.yAxis || this.angleAxis;
        },

        _getAxisTypes:function(){
            return ['xAxis', 'yAxis'];
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'y';
        },

        //图形坐在的那个坐标轴的key
        getBaseAxisType: function () {
            return 'xAxis';
        },

        _calculateAutoLabelPos:function(point, pos, isVertical, manager, rightBottom){

            var step = 3; //自动调整的时候每次3px
            //先测试一下从上往下的效果
            var labelDim = point.labelDim, plotBounds = this.vanchart.bounds;

            function verticalPosFix(start, end, step, labelDim){
                for(var y = start; (step < 0 ? y > end : y < end); y += step){
                    var labelPos = {x: pos.x, y: y};
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim))){
                        return labelPos;
                    }
                }
            }

            function horizontalFix(start, end, step, labelDim){
                for(var x = start; (step < 0 ? x > end : x < end); x += step){
                    var labelPos = {x:x, y: pos.y};
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim))){
                        return labelPos;
                    }
                }
            }

            var testPos;
            if(isVertical){
                var startY, endY;

                if(BaseUtils.hasDefined(rightBottom)){
                    if(rightBottom){
                        //往下
                        startY = Math.max(0, pos.y);
                        endY = plotBounds.height - labelDim.height;
                        testPos = verticalPosFix(startY, endY, step, labelDim);
                    }else{
                        endY = 0;
                        startY = Math.min(pos.y, plotBounds.height - labelDim.height);
                        testPos = verticalPosFix(startY, endY, -step, labelDim);
                    }
                }else{
                    //往下
                    startY = Math.max(0, pos.y);
                    endY = plotBounds.height - labelDim.height;
                    testPos = verticalPosFix(startY, endY, step, labelDim);

                    //往上
                    if(!testPos){
                        endY = 0;
                        startY = Math.min(pos.y, plotBounds.height - labelDim.height);
                        testPos = verticalPosFix(startY, endY, -step, labelDim);
                    }
                }

            }else{
                var startX, endX;

                if(BaseUtils.hasDefined(rightBottom)){
                    if(rightBottom){
                        //往右
                        startX = Math.max(0, pos.x);
                        endX = plotBounds.width - labelDim.width;
                        testPos = horizontalFix(startX, endX, step, labelDim);
                    }else{
                        endX = 0;
                        startX = Math.min(pos.x, plotBounds.width - labelDim.width);
                        testPos = horizontalFix(startX, endX, -step, labelDim);
                    }
                }else{

                    //往右
                    startX = Math.max(0, pos.x);
                    endX = plotBounds.width - labelDim.width;
                    testPos = horizontalFix(startX, endX, step, labelDim);

                    //往左
                    if(!testPos){
                        endX = 0;
                        startX = Math.min(pos.x, plotBounds.width - labelDim.width);
                        testPos = horizontalFix(startX, endX, -step, labelDim);
                    }

                }
            }

            return testPos ? testPos : pos;
        },

        _getArcPoint:function(r, radian){
            return [this._dealWithFloat(r * Math.sin(radian)), this._dealWithFloat(-r * Math.cos(radian))]
        },

        _getNormalTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];
            var key = this.vanchart.isInverted() ? 'posY' : 'posX';
            var location = this.vanchart.isInverted() ? Constants.LEFT : Constants.BOTTOM;

            sery.points.sort(function(p1, p2){
                return p1[key] - p2[key];
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.posX);
                    yValues.push(point.posY);
                }

            });

            return [xValues, yValues, location];
        },

        _getSeriesInterpolate: function(queryList){
            var step = QueryUtils.queryList(queryList, 'step');
            var curve = QueryUtils.queryList(queryList, 'curve');
            var options = queryList[0];

            var interpolate = 'linear';
            if(options.step || (step && !options.curve)){
                interpolate = 'step-after'
            }else if(options.curve || (curve && !options.step)){
                interpolate = 'cardinal';
            }
            return interpolate;
        },

        _getAngle:function(current, center){

            center = center || {x:0, y:0};

            return Math.atan2(current.y - center.y, current.x - center.x) / (Math.PI / 180);
        },

        _getBackgroundColor:function(){

            var opt = this.vanchart.options;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        getSeryTotalValue:function(){
            var total = 0;

            this.points.forEach(function(point){
                total += point.getTargetValue();
            });

            return total;
        },

        getLegendKey:function(point){
            return this.isSeriesAccumulated() ? point.name : this.name;
        },

        calculateLabelInfo:function(point){
            FormattedText.dataLabelGenerator(point);
        },

        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        isSupportLegendHighlight:function(){
            return true;
        },

        isSeriesAccumulated:function(){
            return false;
        },

        isTreeSeries:function(){
            return false
        },

        /**
         * 增加新的point
         * @param {[type]} options [description]
         * @param {[type]} redraw  [description]
         */
        addPoint: function (options, redraw){
            var data = this._getOriginSerData();
            var vanchart = this.vanchart;

            // todo 多分类轴下等情况下，需要重新计算dataDomain
            data.push(options);
            redraw && vanchart.update();
        },

        /**
         * 移除单个point
         * @param  {[type]} index  [description]
         * @param  {[type]} redraw [description]
         * @return {[type]}        [description]
         */
        removePoint: function(index ,redraw){
            if (index < 0) { return; }
            var series = this, vanchart = this.vanchart, data = this._getOriginSerData();
            var serIndex = vanchart.series.indexOf(series);

            data.splice(index, 1);
            series.options.data.splice(index, 1);

            if(data.length === 0) {
                series.remove();
                vanchart.series.splice(serIndex, 1);
                vanchart.options.series.splice(serIndex, 1);
            }

            redraw && vanchart.update();
        },

        /**
         * 更新单个point的数据信息
         * @param  {[type]} index  [description]
         * @param  {[type]} option [description]
         * @param  {[type]} redraw [description]
         * @return {[type]}        [description]
         */
        updatePoint: function (index, option, redraw) {
            if(index < 0) { 
                return; 
            } 
            var vanchart = this.vanchart, data = this._getOriginSerData();
            data[index] = option;

            redraw && vanchart.update();
        },

        /**
         * 计算数据点的option在对应的vanchart.series中具体series中的索引
         * 更具该索引，便可以更新和删除该数据点
         * @param option
         * @returns {number}
         */
        calculatePointIndex: function (option){
            var series = this, vanchart = this.vanchart, pos = -1,index = 0;
            var data = this._getOriginSerData();

            var clone = BaseUtils.clone;

            // 计算坐标点
            var toLnglatPoint = function (option){
                if(option.lnglat) {
                    return option;
                }
                var Geo = vanchart.getCurrentGeo();
                var lnglat = Geo.getFeaturesByName(option.name, series.type);
                var newOption = clone(option);   // 只用作判断依据，不修改原始数据
                newOption.lnglat = lnglat;
                return lnglat && newOption;
            };

            var isLineMap = series.type === Constants.LINE_MAP;

            // 这种坐标数据中不存在name的直接返回，不继续算了
            if(isLineMap && (!toLnglatPoint(option.from) || !toLnglatPoint(option.to))){
                return -1;
            }

            // 重新构建一个新的option，用于_getPointKey
            var reBuildOption = function(option){
                if(isLineMap) {
                    var newOption = clone(option);
                    newOption.from = toLnglatPoint(option.from);
                    newOption.to = toLnglatPoint(option.to);
                    return newOption.from && newOption.to && newOption;
                }
                return option;
            };

            var op1, op2;
            while(index < data.length) {
                op1 = reBuildOption(option);
                op2 = reBuildOption(data[index]);
                if(!op1 || !op2){
                    index++;   // 这里不应该跳出，而是继续下一个while
                    continue;
                }
                var key = series._getPointKey(op1);
                var pointKey = series._getPointKey(op2);
                if(key === pointKey) { 
                    pos = index; 
                    break; 
                } 
                index++; 
            } 
 
            return pos; 
        },

        /**
         * @Cmen:监控刷新时，有个比较尴尬的问题：
         * 现在的图表绘制，都是直接使用初始的OriginOption，直接使用，这就导致第一次绘制结束，OriginOption里面的series已经被修改(扩展)了，
         * 而监控刷新时那些未发生值变化的数据，却依旧使用OriginOption.series，而此时的这个series已经被扩展了一些方法和属性，
         * 这就导致某些属性诸如markerFillColor等不能被更新,因此在监控刷新时，应该修改原始数据，
         * 而绘图的时候，使用原始数据的拷贝，不对原始的series进行属性和方法扩展
         */
        _getOriginSerData: function (){
            var series = this, vanchart = this.vanchart, originSeriesData = vanchart.options.series;
            var serIndex = vanchart.series.indexOf(series);
            return serIndex < 0 ? [] : originSeriesData[serIndex].data;
        }
    });


    //view related
    Series.include({

        getClosestPoint:function(){
            return null;
        },

        getTooltipPos:function(point, divDim, event){
            var leftTopPos;
            if(point.options.tooltip.follow){
                var pos = event.containerPoint;
                leftTopPos = [pos.x + 10, pos.y + 10];
            }else{
                leftTopPos = this._getFixedPos(point, divDim);
            }

            if(!leftTopPos){
                return;
            }

            //调整位置
            var chartBounds = this.vanchart.getChartBounds();
            var top = chartBounds.y, left = chartBounds.x;
            var bottom = chartBounds.y + chartBounds.height;
            var right = chartBounds.x + chartBounds.width;
            var x = leftTopPos[0], y = leftTopPos[1];

            if(x < left){
                x += (left - x);
            }else if(x + divDim.width > right){
                x -= (x + divDim.width - right);
            }

            if(y < top){
                y += (top - y);
            }else if(y + divDim.height > bottom){
                y -= (y + divDim.height - bottom);
            }

            return [x, y];
        },

        //统一处理渐变色,图片填充,阴影等情况,默认就返回颜色
        getFillFilter:function(color){
            return color;
        },

        filterRender: function () {
            this.useCanvas() ? this._canvasRender() : this._svgFilterRender();
        },

        render:function(){
            this.useCanvas() ? this._canvasRender() : this._svgRender();
        },

        useCanvas: BaseUtils.falseFn,

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.clipSeriesGroup);
        },

        _svgRender:function(){

            //todo 这个临时变量应该可以规避
            this.initialAnimationMoving = !this.group;

            var vanchart = this.vanchart, renderer = vanchart.renderer;
            if(!this.group){
                this.group = this._createGroup(renderer, vanchart).style('cursor', this._pointerStyle())
                    .attr('transform', BaseUtils.makeTranslate(this._getTranslate()))
                    .attr('class', this.className + ' ' + this.type);
            }

            //对于可以自定义位置的如雷达图,仪表盘这边的translate不是绘图取
            if(this.type == Constants.GAUGE_CHART){
                this.group.animate({
                    duration:ANIMATION_TIME, ease:EASE_TYPE, attr:{transform:BaseUtils.makeTranslate(this._getTranslate())}
                });
            }else{
                this.group.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            this.drawSeries && this.drawSeries();

            this.drawPoints();
        },

        _svgFilterRender:function(){
            var series = this;

            //todo：@eason 拖拽范围图例filter一部分点后，缩放的时候visible==false的点会被remove掉

            series.getDataToDraw().forEach(function(point){
                if (point.isVisible()) {
                    point.graphic && point.graphic.style({'display': 'inline'});

                    if(!point.textGraphic){
                        series._createTextGraphic(point);
                    }

                    if(!point.effectGraphic){
                        series.drawPointEffect(point);
                    }
                } else {
                    point.graphic && point.graphic.style({'display': 'none'});
                    point.textGraphic && point.textGraphic.remove();
                    point.textGraphic = null;

                    point.clearPointEffect();
                }
            });
        },

        _canvasRender:function(){
            if(!this._canvas){
                this._canvas = new CanvasRenderer(this.vanchart.dom, this.vanchart);
                this._canvas.onAdd();
            }
            this._canvas.clearAll();
            this._canvas.addSeries(this);
        },

        _pointerStyle:function(){

            // point为null时，设计器导出时是没有hyperlink和onClick属性的，这里过滤一下
            var validPoints = this.points.filter(function (p){
                return !p.isNull;
            });

            return validPoints[0] && validPoints[0].options.onClick ? 'pointer' : '';
        },

        getDataToDraw: function () {
            return this.points;
        },

        getTextDataToDraw: function () {
            return this.getDataToDraw();
        },

        updatePointGraphic:function(point){

        },

        _updateMarkerPointGraphic:function(point){
            var group = point.graphic, marker = point.options.marker, markerType = marker.symbol;

            if(!group){
                return;
            }
            // 每次都重新画
            group.strokePath && group.strokePath.remove();
            group.fillPath && group.fillPath.remove();
            group.markerPath && group.markerPath.remove();
            group.image && group.image.remove();

            group.strokePath = group.fillPath = group.markerPath = group.image = null;

            this._createMarker(marker, group);
        },

        // 现在的处理方式是全部重新写一遍
        drawPoints:function(){
            var series = this, vanchart = series.vanchart;
            var graphicGroup = this._getPointGraphicGroup();

            graphicGroup && vanchart.registerInteractiveTarget(this, graphicGroup);

            if (this.initialAnimationMoving && this.initialAnimation) {
                this.initialAnimation();
            }

            var delay = this._calculateAnimationDelay();
            var points = series.getDataToDraw();
            for(var i = 0, len = points.length; i < len; i++){
                series.drawPoint(points[i], delay);
            }

        },

        _drawEffectPoints:function () {
            var series = this;
            series.getTextDataToDraw()
                .forEach(function(point){
                    series.drawPointEffect(point);
                });
        },

        drawPointEffect:function (point) {
            var series = point.series;

            point.clearPointEffect();

            var time = point.getEffectTime();
            if(time) {//shine:0秒没有effect动画
                series.effectAnimation(point);
                point.effectInterval = setInterval(function () {
                    series.effectAnimation(point)
                }, time);
            }
        },

        effectAnimation:function () {
        },

        _drawUpdatePoints: function (point, delay) {
            this._updatePointGraphicStyle(point);   // 更新颜色

            // 大量数据情形下缩放，直接更新attr，不加动画了
            if(this.vanchart.isZoomingWithLargeModel()) {
                point.graphic.attr(this.getPointUpdateAnimationAttr(point, delay).attr);
            } else {
                point.graphic.animate(this.getPointUpdateAnimationAttr(point, delay));
            }

            this.vanchart.registerInteractiveTarget(point, point.graphic);  // 更新映射关系
        },

        _drawEnterPoints: function (point) {
            var series = this, group = series._getPointGraphicGroup();

            var graphic = point.graphic = this._createPointGraphic(point);

            series._updatePointGraphicStyle(point);

            var reShow = series.reShowPoint(point);

            var attrFun = reShow && series.getPointReShowAttr ? series.getPointReShowAttr : series.getPointInitAttr;
            var styleFun = reShow && series.getPointReShowStyle ? series.getPointReShowStyle : series.getPointInitStyle;
            var animateFun = reShow && series.getPointReShowAnimationAttr ? series.getPointReShowAnimationAttr : series.getPointInitAnimationAttr;
	
			// todo 折线图这里会导致标记点在折线的前面
            point.hasEffect() ? graphic.addTo(group) : graphic.addToBack(group);

            graphic.attr(attrFun ? attrFun.call(series, point) : {})
                .style(styleFun ? styleFun.call(series, point) : {})
                .animate(animateFun ? animateFun.call(series, point) : {});

            series.vanchart.registerInteractiveTarget(point, graphic);
        },

        _drawExitPoints: function (point) {
            var series = point.series;
            if(series.getPointDropAnimationAttr){
                point.graphic.animate(series.getPointDropAnimationAttr(point)).remove();
            } else {
                point.graphic.remove();
            }
        },

        // todo
        // 范围图例导致复杂判断
        // TreeSeries 目前覆盖了这个方法
        // 理清逻辑 或者 加测试
        drawPoint:function (point, delay) {

            delay = delay || 0;

            var shouldBeVisible = point.isVisible();
            var currentVisibleState = point.graphic && point.graphic.isVisible();

            if (shouldBeVisible === currentVisibleState){

                point.graphic && this._drawUpdatePoints(point, delay);

            } else if (shouldBeVisible && !currentVisibleState) {

                if(point.graphic && !point.graphic.removed()){
                    point.graphic.style('display','inline');
                    this._drawUpdatePoints(point, delay)
                }else{
                    this._drawEnterPoints(point);
                }

            } else if (!shouldBeVisible && currentVisibleState){

                this._drawExitPoints(point);

            }
        },

        _getEffectTime:function (point) {
            return isNaN(point.options.effect.period) ? point.series.getDefaultEffectTime() : point.options.effect.period;
        },

        _getPointEffectGroup:function (point) {
            var series = point.series, renderer = series.vanchart.renderer;
            return point.effectGraphic = point.effectGraphic || renderer.group().addTo(series._getPointGraphicGroup()).style('pointer-events', 'none');
        },

        _createPointGraphic:function(point){
            var graphicKey = this.getPointGraphicKey(point), renderer = this.vanchart.renderer;
            return renderer[graphicKey]();
        },

        getStyle:function(p){
            var options = p.options, series = p.series;
            return {
                'fill':series.getFillFilter(p.color, p),
                'fill-opacity':options.image ? 1 : p.opacity,
                'stroke':p.borderColor,
                'stroke-opacity':p.borderOpacity,
                'stroke-width':options.borderWidth,
                'filter':'none'
            };
        },

        _getDynamicStyle: function (point) {
            var style = this.getStyle(point);

            var target = this.vanchart.highlightTarget;
            if(target != null && this.isSupportLegendHighlight()){     // 理论上系列值为""也可以触发高亮
                var key = this.getLegendKey(point);
                var opacity = (key == target || point._rangeItem == target) ? 1 : 0.3;
                style['fill-opacity'] = style['stroke-opacity'] = opacity;
            }
            return style
        },

        _updatePointGraphicStyle:function(point, style){
            style = style || point.series._getDynamicStyle(point);
            point.graphic && point.graphic.style(style);//update style
        },

        _createMarker:function(marker, group){
            var markerType = marker.symbol, renderer = this.vanchart.renderer;
            group = group || renderer.group();

            if(BaseUtils.isImageMarker(markerType)){
                var w = marker.width, h = marker.height;
                group.image = renderer.image({
                    'preserveAspectRatio':'none', 'x':-w/2, 'y':-h/2, 'width':w, 'height':h
                }).imageContent(markerType).addTo(group);
            }else{
                //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath = renderer.path().addTo(group);
                    group.fillPath = renderer.path().addTo(group);
                }else{
                    group.markerPath = renderer.path().addTo(group);
                }
            }

            return group;
        },

        //加上.attr(d)原因：刷新symbol改变的点
        _updateMarker:function(point, group, marker){
            group = group || point.graphic;
            marker = marker || point.options.marker;

            var opacity = marker.fillColorOpacity;

            var target = this.vanchart.highlightTarget;
            if(target){
                var key = this.getLegendKey(point);
                opacity = (key == target || point._rangeItem == target) ? 1 : 0.3;
            }

            var markerType = marker.symbol, backgroundColor = this._getBackgroundColor();

            if(BaseUtils.isImageMarker(markerType)){

            }else{
                //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius + 2)})
                        .style({'fill':marker.fillColor, 'fill-opacity':opacity,'stroke':backgroundColor, 'stroke-width':2});
                    group.fillPath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius - 1)})
                        .style({'fill':backgroundColor});
                }else if(isHollow){
                    group.markerPath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius)})
                        .style({'stroke':marker.fillColor,'stroke-opacity':opacity,'stroke-width':2, 'fill':backgroundColor})
                }else{
                    group.markerPath.attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius)});
                    isLine ? group.markerPath.style({'fill':marker.fillColor,'fill-opacity':opacity, 'stroke-width':2, 'stroke':backgroundColor})
                        : group.markerPath.style({'fill':marker.fillColor, 'fill-opacity':opacity});
                }
            }
        },

        _onMarkerPressed:function(point){
            if(point.graphic){
                var marker = point.options.marker, markerType = marker.symbol, series = point.series;
                var style = {'fill':point.clickColor, 'fill-opacity': point.clickOpacity};
                if(!BaseUtils.isImageMarker(markerType)){
                    //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        point.graphic.strokePath.style(style);
                    }else{
                        point.graphic.markerPath.style(style);
                    }
                }
            }
        },

        _onMarkerState:function (point, isChosen) {
            var marker = point.options.marker, markerType = marker.symbol, gap = 5;

            if(point.graphic){
                gap = 2;
                if(BaseUtils.isImageMarker(markerType)){
                    var w = marker.width + (isChosen ? 4 : 0), h = marker.height+ (isChosen ? 4 : 0);
                    point.graphic.image.attr({
                        'x':-w/2, 'y':-h/2, 'width':w, 'height':h
                    });
                }else{
                    var radius = marker.radius + (isChosen ? 2 : 0);

                    function pathAnimate(path, r) {
                        path
                            .interrupt(Constants.SELECT_ANIMATION)
                            .transition(Constants.SELECT_ANIMATION)
                            .animate({
                            duration:300,
                            ease:BezierEasing.custom["ease-out-back"],
                            attr:{'d':PathGenerator.getMarkerPath(markerType, r)}
                        })
                    }

                    //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        pathAnimate(point.graphic.strokePath, radius + 2);
                        pathAnimate(point.graphic.fillPath, radius - 1);
                    }else{
                        pathAnimate(point.graphic.markerPath, radius);
                    }
                }
            }

            var series = point.series, diffX = 0, diffY = 0;
            if(series.type == Constants.RADAR_CHART){
                var pos = series._getArcPoint(gap, point.radian);
                diffX = pos[0]; diffY = pos[1];
            } else {
                diffY = -gap;
                var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
                if (align == Constants.BOTTOM) {
                    diffY = gap;
                }
            }
            series._labelTransformState(point,diffX,diffY,isChosen,300,BezierEasing.custom["ease-out-back"]);
        },

        removeDefaultMarker:function () {
            var series = this;
            series.defaultMarker && series.defaultMarker.remove();
            series.defaultMarker = null;
        },

        _onMarkerMouseOver:function(point){
            var series = point.series, vanchart = series.vanchart;

            series._onMarkerState(point, true);

           if(!point.graphic){
                var marker = this._getDefaultMarker(point);
                series.defaultMarker = series.defaultMarker || this._createMarker(marker).addTo(this.group);

               series.defaultMarker.attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(0.01)');

                this._updateMarker(point, series.defaultMarker, marker);

               series.defaultMarker
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .animate({
                    duration:300,
                    ease:'ease',
                    attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(1.5)'}
                })
            }
        },

        _onMarkerMouseOut:function(point){
            var series = point.series, vanchart = series.vanchart;

            series._onMarkerState(point, false);

            if(!point.graphic && series.defaultMarker) {
                series.defaultMarker.animate({
                    duration:300,
                    ease:'ease',
                    attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'}
                }).remove();
                series.defaultMarker = null;
            }
        },

        //当没有marker的时候默认加一个marker
        _getDefaultMarker:function(point){
            return {
                'symbol':Constants.CIRCLE,
                'fillColor': point.options.marker.fillColor,
                'fillColorOpacity':point.options.marker.fillColorOpacity,
                "radius": 4.5,
                "enabled": true
            }
        },

        _calculateAnimationDelay:function(){
            return 0;
        },

        _isHollowMarker:function(markerType) {
            return markerType && markerType.indexOf('hollow') != -1;
        },

        _animateEnd: function () {
            this._showLabels();
            this._drawEffectPoints();
        },

        _showLabels: function () {
            var series = this, vanchart = series.vanchart;

            series._updateDataLabels();  // 图表绘制结束就绘制标签，没有必要等MoreLabel了

            if(vanchart._needShowMoreLabel()){
                series.getTextDataToDraw().forEach(function(point){
                    if(point.visible && series.visible) {
                        series._showMoreLabel(point);
                    }
                });
            }

            vanchart._removeChangeDataState(series);
        },

        /**
         * 统一显示MoreLabel:值变化提示
         * @param  {[type]} point           [point]
         * @param  {[type]} startX     [moreLabel缩放起始点X](非必填, 未传值的则使用series.calcMoreLabelPosition计算)
         * @param  {[type]} startY     [moreLabel缩放起始点Y](同上)
         */
        _showMoreLabel: function(point, startX, startY){
            if(point.depth === 0){//多层饼图
                return;
            }

            var series = this, vanchart = series.vanchart, points = point.points;
            var moreLabel = vanchart.getComponent(ComponentLibrary.MORELABEL_COMPONENT);

            if(series.type === Constants.GANTT_CHART) {
                return;  // 甘特图暂不支持MoreLabel 
            } 

            var lastValue = point._lastValue || 0,
                lastArrivalRate = point._lastArrivalRate || 0;

            // 判断是否需要一框对多点
            var morePointsOneTip = function (series){ 
                var seriesType = series.type, gaugeType = series.gaugeType;
                if(gaugeType === "pointer_semi" || gaugeType === "pointer" || seriesType === Constants.AREA_MAP || seriesType === Constants.POINT_MAP){
                    return true; 
                }
                return false; 
            }; 

            // 计算变化值,用作判断是否需要显示moreLabel
            var changedValue = BaseUtils.accAdd(point.options[series.getTargetKey()], -lastValue);

            // 最后一个点如果是未变化的且需要一框多点的时候，在这里触发渲染 
            // 框架图points为undefined
            if (changedValue === 0 || isNaN(changedValue)){
                if(points && point === points[points.length - 1] && morePointsOneTip(series)){ 
                    moreLabel.showWithPoint(point, startX, startY);
                } 
                return;
            }

            point.changedValue = changedValue;
           var changedPercent = changedValue / lastValue;

            point.changedPercent = isFinite(changedPercent) ? changedPercent : (changedPercent < 0 ? "-∞" : "∞");
            // 漏斗图-转换率
            if(series.type === Constants.FUNNEL_CHART){
                point.changedArrivalRate = BaseUtils.accAdd(point.arrivalRate, lastArrivalRate);
            }


            // 指针仪表盘这样的，需要一框多点显示，要特殊处理：
            // 先MoreLabelHelper.collectPoint(point)把点相关的提示保存起来，等到遍历到最后一个点的时候，再统一布局绘制
            // 注意：如果最后一个点未发生值变化，那么在判断changedValue的时候，就该触发渲染操作了。
            if(morePointsOneTip(series)){ 
                moreLabel.collectPoint(point); 
                if(point === points[points.length - 1]){
                   moreLabel.showWithPoint(point, startX, startY); 
                }
                return;
            }
            // 普通的一框对一点的渲染方式
            moreLabel.collectPoint(point); 
            moreLabel.showWithPoint(point, startX, startY); 
        },

        /**
         * 计算MoreLabel的起始位置和缩放方向:具体图表要重写这个方法。
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [moreLabel尺寸大小]
         * @return {[type]}              [moreLabelPosition]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            return { 
                startX: point.x + point.width/2, 
                centerY: point.y - moreLabelDim.height/2, 
                direction : "top" 
            } 
        }, 

        /**
         * 判断是否有数据点发生值变化：多用于渲染时，针对值变化的情况特殊处理。
         * @return {Boolean} [description]
         */
        hasChangedPoint: function () { 
            var validPoints = this.points.filter(function(point){
                return !point.isNull;
            }); 
            var pointChanged = false, index = 0; 
            
            while(index < validPoints.length) { 
                var point = validPoints[index]; 
                if(point.value != point._lastValue){ 
                    pointChanged = true;
                    break; 
                } 
                index++; 
            }
            // 有值变化且 _changeDataState才算hasChangedPoint，诸如resize之类的不会更新point的value和_lastValue，因此，计算出的pointChanged为true，但是不算发生值变化
            return pointChanged && this.vanchart._changeDataState;
        }, 

        _updateDataLabels:function(){
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                series._createTextGraphic(point);
            });
        },

        _removeDataLabels: function () {
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                if(point.textGraphic){
                    point.textGraphic.remove();
                    point.textGraphic = null;
                }
                if (point.leadLine) {
                    point.leadLine.remove();
                    point.leadLine = null;
                }

                point.newMoreLabelG && point.newMoreLabelG.remove();
                point.newMoreLabelG = null;
            });
        },

        //labelPos是整个标签左上角
        //text.tans(x+width/2, y+height/2).dx(dx-width/2).dy(dy-height/2)。这样做的原因：选中放大，要trans到缩放中心
        _createTextGraphic:function(point){
            var series = this;

            if(point.hasValidDataLabel()){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var labelContent = point.labelContent, dataLabels = point.options.dataLabels, useHtml = dataLabels.useHtml;

                var textLabelGroup = this._getPointTextLabelGroup();

                var text = renderer.vtext(useHtml).attr('transform', BaseUtils.makeTranslate(series._labelTrans(point))).style({'pointer-events': 'none'});
                var startY = 0, halfWidth = point.labelDim.width/2, halfHeight = point.labelDim.height/2;
                text.tspans = [];
                for (var i = 0, count = labelContent.length; i < count; i++) {
                    var label = labelContent[i], labelDim = label.dim, labelText = label.text, labelStyle = label.style, dx;

                    switch (point.options.dataLabels._align) {
                        case Constants.LEFT:
                            dx = 0;
                            break;
                        case Constants.RIGHT:
                            dx = point.labelDim.width - labelDim.width;
                            break;
                        case Constants.CENTER:
                        default:
                            dx = (point.labelDim.width - labelDim.width)/2;
                    }
                    text.tspans.push(
                        renderer.vtspan(useHtml)
                        .style({'width': dataLabels.labelWidth + 'px', height:dataLabels.labelHeight + 'px', 'margin-top':-halfHeight + 'px'})
                        .attr('y', startY)
                        .attr('x', 0)
                        .attr('dy', labelDim.height * .85 - halfHeight)
                        .attr('dx', dx - halfWidth)
                        .textContent(labelText).style(labelStyle)
                        .addTo(text)
                    );

                    startY += (labelDim.height + 2);
                }

                point.textGraphic = textLabelGroup.append(text);

                if (point.labelPos.startPos) {//leadLine
                    point.leadLine = textLabelGroup.append(this._getLeadLine(point));
                }
            }
        },

        _labelTrans:function (point) {
            return {x:point.labelPos.x + point.labelDim.width/2, y:point.labelPos.y + point.labelDim.height/2}
        },

        _labelFontSizeState:function (point, isChosen, duration, ease) {
            if(point.labelPos) {
                var pos = point.series._labelTrans(point), scale = isChosen ? 1.1 : 1;

                if(point.textGraphic){

                    var paras = point.textGraphic.type === 'div' ? {duration: duration, ease: ease,
                            style: {'transform': 'translate(' + pos.x + 'px,' + pos.y + 'px)scale('+  scale + ')'}} : {duration: duration, ease: ease,
                            attr: {'transform': 'translate(' + pos.x + ',' + pos.y + ')scale('+  scale + ')'}};

                    point.textGraphic && point.textGraphic
                        .interrupt(Constants.SELECT_ANIMATION)
                        .transition(Constants.SELECT_ANIMATION)
                        .animate(paras)
                }

            }
        },

        _labelTransformState:function (point, diffX, diffY, isChosen, duration, ease) {
            if(point.labelPos) {
                var trans = point.series._labelTrans(point);
                if(isChosen){
                    trans = {x:trans.x + diffX, y:trans.y + diffY}
                }

                point.textGraphic && point.textGraphic.animate({
                    duration: duration,
                    ease: ease,
                    attr: {'transform': BaseUtils.makeTranslate(trans)},
                    style: {'transform': 'translate(' + trans.x + 'px,' + trans.y + 'px)'}
                })
            }
        },

        _outSideLabelColorState:function (point, isChosen, duration, ease) {
            var labelContent = point.labelContent, len = labelContent.length;
            if (point.textGraphic && point.textGraphic.tspans) {

                point.textGraphic.tspans.forEach(function (span, i) {
                    if (i < len) {
                        var style = labelContent[i].style;
                        span.animate({
                            duration: duration,
                            ease: ease,
                            style: {'color':isChosen ? point.mouseOverColor : style.color}
                        });
                    }
                })
            }
        },

        _leadLineState:function (point, diffX, diffY, isChosen, duration, ease) {
            var series = point.series, labelPos = point.labelPos,
                options = point.options, dataLabels = options.dataLabels;

            if(!labelPos || !labelPos.startPos){
                return;
            }

            function addDiff(pos) {
                return {x:pos.x + diffX, y:pos.y + diffY};
            }

            var leadLinePos = labelPos, leadLineColor = dataLabels.connectorColor || point.color;
            if(isChosen){
                leadLinePos = {startPos:addDiff(labelPos.startPos), midPos:addDiff(labelPos.midPos), endPos:addDiff(labelPos.endPos)}
                leadLineColor = point.mouseOverColor;
            }

            point.leadLine && point.leadLine.animate({
                duration: duration || 100,
                ease: ease || 'ease',
                attr: {'d': series._getLeadLinePathWithPos(leadLinePos)},
                style: {'stroke': leadLineColor}
            });
        },

        _getLeadLine:function(point){
            return this.vanchart.renderer.path().attr('d', this._getLeadLinePath(point))
                .style({
                    'fill':'none', 'stroke': point.options.dataLabels.connectorColor || point.color,
                    'stroke-width':point.options.dataLabels.connectorWidth || 0
                })
        },

        _getLeadLinePath:function (point) {
            return this._getLeadLinePathWithPos(point.labelPos);
        },

        _getLeadLinePathWithPos:function (labelPos) {
            var startPos = labelPos.startPos, midPos = labelPos.midPos, endPos = labelPos.endPos;
            var F = this._dealWithFloat;
            return  'M' + F(startPos.x) + ',' + F(startPos.y) + 'L' + F(midPos.x) + ',' + F(midPos.y) + 'L' + F(endPos.x) + ',' + F(endPos.y);
        },

        _dealWithFloat:function(v){
            return Math.abs(v) < 1e-6 ? 0 : v;
        },

        _getPointGraphicGroup:function(){
            return this.group;
        },

        _getPointTextLabelGroup:function(){
            if(!this.textGraphicGroup){
                var vanchart = this.vanchart,
                    textRenderGroup = vanchart.seriesTextRenderGroup,
                    textDivGroup = vanchart.seriesTextDivGroup;

                this.textGraphicGroup = vanchart.renderer.vgroup();
                textRenderGroup.append(this.textGraphicGroup.renderG);
                textDivGroup.append(this.textGraphicGroup.divG);

                this.textGraphicGroup.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }else{
                this.textGraphicGroup.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            return this.textGraphicGroup;
        },

        _getTranslate:function(){
            return this.vanchart.bounds;
        },

        //seriesUnChosen:series.fire; mouseout:dom event。
        //原因：折线图鼠标移出线，线依然选中因为有选中点。折线图的mouseout不做任何事情，seriesUnChosen取消线的选中状态。
        getEvents:function(){
            return {
                'mouseover':this._onSeriesMouseOver,
                'mouseout':this._onSeriesMouseOut,
                'seriesUnChosen':this._seriesUnChosen,
                'pointMouseOver':this._onPointMouseOver,
                'pointMouseOut':this._onPointMouseOut,
                'tap':this._onSeriesTap
            }
        },
        // 对于词云框架图的超链鼠标悬浮变手统一处理
        _onPointMouseOver: function(point){
            if(point.graphic) {
                point.graphic.style('cursor', point.onClick ? 'pointer' : '');
            }
        },

        _seriesUnChosen:function (ev) {
            this._onSeriesMouseOut && this._onSeriesMouseOut(ev);
        },

        _onSeriesMouseOver:function(ev){

            var series = this, vanchart = series.vanchart, hoverSeries = vanchart.hoverSeries;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverSeries != series){
                hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                vanchart.hoverSeries = series;
            }

            var closestPoint = series.getClosestPoint(ev.containerPoint);

            if(closestPoint && closestPoint != hoverPoint){
                hoverPoint && hoverPoint.fire('mouseout', ev);

                vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
                closestPoint.fire('mouseover', ev);
                vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
            }
        },

        // 只对移动端的tap事件做单独处理
        _onSeriesTap : function (ev) {
            BaseUtils.hasTouch() && this.fire('mouseover', ev);
        },

        getPressedStyle:function(){
            return null;
        },

        onPointPress:function(){
            var point = this, series = point.series, style = series.getPressedStyle(point);
            if(style && point.graphic){
                point.graphic.style(style);
            }
        },

        onPointPressUp:function(){
            var point = this, series = point.series, style = series.getHighLightStyle && series.getHighLightStyle(point);
            if(style && point.graphic){
                point.graphic.style(style);
            }
        },

        remove:function(){

            var series = this, vanchart = series.vanchart;
            this.points.forEach(function(point){
                vanchart.removePointGraphics(point, series.type, false);
            });

            this._canvas && this._canvas.remove();
            this.textGraphicGroup && this.textGraphicGroup.remove();
            this.group && this.group.remove();
            this.textGraphicGroup = this._canvas = this.group = null;
        },

        reShowPoint:function (point) {
            var series = point.series, vanchart = series.vanchart, legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            return legend && legend.items && legend.reShowPoint(point);
        },

        //等其他系列消失，此系列再动画
        updateDelay:function (delay) {
            var series = this, vanchart = series.vanchart, legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            if(legend && legend.showSeries(series)) {
                var chartSeries = vanchart.seriesOfType(series.type);
                for (var i = 0, len = chartSeries.length; i < len; i++) {
                    if (legend.toDropSeries(chartSeries[i])) {
                        return delay || 150;
                    }
                }
            }
            return 0;
        }
    });

    return Series;
});
/**
 * Created by Yuqian on 2017/1/11.
 */

define('chart/gantt/GanttSeries',['require','../Series','../../utils/BaseUtils','../../Constants','../../utils/BezierEasing','../../locale/localeText','../../ChartLibrary'],function (require) {

    var Series = require('../Series');
    var BaseUtils = require('../../utils/BaseUtils');
    var Constants = require('../../Constants');
    var BezierEasing = require('../../utils/BezierEasing');
    var localeText = require('../../locale/localeText');

    var BORDER_RADIUS = 2;
    var GAP_PCT = 0.1;
    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;

    var INIT_ANIMATION_TIME = 1200;//初始（刷新）
    var INIT_EASE = BezierEasing.css["ease-out-cubic"];
    var EXIT_ANIMATION_TIME = 150;//点击图例消失
    var EXIT_EASE = BezierEasing.css["ease-in-back"];
    var UPDATE_ANIMATION_TIME = 250;//点击图例其他系列更新位置、大小
    var UPDATE_EASE = BezierEasing.custom["ease-out"];
    var RE_SHOW_ANIMATION_TIME = 900;//点击图例重新出现
    var RE_SHOW_EASE = BezierEasing.custom["ease-out-quint"];

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';


    var LEVEL_DIVIDE = 7; // 0-6 is low, 7-12 is high

    function fmtYYYYMMdd (d) {
        return d.format('YYYY-MM-dd')
    }

    function fmtYYYYMMddHHmm (d) {
        return d.format('YYYY-MM-dd HH:mm')
    }

    function fmtProgress (v) {
        return v * 100 + '%'
    }

    function fmtProcesses (ps) {
        return ps.map(function (obj) { return obj.name}).join(' ')
    }

    var fmtFns = {};

    function genTimeFormatter (prefix, dateFmtStr) {
        var str = prefix + dateFmtStr;
        if (!fmtFns[str]) {
            fmtFns[str] = function (d) {
                return prefix + d.format(dateFmtStr);
            }
        }
        return fmtFns[str]
    }

    var isSupportSVG = BaseUtils.isSupportSVG();

    var Gantt = Series.extend({
        
        doLayout: function () {

            var series = this, vanchart = series.vanchart;

            var timeAxis = vanchart.getTimeAxis();
            var scale = timeAxis.scale;
            var processes = vanchart.getProcesses();
            var procMap = processes.procMap;
            var cateMap = processes.cateMap;
            var rowHeight = processes.tableDims.rowHeight;

            var newLine = vanchart.options.plotOptions.newLine;
            var oh = this._getSeriesOffsetAndHeight(rowHeight, newLine);

            this.getDataToDraw().forEach(function(point){
                var options = point.options, borderWidth = options.borderWidth;
                var pId = options.processesId;

                var x1 = scale(+point.startTime);
                var x2 = scale(+point.finishTime);

                var rect = {};
                rect.x = x1;
                rect.y = cateMap[pId] * rowHeight + oh.offset;
                rect.width = x2 - x1;
                rect.height = oh.height;

                rect = BaseUtils.rectSubPixelOpt(rect, borderWidth);
                rect.rx = rect.ry = BORDER_RADIUS;

                point.rect = rect;
                point.initRect = {
                    x: rect.x,
                    y: rect.y,
                    width: 0,
                    height: rect.height
                };

                // VML
                point.leftRect = {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width * point.progress,
                    height: rect.height
                };

                point.rightRect = {
                    x: rect.x + point.leftRect.width,
                    y: rect.y,
                    width: rect.width * (1 - point.progress),
                    height: rect.height
                };
            });
        },

        _getSeriesOffsetAndHeight: function (rowHeight, newLine) {

            var height = 0;
            var offset = rowHeight * GAP_PCT;

            var visibles = this._getVisibles();
            var total = newLine ? visibles.length : 1;
            var index = newLine ? visibles.indexOf(this.index) : 0;

            height = rowHeight * (1 - GAP_PCT * (total + 1)) / total; // what does 25% mean? F**k
            offset += index * (height + rowHeight * GAP_PCT);

            return {
                height: height,
                offset: offset
            }
        },

        _getVisibles: function () {
            return this.vanchart.seriesOfType(this.type)
                .filter(function (s) {
                    return s.visible
                })
                .map(function (s) {
                    return s.index
                })
        },

        getDataToDraw: function () {
            var procMap = this.vanchart.getProcesses().procMap;
            return this.points.filter(function (p) { return procMap[p.options.processesId] && !p.isNull });
        },

        // gantt's points are so different from others
        isNullValue: BaseUtils.falseFn,

        _getTranslate: function () {
            return [0, 0]
        },

        _calculateLabelPos: function () {
            this.getDataToDraw().forEach(function(point){
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    var rect = point.rect, labelDim = point.labelDim;
                    // pct bar width
                    var width = rect.width * point.progress;

                    var pos = {y: rect.y + rect.height / 2 - labelDim.height / 2};
                    if (dataLabels.align === Constants.RIGHT) {
                        pos.x = rect.x + width - labelDim.width - LABEL_GAP;
                    } else {
                        pos.x = rect.x + width / 2 - labelDim.width / 2;
                    }

                    point.labelPos = pos;
                }
            });
        },

        getFillFilter: function (color, p) {
            var R = this.vanchart.renderer;
            var attrs = {'x1': 0, 'y1': 0, 'x2': 1, 'y2': 0};

            var pct = p.progress;

            var stops = [
                {'offset':  pct, 'stop-color': color},
                {'offset':  pct, 'stop-color': color, 'stop-opacity': '0.5'}
            ];

            if(p.colorGradient){
                R.updateColorGradient(p.colorGradient, attrs, stops);
            }else{
                p.colorGradient = R.colorGradient(attrs, stops);
            }

            return "url(#" + BaseUtils.stamp(p.colorGradient) + ")";
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        getPointInitAttr:function(point){
            return point.initRect;
        },

        _calculateAnimationDelay:function(){
            return this.updateDelay(EXIT_ANIMATION_TIME);
        },

        getPointInitAnimationAttr:function(point){
            return {
                ease:INIT_EASE,
                duration:INIT_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:RE_SHOW_EASE,
                duration:RE_SHOW_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointUpdateAnimationAttr:function(point, delay){
            return {
                delay:delay || 0,
                ease:UPDATE_EASE,
                duration:UPDATE_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointDropAnimationAttr:function(point){
            return {
                ease:EXIT_EASE,
                duration:EXIT_ANIMATION_TIME,
                attr:point.initRect
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, style, true);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);
            series._onState(point, style, false);
        },

        _onState:function (point, style, isChosen) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, BezierEasing.css["ease"]);
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor ,
                'fill':p.series.getFillFilter(p.mouseOverColor, p),
                'fill-opacity': p.opacity,
                'stroke-width':6,
                'stroke-opacity':  p.opacity === 0 ? 0 : 0.35
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity
            }
        },

        _formatFn: function (key) {
            switch (key) {
                case 'processes':
                    return fmtProcesses;
                case 'startTime':
                case 'finishTime':
                    return this.vanchart.getTimeAxis().initLevel < LEVEL_DIVIDE
                        ? fmtYYYYMMdd
                        : fmtYYYYMMddHHmm;
                case 'progress':
                    return fmtProgress;
                default:
                    return null
            }
        },

        _postLabel: function (str, key) {
            switch (key) {
                case 'duration':
                case 'progress':
                case 'startTime':
                case 'finishTime':
                    return localeText(key) + str;
                default:
                    return str
            }
        },

        _postTooltip: function (str, key) {
            switch (key) {
                case 'duration':
                case 'progress':
                case 'startTime':
                case 'finishTime':
                    return localeText(key).trim() + ': ' + str;
                default:
                    return str
            }
        }

    });

    Gantt.prototype._getLabelFormatFn = Gantt.prototype._formatFn;
    Gantt.prototype._getTooltipFormatFn = Gantt.prototype._formatFn;

    //
    // VML patch
    //
    if (!isSupportSVG) {
        Gantt.include({

            getFillFilter: function (color) {
                return color
            },

            _drawUpdatePoints: function (point) {
                this._updatePointGraphicStyle(point);   // 更新颜色
                this._updateAttr(point);
                this.vanchart.registerInteractiveTarget(point, point.graphic);  // 更新映射关系
            },

            _drawEnterPoints: function (point) {
                var series = this, group = series._getPointGraphicGroup();

                var R = this.vanchart.renderer;
                var graphic = point.graphic = R.group();

                graphic.outerRect = R.rect();
                graphic.leftRect = R.rect();
                graphic.rightRect = R.rect();

                this._updateAttr(point);

                var s = series.getStyle(point);
                this._updatePointGraphicStyle(point, s);

                graphic.append(graphic.outerRect);
                graphic.append(graphic.leftRect);
                graphic.append(graphic.rightRect);

                group.append(graphic);

                series.vanchart.registerInteractiveTarget(point, graphic);
            },

            _updateAttr: function (point) {
                var graphic = point.graphic;
                graphic.outerRect.attr(point.rect);
                graphic.leftRect.attr(point.leftRect);
                graphic.rightRect.attr(point.rightRect);
            },

            _drawExitPoints: function (point) {
                point.graphic.remove();
            },

            _updatePointGraphicStyle:function(point, style){
                var s = style || point.series._getDynamicStyle(point);
                point.graphic.outerRect.style({
                    'stroke-width': (s['stroke-width'] || 0) + 1,
                    'stroke': s['stroke']
                });
                s['stroke-width'] = 0;
                point.graphic.leftRect.style(BaseUtils.clone(s));
                s['fill-opacity'] = s['fill-opacity'] || 1;
                s['fill-opacity'] *= 0.5;
                point.graphic.rightRect.style(s);
            },

            _onPointMouseOver:function(point){
                var series = point.series, style = series.getHighLightStyle(point);
                series._updatePointGraphicStyle(point, style);
            },

            _onPointMouseOut:function(point){
                var series = point.series,style = series.getStyle(point);
                series._updatePointGraphicStyle(point, style);
            }
        })
    }


    require('../../ChartLibrary').register(Constants.GANTT_CHART, Gantt);

    return Gantt;
});

/**
 * Created by eason on 15/8/17.
 */

define('component/LegendIconFactory',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var LegendPath = {};
    var LegendSize = {};

    LegendPath[Constants.PIE_ICON] = 'M15.795,7.943L7.909,12.5L0.205,8.052C1.756,5.333,4.68,3.5,8.032,3.5C11.338,3.5,14.23,5.287,15.795,7.943z';
    LegendSize[Constants.PIE_ICON] = {
        width:16,
        height:16
    };

    LegendPath[Constants.TREEMAP_ICON] = 'M9,12H3c-1.6,0-3-1.4-3-3l0-6c0-1.6,1.3-3,3-3l6,0c1.7,0,3,1.4,3,3v6C12,10.6,10.6,12,9,12z';
    LegendSize[Constants.TREEMAP_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.DONUT_ICON] = 'M8.945,11.107c1.671,0,3.181,0.684,4.269,1.786l4.271-4.271c-4.686-4.686-12.284-4.686-16.971,0l4.216,4.216C5.815,11.768,7.302,11.107,8.945,11.107z';
    LegendSize[Constants.DONUT_ICON] = {
        width:18,
        height:18
    };

    LegendPath[Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.BUBBLE_ICON] = "M6,11.5c-1.47,0-2.851-0.572-3.889-1.611C1.072,8.851,0.5,7.47,0.5,6s0.572-2.851,1.611-3.889C3.149,1.072,4.53,0.5,6,0.5s2.851,0.572,3.889,1.611C10.928,3.149,11.5,4.53,11.5,6s-0.572,2.851-1.611,3.889C8.851,10.928,7.47,11.5,6,11.5z";
    LegendSize[Constants.BUBBLE_ICON] = {
        width:11,
        height:11
    };

    LegendPath[Constants.NULL_MARKER] = 'M1,8L1,8c0-0.552,0.448-1,1-1h12c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1H2C1.448,9,1,8.552,1,8z';
    LegendSize[Constants.NULL_MARKER] = {
        width:16,
        height:16
    };

    LegendPath[Constants.CIRCLE] = 'M11,8c0,1.657-1.343,3-3,3S5,9.657,5,8s1.343-3,3-3S11,6.343,11,8z M14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,8c0-0.347,0.058-0.678,0.142-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.142C4.058,8.678,4,8.347,4,8z';
    LegendSize[Constants.CIRCLE] = {
        width:16,
        height:16
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NULL_MARKER] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NULL_MARKER] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE] = "M4,8C2.897,8,1.897,7.551,1.173,6.827S0,5.103,0,4s0.449-2.103,1.173-2.827S2.897,0,4,0s2.103,0.449,2.827,1.173S8,2.897,8,4S7.551,6.103,6.827,6.827S5.103,8,4,8";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE] = 'M11,11H5V5h6V11z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2V7z';
    LegendSize[Constants.SQUARE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE] = "M0,0h8c0,0,0,3.889,0,8C4,8,0,8,0,8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND] = 'M8,11L5,8l3-3l3,3L8,11z M14,7h-2.586l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M3.586,8l1-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.586L3.586,8z';
    LegendSize[Constants.DIAMOND] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND] = "M0,4.5L4.502,0l4.5,4.5c0,0,0,0-4.5,4.5C0,4.5,0,4.5,0,4.5z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND] = {
        width:9,
        height:9
    };

    LegendPath[Constants.TRIANGLE] = 'M5,10l3-5.196L11,10H5z M14,7h-3.577l1.155,2H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M5.577,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.423L5.577,7z';
    LegendSize[Constants.TRIANGLE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE] = "M4.5,0L9,8c0,0-4.617,0-9,0L4.5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE] = {
        width:9,
        height:8
    };

    LegendPath[Constants.CIRCLE_HOLLOW] = 'M4.142,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.142C4.058,7.322,4,7.653,4,8S4.058,8.678,4.142,9zM14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,7C7.449,7,7,7.449,7,8s0.449,1,1,1s1-0.449,1-1S8.551,7,8,7 M8,5c1.657,0,3,1.343,3,3s-1.343,3-3,3S5,9.657,5,8S6.343,5,8,5L8,5z';
    LegendSize[Constants.CIRCLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = "M4,2c1.102,0,2,0.898,2,2S5.102,6,4,6S2,5.102,2,4S2.898,2,4,2 M4,0C1.791,0,0,1.791,0,4s1.791,4,4,4s4-1.791,4-4S6.209,0,4,0";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE_HOLLOW] = 'M4,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2V9z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M9,7H7v2h2V7 M11,5v6H5V5H11L11,5z';
    LegendSize[Constants.SQUARE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = "M6,6H2V2h4V6z M8,0H0v8h8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND_HOLLOW] = 'M4.157,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.157l-1,1L4.157,9z M14,7h-2.157l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,5.986L5.986,8L8,10.014L10.014,8L8,5.986 M8,4.571L11.429,8L8,11.429L4.571,8L8,4.571L8,4.571z';
    LegendSize[Constants.DIAMOND_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = "M2.121,4.999L5,2.121l2.878,2.878L5,7.879L2.121,4.999z M5,0L0,4.999L5,10l4.999-5.001L5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = {
        width:10,
        height:10
    };

    LegendPath[Constants.TRIANGLE_HOLLOW] = 'M4.5,9H2C1.448,9,1,8.552,1,8s0.448-1,1-1h3.655L4.5,9z M14,7h-3.655L11.5,9H14c0.552,0,1-0.448,1-1S14.552,7,14,7z M8,6.938L6.232,10h3.536L8,6.938 M8,4.938L11.5,11h-7L8,4.938L8,4.938z';
    LegendSize[Constants.TRIANGLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = "M5.001,3.34L7.402,7.5H2.598L5.001,3.34z M5.001,0.34L0,9h10L5.001,0.34z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = {
        width:10,
        height:9
    };

    function getLegendIconPath(name){
        return LegendPath[name];
    }

    function getLegendIconSize(name){
        return LegendSize[name] ? LegendSize[name] : LegendSize[Constants.NORMAL_ICON];
    }

    function hasIcon(name){
        return LegendPath[name];
    }
    
    return {
        getLegendIconPath:getLegendIconPath,
        getLegendIconSize:getLegendIconSize,
        hasIcon:hasIcon
    }
});
/**
 * Created by eason on 15/5/4.
 * 图表中所有可以显现的内容都作为一个组件
 */
define('component/Base',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../dom/Evented','../utils/QueryUtils','./LegendIconFactory','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Evented = require('../dom/Evented');
    var QueryUtils = require('../utils/QueryUtils');
    var LegendIconFactory = require('./LegendIconFactory');

    var Class = require('../utils/Class');

    var DEFAULT_MARKER_RADIUS = 4.5;

    var Base = Evented.extend({

        initialize:function(options, componentType, vanchart){

            this.componentType = componentType;
            this.vanchart = vanchart;

            this.refresh(options);
        },

        refresh:function(options){

            this.options = options || this.options;
            
            options = this.options;

            BaseUtils.extend(this, {
                isFloat:options.floating,
                _floatX:this._getPercentValue(options.x, this.vanchart.width),
                _floatY:this._getPercentValue(options.y, this.vanchart.height)
            });

            BaseUtils.calculateFontSizeWithScale(options.style);

            this._refresh && this._refresh(options);
        },

        createComponentGroup:function(){
            return this.vanchart.renderer.group().addTo(this.getComponentParentGroup());
        },
        
        getComponentParentGroup:function(){
            return this.isFloat ? this.vanchart.frontGroup : this.vanchart.backGroup;
        },

        useHtmlLabel:function(){
            return this.options.useHtml || !BaseUtils.isSupportSVG();
        },

        _getLegendType:function(sery){

            var marker = sery.options.marker;

            var icon = '';

            switch (sery.type) {
                case Constants.MULTIPIE_CHART:
                case Constants.PIE_CHART:
                    var innerRadius = sery.options.innerRadius;
                    if (innerRadius && parseFloat(innerRadius) > 0) {
                        return Constants.DONUT_ICON;
                    }else{
                        return Constants.PIE_ICON;
                    }
                case Constants.RADAR_CHART:
                    if (sery.options.columnType) {
                        return Constants.NORMAL_ICON;
                    }
                    break;
                case Constants.FORCE_BUBBLE_CHART:
                case Constants.BUBBLE_CHART:
                    return Constants.BUBBLE_ICON;
                case Constants.TREEMAP_CHART:
                    return Constants.TREEMAP_ICON;
                case Constants.LINE_MAP:
                    return Constants.NULL_MARKER;
                default:
                    icon = Constants.NORMAL_ICON;
            }

            if(sery.type == Constants.POINT_MAP && sery.options.icon){
                return sery.options.icon.iconUrl;
            }

            //有marker的图例,跟marker的类型一致,跟具体的图表类型无关
            //优先读取image属性
            if(sery.options.image && BaseUtils.isSupportSVG()){
                //图片类型的填充系列用图片作为图例标记
                icon = sery.options.image;
            }else if(marker){
                icon = marker.symbol;
                if(sery.type == Constants.SCATTER_CHART && !BaseUtils.isImageMarker(icon)){
                    icon = Constants.SCATTER_ICON + marker.symbol;
                }
            }

            return icon;
        },

        //用百分比表示或者数字表示的值
        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        _setComponentBounds:function(position, usedSize){
            if(this.isFloat || (this.options && this.options.onZero)){
                this._updateFloatBounds(position, usedSize);
            }else{
                this._updateComponentBounds(position, usedSize);
            }
        },

        isHorizontal:function(){
            var position = this.getPosition();
            return position == Constants.TOP || position == Constants.BOTTOM;
        },

        isVertical:function(){
            return !this.isHorizontal();
        },

        getPosition:function(){
            return this.options.position;
        },

        _updateFloatBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;

            var x = this._floatX;
            var y = this._floatY;

            var width = originBounds.x + originBounds.width - x;
            var height = originBounds.y + originBounds.height - y;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break
            }

            /**
             * 以前0值对齐的时候忘了更新绘图区的bounds，
             * 导致设置0值对齐的坐标轴的标签在坐标轴之外的时候会被挤出去，
             * 所以现在更新一下绘图区的bounds
             */
            this.options && this.options.onZero && this._clipPlotBounds(position, usedSize);
        },

        /**
         * 从原始区域裁减出一块区域以后作为组件区域，并且更新原始区域
         * @param position{string} 位置
         * @para usedSize 占据的大小
         * @private
         */
        _updateComponentBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y+height-usedSize, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    this.bounds = {x:x+width-usedSize, y:y, width:usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);

            this._clipPlotBounds(position, usedSize);
        },

        _clipPlotBounds:function(position, usedSize){

            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    originBounds = {x:x, y:y+usedSize, width:width, height:height - usedSize};
                    break;
                case Constants.BOTTOM:
                    originBounds = {x:x, y:y, width:width, height:height - usedSize};
                    break;
                case Constants.LEFT:
                    originBounds = {x:x+usedSize, y:y, width:width-usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    originBounds = {x:x, y:y, width:width-usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);
        },

        // cannot decide how to clip now
        // clip them in the end
        _recordForPlotBounds: function (position, usedSize) {
            usedSize = Math.ceil(usedSize);

            (position === Constants.RIGHT_TOP) && (position = Constants.RIGHT);
            (position === Constants.RIGHT_BOTTOM) && (position = Constants.RIGHT);

            this.vanchart.clipPool[position] = Math.max(this.vanchart.clipPool[position] || 0, usedSize);
        },

        _getBackgroundColor:function(){

            var opt = this.option;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        _maxHeight:function(max){
            var maxHeight = this.vanchart.height;

            if(max || this.options.maxHeight){
                return this._getPercentValue(this.options.maxHeight, maxHeight);
            }

            return maxHeight;
        },

        _maxWidth:function(max){
            var maxWidth = this.vanchart.width;

            if(max || this.options.maxWidth){
                return this._getPercentValue(this.options.maxWidth, maxWidth);
            }

            return maxWidth;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter){
                return tick;
            }

            return BaseUtils.format(tick, formatter);
        },

        getDefaultMarkerRadius:function(){
            return DEFAULT_MARKER_RADIUS;
        },

        getPlotBounds:function(){
            return this.vanchart.bounds;
        },

        getChartBounds:function(){
            return this.vanchart.getChartBounds();
        },

        getParentDom:function(){
            return this.vanchart.getParentDom();
        },

        getDivParentDom:function(){
            return this.vanchart.getDivParentDom();
        },

        getTooltipComponent:function(){
            return this.vanchart.components.tooltip;
        },

        remove:function(){

        },

        _bindData: BaseUtils.bindData,

        invisible:function(){
            return BaseUtils.hasDefined(this.options.visible) && (this.options.visible === false);
        },

        _innerClip: function (group) {
            var comp = this, bounds = comp.bounds, vanchart = comp.vanchart, renderer = vanchart.renderer;
            var innerBounds = BaseUtils.makeBounds(0, 0, bounds.width, bounds.height);

            if(!this._clip){
                this._clip = renderer.createClip(innerBounds);
            }else{
                renderer.updateClip(this._clip, innerBounds);
            }

            if (group.type === 'vgroup') {
                var top = 0, left = 0, right = left + innerBounds.width, bottom = top + innerBounds.height;
                group.divG.style({'clip': 'rect(' + top + 'px '+ right +'px '+ bottom +'px ' + left + 'px)'});
                renderer.clip(group.renderG, this._clip);
            } else {
                renderer.clip(group, this._clip);
            }

        }
    });

    return Base;
});
/**
 * Created by Yuqian on 2017/2/7.
 */

define('chart/gantt/defaultValues',['require'],function (require) {
    return {
        PADDING: '0.25rem',
        WEEKEND_COLOR: 'rgba(169, 195, 200, 0.1)',
        OUTLINE: {'fill':'none', 'stroke': 'rgba(207, 207, 207, 1)', 'stroke-width': 1},
        TWEENLINE: {'fill':'none',
            'stroke': 'rgba(207, 207, 207, 0.6)',
            // 'stroke': 'red',
            'stroke-width': 1},
        INNERLINE: {'fill':'none',
            'stroke': 'rgba(207, 207, 207, 0.6)',
            // 'stroke': 'green',
            'stroke-width': 0.5},

        MINUS_PATH: {
            size: [7.5, 7.5],
            graphics: [
                {fill: '#F2F2F2', d: 'M0,12.7c2,0,3.6,1.6,3.6,3.6S2,19.9,0,19.9s-3.6-1.6-3.6-3.6S-2,12.7,0,12.7z'},
                {fill: '#727171', d: 'M0,20c-2.1,0-3.8-1.7-3.8-3.8s1.7-3.7,3.8-3.7s3.8,1.7,3.8,3.8S2.1,20,0,20z M0,12.8c-1.9,0-3.4,1.5-3.4,3.4  s1.5,3.4,3.4,3.4s3.4-1.5,3.4-3.4S1.9,12.8,0,12.8z M2.1,16h-4.3v0.3h4.3V16z'}
            ]
        },

        PLUS_PATH: {
            size: [7.5, 7.5],
            graphics: [
                {fill: '#F2F2F2', d: 'M0,12.7c2,0,3.6,1.6,3.6,3.6S2,19.9,0,19.9s-3.6-1.6-3.6-3.6S-2,12.7,0,12.7z'},
                {fill: '#727171', d: 'M0,20c-2.1,0-3.8-1.7-3.8-3.8s1.7-3.7,3.8-3.7s3.8,1.7,3.8,3.8S2.1,20,0,20z M0,12.8c-1.9,0-3.4,1.5-3.4,3.4  s1.5,3.4,3.4,3.4s3.4-1.5,3.4-3.4S1.9,12.8,0,12.8z M2.1,16H0.2v-1.9h-0.3V16h-2v0.3h2v2h0.3v-2h1.9C2.1,16.3,2.1,16,2.1,16z'}
            ]
        },

        THUMB_PATH: {
            size: [4.6, 7.1],
            graphics: [
                {fill: '#F2F2F2', d: 'M-0.008,13.717h-2.1v4.5l2.2,2.2l0,0l2.1-2.2v-4.5H-0.008'},
                {fill: '#727171', d: 'M-0.008,20.617l-2.3-2.4v-4.7h4.6v4.7L-0.008,20.617z M-2.008,18.117l2,2l2-2v-4.3h-4V18.117z'}
            ]
        }

    }
});

/**
 * Created by Yuqian on 2017/2/6.
 */

define('chart/gantt/levelDomain',['require'],function (require) {

    var SECOND = 1000,
        MINUTE = 60 * SECOND,
        HOUR = 60 * MINUTE,
        DAY = 24 * HOUR,

        WEEK = 7 * DAY,

        MIN_HALF_YEAR = 181 * DAY,

        // not accurate
        YEAR = 365 * DAY,
        MONTH = YEAR / 12,
        QUARTER = YEAR / 4,
        HALF_YEAR = YEAR / 2;

    var units = [
        // 0
        ['year', 'halfYear'],
        // 1
        ['year', 'halfYear'],
        // 2
        ['year', 'quarter'],
        // 3
        ['halfYear', 'month'],
        // 4
        ['quarter', 'month'],
        // 5
        ['quarter', 'month'],
        // 6
        ['month', 'week'],
        // 7
        ['week', 'day'],
        // 8
        ['month', 'date'],
        // 9
        ['month', 'date'],
        // 10
        ['date', 'meridiem'],
        // 11
        ['date', 'qDay'],
        // 12
        ['date', 'hour']
    ];

    var r0 = 3 / MIN_HALF_YEAR;// R0 = 1emWidth * 3 / halfYear

    function upUnit (level) {
        return units[level][0]
    }

    function subUnit (level) {
        return units[level][1]
    }

    /***
     * @returns {number}
     */
    function Ratio (em, level) {
        return r0 * em * Math.pow(2, level)
    }

    return {
        r0: r0,
        LEN: units.length,
        Ratio: Ratio,
        upUnit: upUnit,
        subUnit: subUnit
    }

});

/**
 * Created by Yuqian on 2017/1/22.
 */

define('chart/gantt/helper',[],function () {

    function lineH (R, G, styles, x1, x2, y, old) {
        if (!old) {
            old = G.append(R.line().style(styles));
        }
        return old.attr({
            x1: x1,
            y1: y,
            x2: x2,
            y2: y
        });
    }

    function lineV (R, G, styles, y1, y2, x, old) {
        if (!old) {
            old = G.append(R.line().style(styles));
        }
        return old.attr({
            x1: x,
            y1: y1,
            x2: x,
            y2: y2
        });
    }

    function rect(R, G, styles, x, y, width, height, old) {
        if (!old) {
            old = G.append(R.rect().style(styles));
        }
        return old.attr({
            x: x,
            y: y,
            width: width,
            height: height
        });
    }

    function traverse (root, childName, before, after) {

        function dfs (node, depth, len, i, parent) {
            before && before(node, depth, len, i, parent);
            var c = node[childName], n;
            if (c && (n = c.length)) {
                c.map(function (d, i) {
                    dfs(d, depth + 1, n, i, node)
                });
            }
            after && after(node, depth, len, i, parent);
        }

        dfs(root, 0, 0, 0, null);
    }

    function sum (arr) {
        return arr.reduce(function (a, b) { return a + b }, 0)
    }

    // calc new values according to old proportions
    function distribValues (oldValues, newValue) {
        var old = sum(oldValues);
        return oldValues.map(function (v) {
            return v / old * newValue
        });
    }

    function getValidProgress(progress) {
        var v = progress;
        if (0 <= v && v <= 1) {
            return v
        }
        return 1
    }

    return {
        lineH: lineH,
        lineV: lineV,
        rect: rect,
        traverse: traverse,
        sum: sum,
        distribValues: distribValues,
        getValidProgress: getValidProgress
    }
});

/**
 * Created by Yuqian on 2017/3/2.
 */

define('chart/gantt/LevelBar',['require','../../component/Base','../../Constants','../../utils/BaseUtils','../../ComponentLibrary','./defaultValues','../../dom/EventObject','./levelDomain','./helper'],function (require) {
    var Base = require('../../component/Base');
    var Constants = require('../../Constants');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var defaultValues = require('./defaultValues');
    var EventObject = require('../../dom/EventObject');

    var LEN = require('./levelDomain').LEN;

    var helper = require('./helper');
    var LineV = helper.lineV;
    var LineH = helper.lineH;

    var MINUS_PATH = defaultValues.MINUS_PATH;
    var PLUS_PATH = defaultValues.PLUS_PATH;
    var THUMB_PATH = defaultValues.THUMB_PATH;

    var THUMB_WIDTH = THUMB_PATH.size[0];

    var HEIGHT = 12;
    var GAP = 12;
    var SLIDER_WIDTH = 64;

    var MOVE_WIDTH = SLIDER_WIDTH - THUMB_WIDTH; // width thumb can move
    var STEP = MOVE_WIDTH / (LEN - 1);

    var LevelBar = Base.extend({

        doLayout: function () {
            this._setComponentBounds(Constants.BOTTOM, HEIGHT);

            var chartBounds = this.vanchart.bounds;
            this.bounds = {
                x: chartBounds.x,
                y: chartBounds.y + chartBounds.height,
                height: HEIGHT,
                width: chartBounds.width
            }
        },
        
        render: function () {
            // render once
            if (!this.group) {
                var R = this.vanchart.renderer;
                this.group = R.group().add();
                this.group
                    .attr('transform', BaseUtils.makeTranslate(this.bounds))
                    .attr('class', 'level-bar');

                this._bar(R);
                this._slider(R);
            }

            // debug icon reference
            // this.group.append(R.rect()
            //     .attr({
            //         x: this._getLineStartX() + SLIDER_WIDTH / 4 * 3,
            //         y: HEIGHT / 2 - 1,
            //         width: 2,
            //         height: 2,
            //         fill: 'red'
            //     }));
        },

        // in case of empty data
        isEnabled: function () {
            return this.enabled && this.vanchart.getTimeAxis().isZoomEnabled();
        },

        setLevel: function (level) {
            if (level == null) {
                return
            }
            // invalid if never set the level
            this.enabled = true;
            this._setThumbLevel(level);
        },

        _setThumbLevel: function (level) {
            var x = THUMB_WIDTH / 2 + STEP * level;
            this.thumbG.attr('transform', BaseUtils.makeTranslate({
                x: x,
                y: -17
            }));
        },

        _bar: function (R) {
            this.group.append(R.rect()
                .attr({
                    x: 0,
                    y: 0,
                    width: this.bounds.width,
                    height: this.bounds.height
                })
                .style({
                    stroke: 'none',
                    fill: this._gradient(R)
                })
            );
        },

        _gradient: function (R) {
            if (!BaseUtils.isSupportSVG()) {
                return 'rgb(220, 220, 220)'
            }

            var attrs = {'x1': 0, 'y1': 0, 'x2': 0, 'y2': 1};

            var stops = [
                {'offset':   '0%', 'stop-color': 'rgb(220, 220, 220)'},
                {'offset':  '75%', 'stop-color': 'rgb(181, 181, 181)'},
                {'offset': '100%', 'stop-color': 'rgb(137, 137, 137)'}
            ];

            var gradient = R.colorGradient(attrs, stops);
            return "url(#" + BaseUtils.stamp(gradient) + ")";
        },

        _slider: function (R) {

            var g = this.group.append(R.group());
            g.attr('transform', BaseUtils.makeTranslate({
                x: this._getLineStartX(),
                y: HEIGHT / 2
            }));

            LineH(R, g,
                {'fill':'none', 'stroke': '#727171', 'stroke-width': 0.5},
                0,
                SLIDER_WIDTH,
                0
            );

            this.minusG = this._getIconGroup(R, MINUS_PATH, -MINUS_PATH.size[0] / 2);
            this.plusG = this._getIconGroup(R, PLUS_PATH, SLIDER_WIDTH + PLUS_PATH.size[0] / 2);
            this.thumbG = this._getIconGroup(R, THUMB_PATH, SLIDER_WIDTH / 2);

            ['minus', 'plus', 'thumb'].map(function (name) {
                var graphic = this[name + 'G'];
                g.append(graphic);
                var evObj = new EventObject(this.iconEvents(name));
                evObj.control = this;
                this.vanchart.registerInteractiveTarget(evObj, graphic);
            }, this);

        },

        // relative to bounds
        _getLineStartX: function () {
            return this.bounds.width - SLIDER_WIDTH - GAP
        },

        eventsMap: {
            minus: ['tap'],
            plus: ['tap'],
            thumb: ['panstart', 'panmove', 'panend']
        },

        iconEvents: function (name) {
            var types = this.eventsMap[name];
            var events = {};
            types.map(function (type) {
                events[type] = this['on' + name + type];
            }, this);
            return events
        },

        onminustap: function (ev) {
            this.control._changeLevel(-1);
        },

        onplustap: function (ev) {
            this.control._changeLevel(1);
        },

        onthumbpanstart: function (ev) {
        },

        onthumbpanmove: function (ev) {
            var bar = this.control;
            var bounds = bar.bounds;
            var pos = ev.containerPoint;

            // adjust to [0, MOVE_WIDTH]
            var v = pos.x - bounds.x - bar._getLineStartX() - THUMB_WIDTH / 2;
            v = Math.min(Math.max(0, v), MOVE_WIDTH);

            var level = Math.round(v / STEP);
            bar._changeToLevel(level);
        },

        onthumbpanend: function (ev) {
        },

        _changeToLevel: function (level) {

            if (!this.isEnabled()) {
                return
            }

            this.vanchart.changeToLevel(level);
            this._setThumbLevel(this.vanchart.getTimeAxis().getLevel());
        },

        _changeLevel: function (c) {
            var level = this.vanchart.getTimeAxis().getLevel() + c;
            this._changeToLevel(level);
        },

        _getIconGroup: function (R, paths, x) {
            var g = R.group();
            g.attr('transform', BaseUtils.makeTranslate({
                x: x,
                y: -17
            }));
            g.append(R.path().attr(paths.graphics[0]));
            g.append(R.path().attr(paths.graphics[1]));
            return g
        }

    });

    ComponentLibrary.register(ComponentLibrary.LEVELBAR, LevelBar);

    return LevelBar

});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/Table',['require','../../component/Base'],function (require) {
    var Base = require('../../component/Base');

    return Base.extend({

        _getHeader: function () {
            return this.options.header;
        },

        _getBody: function () {
            return this.options.body;
        }
    });

});

/**
 * Created by Yuqian on 2017/2/27.
 */

define('chart/gantt/ScrollbarItem',['require','../../dom/Evented','../../utils/BaseUtils'],function (require) {

    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var isSupportSVG = BaseUtils.isSupportSVG();

    // todo, need a transform util
    var transReg = /translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i;

    var BG_SIZE = 12;
    var BG_COLOR = 'rgba(233, 233, 233, 0.6)';
    var BG_STROKE = 'rgba(207, 207, 207, 0.6)';
    var BG_STROKE_WIDTH = 0.5;
    var BAR_SIZE = 6;
    var BAR_COLOR = 'rgba(160, 160, 160, 0.6)';
    var BAR_HOVER_COLOR = 'rgba(88, 88, 88, 0.6)';
    var BAR_ROUND = BAR_SIZE / 2;

    var ScrollbarItem = Evented.extend({

        initialize: function (opt) {
            this.opt = opt;

            this.pos = {
                x: 0,
                y: 0
            };
            var vanchart = opt.manager.vanchart,
                R = opt.manager.renderer;

            this.group = opt.group.append(R.group());
            this.group.style('transition', 'opacity 0.3s');
            this.group.attr('transform', BaseUtils.makeTranslate([opt.x, opt.y]));

            var width, height, barWidth, barHeight, offsetDir;
            if (opt.dir === 'x') {
                width = this.opt.length;
                height = BG_SIZE;
                barWidth = this.opt.barLength;
                barHeight = BAR_SIZE;
                offsetDir = 'y';
            } else {
                width = BG_SIZE;
                height = this.opt.length;
                barWidth = BAR_SIZE;
                barHeight = this.opt.barLength;
                offsetDir = 'x';
            }

            this.background = this.group.append(R.rect().attr({
                'width': width,
                'height': height
            }).style({
                'fill': BG_COLOR,
                'stroke': BG_STROKE,
                'stroke-width': BG_STROKE_WIDTH
            }));

            var barAttrs = {
                'rx': BAR_ROUND,
                'ry': BAR_ROUND,
                'width': barWidth,
                'height': barHeight
            };
            barAttrs[offsetDir] = (BG_SIZE - BAR_SIZE) / 2;

            this.bar = this.group.append(R.rect().attr(barAttrs).style('fill', BAR_COLOR));

            vanchart.registerInteractiveTarget(this, this.bar);
        },

        show: function (d) {
            d = this._over || d;
            if (d !== this._showed) {
                this._showed = d;
                if (BaseUtils.isSupportSVG()) {
                    this.group.style('opacity', d ? '1' : '0');
                } else {
                    this.group.style('display', d ? '' : 'none');
                }
            }
        },

        remove: function () {
            this.group.remove();
        },

        setPos: function (x, y) {
            if (x !== this.opt.x || y !== this.opt.y) {
                this.group.attr('transform', BaseUtils.makeTranslate([x, y]));
                this.opt.x = x;
                this.opt.y = y;
            }
        },

        setSize: function (length, barLength) {
            if (length !== this.opt.length || barLength !== this.opt.barLength) {

                if (length < barLength || length < 0 || barLength < 0) {
                    length = barLength = 0;
                }

                var key = this.opt.dir === 'x' ? 'width' : 'height';
                this.background.attr(key, length);
                this.bar.attr(key, barLength);
                this.opt.length = length;
                this.opt.barLength = barLength;
            }
        },

        setPct: function (pct) {
            this.setBarPos(this._getRemainLength() * pct);
        },

        getBarPos: function () {
            return this.pos[this.opt.dir]
        },

        setBarPos: function (value) {
            value = Math.max(0, Math.min(value, this._getRemainLength()));
            if (this.getBarPos() !== value) {
                this.pos[this.opt.dir] = value;
                this.bar.attr('transform', BaseUtils.makeTranslate(this.pos));
            }
        },

        _getRemainLength: function () {
            return this.opt.length - this.opt.barLength
        },

        // _getBarPos: function () {
        //     var translate;
        //     if (isSupportSVG) {
        //         translate = this.bar.attr('transform').match(transReg);
        //         translate && translate.shift();
        //
        //     } else {
        //         var style = this.bar.node().style;
        //         translate = [parseFloat(style.left), parseFloat(style.top)];
        //     }
        // },

        getEvents: function () {
            return {
                'mouseover': this.onMouseOver,
                'mouseout': this.onMouseOut,
                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        onMouseOver: function () {
            this._over = true;
            this.bar.style({ fill: BAR_HOVER_COLOR });
        },

        onMouseOut: function () {
            this._over = false;
            this.bar.style({ fill: BAR_COLOR });
        },

        onPanStart:function(ev){
            this.initPos = this.getBarPos();
            this.initPointPos = ev.containerPoint;
        },

        onPanMove:function(ev){
            var delta = ev.containerPoint[this.opt.dir] - this.initPointPos[this.opt.dir];

            // this.setBarPos(this.initPos + delta); // 不改变自己, 避免重复事件还要加判断

            this.opt.manager['on' + this.opt.dir]((this.initPos + delta) / this._getRemainLength());
        },

        onPanEnd:function(){
            this.opt.manager.vanchart.handler.panTarget = null;
        }
    });

    ScrollbarItem.SIZE = BG_SIZE;

    return ScrollbarItem

});

/**
 * Created by Yuqian on 2017/2/27.
 */

define('chart/gantt/Scrollbar',['require','../../dom/Evented','../../utils/BaseUtils','./ScrollbarItem'],function (require) {

    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var Bar = require('./ScrollbarItem');

    var MIN_BAR_LENGTH = 20;

    function toFixed (value) {
        return +value.toFixed(3);
    }

    /**
     * usage:
     *
     // view
     var view = this;
     view.scrollbar = new Scrollbar({
         view: view, // view
         group: g, // svg group
         width: this.bounds.width,
         height: this.bounds.height,
         innerWidth: this.innerWidth,
         innerHeight: this.innerBodyHeight
     })

     // listen on:
     view.scrollbar
         .on('scrollX', this.onScrollX, view) // data: {x: Number}
         .on('scrollY', this.onScrollY, view) // data: {y: Number}

     // fire:
     view.fire('innerChange', pos) // give it a pos object {x: Number, y: Number}
     view.fire('resize', options) // new width, height, innerWidth, innerHeight
     view.fire('mouseover') // display
     view.fire('mouseout') // hide

     */

    return Evented.extend({

        /**
         *
         * @param options
         * {
         *   view: object, // the view this bar built on
         *   group: object, // the dom g this manager appended
         *   onChangeName: string, | 'innerChange' // listen on eventName
         *   onResizeName: string, | 'resize'
         *   onOverName: string, | 'mouseover'
         *   onOutName: string, | 'mouseout'
         *   width: 0, // visible area
         *   height: 0,
         *   innerWidth: 0, // inner real size
         *   innerHeight: 0,
         *   scrollX: true,
         *   scrollY: true,
         *   autoHide: true
         * }
         */
        initialize: function (options) {
            // for convenient
            this.view = options.view;
            this.vanchart = options.view.vanchart;
            this.renderer = options.view.renderer || this.vanchart.renderer;
            this.group = options.group;
            this.options = options;

            this.options.autoHide = options.autoHide !== false;

            this.x = this.y = 0; // inner bounds translation

            if (this._isScrollX(options)) {
                this.barX = this._barBottom();
            }
            if (this._isScrollY(options)) {
                this.barY = this._barRight();
            }

            var changeName = options.onChangeName || 'innerChange';
            var resizeName = options.onResizeName || 'resize';
            var overName = options.onOverName || 'mouseover';
            var outName = options.onOutName || 'mouseout';
            this.view
                .on(changeName, this.setPos, this)
                .on(resizeName, this.setSize, this);

            if (options.autoHide) {
                this.barX && this.barX.show(false);
                this.barY && this.barY.show(false);
                this.view.on(overName, this.onover, this);
                this.view.on(outName, this.onout, this);
            }
        },

        onover: function () {
            this.show(true);
        },

        onout: function () {
            this.show(false);
        },

        show: function (d) {
            this.barX && this.barX.show(d);
            this.barY && this.barY.show(d);
        },

        setPos: function (pos) {
            // if (pos.initiator === this) {
            //     return
            // }
            if (this.barX && pos.x != null) {
                var pctX = pos.x / (this.options.width - this.options.innerWidth);
                this.barX.setPct(pctX);
            }
            if (this.barY && pos.y != null) {
                var pctY = pos.y / (this.options.height - this.options.innerHeight);
                this.barY.setPct(pctY);
            }
        },

        // resize, bar group pos and bar size
        setSize: function (options) {
            options.scrollX = this.options.scrollX;
            options.scrollY = this.options.scrollY;

            if (this.options.scrollX) {
                var shouldX = this._isScrollX(options);

                if (shouldX && !this.barX) {
                    this.barX = this._barBottom();
                }
                if (!shouldX && this.barX) {
                    this.barX.remove();
                    this.barX = null;
                }
                if (shouldX && this.barX) {
                    var lengths = this._getLengths(options, 'width');
                    this.barX.setPos(0, options.height - Bar.SIZE);
                    this.barX.setSize(lengths.length, lengths.barLength);
                }
            }
            if (this.options.scrollY) {
                var shouldY = this._isScrollY(options);

                if (shouldY && !this.barY) {
                    this.barY = this._barBottom();
                }
                if (!shouldY && this.barY) {
                    this.barY.remove();
                    this.barX = null;
                }
                if (shouldY && this.barY) {
                    var lengths = this._getLengths(options, 'height');
                    this.barY.setPos(options.width - Bar.SIZE, 0);
                    this.barY.setSize(lengths.length, lengths.barLength);
                }
            }
            BaseUtils.extend(this.options, options);
        },

        _barBottom: function () {
            var lengths = this._getLengths(this.options, 'width');
            return this._bar(
                'x',
                0,
                this.options.height - Bar.SIZE,
                lengths.length,
                lengths.barLength
            );
        },

        _barRight: function () {
            var lengths = this._getLengths(this.options, 'height');
            return this._bar(
                'y',
                this.options.width - Bar.SIZE,
                0,
                lengths.length,
                lengths.barLength
            );
        },

        _getLengths: function (options, prop) {
            var outer = options[prop];
            var inner = prop === 'width' ? options.innerWidth : options.innerHeight;
            var length = outer - (this._isScrollBoth(options) ? Bar.SIZE : 0);
            return {
                length: length,
                barLength: Math.max(outer / inner * length, MIN_BAR_LENGTH)
            }
        },

        /**
         *
         * @param dir 'x'/'y'
         * @param x translate x
         * @param y translate y
         * @param length background length
         * @param barLength
         * @private
         */
        _bar: function (dir, x, y, length, barLength) {
            return new Bar({
                manager: this,
                group: this.group,
                x: x,
                y: y,
                length: length,
                barLength: barLength,
                dir: dir
            });
        },

        onx: function (pct) {
            this.fire('scrollX', {
                initiator: this,
                x: pct * (this.options.width - this.options.innerWidth)
            });
        },

        ony: function (pct) {
            this.fire('scrollY', {
                initiator: this,
                y: pct * (this.options.height - this.options.innerHeight)
            });
        },

        _isScrollX: function (options) {
            return options.scrollX && (toFixed(options.width) < toFixed(options.innerWidth))
        },

        _isScrollY: function (options) {
            return options.scrollY && (toFixed(options.height) < toFixed(options.innerHeight))
        },

        _isScrollBoth: function (options) {
            return this._isScrollX(options) && this._isScrollY(options)
        },

        remove:function () {
            this.barX && this.barX.remove();
            this.barY && this.barY.remove();
            this.barX = this.barY = null;
        }
    });
});

/**
 * Created by Yuqian on 2017/2/24.
 */

define('chart/gantt/TableView',['require','../../dom/Evented','../../utils/BaseUtils','../../utils/ColorUtils','../../dom/DomUtils','../../Constants','./Scrollbar','./helper'],function (require) {
    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var toBack = require('../../dom/DomUtils').toBack;
    var Constants = require('../../Constants');
    var Scrollbar = require('./Scrollbar');
    var helper = require('./helper');
    var sum = helper.sum;

    var makeTranslate = BaseUtils.makeTranslate;
    var isEmpty = BaseUtils.isEmpty;
    var mixColorWithAlpha = ColorUtils.mixColorWithAlpha;
    var min = Math.min;
    var max = Math.max;

    return Evented.extend({

        _parts: ['header', 'body', 'outline', 'scrollbar'],

        _eventNames: ['wheelMove', 'resizeStart', 'resizeMove', 'over', 'pan'],

        initialize: function (model, vanchart) {
            this.model = model;
            this.vanchart = vanchart;
            this.renderer = vanchart.renderer;
            var G = this.G = {};
            var cn = this.className;

            // todo, &vanchart.render, group init seq
            ['', 'body', 'inner-body'].map(function (name) {
                G[name || cn] = vanchart[name ? cn + '-' + name : cn];
            });

            this.innerPosX = this.innerPosY = 0;

            var innerBodyHeight = this.model.tableDims.rowHeight * this.model.tableDims.rowNum;
            this.visibleBodyHeight = this.model.bounds.height - this.model.tableDims.headerHeight;
            this.innerBodyHeight = max(innerBodyHeight, this.visibleBodyHeight);
        },

        _getInnerWidth: function () {
            return this.model.innerWidth
        },

        render: function () {

            var renderer = this.renderer, bounds = this.model.bounds;
            this.clip = renderer.createClip({width: bounds.width, height: bounds.height});
            var group = this._getGroup().attr('transform', makeTranslate(bounds));
            renderer.clip(group, this.clip);

            this._parts.map(function (key) {
                this['_' + key]();
            }, this);

            this._eventNames.map(function (key) {
                this.vanchart.handler.on(key, this['on' + key], this);
            }, this);

        },

        _prepareBody: function () {
            var R = this.renderer;

            var bodyG = this._getGroup('body'),
                G = this._getGroup('inner-body');

            var backGroup = this._addGroup('inner-body-back', G);
            toBack(backGroup.node());

            bodyG.attr('transform', BaseUtils.makeTranslate({x: 0,y: this.model.tableDims.headerHeight}));
            // make it exceed any bounds, so needn't to update
            this.bodyClip = R.createClip({
                width: this.vanchart.bounds.width,
                height: this.vanchart.bounds.height
            });
            R.clip(bodyG, this.bodyClip);

            this._bodyEles = {
                hLines: [],
                vLines: [],
                rects: []
            };
            this._bodyEles.gs = [];
        },

        _buildScrollbar: function (opt) {
            this.scrollbar = new Scrollbar(
                BaseUtils.extend({
                    view: this,
                    group: this._getGroup('body'),
                    width: this.model.bounds.width,
                    height: this.visibleBodyHeight,
                    innerWidth: this._getInnerWidth(),
                    innerHeight: this.innerBodyHeight
                }, opt)
            );

            this.scrollbar
                .on('scrollX', this.onScrollX, this)
                .on('scrollY', this.vanchart.onScrollY, this.vanchart); // sync with another

            this.vanchart.on('moveY', this.onScrollY, this); // sync with another
        },

        _addGroup: function (name, parentG) {
            var newGroup = this.renderer.group();
            var className = name ? this.className + '-' + name : this.className;
            newGroup.attr('class', className);

            this.G[name || this.className] = newGroup;

            if (parentG) {
                parentG.append(newGroup);
            }

            return newGroup
        },

        _getGroup: function (name) {
            return this.G[name || this.className];
        },

        _getOptionsColor: function (obj) {
            if (isEmpty(obj.opacity)) {
                return obj.backgroundColor
            } else {
                return mixColorWithAlpha(obj.backgroundColor, obj.opacity);
            }
        },

        changeInner: function (pos) {
            this._setInnerPos(pos);
        },

        onwheelMove: function (ev) {
            var pos = {x: null, y: null};

            if (this._shouldYMove(ev.containerPoint)) {
                pos.y = this.innerPosY - ev.wheel.pixelY;
            }

            if (this._shouldXMove(ev.containerPoint)) {
                pos.x = this.innerPosX - ev.wheel.pixelX;
            }

            this.changeInner(pos);
        },

        onpan: function (ev) {
            switch (ev.type) {
                case 'panstart':
                    this._initInnerPos = {x: this.innerPosX, y: this.innerPosY};
                    this._initPoint = ev.containerPoint;
                    break;
                case 'panmove':
                    var pos = {x: null, y: null};
                    if (this._shouldYMove(this._initPoint)) {
                        pos.y = this._initInnerPos.y + ev.deltaY;
                    }
                    if (this._shouldXMove(this._initPoint)) {
                        pos.x = this._initInnerPos.x + ev.deltaX;
                    }
                    this._setInnerPos(pos);
                    break;
                case 'panend':
            }
        },

        // not strict since y is within bounds
        _shouldYMove: function (p) {
            return p.y > (this.model.bounds.y + this.model.tableDims.headerHeight)
        },

        _shouldXMove: function (p) {
            return BaseUtils.containsPoint(this.model.bounds, p)
        },

        onScrollX: function (data) {
            this._setInnerPos(data);
        },

        onScrollY: function (data) {
            this._setInnerPos(data);
        },

        /**
         * check and set inner group position
         * @param {Object} pos = {
         *     x: {Number}
         *     y: {Number}
         * }
         * @returns {Object} pos // valid pos
         * @private
         */
        _setInnerPos: function (pos) {
            var x, y;
            if (pos) {
                if (pos.x != null) {
                    x = pos.x;
                }
                if (pos.y != null) {
                    y = pos.y;
                }
            }

            if (x == null) {
                x = this.innerPosX;
            }
            if (y == null) {
                y = this.innerPosY;
            }

            x = min(max(this.model.bounds.width - this._getInnerWidth(), x), 0);
            y = min(max(this.visibleBodyHeight - this.innerBodyHeight, y), 0);

            if (x !== this.innerPosX || y !== this.innerPosY) {
                this._showShadow && this._showShadow(x !== 0);

                this._getGroup('header').attr('transform', BaseUtils.makeTranslate([x, 0]));
                this._getGroup('inner-body').attr('transform', BaseUtils.makeTranslate([x, y]));
                this.innerPosX = x;
                this.innerPosY = y;

                this.fire('innerChange', { x: x, y: y});
            }
        },

        onresizeStart: function (ev) {
            this._initX = this.model.bounds.x;
            this._initWidth = this.model.bounds.width;
            this._initPointX = ev.containerPoint.x;
        },

        onresizeMove: function () {
            this.update();
            this._fireResize();
        },

        _fireResize: function () {
            this.fire('resize', {
                width: this.model.bounds.width,
                height: this.visibleBodyHeight,
                innerWidth: this._getInnerWidth(),
                innerHeight: this.innerBodyHeight
            });
            this._setInnerPos(); // bounds checking
        },

        onover: function (ev) {
            if (BaseUtils.containsPoint(this.model.bounds, ev.containerPoint)) {
                this.fire('mouseover');
            } else {
                this.fire('mouseout');
            }
        }

    });

});

/**
 * Created by Yuqian on 2017/2/3.
 */

define('chart/gantt/ProcessesView',['require','./TableView','../../utils/BaseUtils','./Scrollbar','../../dom/DomUtils','./helper','./defaultValues'],function (require) {
    var TableView = require('./TableView');
    var BaseUtils = require('../../utils/BaseUtils');
    var Scrollbar = require('./Scrollbar');
    var toBack = require('../../dom/DomUtils').toBack;
    var helper = require('./helper');
    var DEFAULT = require('./defaultValues');
    var LineV = helper.lineV;
    var LineH = helper.lineH;
    var Rect = helper.rect;
    var traverse = helper.traverse;
    var sum = helper.sum;

    var OUTLINE = DEFAULT.OUTLINE,
        INNERLINE = DEFAULT.INNERLINE,
        TWEENLINE = DEFAULT.TWEENLINE;

    return TableView.extend({

        className: 'processesGroup',

        update: function () {
            var renderer = this.renderer, bounds = this.model.bounds;
            renderer.updateClip(this.clip, {width: bounds.width, height: bounds.height});
            this._header();
            this._body();
            this._outline();
        },

        _getInnerWidth: function () {
            return sum(this.model.tableDims.widths)
        },

        _header: function () {
            var R = this.renderer, group = this._getGroup();
            var widths = this.model.tableDims.widths,
                height = this.model.tableDims.headerHeight;

            var header = this.model._getHeader();

            var G = this._getGroup('header');

            if (!G) {
                G = this._addGroup('header', group);
                this._headerEles = {};
                this._headerEles.gs = [];
            }

            var lineV = LineV.bind(null, R, G);
            var lineH = LineH.bind(null, R, G);
            var rect = Rect.bind(null, R, G);

            var gs = this._headerEles.gs, _p = -1;

            var width = 0;
            widths.map(function (w, i) {

                gs[++_p] = rect(
                    {fill: this._getOptionsColor(header[i])},
                    width, 0, w, height,
                    gs[_p]
                );

                if (i) {
                    gs[++_p] = lineV(TWEENLINE, 0, height, width, gs[_p]);
                }

                gs[++_p] = this._drawText(G, header[i].style, height / 2, width + w / 2, header[i].text, gs[_p]);

                width += w;
            }, this);

            var lineAdj = TWEENLINE['stroke-width'] / 2;
            gs[++_p] = lineH(TWEENLINE, 0, width, height - lineAdj, gs[_p]);
        },

        _body: function () {

            if (!this._bodyEles) {
                this._prepareBody();
            }

            var R = this.renderer;
            var G = this._getGroup('inner-body-back');

            var gs = this._bodyEles.gs, _p = -1;

            var lineV = LineV.bind(null, R, G);
            var lineH = LineH.bind(null, R, G);
            var rect = Rect.bind(null, R, G);

            var body = this.model._getBody();

            var widths = this.model.tableDims.widths,
                accWidths = [],
                width = widths.reduce(function (acc, w, i) {
                    accWidths[i] = acc;
                    return acc + w
                }, 0),
                rowNum = this.model.tableDims.rowNum,
                rowHeight = this.model.tableDims.rowHeight;

            var lineIdx = 0,
                colsIdxes = widths.map(function () { return 0 });

            var _drawText = this._drawText.bind(this);

            traverse(
                this.model._getCateRoot(),
                'categories',
                null,
                function (node, depth, len, i) {
                    if (!depth) { return }

                    var col = depth - 1, // col no.
                        lastColIdx = colsIdxes[col], // save up bound
                        nextLineIdx = lineIdx + 1; // down bound

                    // skip merged cell's last child
                    // needn't to draw every single cell outline
                    if (i < len - 1) {
                        ++lineIdx;
                        var style = depth === 1 ? TWEENLINE : INNERLINE;
                        gs[++_p] = lineH(style, accWidths[col], width, rowHeight * lineIdx, gs[_p]);

                        // when a line is drawn,
                        // the cell's last child drawn as well.
                        var n = colsIdxes.length;
                        while (--n >= col) {
                            colsIdxes[n] = lineIdx;
                        }
                    }

                    var text = node.name;
                    if (text == null || text === '') { return }

                    gs[++_p] = _drawText(
                        G,
                        body[col].style,
                        rowHeight * (lastColIdx + nextLineIdx) / 2,
                        accWidths[col] + widths[col] / 2,
                        text,
                        gs[_p]
                    );
            });

            ++lineIdx; // last line height
            var additionIdx = lineIdx;
            while (additionIdx <= rowNum) {
                var style = additionIdx === lineIdx ? TWEENLINE : INNERLINE;
                gs[++_p] = lineH(style, 0, width, rowHeight * additionIdx, gs[_p]);
                ++additionIdx;
            }

            // vertical line
            var acc = 0;
            var height = this.innerBodyHeight;
            widths.map(function (w, i) {
                if (body[i]) {
                    ++_p;
                    if (!gs[_p]) {
                        gs[_p] = G.append(R.rect());
                        gs[_p].style({fill: this._getOptionsColor(body[i])});
                        toBack(gs[_p].node());
                    }

                    rect(null,
                        acc, 0, w, height,
                        gs[_p]
                    );
                }

                if (i) {
                    gs[++_p] = lineV(TWEENLINE, 0, height, acc, gs[_p]);
                }

                acc += w;
            }, this);
        },

        _outline: function () {
            var R = this.renderer, G = this._getGroup();
            var bounds = this.model.bounds;

            if (!this._outlineEles) {
                var lineAdj = OUTLINE['stroke-width'] / 2;

                var lineV = LineV.bind(null, R, G, OUTLINE);
                var lineH = LineH.bind(null, R, G, OUTLINE);

                lineV(0, bounds.height, lineAdj); // left
                lineH(0, this.vanchart.bounds.width, lineAdj); // top
                lineH(0, this.vanchart.bounds.width, bounds.height - lineAdj);// bottom
            }

            this._outlineEles = LineV(R, G, INNERLINE, 0, bounds.height, bounds.width - INNERLINE['stroke-width'] / 2, this._outlineEles); // right
        },

        _scrollbar: function () {
            this._buildScrollbar({
                scrollX: true,
                scrollY: false
            })
        },

        _drawText: function (G, style, y, x, content, old) {
            if (!old) {
                old = G.append(this.renderer
                    .text()
                    .style(style)
                    .textContent(content)
                );
            }
            old.attr({
                x: x,
                y: y,
                dy: '.35em',
                'margin-top': '-0.5em'
            }).vMiddle();
            return old;
        },

        onresizeMove: function (ev) {
            var bounds = this.model.bounds;

            var delta = ev.containerPoint.x - this._initPointX;
            bounds.width = this._initWidth + delta || 0;

            this.model.expandPanelWidth(bounds.width);

            TableView.prototype.onresizeMove.call(this);
        }
    });
});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/Processes',['require','./Table','../../utils/BaseUtils','../../ComponentLibrary','./ProcessesView','./helper','./defaultValues'],function (require) {
    var Table = require('./Table');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var ProcessesView = require('./ProcessesView');
    var helper = require('./helper');
    var traverse = helper.traverse;
    var sum = helper.sum;
    var distribValues = helper.distribValues;

    var _PADDING = require('./defaultValues').PADDING;
    var PADDING = 0; // get from font-size
    var LINE_HEIGHT = 3;

    var getTextDimension = BaseUtils.getTextDimension;
    var Max = Math.max;

    var Processes = Table.extend({

        _refresh: function () {
            PADDING = BaseUtils.paddingConvertWithScale(_PADDING);
        },

        doLayout: function () {

        },

        // get the outline dim
        getInitPanelDims: function () {
            this.tableDims = this._calcTableDims();
            return {
                width: this._calcPanelWidth(),
                headerHeight: this.tableDims.headerHeight, // may change
                rowHeight: this.tableDims.rowHeight,
                rowNum: this.tableDims.rowNum
            }
        },

        setPanelDims: function (panelDims) {
            // set the real dim for render
            this.tableDims.headerHeight = panelDims.headerHeight;
            this.tableDims.rowNum = panelDims.rowNum;

            this.bounds = {
                x: panelDims.x,
                y: panelDims.y,
                width: panelDims.pWidth,
                height: panelDims.height
            }
        },

        _calcPanelWidth: function () {
            var ratio, width;
            var originWidth = sum(this.tableDims.widths);
            if (ratio = this.options.width) {
                var bounds = this.vanchart.bounds;
                width = bounds.width * ratio;

                // may have to expand table width
                if (width > originWidth) {
                    this.expandPanelWidth(width);
                }


            } else {
                width = originWidth;
            }

            // visible width
            return width;
        },

        expandPanelWidth: function (width) {
            if (width <= sum(this.tightWidths)) {
                return
            }

            this.tableDims.widths = distribValues(this.tableDims.widths, width)
        },

        _calcTableDims: function () {
            var header = this._getHeader();
            var body = this._getBody();
            var root = this._getCateRoot();

            var headerDim = this._calcHeaderDim(header);
            var rowDim = this._calcRowDim(headerDim.widths, body, root);

            return {
                headerHeight: headerDim.height,
                rowHeight: rowDim.height,
                widths: rowDim.widths,
                rowNum: rowDim.num
            }
        },

        _calcHeaderDim: function (header) {
            if (!header || !header.length) {
                return {
                    height: 0,
                    widths: []
                }
            }
            var height = 0;

            var widths = header.map(function (h) {
                var dim = getTextDimension(h.text, h.style, false);
                height = Max(height, dim.height * LINE_HEIGHT);
                return dim.width + PADDING * 2;
            });

            return {
                height: height,
                widths: widths
            }
        },

        _calcRowDim: function (widths, body, root) {

            var procMap = this.procMap = {}; // store node & parent
            var cateMap = this.cateMap = {}; // for row

            var height = 0, num = 0;

            traverse(root, 'categories',
            function (node, depth, len, i, parent) {
                if (!depth) { return }
                var col = depth - 1;
                var dim = getTextDimension(node.name, body[col].style, false);
                widths[col] = Max(widths[col], dim.width);

                var c = node.categories;
                if (!(c && c.length > 1)) {
                    // check node has 1/no child's height (:= 1 line height)
                    height = Max(height, dim.height * LINE_HEIGHT);
                    cateMap[node.processesId] = num;
                }

                if (!(c && c.length)) { // leaf
                    ++num;
                }

                procMap[node.processesId] = {
                    options: node,
                    parent: procMap[parent.processesId]
                }
            });

            widths = widths.map(function (w) {
                return w + PADDING * 2
            });

            this.tightWidths = widths.slice();

            return {
                num: num,
                height: height,
                widths: widths
            }
        },

        _getCateRoot: function () {
            return this.options;
        },

        // move view to xxxView
        render: function () {

            if (!Object.keys(this.procMap).length) {
                return
            }

            if (!this.view) {
                this.view = new ProcessesView(this, this.vanchart);
            }

            this.view.render();

        }
    });

    ComponentLibrary.register(ComponentLibrary.PROCESSES, Processes);

    return Processes;
});

/**
 * Created by Yuqian on 2017/2/3.
 */

define('chart/gantt/TimeAxisView',['require','./TableView','../../utils/BaseUtils','./levelDomain','../../dateUnits/dateUnits','./helper','./defaultValues'],function (require) {
    var TableView = require('./TableView');
    var BaseUtils = require('../../utils/BaseUtils');

    var levelDomain = require('./levelDomain');
    var dateUnits = require('../../dateUnits/dateUnits');

    var helper = require('./helper');
    var LineV = helper.lineV;
    var LineH = helper.lineH;
    var Rect = helper.rect;
    var sum = helper.sum;
    var DEFAULT = require('./defaultValues');

    var OUTLINE = DEFAULT.OUTLINE,
        INNERLINE = DEFAULT.INNERLINE,
        TWEENLINE = DEFAULT.TWEENLINE,

        getTextDimension = BaseUtils.getTextDimension,
        bindData = BaseUtils.bindData;

    function findIndex (array, fn) {
        var i = -1, len = array.length;
        while (++i < len) {
            if (fn(array[i])) {
                return i
            }
        }
    }

    return TableView.extend({

        className: 'timeaxisGroup',

        initialize: function () {
            TableView.prototype.initialize.apply(this, arguments);

            var vanchart = this.vanchart;
            this.on('innerChange', function (v) {
                vanchart.fire('moveSeriesTextDivGroup', v);
            });
            this.on('resize', function () {
                vanchart.fire('updateSeriesTextDivGroup');
            })
        },

        update: function () {
            var renderer = this.renderer, bounds = this.model.bounds;
            this._getGroup().attr('transform', BaseUtils.makeTranslate(bounds));
            renderer.updateClip(this.clip, {width: bounds.width, height: bounds.height});
            this._header();
            this._body();
            this._outline();
        },

        updateContent: function () {
            this._header();
            this._body();
            this.leftUp = null;
            this._fireResize();
        },

        _setInnerPos: function (pos) {

            pos = TableView.prototype._setInnerPos.call(this, pos);

            // so, bad, smell...
            var headerData = this.model._headerData;
            if (!this.leftUp) {
                var l = this.l.bind(null, -this.innerPosX);
                var r = this.r.bind(null, -this.innerPosX + this.model.bounds.width);
                this.leftUp = {
                    i: findIndex(headerData.upTexts, l),
                    data: headerData.upTexts
                };
                this.leftSub = {
                    i: findIndex(headerData.subTexts, l),
                    data: headerData.subTexts
                };
                this.rightUp = {
                    i: findIndex(headerData.upTexts, r),
                    data: headerData.upTexts
                };
                this.rightSub = {
                    i: findIndex(headerData.subTexts, r),
                    data: headerData.subTexts
                };
            }
            this._checkTextBounds('left', this.leftUp);
            this._checkTextBounds('left', this.leftSub);
            this._checkTextBounds('right', this.rightUp);
            this._checkTextBounds('right', this.rightSub);

            return pos;
        },

        l: function (px, d) {
            return px >= d.left
        },

        r: function (px, d) {
            return px <= d.right
        },

        _checkTextBounds: function (side, t) {
            t.i = t.i || 0;
            t.i = Math.min(t.i, t.data.length - 1);
            var d = t.data[t.i]; // text data
            var px, left, right;
            var leftBound = -this.innerPosX;
            var rightBound = -this.innerPosX + this.model.bounds.width;
            if (side === 'left') {
                px = leftBound;
                left = px;
                right = Math.min(d.right, rightBound);
            } else {
                px = rightBound;
                left = Math.max(d.left, leftBound);
                right = px;
            }
            var l = this.l(px, d);
            var r = this.r(px, d);
            if (l && r) {
                // adjust label pos
                if (!d.width) { // text width
                    d.width = getTextDimension(d.content, d.style).width;
                }
                if (right - left >= d.width) {
                    // cell wider than text
                    d.ele.attr('x', (left + right) / 2).vMiddle();
                } else {
                    // hide this text
                    d.ele.attr('x', -100);
                }
            } else {
                d.ele.attr('x', d.x).vMiddle(); // recover
                if (!l) { // adjust last text
                    --t.i;
                } else if (!r) { // adjust next text
                    ++t.i;
                }
            }
        },

        _header: function () {
            var R = this.renderer, group = this._getGroup();

            var model = this.model;
            var tWidth = model.bounds.width;
            var heights = model.tableDims.heights;
            var height = sum(heights);

            var header = model._getHeader();

            if (!this._headerEles) {
                this._headerEles = {
                    upLines: [],
                    upTexts: [],
                    subLines: [],
                    subTexts: []
                };
                this._headerEles.gs = [];
            }

            var gs = this._headerEles.gs, _p = -1;
            var eles = this._headerEles;
            var data = this.model._headerData;

            // add the background on the parent group
            // so, unrelated with innerWidth
            gs[++_p] = Rect(R, group,
                {fill: this._getOptionsColor(header[0])},
                0, 0, tWidth, heights[0],
                gs[_p]
            );

            gs[++_p] = Rect(R, group,
                {fill: this._getOptionsColor(header[1])},
                0, heights[0], tWidth, heights[1],
                gs[_p]
            );

            var lineAdj = TWEENLINE['stroke-width'] / 2;
            gs[++_p] = LineH(R, group, TWEENLINE, 0, tWidth, heights[0] - lineAdj, gs[_p]);
            gs[++_p] = LineH(R, group, TWEENLINE, 0, tWidth, height - lineAdj, gs[_p]);

            var G = this._getGroup('header') || this._addGroup('header', group);

            ['upLines', 'subLines'].map(function (type) {
                var selection = bindData(eles[type], data[type]);

                selection.exit.map(function (d) {
                    d.remove();
                });

                var enter = selection.enter.map(function (d) {
                    return G.append(R.line().datum(d).style(INNERLINE));
                });

                eles[type] = enter.concat(selection.update)
                    .map(function (ele) {
                        return ele.attr(ele.datum())
                    });
            });

            ['upTexts', 'subTexts'].map(function (type) {
                var selection = bindData(eles[type], data[type]);

                selection.exit.map(function (d) {
                    d.remove();
                });

                var enter = selection.enter.map(function (d) {
                    return G.append(R.text().datum(d).style(d.style));
                });

                eles[type] = enter.concat(selection.update)
                    .map(function (ele) {
                        var d = ele.datum();

                        d.ele = ele;

                        ele
                        .textContent(d.content)
                        .attr({
                            x: d.x,
                            y: d.y,
                            dy: '.35em',
                            'margin-top': '-0.5em'
                        }).vMiddle();
                        return ele
                    });
            });
        },

        _body: function () {

            if (!this._bodyEles) {
                this._prepareBody();
                this._shadow();
            }

            this._bodyData = {
                hLines: [],
                vLines: [],
                rects: [] // weekend bg
            };

            var eles = this._bodyEles, data = this._bodyData;

            var R = this.renderer;
            var G = this._getGroup('inner-body-back');

            var rowHeight = this.model.tableDims.rowHeight;
            var rowNum = this.model.tableDims.rowNum;
            var height = this.innerBodyHeight;

            // maybe need another back group
            data.rects = this.model._weekendsWidths;

            var selection = bindData(eles.rects, data.rects);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.rect().datum(d).style({fill: DEFAULT.WEEKEND_COLOR}));
            });

            eles.rects = enter.concat(selection.update)
                .map(function (ele) {
                    var d = ele.datum();
                    return ele.attr({
                        x: d.from,
                        y: 0,
                        width: d.to - d.from,
                        height: height
                    })
                });

            // vertical lines
            data.vLines = this.model._headerData.subLines;

            var selection = bindData(eles.vLines, data.vLines);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.line().datum(d).style(INNERLINE));
            });


            eles.vLines = enter.concat(selection.update)
                .map(function (ele) {
                    var d = ele.datum();
                    return ele.attr({
                        x1: d.x1,
                        y1: 0,
                        x2: d.x2,
                        y2: height
                    })
                });

            // horizontal lines
            var i = 0;
            while (++i <= rowNum) {
                data.hLines.push({
                    x1: 0,
                    y1: i * rowHeight,
                    x2: this._getInnerWidth(),
                    y2: i * rowHeight
                })
            }

            var selection = bindData(eles.hLines, data.hLines);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.line().datum(d).style(INNERLINE));
            });

            eles.hLines = enter.concat(selection.update)
                .map(function (ele) {
                    return ele.attr(ele.datum())
                });

        },

        _outline: function () {
            var R = this.renderer, G = this._getGroup();
            var bounds = this.model.bounds;

            var lineV = LineV.bind(null, R, G, OUTLINE);
            var lineAdj = OUTLINE['stroke-width'] / 2;

            if (!this._outlineEles) {
                var lineH = LineH.bind(null, R, G, OUTLINE);

                lineH(0, this.vanchart.bounds.width, lineAdj); // top
                lineH(0, this.vanchart.bounds.width, bounds.height - lineAdj); // bottom
            }

            // VML bug
            var right = bounds.width - lineAdj;
            if (!BaseUtils.isSupportSVG()) {
                right = Math.floor(right);
            }

            this._outlineEles = lineV(0, bounds.height, right, this._outlineEles); // right
        },

        _scrollbar: function () {
            this._buildScrollbar({
                scrollX: true,
                scrollY: true
            })
        },

        _shadow: function () {
            var attrs = {'x1': 0, 'y1': 0, 'x2': 1, 'y2': 0};

            var stops = [
                {'offset':   '0%', 'stop-color': 'rgb(62, 62, 62)', 'stop-opacity': '0.2'},
                {'offset':  '75%', 'stop-color': 'rgb(62, 62, 62)', 'stop-opacity': '0'}
            ];

            var gradient = this.renderer.colorGradient(attrs, stops);
            var url = "url(#" + BaseUtils.stamp(gradient) + ")";

            this._shadowRect = this._getGroup('body')
                .append(this.renderer.rect())
                .style('transition', 'opacity 0.2s')
                .attr({
                    x: 0,
                    y: 0,
                    width: 10,
                    height: this.model.bounds.height,
                    fill: url
                });

            this._showShadow(false);
        },

        _showShadow: function (d) {
            if (d !== this._shadowShowed) {
                this._shadowShowed = d;
                this._shadowRect.style('opacity', d ? '1' : '0');
            }
        },

        onresizeMove: function (ev) {
            var bounds = this.model.bounds;

            var delta = this._initPointX - ev.containerPoint.x;
            bounds.x = this._initX - delta;
            bounds.width = this._initWidth + delta || 0;

            TableView.prototype.onresizeMove.call(this);
        }

    });
});
/**
 * Created by Yuqian on 2017/2/6.
 */

define('chart/gantt/levelText',['require','../../locale/localeText'],function (require) {

    var localeText = require('../../locale/localeText');

    // wow, such work
    // so dirty...
    var keys = [
        // 0
        // 2017年 | __上__
        ['yyyy', 'N'],
        // 1
        // 2017年 | 上
        ['yyyy', 'N'],
        // 2
        // 2017年 | 一季度
        ['yyyy', 'QQQ'],
        // 3
        // 2017,上 | 01
        ['N[,]yyyy', 'MMM'],
        // 4
        // 2017,一季度 | 1月
        ['QQQ[,]yyyy', 'MMM'],
        // 5
        // 2017,一季度 | 1月
        ['QQQ[,]yyyy', 'MMM'],
        // 6
        // 2017年1月 | 01周
        ['MMM[,]yyyy', 'www'],
        // 7
        // 2017年1月2日 | 一...日
        ['d[,]MMM[,]yyyy', 'eee'],
        // 8
        // 2017年1月 | 1...30
        ['MMM[,]yyyy', 'd'],
        // 9
        // 1月 | 1...30
        ['MMM', 'd'],
        // 10
        // 1月1日 | 上午
        ['d[,]MMM', 'a'],
        // 11
        // 1月1日 | 0~6点
        ['d[,]MMM', 'I'],
        // 12
        // 1月1日 | 1...24
        ['d[,]MMM', 'HHH']
    ];

    function getKeys () {
        return localeText.getTextMap()['ganttLevels'] || keys
    }

    function getUpText(date, level) {
        return date.format(getKeys()[level][0])
    }

    function getSubText(date, level) {
        return date.format(getKeys()[level][1])
    }

    return {
        getUpText: getUpText,
        getSubText: getSubText
    }


});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/TimeAxis',['require','./Table','../../utils/BaseUtils','../../ComponentLibrary','./TimeAxisView','./levelDomain','../../dateUnits/dateUnits','../../utils/Scale','./helper','./levelText','./levelText','./defaultValues'],function (require) {
    var Table = require('./Table');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var TimeAxisView = require('./TimeAxisView');
    var levelDomain = require('./levelDomain');
    var dateUnits = require('../../dateUnits/dateUnits');
    var Scale = require('../../utils/Scale');
    var helper = require('./helper');
    var sum = helper.sum;
    var distribValues = helper.distribValues;
    var getUpText = require('./levelText').getUpText;
    var getSubText = require('./levelText').getSubText;

    var _PADDING = require('./defaultValues').PADDING,
        PADDING = 0,
        LINE_HEIGHT = 3;

    var upUnit = levelDomain.upUnit,
        subUnit = levelDomain.subUnit,
        LEVEL_LEN = levelDomain.LEN,
        Ratio = levelDomain.Ratio;

    var getTextDimension = BaseUtils.getTextDimension,
        getTextHeight = BaseUtils.getTextHeight;
    var object2date = BaseUtils.object2date;
    var isEmpty = BaseUtils.isEmpty;
    var Max = Math.max;
    var Min = Math.min;

    function moveToNext (datetime, unit, ref, ratio, acc) {
        datetime.add(1, unit);
        var pos = (datetime - ref) * ratio;
        acc.push(pos);
        return pos;
    }

    var TimeAxis = Table.extend({

        _refresh: function () {
            PADDING = BaseUtils.paddingConvertWithScale(_PADDING);

            this.lastScale = this.scale;
            this.scale = Scale.linear();
        },

        doLayout: function () {

        },

        // get the outline dim
        getInitPanelDims: function () {
            this.tableDims = this._calcTableDims();
            return {
                headerHeight: sum(this.tableDims.heights)
                // , rowHeight: this.tableDims.rowHeight
            }
        },

        // tablesDims.heights are header heights
        setPanelDims: function (panelDims) {
            // set the real dim for render
            var headerHeight = panelDims.headerHeight;
            this.tableDims.headerHeight = headerHeight; // distribute to two
            this.tableDims.rowHeight = panelDims.rowHeight;
            this.tableDims.rowNum = panelDims.rowNum;

            var heightNow = sum(this.tableDims.heights);
            if (headerHeight > heightNow) {
                this.tableDims.heights =
                    distribValues(this.tableDims.heights, headerHeight);
            }

            this.bounds = {
                x: panelDims.x + panelDims.pWidth,
                y: panelDims.y,
                width: panelDims.tWidth,
                height: panelDims.height
            }
        },

        _calcTableDims: function () {

            var heights = this._getHeaderHeights();

            return {
                heights: heights
                // , rowHeight: 0 // according to P
            }
        },

        _getHeaderHeights: function () {
            return this._getHeader().map(function (h) {
                return getTextHeight(h.style) * LINE_HEIGHT;
            });
        },

        calcSeries: function (series, procMap, cateMap) {

            // get time range
            var min = Number.MAX_VALUE, max = 0;
            var domainMap = {};
            var idMap = {};
            var rowMap = {};
            var markArray = [];
            series.map(function (item) {

                item.points.map(function (p) {
                    var options = p.options;
                    var st = object2date(options.startTime),
                        ft = object2date(options.finishTime),
                        mt = object2date(options.markTime);

                    if (isNaN(st.getTime()) || isNaN(ft.getTime())) {
                        p.isNull = true;
                        return
                    }

                    var pid = p.options.processesId;

                    if (procMap[pid] != null) {

                        var rowNum = cateMap[pid];
                        rowMap[rowNum] = rowMap[rowNum] || [];
                        rowMap[rowNum].push(p);
                        p.rowNum = rowNum;

                        // wonder about where to deal default value
                        // debug first...
                        p.progress = helper.getValidProgress(options.progress);
                        options.tooltip.follow = true;

                        // problem: [A, B, C, D]; pId -> C
                        if (!p.processes) {
                            var id = pid, node = procMap[id];
                            p.processes = [node.options];
                            while (node = node.parent) {
                                p.processes.unshift(node.options);
                            }
                        }

                        if (!isEmpty(p.options.id)) {
                            idMap[options.id] = p;
                        }

                        var thisMap =
                            domainMap[pid] = domainMap[pid] ||
                                {min: Number.MAX_VALUE, max: 0};

                        if (mt && !isNaN(mt.getTime())) {
                            markArray.push(p);
                            thisMap.min = Min(thisMap.min, mt);
                            thisMap.max = Max(thisMap.max, mt);
                        }

                        thisMap.min = Min(thisMap.min, st, ft);
                        thisMap.max = Max(thisMap.max, st, ft);
                        min = Min(thisMap.min, min);
                        max = Max(thisMap.max, max);

                        p.startTime = dateUnits(st);
                        p.finishTime = dateUnits(ft);
                        p.markTime = dateUnits(mt);
                        p.duration = dateUnits.duration(ft - st);
                    }
                })
            });

            this.domainMap = domainMap; // seems useless →_→
            this.dateDomain = [min, max];
            this.idMap = idMap;
            this.rowMap = rowMap;
            this.markArray = markArray;

            if (min > max) {
                this.dateDomain = []
            }
        },

        render: function () {

            if (!this.dateDomain.length) {
                return
            }

            if (!this.view) {
                this.view = new TimeAxisView(this, this.vanchart);
                this.view.render();
                var m = this._calcFirstViewMovement();
                this.view.changeInner({x: m});
            } else {
                this.view.render();
            }
        },

        _calcFirstViewMovement: function () {
            var oFrom = dateUnits(this.dateDomain[0]);
            var su = subUnit(this.level);
            var barFrom = +oFrom.startOf(su);
            var from = +oFrom.add(-1, su);
            return this.scale(from) - this.scale(barFrom);
        },

        // level change
        renderContent: function () {
            if (!this.dateDomain.length) {
                return
            }
            this.view.updateContent();
        },

        calcScale: function () {
            if (!this.dateDomain.length) {
                return
            }

            var data = this._headerData = {
                upLines: [],
                upTexts: [],
                subLines: [],
                subTexts: []
            };

            var heights = this.tableDims.heights;
            var height = sum(heights);
            var header = this._getHeader();

            var dateDomain = this.dateDomain;
            var em = this._getEm();

            var level = this.getLevel();
            var ratio = Ratio(em, level);
            var shouldCheckWeekends = this.shouldShowWeekends();

            // prepare date stuff

            // get units
            var uu = upUnit(level),
                su = subUnit(level);

            // dateUnits Objects
            var oFrom = dateUnits(dateDomain[0]),
                oTo = dateUnits(dateDomain[1]);

            // round the date
            var sFrom = dateUnits(oFrom).startOf(su).add(-1, su),
                sTo = dateUnits(oTo).endOf(su).add(1, su);
            var uFrom = dateUnits(sFrom).startOf(uu); // according to sub

            // accumulators
            var upDatetime = dateUnits(uFrom);
            var subDatetime = dateUnits(sFrom);
            var upW = (upDatetime - sFrom) * ratio; // first cell
            var subW = (subDatetime - sFrom) * ratio; // first cell

            // step record
            var upWidths = [upW];
            var subWidths = [subW];

            var moveToNextUp = moveToNext.bind(null, upDatetime, uu, sFrom, ratio, upWidths);
            var moveToNextSub = moveToNext.bind(null, subDatetime, su, sFrom, ratio, subWidths);

            // store weekend background (width from, to)
            var ww = this._weekendsWidths = [];

            var timeRangeWidth = (sTo - sFrom) * ratio;
            this.scale.domain([sFrom, sTo]).range([0, timeRangeWidth]);

            // time range width < bounds.width
            this.innerWidth = Math.max(timeRangeWidth, this.bounds.width);

            while (subW < this.innerWidth) {

                checkWeekend();

                var content, pos;

                if (upDatetime <= subDatetime) { // should draw up

                    data.upLines.push({
                        x1: upW,
                        y1: 0,
                        x2: upW,
                        y2: heights[0]
                    });
                    data.subLines.push({
                        x1: subW,
                        y1: heights[0],
                        x2: subW,
                        y2: height
                    });

                    // text means left bound date, save it now
                    content = getUpText(upDatetime, level);

                    pos = moveToNextUp();

                    data.upTexts.push({
                        style: header[0].style,
                        left: upW, // left & right bounds for adjust
                        right: pos,
                        x: (pos + upW) / 2,
                        y: heights[0] / 2,
                        content: content
                    });

                    upW = pos;

                } else {
                    data.subLines.push({
                        x1: subW,
                        y1: heights[0],
                        x2: subW,
                        y2: height
                    });
                }

                content = getSubText(subDatetime, level);

                pos = moveToNextSub();

                data.subTexts.push({
                    style: header[1].style,
                    left: subW,
                    right: pos,
                    x: (pos + subW) / 2,
                    y: heights[0] + heights[1] / 2,
                    content: content
                });

                subW = pos;
            }

            checkWeekend(true); // to end up right bounds

            // helper
            function checkWeekend(isEnd) {
                if (!shouldCheckWeekends) {
                    return
                }
                var last = ww[ww.length - 1];
                if (subDatetime.isWeekend() && !isEnd) {
                    if (!last || last && last.finish) {
                        ww.push({
                            from: subW,
                            finish: false
                        });
                    }
                } else {
                    if (last && !last.finish) {
                        last.to = subW;
                        last.finish = true;
                    }
                }
            }
        },

        getLevel: function () {

            if (this.level == null) {
                if (this.dateDomain.length) {
                    // get from options
                    var isLegal = this.setLevel(this.options.zoomLevel);
                    // options' illegal
                    if (!isLegal) {
                        this.setLevel(this._guessLevel());
                    }
                    this.initLevel = this.level;
                } else {
                    return
                }
            }

            return this.level
        },

        setLevel: function (level) {
            if (level == null || level < 0 || level > LEVEL_LEN - 1) {
                return false
            } else {
                this.level = level;
                return true
            }
        },

        _guessLevel: function () {
            var dateDomain = this.dateDomain;
            var em = this._getEm();
            var width = this.bounds.width;

            var ratio = width / (dateDomain[1] - dateDomain[0]);

            var l = LEVEL_LEN;
            while (--l > -1) {
                var r = Ratio(em, l);
                if (r < ratio) {
                    break;
                }
            }

            return Math.max(0, l);
        },

        // the problem here:
        // did not consider the up header width.
        // thus when the up exceed the sub...
        // adjust em. (do not seem as the true font em)
        // em = width / 6;
        _getEm: function () {
            var header = this._getHeader();

            var tmpDate = dateUnits();
            var upWidth = getTextDimension(getUpText(tmpDate, 0), header[0].style).width + 2 * PADDING;
            // seem sub as one char
            var subWidth = 6 * getTextDimension(getSubText(tmpDate, 0), header[1].style).width;

            var sub = subWidth / 6;
            if (upWidth > subWidth) {
                sub = upWidth / 6;
            }

            return sub
        },

        isZoomEnabled: function () {
            return this.options.zoom
        },

        shouldShowWeekends: function () {
            return this.level > 6 && this.options.showWeekends
        }

    });

    ComponentLibrary.register(ComponentLibrary.TIMEAXIS, TimeAxis);

    return TimeAxis;
});

/**
 * Created by Yuqian on 2017/3/8.
 */

define('chart/gantt/Link',['require','../../vans/VanChart','../../utils/PathGenerator','../../Constants'],function (require) {
var VanChart = require('../../vans/VanChart');
var PathGenerator = require('../../utils/PathGenerator');
var Constants = require('../../Constants');

var PathBefore = PathGenerator.line().interpolate('step-before');
var PathAfter = PathGenerator.line().interpolate('step-after');

var SAME_LINE_GAP = 2;
var ARROW_WIDTH = 3;

var TYPES = {};
TYPES.fs = TYPES.ff = TYPES.sf = TYPES.ss = true;

function calcLinks (cfg) {
    var options = cfg.links,
        idMap = cfg.idMap;
    return options
        .filter(function (link) {
            return link.type && TYPES[link.type.toLowerCase()]
                && link.lineWidth
                && idMap[link.from] && idMap[link.from].isVisible()
                && idMap[link.to] && idMap[link.to].isVisible()
        })
        .map(function (link) {
            return buildLink(link, cfg)
        }, this);
}

function buildLink (link, cfg) {

    var paths = getLinkPath(link, cfg);

    var lineAttr = {
        'd': paths.line
    };
    var lineStyle = {
        'fill': 'none',
        'stroke': link.lineColor,
        'stroke-width': link.lineWidth,
        'stroke-dasharray': Constants.DASH_TYPE[link.dashStyle || 'Solid']
    };

    var arrowAttr = {
        'd': paths.arrow
    };
    var arrowStyle = {
        'fill': link.lineColor,
        'stroke': 'none'
    };

    return {
        lineAttr: lineAttr,
        lineStyle: lineStyle,
        arrowAttr: arrowAttr,
        arrowStyle: arrowStyle
    }
}

function getLinkPath (link, cfg) {
    var idMap = cfg.idMap;
    var type = link.type.toLowerCase();
    var from = getLinePoint(type, 0, idMap[link.from]);
    var to = getLinePoint(type, 1, idMap[link.to]);

    var begin = from[1]; // turn point of from
    var end = to[0]; // turn point of to
    var beginx = begin[0];
    var endx = end[0];

    var gen = PathBefore;
    var mp = [null, (begin[1] + end[1]) / 2]; // middle point to adjust line

    if (begin[1] === end[1]) { // same line
        var rowNum = idMap[link.from].rowNum;
        var barFrom = idMap[link.from];
        var barTo = idMap[link.to];
        var fromLeft = barFrom.rect.x;
        var fromRight = barFrom.rect.x + barFrom.rect.width;
        var toLeft = barTo.rect.x;
        var toRight = barTo.rect.x + barTo.rect.width;

        // same line no turn:
        //    1. fs/sf, f < s
        // && 2. no bar is between from,to

        var condition1 = (type === 'fs' && fromRight < toLeft) || (type === 'sf' && toRight < fromLeft);

        function noBetween() {
            var left = Math.min(fromRight, toRight);
            var right = Math.max(fromLeft, toLeft);
            return cfg.rowMap[rowNum].every(function (bar) {
                if (bar === barFrom || bar === barTo) {
                    return true
                }
                var minx = Math.max(left, bar.rect.x);
                var maxx = Math.min(right, bar.rect.x + bar.rect.width);
                return minx > maxx
            });
        }

        if (condition1 && noBetween()) {
            to = [from[0], to[1]];
            from = [];
        } else {
            mp = [begin[0], begin[1] - idMap[link.from].rect.height / 2 - SAME_LINE_GAP];
        }
        gen = PathAfter;
    } else {
        switch (type) {
            case 'fs':
                if (beginx > endx) {
                    mp[0] = endx;
                }
                break;
            case 'ff':
                if (beginx < endx) {
                    gen = PathAfter;
                }
                break;
            case 'ss':
                if (beginx > endx) {
                    gen = PathAfter;
                }
                break;
            case 'sf':
            default:
                if (beginx < endx) {
                    mp[0] = endx
                }
        }
    }

    var points = from;
    if (mp[0] != null) {
        points.push(mp);
    }
    points = points.concat(to);

    return {
        line: gen(points),
        arrow: genArrowPath(to[1], type.charAt(1))
    }
}

// i = 0/1
function getLinePoint (type, i, p) {
    var cmd = type.charAt(i);
    var rect = p.rect;
    var y = rect.y + rect.height / 2;
    var a = Math.max(rect.height / 2, ARROW_WIDTH * 2);

    // point on the rect
    var onPoint = [
        cmd === 's' ? rect.x : rect.x + rect.width,
        y
    ];

    // point off the rect
    var offPoint = [
        onPoint[0] + (cmd === 's' ? -a : a),
        y
    ];

    var points;

    // if 0 (from), on -> off
    // if 1 (to), off -> on

    if (i) { // 1
        points = [offPoint, onPoint];
    } else {
        points = [onPoint, offPoint];
    }
    return points
}

// pos: vertex
// cms: f ←, s →
// Mx,yl3,3v-6z
// Mx,yl-3,3v-6z
function genArrowPath (pos, cmd) {
    var d = 'M' + pos[0] + ',' + pos[1] + 'l';
    var w = ARROW_WIDTH;
    if (cmd === 's') { // to right
        d += '-';
    }
    d += w + ',' + w + 'v-' + w * 2 + 'z';
    return d
}

VanChart.include({

    renderLinks: function () {
        this._linksGroup && this._linksGroup.remove();
        this._linksGroup = this._links = null;

        var links = this.options.plotOptions.links;
        if (!links || !links.length) { return }

        if (!this._linksGroup) {
            this._linksGroup = this.renderer.group().addTo(this.clipSeriesGroup);
        }
        if (!this._links) {

            var T = this.getTimeAxis();

            this._links = calcLinks({
                links: links,
                idMap: T.idMap,
                rowMap: T.rowMap
            });
            var g = this._linksGroup, R = this.renderer;

            this._links.map(function (link) {
                link._line = g.append(R.path()
                    .attr(link.lineAttr)
                    .style(link.lineStyle)
                );
                link._arrow = g.append(R.path()
                    .attr(link.arrowAttr)
                    .style(link.arrowStyle)
                )
            });
        }
    }
});
});
/**
 * Created by Yuqian on 2017/3/9.
 */

define('chart/gantt/Mark',['require','../../vans/VanChart','../../utils/PathGenerator','../../Constants','../../utils/BaseUtils'],function (require) {
    var VanChart = require('../../vans/VanChart');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');
    var BaseUtils = require('../../utils/BaseUtils');
    var getMarkerPath = PathGenerator.getMarkerPath;
    var makeTranslate = BaseUtils.makeTranslate;

    function drawMark (R, pos, size, type, color) {
        var g = R.group().attr('transform', makeTranslate(pos));

        if(BaseUtils.isImageMarker(type)) {
            var w = size, h = size;
            g.image = R.image({
                'preserveAspectRatio': 'none', 'x': -w / 2, 'y': -h / 2, 'width': w, 'height': h
            });
            g.image.imageContent(type);
            g.append(g.image);

        } else {
            var d = getMarkerPath(type, size / 2);
            g.append(R.path()
                .attr('d', d)
                .style({
                    stroke: 'none',
                    fill: color
                })
            );
        }

        return g
    }

    VanChart.include({
        renderMarks: function () {
            this._marksGroup && this._marksGroup.remove();
            this._marksGroup = this._marks = null;
            if (!this._marksGroup) {
                this._marksGroup = this.renderer.group().addTo(this.clipSeriesGroup);
            }
            if (!this._marks) {
                var timeAxis = this.getTimeAxis();
                var markArray = timeAxis.markArray;
                var scale = timeAxis.scale;
                var g = this._marksGroup, R = this.renderer;

                markArray.map(function (p) {
                    if (!(p.visible && p.series.visible)) { return }
                    var height = p.rect.height;
                    var x = scale(p.markTime);
                    var y = p.rect.y + 0.5 * height;
                    g.append(
                        drawMark(R, [x, y], height, p.options.markType, p.options.markColor)
                    );
                });
            }
        }
    });
});

/**
 * Created by Yuqian on 2017/3/1.
 */

define('dateUnits/locale/zh-cn',[],function () {
    return {

        _locale: 'zh-cn',

        // duration[units] can be a function
        // duration.year = function(duration) { return 'string' }
        duration: {
            year: '年',
            month: '月',
            day: '天',
            hour: '小时',
            minute: '分钟',
            second: '秒'
        },

        halfYears: ['上', '下'],
        quarters: '一季度_二季度_三季度_四季度'.split('_'),
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        meridiem: ['上午', '下午'],
        qDay: '0~6点_6~12点_12~18点_18~24点'.split('_'),

        base: function (add, names) {
            // format according to
            // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
            //
            // custom:
            // half year = N
            // 1/4 day = I

            // week of year
            add('www', 0, 0, function () {
                return this.week() + '周';
            });
        }
    }
});

/**
 * Created by Yuqian on 2017/6/7.
 */

define('dateUnits/locale/ja-jp',[],function () {
    return {

        _locale: 'ja-jp',

        // duration[units] can be a function
        // duration.year = function(duration) { return 'string' }
        duration: {
            year: '年',
            month: 'か月',
            day: '日',
            hour: '時間',
            minute: '分',
            second: '秒'
        },

        halfYears: ['前', '後'],
        quarters: '第1四半期_第2四半期_第3四半期_第4四半期'.split('_'),
        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
        meridiem: ['午前', '午後'],
        qDay: '0~6時_6~12時_12~18時_18~24時'.split('_'),

        base: function (add, names) {
            // format according to
            // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
            //
            // custom:
            // half year = N
            // 1/4 day = I

            // week of year
            add('www', 0, 0, function () {
                return '第' + this.week() + '週';
            });
        }
    }
});

/**
 * Created by Yuqian on 2017/6/7.
 */

define('locale/ja-jp',['require'],function (require) {
    return {

        _locale: 'ja-jp',

        'startTime': '開始時間',
        'finishTime': '終了時間',
        'duration': '続ける時間',
        'progress': '進捗',

        ganttLevels: [
            // 0
            ['yyyy[年]', 'N'],
            // 1
            ['yyyy[年]', 'N'],
            // 2
            ['yyyy[年]', 'QQQ'],
            // 3
            ['yyyy[、]N', 'MMM'],
            // 4
            ['yyyy[、]QQQ', 'MMM'],
            // 5
            ['yyyy[、]QQQ', 'MMM'],
            // 6
            ['yyyy[年]MM[月]', 'www'],
            // 7
            ['yyyy[年]MM[月]dd[日]', 'eeeeee'],
            // 8
            ['yyyy[年]MM[月]', 'd'],
            // 9
            ['MMM', 'd'],
            // 10
            ['MM[月]dd[日]', 'a'],
            // 11
            ['MM[月]dd[日]', 'I'],
            // 12
            ['MM[月]dd[日]', 'H']
        ]
    }
});

/**
 * Created by Yuqian on 2017/1/11.
 */

define('chart/gantt/Gantt',['require','../../Constants','../../vans/VanChart','../../vans/VanChartLayout','../../ComponentLibrary','../../utils/BaseUtils','../../locale/localeText','../../dateUnits/dateUnits','./GanttSeries','./LevelBar','./Processes','./TimeAxis','./Link','./Mark','../../dateUnits/locale/zh-cn','../../dateUnits/locale/ja-jp','../../locale/ja-jp','../../vans/VanChartLibrary'],function (require) {

    var Constants = require('../../Constants');
    var VanChart = require('../../vans/VanChart');
    var VanChartLayout = require('../../vans/VanChartLayout');
    var ComponentLibrary = require('../../ComponentLibrary');
    var BaseUtils = require('../../utils/BaseUtils');
    var localeText = require('../../locale/localeText');
    var dateUnits = require('../../dateUnits/dateUnits');

    // require for build
    require('./GanttSeries');
    require('./LevelBar');
    require('./Processes');
    require('./TimeAxis');
    require('./Link');
    require('./Mark');

    require('../../dateUnits/locale/zh-cn');

    require('../../dateUnits/locale/ja-jp');
    require('../../locale/ja-jp');

    var PROCESSES = ComponentLibrary.PROCESSES;
    var TIMEAXIS = ComponentLibrary.TIMEAXIS;
    var LEVELBAR = ComponentLibrary.LEVELBAR;

    var Max = Math.max;

    var RESZIE_TOLERANCE = 10;

    var Gantt =  VanChart.extend({
        vanChartType: Constants.GANTT_CHART,

        initialize: function (option) {

            var lan = localeText.normalizeLocale(option.language);
            if (lan && !/^en/.test(lan)) { // default
                var dateLocale = require('../../dateUnits/locale/' + lan);
                dateUnits.setLocale(dateLocale);
            }

            VanChart.prototype.initialize.apply(this, arguments);
            this.handler && this.handler.on('resizeEnd', this.onResizeEnd, this);

            // 看来还是少了个中介→_→
            this.on('moveSeriesTextDivGroup', this.moveSeriesTextDivGroup);
            this.on('updateSeriesTextDivGroup', this.updateSeriesTextDivGroup)
        },

        refresh: function (options) {
            // @Cmen：CHART-1130:同initialize
            if(!this.width || !this.height) { return; }

            if (this.getTimeAxis()) {
                this.remove();
                var vanchart = this;
                vanchart.panBounds = vanchart.backGroup = vanchart.processesGroup
                    = vanchart.timeaxisGroup = vanchart.frontGroup
                    = vanchart.seriesTextDivGroupWrapper = null;
                ComponentLibrary.ComponentsOrder.map(function (c) {
                    if (c in vanchart.components) {
                        vanchart.components[c].remove();
                        vanchart.components[c] = null;
                    }
                });
                vanchart.components = {};
                var oldFullScreenChart = this.fullScreenChart;

                this.initialize(options, this.wrapDom, this.vancharts);   // 这一步把fullScreenChart置为null，这里在之前保存一下

                if(oldFullScreenChart){
                    this.fullScreenChart = oldFullScreenChart;
                    this.fullScreenChart.setData(this.options);
                }
            } else {
                VanChart.prototype.refresh.call(this, options);
            }
        },

        resize: function () {
            this._sizeChanged = true;
            this.refresh(this.options);
        },

        layoutComponentsAndCharts: function () {
            var vanchart = this;
            vanchart.bounds = vanchart._getDefaultBounds();
            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in vanchart.components) {
                    vanchart.components[c].doLayout();
                }
            });

            var P = this.getProcesses();
            var T = this.getTimeAxis();

            if (!this.panBounds) {
                var panelDims = this._calcDims(P, T);
                this.panBounds = this._calcPanBounds(panelDims);

                // re-calc after resize
                this.resizeBounds = this._calcResizeBounds(panelDims);

                P.setPanelDims(panelDims);
                T.setPanelDims(panelDims);
            }

            // todo calcSeries -> vcLayout.calcS...
            T.calcSeries(this.series, P.procMap, P.cateMap);
            T.calcScale();

            VanChartLayout.calculateSeries(this); // calculateLabelInfo
            VanChartLayout.calculateSeriesShapes(this);

            this.render();
        },

        render:function(){

            this.vancharts.endLoading();

            var vanchart = this, renderer = this.renderer;

            // 数据为空时显示提示
            if (this._isEmptyDataChart()) {
                this._showEmptyDataTip();
                window.console && console.log('done');
                return;
            } else {
                this.emptyDataGroup && this.emptyDataGroup.remove();
            }

            // var clipBounds = this.getPlotClipBounds();
            // if(!this.plotClip){
            //     this.plotClip = renderer.createClip(clipBounds);
            // }else{
            //     renderer.updateClip(this.plotClip, clipBounds);
            // }

            // gantt
            // series' inside timeAxis [inner-body] group
            // so...

            ['backGroup', 'processesGroup', 'timeaxisGroup' ,'frontGroup']
                .forEach(function (groupName) {
                    if (!vanchart[groupName]) {
                        var g = vanchart[groupName] = renderer.group().addClass(groupName).add();

                        // so ugly
                        if (groupName === 'processesGroup'
                            || groupName === 'timeaxisGroup') {
                            var name = groupName + '-body';
                            g = vanchart[name] = g.append(renderer.group().addClass(name));
                            name = groupName + '-inner-body';
                            vanchart[name] = g.append(renderer.group().addClass(name));
                        }
                    }
                });

            var mainGroup = vanchart['timeaxisGroup-inner-body'];

            ['clipSeriesGroup', 'seriesGroup', 'seriesTextRenderGroup']
                .forEach(function (groupName) {
                    if (!vanchart[groupName]) {
                        vanchart[groupName] = mainGroup.append(
                            renderer.group().addClass(groupName)
                        );
                    }
                });

            this._addSeriesTextDivGroup();

            this._renderBackground();

            this.renderSeries();

            // series related
            this.renderLinks();
            this.renderMarks();

            this.renderComponents();

            // layout levelbar before P&T,
            // but render it last
            var levelBar = this.getComponent(LEVELBAR);
            if (levelBar) {
                levelBar.setLevel(this.getTimeAxis().getLevel());
            }

            this._consoleDone();

        },

        // no clip, but overflow: hidden
        _addSeriesTextDivGroup: function () {
            var vanchart = this;
            if (!vanchart.seriesTextDivGroupWrapper) {
                vanchart.seriesTextDivGroupWrapper = this.renderer.div().add();
                vanchart.seriesTextDivGroup = this.renderer.div();
                vanchart.seriesTextDivGroupWrapper.append(vanchart.seriesTextDivGroup);
            }
            this.updateSeriesTextDivGroup();
        },

        updateSeriesTextDivGroup: function () {
            // contract div to TimeAxis's inner
            var T = this.getTimeAxis();
            var clipBounds = {
                x: T.bounds.x,
                y: T.bounds.y + T.tableDims.headerHeight,
                width: T.bounds.width,
                height: T.bounds.height - T.tableDims.headerHeight
            };

            // CHART-1353
            // 透明div会影响IE8 event
            this.seriesTextDivGroupWrapper.style({
                left: clipBounds.x + 'px',
                top: clipBounds.y + 'px',
                // clip: rect(<top>, <right>, <bottom>, <left>);
                clip: 'rect(' + [
                    0,
                    clipBounds.width,
                    clipBounds.height,
                    0
                ].join('px ') + 'px)'
            });
        },

        moveSeriesTextDivGroup: function (pos) {
            this.seriesTextDivGroup.style('transform', 'translate(' + pos.x + 'px,' + pos.y + 'px)');
        },

        changeToLevel: function (level) {
            var timeAxis = this.getTimeAxis();
            var levelNow = timeAxis.getLevel();

            if (level === levelNow) {
                return
            }

            timeAxis.setLevel(level);

            timeAxis.calcScale();

            timeAxis.renderContent();
            this.reRenderWholePlot();
        },

        reRenderWholePlot: function () {
            VanChartLayout.calculateSeriesShapes(this);

            this.renderSeries();
            this.renderLinks();
            this.renderMarks();
            this.getComponent(ComponentLibrary.LEGEND_COMPONENT).render();
        },

        _calcDims: function (P, T) {
            var bounds = this.bounds;
            var wholeWidth = bounds.width;

            var pDim = P.getInitPanelDims();
            var pWidth = pDim.width;
            var headerHeight = pDim.headerHeight;

            var tDim = T.getInitPanelDims();
            var tWidth = wholeWidth - pWidth;
            headerHeight = Max(headerHeight, tDim.headerHeight);

            var calcHeight = pDim.rowHeight * pDim.rowNum;
            var bodyViewHeight = bounds.height - headerHeight;

            var rowNum = pDim.rowNum;
            if (calcHeight < bodyViewHeight && pDim.rowHeight > 0) {
                rowNum = Math.floor(bodyViewHeight / pDim.rowHeight);
            }

            return {
                x: bounds.x,
                y: bounds.y,
                pWidth: pWidth, // visible width
                tWidth: tWidth,
                height: bounds.height,
                headerHeight: headerHeight,
                rowHeight: pDim.rowHeight,
                rowNum: rowNum
            };
        },

        getProcesses: function () {
            return this.getComponent(PROCESSES)
        },

        getTimeAxis: function () {
            return this.getComponent(TIMEAXIS)
        },

        isResizeEnabled: function () {
            return this.getComponent(PROCESSES).options.resize;
        },

        // bounds to determine wheel/scroll
        _calcPanBounds: function (dims) {
            return {
                x: dims.x,
                y: dims.y,
                width: dims.pWidth + dims.tWidth,
                height: dims.height
            }
        },

        _calcResizeBounds: function (dims) {
            return {
                x: dims.x + dims.pWidth - RESZIE_TOLERANCE / 2,
                y: dims.y,
                width: RESZIE_TOLERANCE,
                height: dims.height
            }
        },

        onResizeEnd: function () {
            this.resizeBounds.x = this.getTimeAxis().bounds.x - RESZIE_TOLERANCE / 2;
        },

        onScrollY: function (data) {
            this.fire('moveY', data);
        }

    });

    require('../../vans/VanChartLibrary').register(Constants.GANTT_CHART, Gantt);

    return Gantt;
});
/**
 * Created by Mitisky on 16/7/28.
 */
define('utils/LoadingUtils',[],function(){
    var loadingMap = {};

    function startLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';
        if(loadingMap[id] || document.getElementById(id)){
            return;
        }

        var background_div = document.createElement('div');
        var inner_div = document.createElement('div');

        background_div.id = id;
        background_div.style.backgroundColor = 'white';
        background_div.style.opacity = 0.75;
        background_div.style.filter = 'alpha(opacity=75)';
        background_div.style.position = 'absolute';
        background_div.style.width = '100%';
        background_div.style.height = '100%';
        background_div.style.left = 0;
        background_div.style.top = 0;
        background_div.style.zIndex = 9999;

        if(inner_div.style.animation != undefined || inner_div.style.webkitAnimation != undefined) {
            inner_div.style.left = '50%';
            inner_div.style.top = '50%';
            inner_div.className = 'loader-inner ball-scale-ripple-multiple';
            inner_div.innerHTML = '<div></div><div></div><div></div>';
        }

        background_div.appendChild(inner_div);
        dom.appendChild(background_div);
        loadingMap[id] = background_div;
    }

    function endLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';

        if(loadingMap[id]) {
            dom.removeChild(loadingMap[id]);
            loadingMap[id] = null;
        } else {
            var loadingDiv = document.getElementById(id);
            if(loadingDiv) {
                dom.removeChild(loadingDiv);
            }
        }
    }

    return {
        startLoading:startLoading,
        endLoading:endLoading
    };
});

/**
 * Created by eason on 15/7/3.
 * reused and modified tooltip component from echarts
 */
//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('component/Tooltip',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary','./FormattedText'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var FormattedText = require('./FormattedText');

    var DEFAULT_DURATION = 0.4;

    var Tooltip = Base.extend({

        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:2000;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;pointer-events:none;',

        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.animation && !opt.follow) {
                var transitionText = 'left ' + DEFAULT_DURATION + 's,'
                    + 'top ' + DEFAULT_DURATION + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if(opt.style){
                var fontStyle = BaseUtils.cssNormalization(opt.style);

                for(var styleName in fontStyle){
                    if(styleName == 'color'){
                        cssText.push(styleName + ':' + ColorUtils.colorToHex(fontStyle[styleName]));
                    }else{
                        cssText.push(styleName + ':' + fontStyle[styleName]);
                    }
                }
            }

            if (opt.backgroundColor) {
                if(typeof opt.backgroundColor == 'string'){
                    if(BaseUtils.isSupportSVG()){
                        cssText.push('background-Color:' + opt.backgroundColor);
                    }else{
                        var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                        // ms: #alpha+hex
                        var msColor = '#' + ('0' + (hexAlpha.alpha * 255 | 0).toString(16)).slice(-2) + hexAlpha.hex.replace('#', '');
                        cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=' + msColor + ', endColorstr=' + msColor + ', GradientType=0)');
                    }
                }else if(typeof opt.backgroundColor == 'object'){

                    var color = opt.backgroundColor;
                    var startColor = ColorUtils.colorToHex(color.startColor);
                    var endColor = ColorUtils.colorToHex(color.endColor);

                    var start = 'left';

                    var startPos = 'left top';
                    var endPos = 'right top';
                    var type = 1;

                    if(color.x1 == color.x2){
                        start = 'top';

                        startPos = 'left top';
                        endPos = 'left bottom';

                        type = 0;
                    }

                    cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                    cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
                }
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            if(opt.shadow){
                cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
            }

            var padding = opt.padding;
            if (padding != null && padding != undefined) {
                padding = BaseUtils.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                    + padding[1] + 'px '
                    + padding[2] + 'px '
                    + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },

        doLayout:function(dom){
            if(!this._tDom){
                dom = dom || this.vanchart.getDivParentDom();

                this._tDom = document.createElement('div');

                this._hiddenDom = document.createElement('div');

                this._tDom.onselectstart = function() {
                    return false;
                };

                this._tDom.style.position = 'absolute';

                this._hiddenDom.style.visibility = 'hidden';

                dom.appendChild(this._tDom);

                dom.appendChild(this._hiddenDom);

                this._tooltipHideTick = null;
            }
        },

        remove:function(){
            if(this._tDom){
                var dom = this.vanchart.getDivParentDom();
                dom.removeChild(this._tDom);
                dom.removeChild(this._hiddenDom);
            }
        },
        /**
         * 根据toolbarIcon和提示内容，显示工具栏提示
         * @param  {Obejct} icon 触发mouseover的toolbarIcon
         * @param  {String} text 对应的提示内容
         */
        showWithToolbarIcon:function (icon, text) {
            var toolbar = icon.toolbar, opt = toolbar.options.tooltip;
            var tooltipDim  = this.calculateTooltipDivDim(opt, text);
            var pos = icon.toolbar.calcToolbarTipPos(icon, tooltipDim);
            this._show(pos, opt, text);
        },

        showWithPoint:function(point, event, formatPoint){
            if(point && point.options.tooltip && point.series.vanchart.renderer){
                var fmtPoint = formatPoint || point,
                    opt = fmtPoint.options.tooltip, // use formatPoint's style
                    seriesChart = point.series;
                var tooltipText = FormattedText.tooltipGenerator(fmtPoint);
                var tooltipDim  = this.calculateTooltipDivDim(opt, tooltipText);
                //优先从地图那边取数据点提示的位置
                var pos = seriesChart.getTooltipPos(point, tooltipDim, event);

                if(pos){
                    this._show(pos, opt, tooltipText);
                    //for bi
                    this._tooltipRect = BaseUtils.makeBounds(pos, tooltipDim);
                }

            }
        },

        // replace '-' with '&#150;' in ie 10, 11, edge;
        // innerHTML '-' will lead to repaint
        _getTooltipText: (function () {
            // todo
            // browser detail version function
            // ie 10, 11, edge
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf('MSIE ');
            if (ua.indexOf('Trident/7.0') > 0 ||
                ua.indexOf('Edge/') > 0 ||
                msie > 0 && parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10) === 10
            ) {
                return function (text) {
                    text += '';
                    var replaced = '';
                    var isContent = true;
                    var i = -1;
                    var len = text.length;
                    var t;
                    while (++i < len) {
                        t = text.charAt(i);
                        if (isContent && t === '-') {
                            t = '&#150;';
                        } else if (t === '<') {
                            isContent = false;
                        } else if (t === '>') {
                            isContent = true
                        }
                        replaced += t;
                    }
                    return replaced;
                }
            } else {
                return function (text) {
                    return text;
                }
            }
        })(),

        _show:function(pos, opt, tooltipText){

            if(pos && opt && tooltipText && !this.vanchart.isMouseDown){
                clearTimeout(this._tooltipHideTick);

                this._tDom.innerHTML = this._getTooltipText(tooltipText);

                this._tDom.style.cssText = this._gCssText
                    + this._style(opt)
                    + 'left:' + pos[0] + 'px;top:' + pos[1] + 'px;';

            }
        },

        hide:function(){

            clearTimeout(this._tooltipHideTick);

            this._tooltipHideTick = setTimeout(function(){
                this._tDom.style.display = 'none';
            }.bind(this), 400);

        },

        immediateHide:function(){
            this._tDom.style.display = 'none';
        },

        calculateTooltipDivDim:function(opt, tooltipText){
            opt = opt || '';
            var testDiv = this._hiddenDom;
            testDiv.innerHTML = tooltipText;
            testDiv.style.cssText = this._gCssText + this._style(opt) + 'visibility:hidden;';
            var width = testDiv.offsetWidth;
            var height = testDiv.offsetHeight;
            return {
                width:width,
                height:height
            };
        },

        render:function(){
            //do nothing
        }

    });

    ComponentLibrary.register(ComponentLibrary.TOOLTIP_COMPONENT, Tooltip);
    return Tooltip;
});
/**
 * Created by Yuqian on 16/9/27.
 */
define('Carousel',['require','./utils/BaseUtils','./utils/QueryUtils','./dom/DomUtils','./utils/ColorUtils','./utils/PathUtils','./Constants','./utils/BezierEasing','./vector/SvgRenderer','./vector/VmlRenderer','./component/Tooltip'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var QueryUtils = require('./utils/QueryUtils');
    var DomUtils = require('./dom/DomUtils');
    var ColorUtils = require('./utils/ColorUtils');
    var PathUtils = require('./utils/PathUtils');
    var Constants = require('./Constants');
    var BezierEasing = require('./utils/BezierEasing');
    var SvgRenderer = require('./vector/SvgRenderer');
    var VmlRenderer = require('./vector/VmlRenderer');
    var Tooltip = require('./component/Tooltip');

    var SWITCH_BUTTON_HEIGHT_RATIO = 3.4375;

    var defaultOpt = {
        type: Constants.BUTTON,
        color: "#7f7f7f",
        interval: 1000,
        style: {
            "fontSize": '16px',
            "color": '#ffffff'
        }
    };

    // button 'text...' hint
    var TOOLTIP_STYLE = {
        borderWidth: 1,
        borderColor: '#000000',
        borderRadius: 2,
        backgroundColor: 'rgba(255, 255, 255, 0.5)',
        padding: 5,
        shadow: true,
        animation: true,
        style: {
            'fontSize': '12px',
            'fontFamily': 'MicrosoftYaHei, sans-serif',
            'color': '#515151'
        }
    };

    /*
     * first and last chart has a wrap inside 'vanchart-chart' dom.
     * move this wrap to the empty wrap, or move back,
     * to make an infinity loop

                 ┌dom┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐
                 ┆╔menu(button)╦════════════════════════════════════╗┆
                 ┆║menuButton  ║                                    ║┆
                 ┆║            ║                                    ║┆
                 ┆╚════════════╩════════════════════════════════════╝┆
┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐╔container════════════════════════════════════════╦═══════════════════┅┅┅┅┅┅┅┅┅
┆(in container)  ┆║chartDoms[0]                                     ║chartDoms[1]                ║
┆frontEmptyWrap  ┆║┌firstChartWrap┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐║[svg...](no wrap)           ║
┆{margin-left:-x}┆║┆                                               ┆║                            ║
┆                ┆║┆ [svg, divLabelDom, calculateDom...]           ┆║                            ║
┆                ┆║┆                                               ┆║                            ║
┆                ┆║┆                                               ┆║                            ║
┆                ┆║┆                                               ┆║                            ║
┆                ┆║┆                                               ┆║                            ║
┆                ┆║┆                                               ┆║                            ║
┆                ┆║└┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘║                            ║
└┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘╚═════════════════════════════════════════════════╩═══════════════════┅┅┅┅┅┅┅┅┅
                 ┆       ┌menu(carousel)┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐       ┆
                 ┆       ┆            o o o o o o            ┆       ┆
                 ┆       └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘       ┆
                 └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘

    */

    var CarouselFun = function (vanCharts) {
        var type = null,
            outerDom = null,
            menu = null,
            menuButtons = [],
            arrowWrapLeft = null,
            arrowWrapRight = null,
            container = null,
            frontEmptyWrap = null,
            lastChartWrap = null,
            rearEmptyWrap = null,
            firstChartWrap = null,
            chartDoms = [],
            onIndex = 0,
            optLength = 0,
            intervalID = null,
            animationID = null,
            fontSize = 0;

        var evented = {
            left: null,
            right: null,
            dom: null
        };

        var tooltip = new Tooltip({}, Constants.TOOLBAR_COMPONENT, {});

        var isCssAni = 'transition' in document.getElementsByTagName('body')[0].style;

        // IE7 in IE11
        var isIE7 = /MSIE 7/.test(navigator.userAgent);

        function refresh (option, i) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (btnDom.mText) {
                if (btnDom.mText.textContent) {
                    btnDom.mText.textContent = titleText;
                } else {
                    btnDom.mText.innerText = titleText;
                }
                checkBtnTextSpace(btnDom);
            }

            btnDom._title = titleText;

            return setupChart(option, vanCharts.charts[i], chartDoms[i], i);
        }

        /**
         * setup carousel container and button
         * return initialized or refreshed charts Array
         * @param {Object} [option]
         * @param {Array} [charts]
         * @param {Object} [dom]
         * @returns {Array} [charts]
         */
        function init (option, charts, dom) {

            if (!option || !option.switchStyle) {
                setInterval();
            }

            var options = option.options;
            var switchStyle = QueryUtils.merge(defaultOpt, option.switchStyle, true);

            if (!BaseUtils.isSupportSVG()) {
                if (switchStyle.style.color) {
                    switchStyle.style.color = ColorUtils.colorToHex(switchStyle.style.color);
                }
            }

            outerDom = dom;
            type = switchStyle.type;
            optLength = options.length;

            menu = menu || DomUtils.create('div', 'vanchart-menu', dom);
            container = container || DomUtils.create('div', 'vanchart-cc', dom);

            dom.style.overflow = 'hidden';

            tooltip.doLayout(dom);

            var color = switchStyle.color;

            charts.splice(optLength)
                .map(function (c) { c.remove(); });

            menuButtons.splice(optLength)
                .map(function (d) { DomUtils.remove(d); });

            chartDoms.splice(optLength)
                .map(function (d) { DomUtils.remove(d); });

            addClass(container, 'van-ani');

            onIndex = (onIndex >= optLength) ? 0 : onIndex;

            switch (type) {
                case Constants.CAROUSEL:
                    menu.style.bottom = 0;
                    menu.style.height = "18px";
                    menu.style.width = "100%";
                    menu.mWrap = menu.mWrap || DomUtils.create('div', 'vanchart-menu-wrap', menu);
                    container.style.cssText = "top:0;" +
                        "bottom: 18px;" +
                        "left:" + -onIndex * 100 + '%;' +
                        "width:" + optLength * 100 + "%";

                    // ie < 8 no resize
                    if (!BaseUtils.isSupportSVG()) {
                        container.style.height = outerDom.clientHeight - 18 + 'px';
                    }

                    arrowWrapLeft = arrowWrapLeft || DomUtils.create('div', 'vanchart-arrow-wrap', dom);
                    arrowWrapRight = arrowWrapRight || DomUtils.create('div', 'vanchart-arrow-wrap', dom);
                    arrowWrapRight.style.right = 0;
                    var left = arrowWrapLeft.arrowLeft = arrowWrapLeft.arrowLeft || DomUtils.create('div', 'vanchart-arrow vanchart-arrow-left', arrowWrapLeft);
                    var right = arrowWrapRight.arrowRight = arrowWrapRight.arrowRight || DomUtils.create('div', 'vanchart-arrow vanchart-arrow-right', arrowWrapRight);
                    setArrow(left, color);
                    setArrow(right, color);

                    var interval  = switchStyle.interval;

                    evented.left && evented.left.off('tap');
                    evented.left = evented.left || new VanHammer(left);
                    evented.left.on('tap', function (e) {
                        e.preventDefault();
                        setInterval(interval);
                        var index = (optLength + onIndex - 1) % optLength;
                        prepareCarouselDom(index, Constants.LEFT);
                        showIndex(index);
                    });

                    evented.right && evented.right.off('tap');
                    evented.right = evented.right || new VanHammer(right);
                    evented.right.on('tap', function (e) {
                        e.preventDefault();
                        setInterval(interval);
                        var index = (onIndex + 1) % optLength;
                        prepareCarouselDom(index, Constants.RIGHT);
                        showIndex(index);
                    });

                    evented.dom && evented.dom.off(dom, 'mouseover mouseout');
                    evented.dom = VanHammer
                        .on(dom, 'mouseover', function () {
                            setInterval();
                        })
                        .on(dom, 'mouseout', function () {
                            setInterval(interval);
                        });

                    setInterval(interval);

                    return carousel(options, charts);

                case Constants.BUTTON:
                default:
                    var startColor = gradualColor(color);
                    var cssText = 'width:100%;top:0;' +
                        'background-color:' + color + ';' +
                        'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=' +
                            startColor + ', endColorstr=' + ColorUtils.colorToHex(color) + ', GradientType=0);';

                    cssText += 'background-image: -webkit-gradient(linear, left top, left bottom, from(' + startColor + '), to(' + color + '));';
                    cssText += 'background-image: -moz-linear-gradient(top' + startColor +', '+ color +');';
                    cssText += 'background-image: -webkit-linear-gradient(top' + startColor +', '+ color +');';
                    cssText += 'background-image: linear-gradient(to bottom' + startColor +', '+ color +');';

                    menu.style.cssText = cssText;
                    setTextStyle(menu, switchStyle.style);

                    fontSize = BaseUtils.getTextHeight(switchStyle.style);
                    var btnH = fontSize * SWITCH_BUTTON_HEIGHT_RATIO;
                    container.style.cssText =
                        "left:" + -onIndex * 100 + '%;' +
                        "top:" + btnH + "px;" +
                        "bottom: 0;" +
                        "width:" + optLength * 100 + "%";

                    if (!BaseUtils.isSupportSVG()) {
                        container.style.height = outerDom.clientHeight - btnH + 'px';
                    }

                    return button(options, charts, switchStyle.style.color, hoverColor(color));
            }
        }

        function carousel(options, oldCharts) {
            // prepare two empty doms in front and end;
            // use these doms to imitate infinity loop.
            frontEmptyWrap = frontEmptyWrap || DomUtils.create('div', 'vanchart-chart', container);
            frontEmptyWrap.style.width = 100 / optLength + "%";
            frontEmptyWrap.style.marginLeft = -100 / optLength + "%";

            if (isIE7) {
                frontEmptyWrap.style.width = outerDom.clientWidth + 'px';
                frontEmptyWrap.style.marginLeft = -outerDom.clientWidth + 'px';
            }

            var cs = options.map(function (option, i) {
                setupCarouselDoms(option, i);
                return setupChart(option, oldCharts[i], chartDoms[i], i);
            });

            rearEmptyWrap = rearEmptyWrap || DomUtils.create('div', 'vanchart-chart', container);
            rearEmptyWrap.style.width = 100 / optLength + "%";
            rearEmptyWrap.style.marginRight = -100 / optLength + "%";

            if (isIE7) {
                rearEmptyWrap.style.width = outerDom.clientWidth + 'px';
                rearEmptyWrap.style.marginLeft = -outerDom.clientWidth + 'px';
            }

            return cs;
        }
        function setupCarouselDoms (option, i) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (!chartDoms[i]) {
                chartDoms[i] = DomUtils.create('div', 'vanchart-chart', container);
                menuButtons[i] = btnDom = DomUtils.create('div', 'vanchart-menu-dot', menu.mWrap);

                if (!BaseUtils.isSupportSVG()) {
                    btnDom.style.background = 'none';
                    var ieDom = DomUtils.create('div', 'vanchart-menu-dot-ie', btnDom);
                    setDot(ieDom);
                }

                if (!i) {
                    addClass(btnDom, 'van-on');
                }
            }

            btnDom._title = titleText;
            btnDom.i = i;

            VanHammer.on(btnDom, 'mouseover', function () {
                showCarouselTooltip(btnDom);
            });

            VanHammer.on(btnDom,'mouseout', function () {
                tooltip.immediateHide();
            });

            new VanHammer(btnDom)
                .on('tap',function (e) {
                    e.preventDefault();
                    prepareCarouselDom(i);
                    showIndex(i);
                });
        }

        function showCarouselTooltip(btnDom) {
            var tooltipDim = tooltip.calculateTooltipDivDim(TOOLTIP_STYLE, btnDom._title);
            var pos = [
                outerDom.clientWidth / 2 - (optLength - 1) / 2 * 16 + btnDom.i * 16 - tooltipDim.width / 2,
                outerDom.clientHeight - 18 - tooltipDim.height
            ];
            pos[0] = Math.min(Math.max(pos[0], 0), outerDom.clientWidth - tooltipDim.width);
            tooltip._show(pos, TOOLTIP_STYLE, btnDom._title);
        }

        function button(options, oldCharts, textColor, hoverColor) {
            return options.map(function (option, i) {
                setupButtonDoms(option, i, textColor, hoverColor);
                return setupChart(option, oldCharts[i], chartDoms[i], i);
            });
        }

        function setupButtonDoms (option, i, textColor, hoverColor) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (!chartDoms[i]) {
                chartDoms[i] = DomUtils.create('div', 'vanchart-chart', container);
                menuButtons[i] = btnDom = DomUtils.create('div', 'vanchart-menu-btn', menu);
                btnDom.mIcon = DomUtils.create('span', 'vanchart-menu-icon', btnDom);
                btnDom.mText = DomUtils.create('span', 'vanchart-menu-text', btnDom);

                if (!BaseUtils.isSupportSVG()) {
                    btnDom.insertAdjacentHTML('afterBegin','<span class="vanchart-menu-btn_before"></span>');
                }

                if (!i) {
                    btnDom.style.background = hoverColor;
                }
            }

            setIcon(btnDom.mIcon, option.chartType, textColor);
            btnDom.style.width = 100 / optLength + "%";

            if (!BaseUtils.isSupportSVG()) {
                var width = outerDom.clientWidth / optLength;
                if (isIE7) {
                    // IE11 quirks IE7 is ... different from IE7
                    width -= 2 * fontSize + 1;
                }

                btnDom.style.width = width + 'px';

                if (btnDom.offsetTop !== 0) {
                    btnDom.style.width = width - 1 + 'px';
                }
            }

            /**
             * CHART-1364
             * 解决火狐在某些版本里不能显示切换按钮标题的问题。
             * 出现这个问题的原因是我们原先的逻辑是判断浏览器是否支持textContent或者innerText属性，然后对它们进行赋值。
             * 没毛病，说实在的，但是可怕的是浏览器如果支持某一个textContent，就会给这个属性赋上空字符串，
             * 所以我们原来的判断就错开了这个属性，而高版本的浏览器支持更多的属性，所以执行else也不会出现问题，
             * 但是低版本就可能存在问题。
             */
            btnDom.mText.textContent = titleText;
            btnDom.mText.innerText = titleText;

            btnDom._title = titleText;
            btnDom.i = i;

            checkBtnTextSpace(btnDom);

            VanHammer.on(btnDom, 'mouseover', function () {
                btnDom.style.background = hoverColor;
                showButtonTooltip(btnDom);
            });

            VanHammer.on(btnDom, 'mouseout', function () {
                (onIndex !== i) && (btnDom.style.background = '');
                tooltip.immediateHide();
            });

            new VanHammer(btnDom)
                .on('tap', function (e) {
                    e.preventDefault();
                    menuButtons[onIndex].style.background = '';
                    menuButtons[i].style.background = hoverColor;
                    showIndex(i);
                });
        }

        function showButtonTooltip(btnDom) {
            var ellipsis = false;
            if (BaseUtils.isSupportSVG()) {
                ellipsis = btnDom.scrollWidth > btnDom.clientWidth;
            } else {
                ellipsis = btnDom.scrollWidth >= btnDom.clientWidth;
            }

            if (ellipsis || btnDom.mText.innerHTML === '') {
                var tooltipDim = tooltip.calculateTooltipDivDim(TOOLTIP_STYLE, btnDom._title);
                var pos = [
                    outerDom.clientWidth * (btnDom.i + 0.5) / optLength - tooltipDim.width / 2,
                    btnDom.offsetHeight
                ];

                pos[0] = Math.min(Math.max(pos[0], 0), outerDom.clientWidth - tooltipDim.width);

                tooltip._show(pos, TOOLTIP_STYLE, btnDom._title);
            }
        }

        function setupChart(option, oldChart, chartDom, i) {
            chartDom.style.width = 100 / optLength + "%";

            // CHART-1077
            //
            // if (!BaseUtils.isSupportSVG() || chartDom.offsetLeft < outerDom.clientWidth * i) {
            //     var det = outerDom.clientWidth * i - chartDom.offsetLeft;
            //     chartDom.style.width = outerDom.clientWidth + det + 'px';
            // }

            var c, targetDom = chartDom;

            if (i === optLength - 1) {
                if (!lastChartWrap) {
                    lastChartWrap = newWrap(chartDom);
                }
                targetDom = lastChartWrap;
            } else if (i === 0) {
                if (!firstChartWrap) {
                    firstChartWrap = newWrap(chartDom)
                }
                targetDom = firstChartWrap;
            }

            c = vanCharts._initSingle(option, oldChart, targetDom);
            if (i !== onIndex) {
                c.set({enable: false});
            }

            return c;
        }

        function newWrap(chartDom) {
            var wrapDom = DomUtils.create('div', 'vanchart-chart-wrap', chartDom);
            wrapDom.style.cssText = 'width:100%;height:100%';
            return wrapDom;
        }

        function prepareCarouselDom(index, direction) {
            var tmp;
            // last -> first
            if (direction === Constants.RIGHT &&
                onIndex === optLength - 1 && index === 0) {
                chartDoms[0].appendChild(firstChartWrap);
                frontEmptyWrap.appendChild(lastChartWrap);
                removeClass(container, 'van-ani');
                container.style.left = '100%';
                tmp = container.clientWidth; // update css
            } else

            // first -> last
            if (direction === Constants.LEFT &&
                onIndex === 0 && index === optLength - 1) {
                chartDoms[optLength - 1].appendChild(lastChartWrap);
                rearEmptyWrap.appendChild(firstChartWrap);
                removeClass(container, 'van-ani');
                container.style.left = -optLength * 100 + '%';
                tmp = container.clientWidth;
            } else {

            // recover
                chartDoms[0].appendChild(firstChartWrap);
                chartDoms[optLength - 1].appendChild(lastChartWrap);
            }

            addClass(container, 'van-ani');
        }

        function showIndex(index) {
            removeClass(menuButtons[onIndex], 'van-on');
            vanCharts.charts[onIndex].set({enable:false});
            addClass(menuButtons[index], 'van-on');
            vanCharts.charts[index].set({enable:true});

            if (isCssAni) {
                container.style.left = -index * 100 + '%';
            } else {
                var easing = BezierEasing.css['swing'];
                animation(container, 'left', -index * 100 + '%', 500, easing);
            }
            onIndex = index;
        }

        function animation(dom, attr, endValue, duration, easing) {
            window.clearTimeout(animationID);
            var from = parseFloat(dom.style[attr]) || 0,
                tmp = endValue.match(/([\d.E-]+)(.*)/i),
                to = +tmp[1], unit = tmp[2],
                here = from, now = 0, STEP = 17;

            move();

            // 0 -> duration, from -> to;
            function move() {
                if (now >= duration) {
                    here = to;
                    dom.style[attr] = here + unit;
                } else {
                    here = from + (to - from) * easing(now / duration);
                    dom.style[attr] = here + unit;
                    now += STEP;
                    animationID = window.setTimeout(move, STEP);
                }
            }
        }

        // start interval or cancel
        function setInterval(interval) {
            window.clearInterval(intervalID);
            if (interval) {
                intervalID = window.setInterval(function () {
                    var index = (onIndex + 1) % optLength;
                    prepareCarouselDom(index, Constants.RIGHT);
                    showIndex(index);
                }, interval);
            }
        }

        // width < padding * 2 + icon + 1em
        // remove padding to prevent wrap
        function checkBtnTextSpace(btnDom) {
            if (btnDom.clientWidth <= 22 + 3 * fontSize) {
                btnDom.mText.innerHTML = '';
                btnDom.mText.style.marginLeft = 0;
                if (!isIE7) {
                    btnDom.style.padding = 0;
                }
            }
        }

        return {
            init: init,
            refresh: refresh
        }
    };

    function getTitleText(option) {
        var title = option.title;

        if (title.text && title.useHtml) {
            return BaseUtils.getPlainText(title.text);
        }

        return title.text || '';
    }

    function setTextStyle(dom, styleObj) {
        Object.keys(styleObj).map(function (name) {
            if (typeof styleObj[name] !== 'string') {
                return
            }
            dom.style[name] = styleObj[name];
        });
    }
    
    function gradualColor(color) {
        var rgba = ColorUtils.getRGBAColorArray(color);
        var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
        return ColorUtils.toColor(ColorUtils.hsb2rgb(hsb[0], hsb[1] * 0.85, (hsb[2] + 0.15) * 100 / 115), 'hex');
    }

    function hoverColor(color) {
        var rgba = ColorUtils.getRGBAColorArray(color);
        var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
        return ColorUtils.toColor(ColorUtils.hsb2rgb(hsb[0], hsb[1] * 0.75, (hsb[2] + 0.25) * 100 / 125), 'hex');
    }


    function addClass(ele, name) {
        var names = ele.className.split(' ');
        if (names.indexOf(name) === -1) {
            ele.className += ' ' + name;
        }
    }

    function removeClass(ele, name) {
        var names = ele.className.split(' ');
        var i = names.indexOf(name);
        if (i !== -1) {
            names.splice(i, i);
            ele.className = names.join(' ');
        }
    }

    function setIcon(dom, type, color) {
        if (BaseUtils.isSupportSVG()) {
            var svg = '<svg width=22 height=22><g>' + icon[type] +  '</g></svg>';
            dom.innerHTML = svg;
            dom.querySelector('g').setAttribute('fill', color)
            if (type === Constants.RADAR_CHART) {
                dom.querySelector('g').setAttribute('stroke', color);
            }
        } else {
            dom.innerHTML = '<img width="22" height="22" src="data:image/png;base64,' + png[type] + '">';
        }
    }

    var icon = {};
    icon[Constants.PIE_CHART] = '<path d="M12,0.266v10.041l9.519-1.314C20.642,4.339,17,0.742,12,0.266z"/> <path d="M21.744,10.061l-7.309,1.009L11,11.511V11v-0.545V9.651V0.208C5.04,0.208,0.208,5.04,0.208,11 c0,5.96,4.832,10.792,10.792,10.792c0,0,1.214,0,1.602-0.12l0.006-0.012c5.195-0.778,9.183-5.247,9.183-10.659 C21.792,10.683,21.771,10.371,21.744,10.061z"/>'
    icon[Constants.BAR_CHART] = '<rect x="0.937" y="6.794" width="8.112" height="2.704"/> <rect x="0.938" y="12.502" width="13.52" height="2.704"/> <rect x="0.938" y="18.211" width="17.125" height="2.704"/> <rect x="0.937" y="1.086" width="6.309" height="2.704"/>';
    icon[Constants.COLUMN_CHART] = '<rect x="0.625" y="11.943" width="2.83" height="9.432"/> <rect x="6.284" y="8.17" width="2.83" height="13.205"/> <rect x="12.886" y="4.398" width="2.83" height="16.977"/> <rect x="18.545" y="0.625" width="2.83" height="20.75"/>';
    icon[Constants.LINE_CHART] = '<path d="M20.527,2.742c-0.813,0-1.473,0.659-1.473,1.473c0,0.308,0.095,0.593,0.256,0.83l-4.155,7.48 c-0.005,0-0.01-0.002-0.016-0.002c-0.296,0-0.571,0.089-0.802,0.24l-5.74-3.399c0.005-0.05,0.015-0.098,0.015-0.149 c0-0.814-0.66-1.473-1.473-1.473S5.667,8.402,5.667,9.215c0,0.154,0.03,0.299,0.074,0.439L1.987,13.84 c-0.161-0.06-0.333-0.097-0.514-0.097C0.66,13.742,0,14.402,0,15.215s0.66,1.473,1.473,1.473s1.473-0.659,1.473-1.473 c0-0.265-0.076-0.511-0.198-0.726l3.614-4.028c0.227,0.142,0.492,0.227,0.778,0.227c0.399,0,0.76-0.16,1.025-0.418l5.572,3.299 c-0.042,0.136-0.07,0.277-0.07,0.427c0,0.814,0.66,1.473,1.473,1.473s1.473-0.659,1.473-1.473c0-0.445-0.202-0.84-0.514-1.11 l4.033-7.259c0.126,0.035,0.257,0.06,0.395,0.06C21.34,5.688,22,5.029,22,4.215S21.34,2.742,20.527,2.742z"/>';
    icon[Constants.AREA_CHART] = '<path d="M15.255,15.935c0.045,0.075,0.079,0.159,0.079,0.253c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5 c0-0.106,0.041-0.199,0.097-0.28l-7.79-8.953C6.571,6.993,6.493,7.021,6.406,7.021c-0.106,0-0.199-0.04-0.28-0.097L1,12.315V21h21 V9.832L15.255,15.935z"/> <path d="M6.642,6.955C6.797,6.87,6.906,6.711,6.906,6.521c0-0.276-0.224-0.5-0.5-0.5s-0.5,0.224-0.5,0.5 c0,0.17,0.09,0.313,0.22,0.403C6.208,6.981,6.3,7.021,6.406,7.021C6.493,7.021,6.571,6.993,6.642,6.955z"/> <path d="M14.834,16.688c0.276,0,0.5-0.224,0.5-0.5c0-0.094-0.033-0.178-0.079-0.253c-0.087-0.145-0.24-0.247-0.421-0.247 c-0.17,0-0.312,0.09-0.403,0.22c-0.057,0.081-0.097,0.174-0.097,0.28C14.334,16.464,14.558,16.688,14.834,16.688z"/> <polygon points="1,12.315 1,0 0,0 0,22 0.088,22 22,22 22,21 1,21 "/>';
    icon[Constants.GAUGE_CHART] = '<path d="M11,1.149c-6.042,0-10.958,4.916-10.958,10.958c0,2.103,0.597,4.146,1.729,5.908l1.845-1.184 c-0.904-1.408-1.381-3.042-1.381-4.724c0-4.834,3.933-8.766,8.766-8.766s8.766,3.933,8.766,8.766c0,1.682-0.477,3.315-1.38,4.723 l1.845,1.184c1.13-1.762,1.728-3.804,1.728-5.907C21.958,6.065,17.042,1.149,11,1.149z"/> <path d="M11.49,12.11L11,4.273l-0.49,7.837c-0.236,0.16-0.4,0.417-0.4,0.724c0,0.492,0.398,0.89,0.89,0.89s0.89-0.399,0.89-0.89 C11.89,12.527,11.726,12.27,11.49,12.11z"/>';
    icon[Constants.RADAR_CHART] = '<polygon fill="none" stroke-miterlimit="10" points="6.828,20.531 1.417,13.746 3.348,5.286 11.167,1.521 18.985,5.286 20.916,13.746 15.506,20.531 "/> <polyline fill="none" stroke-miterlimit="10" points="3.38,5.38 11.042,10.885 15.506,20.531 "/> <polyline fill="none" stroke-miterlimit="10" points="18.985,5.286 11.057,10.87 1.417,13.746 "/> <line fill="none" stroke-miterlimit="10" x1="11.026" y1="10.885" x2="20.916" y2="13.746"/> <line fill="none" stroke-miterlimit="10" x1="11.167" y1="1.521" x2="11.042" y2="10.901"/> <line fill="none" stroke-miterlimit="10" x1="11.042" y1="10.885" x2="6.835" y2="20.539"/>';
    icon[Constants.SCATTER_CHART] = '<circle cx="14.625" cy="12.158" r="0.916"/> <circle cx="14.625" cy="7.383" r="1.291"/> <circle cx="7.958" cy="12.699" r="0.916"/> <circle cx="21.293" cy="3.702" r="0.707"/> <circle cx="2.041" cy="16.965" r="2.041"/>';
    icon[Constants.BUBBLE_CHART] = icon[Constants.FORCE_BUBBLE_CHART] = '<circle cx="3.521" cy="14.938" r="3.521"/> <circle cx="11.927" cy="5.5" r="1.958"/> <circle cx="20.667" cy="10.219" r="1.333"/>';
    icon[''] = icon[Constants.MULTI_CHARTS] = '<rect x="2" y="12" width="3" height="9"/> <rect x="7" y="8" width="3" height="13"/> <rect x="12" y="9" width="3" height="12"/> <rect x="17" y="5" width="3" height="16"/> <path d="M20.172,0.911c-0.507,0-0.917,0.411-0.917,0.917c0,0.056,0.022,0.105,0.032,0.158l-4.522,3.532 c-0.156-0.121-0.342-0.205-0.554-0.205c-0.404,0-0.737,0.266-0.859,0.629L8.582,5.56C8.425,5.278,8.135,5.079,7.79,5.079 c-0.507,0-0.917,0.411-0.917,0.917c0,0.053,0.021,0.1,0.031,0.151L2.395,9.78C2.238,9.654,2.046,9.567,1.828,9.567 c-0.506,0-0.917,0.411-0.917,0.917s0.411,0.917,0.917,0.917c0.507,0,0.917-0.411,0.917-0.917c0-0.121-0.026-0.236-0.069-0.342 l4.42-3.563c0.168,0.2,0.411,0.335,0.693,0.335c0.495,0,0.893-0.394,0.91-0.884l4.627,0.372c0.082,0.422,0.437,0.747,0.883,0.747 c0.507,0,0.917-0.411,0.917-0.917c0-0.127-0.026-0.248-0.073-0.358l4.428-3.457c0.168,0.197,0.41,0.329,0.689,0.329 c0.506,0,0.917-0.411,0.917-0.917C21.089,1.322,20.678,0.911,20.172,0.911z"/>';
    icon[Constants.MULTIPIE_CHART] = '<path d="M5.267,10.754c0,0.009-0.002,0.018-0.002,0.028c0,2.918,2.276,5.356,5.194,5.356l0.017-0.002 C7.585,16.12,5.291,13.643,5.267,10.754z"/> <path d="M10.499,18.487l0.003,0c2.997,0,5.568-1.763,6.804-4.219C16.071,16.724,13.5,18.486,10.499,18.487z"/> <path d="M2.916,10.745c0,0.012-0.002,0.025-0.002,0.037c0,4.215,3.329,7.705,7.544,7.705 c0.008,0,0.015-0.001,0.022-0.001C6.288,18.474,2.935,14.937,2.916,10.745z"/> <path fill-opacity = "0.2" d="M18.856,10h2.233C20.546,5,16,0.396,11,0.212v2.213C15,2.604,18.326,6,18.856,10z"/> <path fill-opacity = "0.6" d="M16.104,10h2.752C18.326,6,15,2.604,11,2.424v2.724C13,5.318,15.603,8,16.104,10z"/> <path d="M11,5.149V10h5.104C15.603,8,13,5.318,11,5.149z"/> <path fill-opacity = "0.2" d="M17.752,13.176c-0.119,0.376-0.269,0.741-0.445,1.092c-1.236,2.456-3.807,4.219-6.804,4.219l-0.003,0 l-0.004,0c0,0-0.007-0.001-0.015-0.001c-0.008,0-0.015,0.001-0.022,0.001c-4.215,0-7.544-3.49-7.544-7.705 c0-0.012,0.002-0.025,0.002-0.037c0-0.012-0.002-0.024-0.002-0.036C2.914,6.708,6,3.432,10,3.109V1.2 c-5,0.329-8.994,4.454-8.994,9.509c0,5.269,4.227,9.686,9.496,9.686c5.27,0,9.497-4.395,9.497-9.395h-1.908 C18.091,11.75,17.972,12.482,17.752,13.176z"/> <path fill-opacity = "0.6" d="M2.914,10.709c0,0.012,0.002,0.024,0.002,0.036c0.019,4.192,3.372,7.729,7.564,7.741 c0.007,0,0.015,0.001,0.015,0.001l0.004,0c3-0.001,5.572-1.764,6.808-4.219c0.177-0.351,0.326-0.716,0.445-1.092 c0.22-0.694,0.339-1.426,0.339-2.176h-2.349c0,3-2.321,5.138-5.239,5.138c-0.009,0-0.019-0.001-0.028-0.002l-0.017,0.002 c-2.917,0-5.194-2.438-5.194-5.356c0-0.009,0.002-0.018,0.002-0.028c0-0.015-0.002-0.03-0.002-0.045C5.264,8.007,7,5.783,10,5.468 V3.109C6,3.432,2.914,6.708,2.914,10.709z"/> <path d="M5.264,10.709c0,0.015,0.002,0.03,0.002,0.045c0.024,2.889,2.319,5.366,5.208,5.382c0.009,0,0.019,0.002,0.028,0.002 c2.918,0,5.239-2.138,5.239-5.138H10V5.468C7,5.783,5.264,8.007,5.264,10.709z"/>';
    icon[Constants.AREA_MAP] = icon[Constants.HEAT_MAP] = icon[Constants.POINT_MAP] = icon[Constants.LINE_MAP] = '<path d="M28.12 36.6h.03-.05z"/><path d="M19.53 15.7l.04-.02v-.04c0-.08-.1-.16-.2-.13h-.1c-.05 0-.1 0-.12.1 0 0 0 .1-.02.1-.07 0-.14.1-.17.2l-.1.2-.07.1-.1.1-.1.3v.2h-.1v.1h-.1l-.1.1v.5c0 .1 0 .4.1.4l.1-.1v.1h.2v.1h.2v-.2s-.1-.3.1-.5v-.9zM13-8.66h-.05.04zm7.2 16.68L20.18 8h-.1s-.03 0-.04.02h.18zM14.77 18v-.02s-.02.02 0 .02z"/><path d="M21.9 5.6c.05-.05-.02-.12-.05-.17 0 0-.04 0-.03-.02 0 0 .02-.1 0-.1h-.04v-.2c.02-.1 0-.1 0-.1.07 0 .1-.1.1-.1.05-.1 0-.2-.05-.2h.02c.05 0 .04-.1.04-.1l-.1-.1-.2.2h-.1c-.1 0-.1.1-.2.1l-.2.1c-.1 0-.1.1-.2.1l-.1.1c-.1 0-.1.1-.1.1l-.1.2s0 .1-.1.1-.2-.1-.2 0c-.1 0-.3 0-.4-.1V5c0-.1.2-.2.1-.24l.1-.1-.1-.05v.1l-.2-.1h-.4l-.1.1h-.2c.1-.1 0-.1 0-.1V4c0-.15-.1-.24-.2-.26v-.4l-.1-.05V3c0-.1-.1-.1-.1-.1 0-.1 0-.1-.1-.1h-.1c-.1-.1-.2 0-.2 0l-.3-.1-.1-.1v.14h-.5.1c0-.04.1 0 .1-.04L17 3v-.02l-.02-.1v.07-.02V3h-.07.1v.03s-.1 0-.1.02l-.1.04c0 .1-.1.1-.1.1l-.1.1s-.2 0-.2.1h.7-.2v.1l-.1-.1c.1 0 .1.1.1.1v.1h.1v.5c-.1.1-.3.1-.3.2l-.1.1v.2s-.1-.1-.1 0l-.1-.1H16c-.03 0-.1 0-.2.3l-.06.2h-.05c-.1 0-.1.1-.1.1h.1-.1c0 .1 0 .1.1.2 0 0 0 .1.1.1h.4s0 .1.1.1l.2-.2h.1l.1.1h.1l.2.2V6h-.2c-.1 0-.2 0-.2.03-.1 0-.2 0-.2.02l-.1.04c-.1 0-.2.4-.2.5V7H16c-.2 0-.3-.2-.3-.08-.07.1-.17-.04-.2-.02-.2 0-.28-.1-.35 0 0 .06-.03.05-.03.1s-.1.1-.1.1H15s-.04 0 0 0l-.4-.1-.1-.05c-.16 0-.25.2-.27.26-.04.1-.06.2-.05.2.04.2.15.3.2.3h-.06c-.3.2-.36.3-.36.3 0 .1-.1.1-.14.1h-.24s-.03-.1-.2-.1h-.05c-.04 0-.23.2-.3.2l-.1.1h-.03l-.02.1-.43.2-.37.4-.1.3h-.1s0-.2-.02-.2c0 0-.05-.1-.1-.1v-.2.2c-.04 0-.1.2-.16.2h-.1c-.1 0-.25-.3-.3-.4v-.1h-.04c-.2 0-.24-.2-.24-.2v-.1l-.6-.1H9l.03-.1-.08-.1.03.1c-.03-.1-.04 0-.03 0h-.02l.24-.7-.35.5-.06-.1-.04-.1c-.02 0-.03 0-.04-.1 0 0-.04-.2-.07-.2v-.1h-.2L8.3 7c0-.05-.2-.2-.2-.2-.1-.07-.2-.1-.4-.1h-.1l-.1-.04h-.2l-.1-.05s0 .2-.02.2V7H7.1v-.15c0-.02 0-.12-.03-.15v-.1c.05-.05.12-.1.14-.17l.1-.1v-.68l-.1-.1v-.03.3c0-.04 0 .2-.1.2H7c-.04 0-.06-.33-.1-.33s-.06-.2-.1-.2v-.4L6.5 5H6s.2-.05.17-.1l.1-.03c.03-.05.08-.06.08-.08 0-.1-.05-.1-.1-.1l-.12-.1H5.9c-.1 0-.1.1-.1.1V5h-.2c-.1 0-.1 0-.1.04l-.1.06c0 .02-.1.04-.1.07v.36l-.1.03c-.1 0-.1.2-.1.2L5 6s0-.3-.02-.3c0 0 0 .1-.1.1-.03 0-.1.1-.14.1l-.07-.3s0-.2-.05-.2c-.08 0-.1-.1-.1-.1 0-.05-.1-.1-.14-.1s-.1 0-.12.05v.05l-.07.04-.1.13-.1.05-.1.1c-.1 0-.1.03-.1.05v.08s-.1.1-.1.15V6l-.1-.04H3c-.03 0-.1.04-.13.1v.1c.03.07.1.1.14.1v.8s-.5 0-.5.04-.5.15-.5.15v.08l.4.03.1.04c-.1 0 0 .02-.1.03l-.1.03-.1.04H2c-.05 0-.1.03-.1.06-.05 0-.1 0-.1.03h-.1c0-.1-.04-.1-.1-.1h-.3s-.03 0-.05.1c-.04 0-.08.1-.1.1V8v-.2l-.02-.1c0-.04 0-.12-.1-.12 0 0-.1 0-.1.02v.2S1 8 .93 8H.8v-.16c-.03 0-.05-.1-.06-.1-.02 0-.04-.05-.07-.04 0 0 0-.03-.03-.03L.6 7.65H.5c-.06 0-.1.06-.1.07H.3c0 .02-.02.03-.03.04-.05.04-.05.1-.04.12H.15l-.02.02c-.06.04-.06.14-.02.2v.02l.1.02c0 .02-.1.06-.1.12 0 .04 0 .12.1.15v.1c.1.1.1.1.2.1h.1l.1.1.1.1V9s-.1.1 0 .2v-.05H.1c-.02.08 0 .18.06.2l.12.07H.3l.07.03H.4v.16h.1H0h.3c-.02.1.1.1.1.1-.06.1 0 .1 0 .1 0 .1.04.1.1.1 0 .1 0 .1.02.1l.03.1H.7l.04.1s.1.1.17.1H1l.1.1.2.1v.4l.3.1.1.1-.05.1h-.1s-.05 0-.06.1c-.1 0-.1.1-.1.1l-.2.1h-.1.1v.1l-.1.1v.1c-.1.1-.1.1-.1.2-.1 0-.1.1-.1.2v.1s-.1.1 0 .2v.1c-.1 0 0 0 0 .1-.1 0-.1 0-.1.1v.2l.1.1h.2l.1.1.1.1v.1h.1l.1.1h.1s.1 0 .1-.1V13H2v.1c0 .05.06.1.1.1h.1v.1l.1.1c0 .04 0 .04.03.05h.05v.14s.04.1.12.1H3v.1s.03.1.06.1h.05l.1.1h.2c0 .1 0 .1.1.2h.3l.1-.1H4c.05 0 .07.1.1.1 0 0 .03.1.07.1h.15v.3s.2.4.3.4h.05l.1-.3c.1 0 .1-.1.2-.2v-.1l.1-.07.04-.06v.15s0 .1.1.16c0 .1.1.1.2.1h.1c.1 0 .1-.1.1-.1v-.1h.1l.1-.1H6l.1.06h.2l.1.02H6v.1c0 .05.04.1.07.1h.16c-.04 0-.07.06-.07.1v.1c.03.1.17.1.2.1l.22.04H7c.02-.02.08-.03.1-.12l.03-.03.08-.07h.4l.1-.06h.1c.1-.05.1-.1.1-.1l.1-.04h.2l.2.1h.1c.1 0 .2.1.2.1h.2c.1-.05.1-.14.1-.2 0 .04.2.06.2.06v.1H9s-.03.04 0 .1v.2s0 .03.05.05c0 .1.05.1.08.1 0 .1.05.1.05.1v.1h.03v.4H9v.1h-.03c-.03 0-.04.1-.05.1h-.1v.2h-.1l-.1.1v.1l-.02.1v.1l.07.1-.1.1v.1c.04.1.07.1.1.1h.4s.03.1.05.1c0 0 0 .1.03.1-.03.02-.03.04 0 .06V17h.02l.1.28v.06c0 .05 0 .14.04.2H9l.15.03.04.02v.4-.5h.3v.2s0-.1.1-.1v-.2.1s0 .1.1.1h.2s.1 0 .1-.1v-.3l.1-.2v-.1c0 .1.1.1.1.1h.2l.1-.1s0 .3.1.3v.3h.1v-.6l.1-.1.1-.1c.1 0 .1-.1.1-.1h.2v.4l.1.5c.1 0 .2-.4.2-.4s.1 0 .1-.1v.1-.1.1h.1s0 .1.1.1c0 0 0 .1.2.1l.1-.1v-.1h.3v-.05h.4v.1c-.1 0-.2.2-.2.2-.1 0-.1.1-.1.2l-.1.1-.1.04v.1c-.07 0-.07 0-.07.1l.1.2c-.1 0 0 .1 0 .1s0 .1.1.1h.4l.1.02v-.05h.1l.1-.08h.06s.1.03.1 0l.1-.08V18h.1l.1-.2.2-.1-.1-.1c-.1-.1-.1-.1-.2-.14l-.3-.1H13h1v.1-.1h.1v-.14h.2s.1 0 .1-.1c.1.07.1.1.2 0h.1V17s.1-.1.18-.1.1.1.1.1c.1 0 .2-.04.2-.14v.6h.2c.08 0 .1-.4.1-.4V17l.1-.1v-.1l.1-.06c.1 0 .1 0 .1-.1v.4c.1.07.1.5.2.5l.1-.4V17h.1l.04-.03.02-.02c.1 0 .2-.04.2-.12l-.1-.05-.1-.05.2-.02h.2l.3.1-.1-.1h.23s.1 0 .1-.1v-.1h.3l.1-.1V16s.1 0 .1-.05l.1-.02.03-.04v-.1c.1 0 .1-.1.1-.1h.1v-.1c.08-.1.07-.2 0-.2v-.2h.05v-.4l.04-.1h.1l-.1-.1v-.5h.2v-.25c0-.1 0-.1-.03-.1l-.53-.1h.6l.1-.1.06-.08s.08-.1 0-.1l.07-.1V13h-.3c-.1-.06-.1-.07-.2-.07l.1-.1h.1l.1-.07-.1-.1v-.27c-.06-.1-.15-.2-.3-.2l-.06-.1s-.1-.1-.2-.1v-.1c0-.1 0-.1-.1-.2l-.1-.1v-.2c0-.1 0-.1-.03-.1l-.1-.2c-.1-.2-.1-.2-.1-.1-.1 0-.1-.1-.2 0-.1-.1-.4-.1-.5-.1l.3-.1h.2l.1-.1.6-.5-.46.1c0-.1.1-.1.1-.1.07 0 .17-.1.2-.1s.05-.1.04-.1l.1-.1v.2c.03 0 .04.2.05.2l.04-.3.1-.1c.06 0 .1-.1.1-.1l-.7-.1H17h.4l.1.1h.2l.1.1h.6c.1-.08.1-.28.1-.3l.1-.17c.1 0 .1-.1.1-.1v-.1h.1s.1 0 .1-.04l.1-.1c.1 0 .1 0 .1-.1.1 0 .1-.1.1-.1h.4l-.04-.1c-.1-.1 0-.1 0-.1v-.1c.1-.1.1-.1.1-.2.1 0 .17-.1.18-.1l.04-.1.05-.1.1-.1c0-.1.1-.2.1-.2l.06-.1h.3c0-.1.2-.1.2-.1v-.1l.3-.1c.1-.1.3-.2.3-.3s-.1-.1 0-.1v-.1s.1 0 .1-.1v-.3c0-.1 0-.2-.1-.2l-.1-.2c0-.1-.1-.1-.1-.1v-.1c.1-.1.1-.1.1-.2h.5c0-.1.1-.2.1-.3 0-.1-.1-.1-.1-.2zM1.25 11.5zm12.8 6.8h.04-.1z"/><path d="M17.38 10h.04"/><path d="M16 3.5h.23H16zm2.32 6.5l-.04-.02V10h.04zM21 7.34h.05L21 7.3v.03zm-4.4 5.4s-.02-.07-.1-.07h-.02v.15l-.03.14h-.03c-.03 0-.06-.13-.07-.13l-.02-.1c-.05 0-.1.08-.14.1-.1 0-.1.1-.1.1h.3c.1 0 .1.05.1.03v-.18l-.1-.05z"/>';
    icon[Constants.TREEMAP_CHART] = '<polygon fill-opacity = "0.6" points="11,0 11,10 11,13 11,14 11,16 11,22 22,22 22,16 22,14 22,13 22,10 22,0 "/> <rect y="14" fill-opacity = "0.2" width="10" height="8"/> <rect width="10" height="13"/>';
    icon[Constants.FUNNEL_CHART] = '<polygon points="20.06,6.533 1.989,6.533 1.082,1.656 20.966,1.656 "/> <polygon points="17.949,14.412 4.005,14.412 2.051,8.409 19.888,8.409 "/> <polygon points="14.963,20.79 6.944,20.79 4.271,15.912 17.933,15.912 "/>';
    icon[Constants.GANTT_CHART] = '<path d="M8.38.95V4.42h-7A.48.48,0,0,1,.83,4V1.37a.47.47,0,0,1,.5-.43ZM2.67,6.48a.47.47,0,0,0-.5.43V9.53a.47.47,0,0,0,.5.43H13.12V6.48ZM20.49,12H8.58a.47.47,0,0,0-.5.43v2.62a.47.47,0,0,0,.5.43H20.49a.47.47,0,0,0,.5-.43V12.43A.48.48,0,0,0,20.49,12ZM4,17.53a.47.47,0,0,0-.5.43v2.63A.47.47,0,0,0,4,21H14.44V17.53Z"/> <path fill-opacity="0.5" d="M11.58,1.37V4a.48.48,0,0,1-.5.43H8.38V.95h2.7A.47.47,0,0,1,11.58,1.37Zm3,5.1H13.12V10h1.46a.47.47,0,0,0,.5-.43V6.9A.48.48,0,0,0,14.58,6.48Zm4.49,11.06H14.44V21h4.63c.32,0,.6-.19.6-.43V18C19.67,17.73,19.39,17.53,19.07,17.53Z"/>';
    icon[Constants.STRUCTURE_CHART] = '<path d="M20.4,18c-1,1-2.5,1-3.5,0.1c-0.7-0.6-0.9-1.6-0.7-2.4l-4-1.7c-0.1,0.1-0.2,0.2-0.3,0.3c-1.4,1.5-3.6,1.6-5.2,0.4l-1,1  c0.7,1,0.6,2.3-0.2,3.2c-1,1-2.5,1-3.5,0.1c-1-1-1-2.5-0.1-3.5c0.9-0.9,2.4-1,3.4-0.2l1-1c-1.3-1.5-1.3-3.8,0.1-5.3  c0,0,0.1-0.1,0.1-0.1l-1.5-3C4,6.3,2.8,6.2,2,5.4c-1-1-1-2.5-0.1-3.5c1-1,2.5-1,3.5-0.1c1,1,1,2.5,0.1,3.5c0,0,0,0,0,0l1.5,3  c1.4-0.9,3.4-0.8,4.7,0.4l2.1-2.1c-0.6-0.9-0.5-2.2,0.3-3.1c1-1,2.5-1,3.5-0.1s1,2.5,0.1,3.5c-0.9,1-2.4,1-3.4,0.1l-2,2  c0.9,1.2,1.1,2.8,0.4,4.2l3.8,1.6c0.1-0.2,0.2-0.3,0.4-0.5c1-1,2.5-1,3.5-0.1C21.3,15.4,21.4,17,20.4,18z"/>';
    icon[Constants.WORD_CLOUD_CHART] = '<path d="M17.61,12.53H15.85v5h1.86a2.5,2.5,0,0,0,1.83-.62A2.51,2.51,0,0,0,20.16,15,2.31,2.31,0,0,0,17.61,12.53Zm-.53,1.12h.49c.88,0,1.29.45,1.31,1.37s-.4,1.43-1.3,1.43h-.5Zm-8-4.52L5,19.47H7.2l1-2.62h4l1,2.62h2.23L11.25,9.13Zm1.08,2.35,0,.07,0,.12s.16.39,1.33,3.42H8.8c1.09-2.84,1.3-3.37,1.34-3.45Zm-5,1.21c-2-.11-3.08-1.26-3.19-3.42C2.05,7,3.13,5.87,5.15,5.74A2.88,2.88,0,0,1,8,7.77l.1.29-1.5.39-.08-.26A1.37,1.37,0,0,0,5.16,7.11c-.63,0-1.52.32-1.62,2.14.07,1.8,1,2.08,1.63,2.14A1.43,1.43,0,0,0,6.63,10l.06-.3,1.48.43-.06.25A2.72,2.72,0,0,1,5.14,12.7ZM19.47,8.62v0A2.22,2.22,0,0,0,18,6.66a2.06,2.06,0,0,0,1.07-1.89c-.08-.95-.66-2.1-3-2.17H12.43v8.56h3.91C18.93,11.16,19.47,9.78,19.47,8.62Zm-1.89-.08c0,.54-.16,1.17-1.44,1.17H14.2V7.53h1.86C17.37,7.56,17.56,8.13,17.59,8.54ZM15.91,6H14.2V4.1h1.71c1.19,0,1.35.51,1.36.88S17.09,6,15.91,6Z"/>';

    function setArrow(dom, color) {
        if (BaseUtils.isSupportSVG()) {
            dom.style.background = color;
            dom.innerHTML = '<svg width=30 height=30><path fill="none" stroke="#FFFFFF" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="M11.1,21.5L20.9 15 11.1 8.5 M11.1,21.5z"></path></svg>';
        } else {
            var circle = createVml('shape');
            circle.path = PathUtils.circlePath(15, 15, 15);
            circle.stroked = 'False';
            circle.fillcolor = color;
            var fill = createVml('fill');
            fill.color = color;
            fill.opacity = 0.5;
            circle.appendChild(fill);
            dom.appendChild(circle);

            var path = createVml('shape');
            path.path = /vanchart-arrow-left/.test(dom.className) ?
                'm19,22 l9,15 l19,9 e' : 'm11,22 l21,15 l11,9 e';
            path.filled = 'False';
            path.strokecolor = '#ffffff';
            dom.appendChild(path);
            VanHammer.on(dom, 'mouseover', function () {
                fill.opacity = 0.2;
            });
            VanHammer.on(dom, 'mouseout', function () {
                fill.opacity = 0.5;
            })
        }
    }

    function setDot(dom) {
        var circle = createVml('shape');
        circle.style.width = '100%';
        circle.style.height = '100%';
        circle.coordsize = '10 10';
        circle.path = PathUtils.circlePath(5, 5, 5);
        circle.stroked = 'False';
        circle.fillcolor = '#7f7f7f';
        var fill = createVml('fill');
        fill.color = '#7f7f7f';
        fill.opacity = 0.5;
        circle.appendChild(fill);
        dom.appendChild(circle);
    }

    var png = {};
    png[Constants.PIE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAMFBMVEUAAAD///////////////////////////////////////////////////////////87TQQwAAAAD3RSTlMAEM/vv4Bgr59AcFAg348jFhddAAAAjElEQVQY02MAArGSDx6JDGDAav//w//PASAmo/5/IPv/JwEgW/g/mP1fEcjWh7I/AVX/h7L/L2AQhrMvMOTD2b8Z6uHsfwz+ULZK1ByG/2B25smtLfYQ9hewLEQNRACoFwZ+AM2EgW9Au2DAkIEVzg6AuO0/xG1wRYpgv0CEBaB+/A/2I8Tv/zVAfgcA4kmspsM258YAAAAASUVORK5CYII=';
    png[Constants.BAR_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAElBMVEUAAAD///////////////////8+Uq06AAAABXRSTlMAQIAgEDB5ccoAAAA+SURBVBjTY0AGoqGhgTjZBICjoKCgCFw9SAMm20hJSUkZlwFwNWAgANELBgrobEdBMDDAZQZEPRQI4GQjAwAQhxXw9o2YjgAAAABJRU5ErkJggg==';
    png[Constants.COLUMN_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAG1BMVEUAAAD////////////////////////////////rTT7CAAAACHRSTlMAgEC/IGCPMNAZ/cwAAAAuSURBVBjTY4ADRSEEW6KRALvYDMHWaCbAtmgiwHZSgbOBiG5skJcDRRgcRYEMADB5J9shBWGXAAAAAElFTkSuQmCC';
    png[Constants.LINE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMA74C/IM9AEN+vYDCfcFCP7HfXwgAAAG9JREFUGNPNjzsOxDAIRA0Yf+J1du5/2siKIQ1dmlA9PQ2gSa8nHznSBIo0gOgGlAPdm+M4HQuK4Qn8jEU88QdoZw6MZ0+lQ/Li5muDFpYGrokpu9UbJjUmtqaqdQeqAN2aYln7hx41nbwzLDN9Yi4tRQMa2y+S7gAAAABJRU5ErkJggg==';
    png[Constants.AREA_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAgklEQVR42mL4DwQMtACjBg8zg4FCBhRbiMPg+f8hIIFqBiMZCgMGFBuMxVAQeE+q4UD1AnCDgVT/f9zgPlgxcYaC4uc8Ayws/xMG5wkZDjX0Pdix/0kD8/EY6gAzlByDsRqOzcfkGIySDHEFIyMFGWEClC7AJslIqyw9avAQNhggwABVPsGVrLOsUQAAAABJRU5ErkJggg==';
    png[Constants.GAUGE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAMFBMVEUAAAD///////////////////////////////////////////////////////////87TQQwAAAAD3RSTlMAgL9A3zAQn89wII/vr2A5/8HrAAAAnUlEQVQY02NAA5kq/52mQZjZ/0FgG4jJ6v/fXbDk/5cAIDvmvzJDKIPR/6MMDGz+HxkYjBkY5L8kMLD/FwCzGf8XMKz/xABmM+j/Ytj/GUjPBGL73wz9DUBaEIg5fjAAlYPYIA0M/ydA2ZxA9gMgfQaI+f5D1NyFqOm/AHUh7w+G/b+g7PXfGeK/Q9n1XxmYtKDsRQoMbHAvJTAQAQCj4DRASabatgAAAABJRU5ErkJggg==';
    png[Constants.RADAR_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMAEO+A32DPr7+fQFAwIHCP1A0rdQAAAMpJREFUGNOFUFlyRCEIlEXcfdz/tAHxVSr5mOmyQJu2UdI39Mob/pOjcuOK9KeQmbPJbd3CS3oqblWQVpiqnEx00tYnjlXqemlo+ISqZHhwBN25AOih0aQDGxhNuI2QbmGh16ByKSLT9w/FAw6aar0v89zItKMhqzJan3tf8i4qe3aWvHxLE81LQ5IKZU7nImu2Y3gvhcQjvBGsLHTat9srTZ0n+V8Ap4fuYd+h4rxCMkNp6YIEwhZwNfkdeWG+fxIfxQsQfdHTB/wA4h0GZUKWX6QAAAAASUVORK5CYII=';
    png[Constants.SCATTER_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAgUlEQVR42mJgGAVA8P//fwFaGFoAxP8ZaWCwAZByGHRhCPYuEKyntsH7oQb/x6WGhUyzF0LpCyMnoRtAkw+6uAMQnwdFIrlhfB5Ko6d3BSA2IDuMgS6aD8T9eDICeV6mNBzn/0eA+dQ0GB1QxeVMtExSDTQJCljBDMQKI7t6AggwAFyzgSCZYutPAAAAAElFTkSuQmCC';
    png[Constants.BUBBLE_CHART] = png[Constants.FORCE_BUBBLE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAnUlEQVR42mJgGAVQwEiswv///ysAqQQodwIjI+MHqrgAaPD7/wiwn1qGOvxHA1QLM1JdzEKC2YbIYUz31AANNgFqG9oPDar3TFR2sAGUFoCnUSCeD4oUKG1AposNgHg9ECdgTUpQEEBpuNzHYfB9Sg3GBwzINZdQ5H0YlEFhgJZd/0P5BhQXm9CckgBNfyDvbwAWiw9GaxWqAIAAAwA2evfwKvysMwAAAABJRU5ErkJggg==';
    png[''] = png[Constants.MULTI_CHARTS] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMAQL/PMBBwgCDvn49gUN+vfvzE8AAAAGJJREFUGNPdjUEOgDAIBFkordpW+f9rNdqUQ3mBeyBhMiwURBNFYQu4HsK60E1aUNAlA+7sUgpQmdXMZh/vDORyPs8cJ+l4T7dEjhsPB8DE+bh0LD4IJkRO3K7Agj/xTzjKDUJoCsaJEKt8AAAAAElFTkSuQmCC';
    png[Constants.MULTIPIE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAe1BMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NgkbwAAAAKHRSTlMAMpkDn0AnIBSz24Dmv4dKOhoQCuzKrJqMLfnyuaZ5dGZaUkIN0pRsCVisMQAAAOZJREFUGNN90dtygyAUhWHWEhA0Gg8xappz0pb3f8LKdkrTXvS/45s9DHtQL8G6TP0qcxYKS3n2gm0UVX9ugblPatFca63IsX4AfdLtB0nF2BbIhHPcNVkV6jBo8Txqj2bkfheCCmG3eA08ZfhC/RYii483GZ9BDkF4qSBLYGE8NDeJw4mUx+DGlU2ssdY9ZeWrFl7bkHcI48gicUHdCFt4+sRHTrCRHcoT33+GL3Cy+wxPVvHlh4Hcfy/fwXi9nL0ntTfo1JqDmSrGqglxxeQw57Iszwbx4lSWYy3/+2td27ad4D99Ae8gE70h03waAAAAAElFTkSuQmCC';
    png[Constants.AREA_MAP] = png[Constants.HEAT_MAP] = png[Constants.POINT_MAP] = png[Constants.LINE_MAP] ='iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAA5ElEQVR42mJgGHHg////AkDsAMQK1DZ4/38IeE/QcJACIDYgwlAHqIH/kQxvAOLz2BTPB0kA8X1CLoC6FtlgOEBXiA76QWGIx1cO/7GDfpCCAqjzcYH76MEC4hNQr8CAyys4QANUIzqAmbEe7kMcCkkF76HxooCeDqkB1mNLMtQAAdhyznkqGHwfawoikDKIBQ64EnwA1Ob9aLFNLFBgIDK7CpAQByDHNMD0s+AymJGR8QDUgngiyqIHQHwQiPlJLcHeIwXRe7QI+w/1mQLOMCZU7iKxQWXIfVoU7uS5blADgAADACOwXahZ5pbvAAAAAElFTkSuQmCC';
    png[Constants.TREEMAP_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAOUlEQVR42mL8DwQMRABGIAAqnclAJGBioBEYNXjU4FGDh5XBLEDMRyuD1YhUe3Y08kYNHqQGAwQYAL9YCMfrIWhGAAAAAElFTkSuQmCC';
    png[Constants.FUNNEL_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXBAMAAAASBMmTAAAAKlBMVEUAAAD///////////////////////////////////////////////////+Gu8ovAAAADXRSTlMAQMCAIGAw0FAQ8HCwS1BQUgAAAHVJREFUGNNjwA2Y78LAZQYGDjjnKgMDC5xzDahuLYxzAcjRhXEKgJxEQShIAHIcYRwHIGcvTFkAkOML40wActih7DsgJ3Aj7ETYehPsuloIRwHT3UlKYNAAZMKMuzUBzGFEGAZxKkJ/LojjAOWwGhsbW2CYCwC1z2uuESf9qgAAAABJRU5ErkJggg==';
    png[Constants.GANTT_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAeFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////GqOSsAAAAJ3RSTlMABOgQCPvZzN3OhMOofnrCZD03jzDs0ryWiXNsXyUjDd9TUkQqHhgfRKpZAAAAmElEQVQY043P2Q6DIBRF0SsiKMrgXKfamf//w1qxQJo0uh73y8kBmEMDYxyA9SI1WrGB310+R9o4ie7mZW1zeXU5bBuaLKhQfQ4HBB7bgKOGbOJuqL45007G8p3MahJvLmVfLcXAjtncE8BEE3NrZXOhfXv5gXxgzaEH/nu2qZQyXUiajUqNavpdQ5wxVuafXEWWJoJzwYo3Z10TfT0w3LEAAAAASUVORK5CYII=';
    png[Constants.STRUCTURE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAhFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8g2+bRAAAAK3RSTlMAA/v3JXcSB9yNRSycF/Dsu7akmJSCTTMOC9HEwKWIWTof4taqoH1wZ1Ydf35d9gAAAO1JREFUGNNVUAlygzAMlA+wMZAQroTc6d3q///rYkHcahikWe+sdkVSitbhOQ2vOyu4/KUyZj4+0ft+gc9sNJdCnBrmSuCCNfuDkDPMHCIlbzS/k1MoUIzhG+D5s/UlKjr6wp6XHJhsHysVxh8K1b3vxJV4bTfM277LV5fSc88aywqalORZHRiGiW2UTfAFGErP9pVbnhz1wvZxT7rSnhEVS6+WqMzGiE7h8TiBzV1Z+fYTUwHcejan2mZDmCN/MPQ2NVEbu+g5oiPkNLQauaBTEvkKtR2mm/R0/3MR7/n9Nhz+xPifP0GL93SGVL8LLRIgop0Y4gAAAABJRU5ErkJggg==';
    png[Constants.WORD_CLOUD_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAACMUlEQVRIS7VUQXLaQBCckcRBXEAXqnY4YP8AvyDJD8IL4rwgzgvivCD2D+AFkBeYvCD4BSEHraq4gE+6UJpUU1plAYkCV3lPQhp6erp7lumNDr8RLl0MnGXZeyJ65wgVRbEIguDZGLP0SV4MnKbpPTN/q5n0q4g8uPevBmbmD8aY+Wq1Gm632xkRDUSkwjsCzrLsKgzDbq/XW9Tp7xg74PV63c3z/DcRJSLSPWJcFkyJCBriLKMoGh02aJLCNToCttaOiegTEY2iKFpiPFVd9/v9G5+5BzxR1SUzg+WtqmoQBDfOxEoKa+2GiOYi8hFAcD8Mw00TY5+h16wy0AdWInoUkTsAQxrHNM9zSITzqKrDMhV3zLwoigJ1SMoQ04oIjPyf4zRNF8zcEZFrfLDWIjpfVPW7i5eqwtCfDXGrSO0BY3RVfYJpRAQASDIpzRwQ0QsRdcCKmSGbO8vD5dgDxo8yk7dEhHHHqgqAqao+E9GsZDoREdTAh6vS8F2KjDEgsjsnF8QlhZk/w1hV/YNm7Xb7OkmSjTflL5AhoicRGZ0ELnO9RlEcxwmArLVz3BNoZIwZO2BsnLUW0k1dbSNjay3S8cPPsHuGici3D+yezwGGiQPoe2AWRu4gx2gEw5n5XlWh+18R2W1uLePSROz/i7//fgyRGAAWRbEzEs3jOB5DskZgb733suklB00r7evkqmUMfVW1GwTBuC6j7nur1Zo13YIX38d17M5mfO6fT9X9A37JPSaAohB+AAAAAElFTkSuQmCC'

    var CSS = "position:absolute;width:1px;height:1px;behavior:url(#default#VML);";

    function createVml (type) {
        var shape = VmlRenderer.prototype.create(type);
        shape.style.cssText = CSS;
        shape.coordsize = '1 1';
        return shape;
    }

    return CarouselFun;
});
/**
 * Created by eason on 15/5/15.
 * 管里当前产生的所有
 */
define('VanCharts',['require','./vans/VanChart','./vans/VanChartMap','./vans/VanChartForceBubble','./vans/VanChartWordCloud','./vans/VanChartStructure','./chart/gantt/Gantt','./utils/BaseUtils','./Constants','./utils/LoadingUtils','./Carousel','./vans/VanChartLibrary'],function(require){

    require('./vans/VanChart');
    require('./vans/VanChartMap');
    require('./vans/VanChartForceBubble');
    require('./vans/VanChartWordCloud');
    require('./vans/VanChartStructure');
    require('./chart/gantt/Gantt');

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var LoadingUtils = require('./utils/LoadingUtils');
    var Carousel = require('./Carousel');
    var VanChartLibrary = require('./vans/VanChartLibrary');

    window.VAN_CANVAS = BaseUtils.isSupportSVG() ? 'canvas' : 'vancanvas';

    var _baseIndex = 0;

    var _instances = Object.create(null);

    function init(dom){
        BaseUtils.initConst();
        var instanceKey = dom.getAttribute(Constants.INSTANCES_KEY);
        if(!instanceKey){
            instanceKey = Constants.INSTANCES_KEY + _baseIndex++;
            dom.setAttribute(Constants.INSTANCES_KEY, instanceKey);
        }

        var vanCharts = _instances[instanceKey] || new VanCharts(dom);
        _instances[instanceKey] = vanCharts;

        return vanCharts;
    }

    function VanCharts(dom){
        this.dom = dom;
        this.charts = [];
        this.carousel = Carousel && Carousel(this);

        this.dom.style.cssText += ';overflow:hidden;-ms-user-select:none;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;';
        this.dom.onselectstart = this.dom.ondrag = function(){
            return false;
        };
    }

    VanCharts.prototype = {
        constructor:VanCharts,

        setOptions:function(options){

            this.options = options || this.options;

            if (options && BaseUtils.isArray(options.options)) {
                this.charts = this.carousel.init(options, this.charts, this.dom);
            }else{
                this.charts = [this._initSingle(options, this.charts[0], this.dom)];
            }
        },

        showLightBox:function(vanchart){
            showLightBox(vanchart);
        },

        hideLightBox:function(container, fullScreenFather){
            hideLightBox(container, fullScreenFather);
        },

        /**
         * return initialized or refreshed chart object
         * @param {Object} [option]
         * @param {Object} [oldChart]
         * @param {Object} [dom]
         * @returns {Object} [chart]
         * @private
         */
        _initSingle: function (option, oldChart, dom) {

            var ChartClass = VanChartLibrary.get(option.chartType);

            if (oldChart && oldChart.vanChartType === ChartClass.prototype.vanChartType) {

                //todo 这个属性看着好想删掉
                oldChart._changeDataState = true;

                oldChart.refresh(option);

                return oldChart;
            } else {
                oldChart && oldChart.remove();
                return new ChartClass(option, dom, this);
            }
        },

        setData:function(options, i){
            if (i != null) {
                // update a single chart in carousel
                this.charts[i] = this.carousel.refresh(options, i);
            } else {
                this.setOptions(options);
            }
        },

        /**
         * 设置自动刷新取回的变化的数据
         * @param {[type]} options [description]
         * @param {[type]} index   [description]
         */
        setAutoRefreshData: function (options, index){
            index = index || 0;
            this.charts[index].autoRefresh(options, index);  // 这样写不知道会不会有啥问题
        },

        eachVanChart:function(callBack){
            // 又是极限情况，当图表切换中一个设置超链，点击之后，第一次each结束之后就
            this.charts && this.charts.forEach(function(chart){
                callBack.call(null, chart);
            });
        },

        refreshRestore:function(){
            this.eachVanChart(function(chart){
                chart.refreshRestore();
            });
        },

        resize:function(options){

            //不要删，删了就坑了露露了
            if(options){
                this.setOptions(options);
            }else{
                this.charts.forEach(function(chart){
                    chart.resize();
                });
            }
        },

        getChart:function(index){
            return this.charts[index];
        },

        clear:function(){
            for(var i = 0, len = this.charts.length; i < len; i++){
                this.charts[i].remove();
                this.charts[i] = null;
            }
        },

        startLoading: function () {
            if(this.dom){
                LoadingUtils.startLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
            }
        },

        endLoading: function () {
            if(this.dom){
                LoadingUtils.endLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
            }
        }
    };

    function initPaddingScale(scale){
        BaseUtils.initPaddingScale(scale);
    }

    function showLightBox(vanchart, zIndex){

        var options = vanchart.options;

        var w, d;

        try {
            d = window.top.document;
            w = window.top;
        } catch (e) {
            w = window;
            d = w.document;
        }

        var body = d.body;

        //todo FR的zIndex没有一个统一的逻辑,3000,8000都是写死的值
        //var currentMaxZ = 7998;  留着以后做参考，这里改成3330是为了全屏之后超链能显示
		var currentMaxZ = 3330;

        if (zIndex == null) {
            var el, i = -1,
                len = document.body.children.length;
            while (++i < len) {
                el = document.body.children[i];
                if ((el.style.display || '').toLowerCase() !== 'none') {
                    currentMaxZ = Math.max(currentMaxZ, el.style.zIndex);
                }
            }
        } else {
            currentMaxZ = zIndex - 1;
        }

        var boxDiv = d.createElement('div');
        boxDiv.style.cssText =
            'position: fixed;' +
            'top:0;' +
            'left:0;' +
            'width:100%;' +
            'height:100%;' +
            'z-index:' + (currentMaxZ + 1) + ';';
        if (BaseUtils.isSupportSVG()) {
            boxDiv.style.background = 'rgba(0,0,0,0.3)';
        } else {
            boxDiv.style.background = '#000000';
            boxDiv.style.filter = 'alpha(opacity=30)';
        }

        body.appendChild(boxDiv);

        var container = d.createElement('div');
        container.style.cssText =
            'position: fixed;' +
            'top:5%;' +
            'left:10%;' +
            'width:80%;' +
            'height:90%;' +
            'z-index:' + (currentMaxZ + 2) + ';' +
            'background:#ffffff;' +
            'box-shadow:0px 4px 50px rgba(0,0,0,0.5);';

        // for ie quirks mode
        try {
            container.style.setExpression("top", "( ignoreMe = document.body.scrollTop + this.previousSibling.clientHeight * 0.05) + 'px' ");
            boxDiv.style.setExpression("top", "( ignoreMe = document.body.scrollTop ) + 'px' ");
            container.style.position = 'absolute';
            boxDiv.style.position = 'absolute';
        } catch (e) {

        }
        body.appendChild(container);

        var fullScrVanCharts = init(container);

        // It's a little strange that
        // the VanChart[S] instance's father is a VanChart instance
        // 'cause we have only one chart in full screen mode
        fullScrVanCharts.fullScreenFather = vanchart;
        fullScrVanCharts.setOptions(options);

        vanchart.set({enable: false});
        vanchart.fullScreenChart = fullScrVanCharts;

        container.boxDiv = boxDiv;

        boxDiv.onclick = function(){
            hideLightBox(container, vanchart);
        };

        container.onclick = function(e){
            e = e || w.event;
            if (e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble = true
            }
        };
    }

    function hideLightBox(container, fullScreenFather){
        var parent = container.parentNode;

        if(parent){
            parent.removeChild(container);
            if(container.boxDiv){
                parent.removeChild(container.boxDiv);
            }
        }

        fullScreenFather.set({enable: true});
        fullScreenFather.fullScreenChart = null;
    }

    function acceptPoint (obj) {
        return obj && obj.vanChartType === 'point'
    }

    return window.VanCharts = {
        version: '8.5.0',
        buildTime: '10/19/2017 15:09:16 GMT+0800 (CST)',
        /*v: commit */
        showLightBox:showLightBox,
        hideLightBox:hideLightBox,
        init:init,
        initPaddingScale:initPaddingScale,
        acceptPoint: acceptPoint,
        instances:_instances
    };
});
/**
 * Created by eason on 15/5/4.
 */
define('chart/Bar',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/BezierEasing','./Series','../ComponentLibrary','../dom/Browser','../ChartLibrary','../ChartLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var Series = require('./Series');
    var ComponentLibrary = require('../ComponentLibrary');
    var Browser = require('../dom/Browser');

    var INIT_ANIMATION_TIME = 1200;//初始（刷新）
    var INIT_EASE = BezierEasing.css["ease-out-cubic"];
    var EXIT_ANIMATION_TIME = 150;//点击图例消失
    var EXIT_EASE = BezierEasing.css["ease-in-back"];
    var UPDATE_ANIMATION_TIME = 250;//点击图例其他系列更新位置、大小
    var UPDATE_EASE = BezierEasing.custom["ease-out"];
    var RE_SHOW_ANIMATION_TIME = 900;//点击图例重新出现
    var RE_SHOW_EASE = BezierEasing.custom["ease-out-quint"];
    var STACK_ANIMATION_TIME = 600;//堆积柱形图，点击图例消失、更新、重新出现时间
    var STACK_EASE = BezierEasing.css["ease-out-cubic"];//堆积柱形图，点击图例消失、更新、重新出现缓动函数

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;
    var MIN_BAR_SIZE = 2;

    var Bar = Series.extend({

        doLayout:function(){

            var ow = this.getSeriesOffsetAndWidth();
            var series = this, vanchart = series.vanchart;
            var isColumn = series.type == Constants.COLUMN_CHART, inverted = vanchart.isInverted();
            var startKey = 'x', stackKey = 'y';
            if(!isColumn){
                startKey = 'y'; stackKey = 'x';
            }

            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);

            var baseAxis = series[startKey + 'Axis'];
            var stackAxis = series[stackKey + 'Axis'];


            var basePos = stackAxis.getZeroPos();
            var axisLineWith = 0;
            if (baseAxis.isOnZero()) {
                axisLineWith = baseAxis.options.lineWidth;
            }

            this.points.forEach(function(point){
                var options = point.options;

                var startPos = baseAxis.scale(baseAxis.getAxisValue(options[startKey], point));
                var stackPrePos = stackAxis.scale(options[stackKey + '0']);

                // 8.5.0的时候改错的，柱形图计算的时候不需要减去startPosValue，折线图需要
                var stackCurrentPos = stackAxis.scale(stackAxis.getAxisValue(options[stackKey], point) + options[stackKey + '0']);

                if (stackPrePos === Infinity) {
                    stackPrePos = stackAxis.scale.range()[0];
                }

                var rectX, rectY, rectWidth, rectHeight;
                rectX = startPos + ow.offset - ow.width / 2;
                rectY = Math.min(stackPrePos, stackCurrentPos);
                rectWidth = ow.width;
                rectHeight = Math.abs(stackPrePos - stackCurrentPos);

                if (rectY === basePos) {
                    rectY += axisLineWith / 2;
                    rectHeight -= axisLineWith / 2;
                } else if (rectY + rectHeight === basePos) {
                    rectHeight -= axisLineWith /2;
                }
                rectHeight = Math.max(rectHeight, 0);

                var rect = {};
                if(showAsColumn){
                    rect.x = rectX; rect.y = rectY; rect.width = rectWidth; rect.height = rectHeight;
                }else{
                    rect.x = rectY; rect.y = rectX; rect.width = rectHeight; rect.height = rectWidth;
                }

                point.rect = BaseUtils.rectSubPixelOpt(rect, options.borderWidth);
                point.rect.rx = point.rect.ry = point.options.borderRadius;

                if(!point.isNull){
                    series._calculateAnimationInitRect(point, isColumn, inverted);
                }
            });

        },

        getSeriesOffsetAndWidth:function(){
            var series = this, options = series.options;

            var columnCount = 0, stackedMap = {};
            var columnIndex = 0;//start from 0
            var allPointsCount = 0;

            var chartSeries = this.vanchart.seriesOfType(this.type);

            var baseAxisType = this.getBaseAxisType();

            chartSeries.forEach(function(otherSeries){

                if(otherSeries[baseAxisType] == series[baseAxisType] && otherSeries.visible){

                    if(otherSeries.stack && !stackedMap[otherSeries.stack]){
                        columnCount++;
                        stackedMap[otherSeries.stack] = true;

                        if(series.stack && series.stack == otherSeries.stack){
                            columnIndex = columnCount - 1;
                        }

                    }else if(!otherSeries.stack){
                        columnCount++;
                        if(series == otherSeries){
                            columnIndex = columnCount - 1;
                        }
                    }
                }

                if(otherSeries[baseAxisType] == series[baseAxisType]){
                    allPointsCount += otherSeries.points.length;
                }
            });

            var categoryAxis = series[baseAxisType];

            var width = 0, offset = 0;

            if(categoryAxis.isCategory()) {

                var categoryGap = options.categoryGap, gap = options.gap, tickLength = categoryAxis.getTickLength();

                categoryGap = BaseUtils.getPercentValue(categoryGap, tickLength);

                var seriesGap;
                
                // @Cmen:CHART-889
                var defaultWidth = (tickLength - categoryGap) / columnCount; // 默认的系列宽度 
                var defaultOffset = categoryGap / 2 + defaultWidth * (columnIndex + 0.5);  // 默认的系列中心点位置 

                if(parseFloat(gap) >= 0) {  // 系列不堆叠
                    seriesGap = BaseUtils.getPercentValue(gap, defaultWidth); 
                    offset = defaultOffset; 
                    width = defaultWidth - seriesGap; 
                }else{  // 系列堆叠
                    seriesGap = Math.abs(BaseUtils.getPercentValue(gap, tickLength - categoryGap));
                    width = (tickLength - categoryGap - seriesGap) / columnCount;
                    offset = categoryGap / 2 + width * (columnIndex + 0.5) + seriesGap * 0.5;   // 这里系列堆叠时，不需要均匀分布，因此offset直接使用计算的即可
                    width += seriesGap;
                }

            } else {
                var rangeLength = categoryAxis._getRange();
                rangeLength = Math.abs(rangeLength[1] - rangeLength[0]);

                width = rangeLength/allPointsCount/3;
                offset = 0;
            }
            // 这里缓存一下seriesWidth,方便Axis.adjustDomain4Radius时使用
            this._seriesWidth = BaseUtils.hasDefined(options.width) ? options.width : Math.max(width, MIN_BAR_SIZE);
            return {
                width: this._seriesWidth,
                offset:offset
            }
        },

        _getPointKey: function (point) {
            if(this.isMultiCategoryAxisBased()){
                return BaseUtils.encodeCategoryArray(point.categoryArray);
            }
            return this.type == Constants.BAR_CHART ? point.y : point.x;
        },

        getTargetKey:function(){
            return this.type == Constants.BAR_CHART  ? 'x' : 'y';
        },

        //图形坐在的那个坐标轴的key
        getBaseAxisType: function () {
            return this.type == Constants.COLUMN_CHART ? 'xAxis' : 'yAxis';
        },

        getTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            var points = sery.points;
            var valueAxis = sery.type == Constants.COLUMN_CHART ? sery.yAxis : sery.xAxis;
            var baseAxis = sery.type == Constants.COLUMN_CHART ? sery.xAxis : sery.yAxis;
            var isHorizontal = baseAxis.isHorizontal(), isAxisReversed = valueAxis.isAxisReversed();

            var bars = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                if(!point.isNull && point.rect){
                    bars.push(point.rect);
                }
            }

            bars.sort(function(a, b){
                return isHorizontal ? a.x - b.x : a.y - b.y;
            });

            bars.forEach(function(barShape){
                var x, y;

                if(isHorizontal){
                    x = barShape.x + barShape.width / 2;
                    y = isAxisReversed ? barShape.y + barShape.height : barShape.y;
                }else{
                    x = isAxisReversed ? barShape.x : barShape.x + barShape.width;
                    y = barShape.y + barShape.height/2;
                }

                xValues.push(x);
                yValues.push(y);
            });

            return [xValues, yValues, baseAxis.getPosition()];
        },

        _calculateAnimationInitRect:function(point, isColumn, inverted){

            var key = isColumn ? 'y' : 'x', options = point.options;
            var valueAxis = point.series[key + 'Axis'], value = valueAxis.getAxisValue(options[key], point);
            var startPos = valueAxis.getStartPos(), isPositive = value >= 0;
            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);
            var location, initRect;

            if(showAsColumn){
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.BOTTOM_TO_TOP;
                    initRect = {
                        x:point.rect.x,
                        y:startPos,
                        width:point.rect.width,
                        height:0
                    };
                }else{
                    location = Constants.TOP_TO_BOTTOM;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:point.rect.width,
                        height:0
                    };
                }
            }else{
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.LEFT_TO_RIGHT;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }else{
                    location = Constants.RIGHT_TO_LEFT;
                    initRect = {
                        x:point.rect.x + point.rect.width,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }
            }

            point.location = location; point.initRect = initRect;
        },

        //计算标签的位置
        _calculateLabelPos:function(){
            var series = this;
            series.points.forEach(function(point) {
                if(point.isVisible()){
                    var dataLabels = point.options.dataLabels;
                    if(dataLabels && dataLabels.enabled){
                        point.labelPos = series._calculateAlignLabelPos(point, dataLabels.align);
                    }
                }
            });
        },

        _calculateAlignLabelPos:function(point, align){

            var labelDim = point.labelDim, rect = point.rect, plotBounds = this.vanchart.bounds;
            var plotWidth = plotBounds.width, plotHeight = plotBounds.height;

            var isVertical = point.location == Constants.TOP_TO_BOTTOM || point.location == Constants.BOTTOM_TO_TOP;
            var isPositive = point.location == Constants.BOTTOM_TO_TOP || point.location == Constants.LEFT_TO_RIGHT;
            var centerX = rect.x + rect.width/2, centerY = rect.y + rect.height/2;

            if (!labelDim) {
                return ;
            }

            var x,y;

            switch (align){
                case Constants.CENTER:

                    x = centerX - labelDim.width/2;
                    y = centerY - labelDim.height/2;

                    break;
                case Constants.INSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y + LABEL_GAP : rect.y + rect.height - LABEL_GAP - labelDim.height;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ?  rect.x + rect.width - LABEL_GAP - labelDim.width : rect.x + LABEL_GAP;
                    }

                    break;
                case Constants.OUTSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y - LABEL_GAP - labelDim.height : rect.y + rect.height + LABEL_GAP;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ? rect.x + rect.width + LABEL_GAP : rect.x - LABEL_GAP - labelDim.width;
                    }

                    break;
            }

            return {
                x:x,
                y:y
            }
        },

        /**
         * 计算MoreLabel的起始位置和朝向：@OverRide Series.calcMoreLabelPosition
         * @param  {[type]} point            [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var isColumn = this.type == Constants.COLUMN_CHART, inverted = this.vanchart.isInverted(); 
            var chartBounds = this.vanchart.bounds; 
            var startX = 0, startY = 0, direction = "top"; 
 
            if((isColumn && !inverted) || (!isColumn && inverted)){ 
                startX = point.rect.x + point.rect.width / 2; 
                startY = point.rect.y; 
            } else { 
                startX = point.rect.x + point.rect.width; 
                startY = point.rect.y + point.rect.height / 2; 
                direction = "right"; 
            } 
 
            return { 
                startX: startX + chartBounds.x, 
                startY: startY + chartBounds.y, 
                direction: direction 
            } 
        }
    });


    //view related
    Bar.include({

        _getFixedPos:function(point, divDim){

            var plotBounds = this.vanchart.bounds;
            var x,y, rect = point.rect;
            if(point.initRect.height === 0){
                //柱形图
                x = plotBounds.x + rect.x + rect.width + TOOLTIP_GAP;
                if(point.location == Constants.BOTTOM_TO_TOP){
                    y = plotBounds.y + rect.y;
                }else{
                    y = plotBounds.y + rect.y + rect.height;
                }

            }else{
                //条形图
                y = plotBounds.y + rect.y + rect.height + TOOLTIP_GAP;

                if(point.location == Constants.LEFT_TO_RIGHT){
                    x = plotBounds.x + rect.x + rect.width - divDim.width;
                }else{
                    x = plotBounds.x + rect.x - divDim.width;
                }

            }
            return [x, y];
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        getFillFilter:function(color, p){

            if(BaseUtils.isSupportSVG()){
                var series = this, options = p.options, vanchart = series.vanchart, renderer = vanchart.renderer;

                if(options.image){

                    var imageX, imageY, rect = p.rect;
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            imageX = rect.x;
                            imageY = rect.y + rect.height % options.imageHeight;
                            break;

                        case Constants.TOP_TO_BOTTOM:
                        case Constants.LEFT_TO_RIGHT:
                            imageX = rect.x;
                            imageY = rect.y;
                            break;

                        case Constants.RIGHT_TO_LEFT:
                            imageX = rect.x + rect.width % options.imageWidth;
                            imageY = rect.y;
                            break;
                    }

                    var patterAttr = {
                        'x':imageX, 'y':imageY, 'width':options.imageWidth, 'height':options.imageHeight,'patternUnits':'userSpaceOnUse'
                    };

                    var imageAttr = {
                        'x':0, 'y':0, 'width':options.imageWidth, 'height':options.imageHeight
                    };

                    if(!p.imagePattern){
                        p.imagePattern = renderer.imagePattern(patterAttr, imageAttr, p.options.image);
                    }else{
                        renderer.updateImagePattern( p.imagePattern, patterAttr, imageAttr, p.options.image);
                    }

                    return "url(#" + BaseUtils.stamp(p.imagePattern) +")";

                }else if(vanchart.options.style == Constants.STYLE_GRADUAL){
                    var x1, y1, x2, y2;
                    x1 = y1 = x2 = y2 = '0%';
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            y1 = '100%';
                            break;
                        case Constants.TOP_TO_BOTTOM:
                            y2 = '100%';
                            break;
                        case Constants.LEFT_TO_RIGHT:
                            x2 = '100%';
                            break;
                        case Constants.RIGHT_TO_LEFT:
                            x1 = '100%';
                            break;
                    }

                    var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
                    var stop1 = {'offset':'0%', 'stop-color':color};
                    var stop2 = {'offset':'100%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.9)};

                    if(p.colorGradient){
                        renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                    }else{
                        p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                    }

                    return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
                }
            }

            return color;
        },

        _calculateAnimationDelay:function(){
            if(this.stack){
                return 0;
            }

            return this.updateDelay(EXIT_ANIMATION_TIME);
        },

        _getStackExitPointDropRect:function (point) {
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;

            if(!preP && !sufP) {
                return point.initRect;
            }
            var rect = (preP ? preP : sufP).rect;
            switch (point.location){
                case Constants.BOTTOM_TO_TOP:
                    return {x:rect.x, y:(preP ? rect.y : rect.y + rect.height), width:rect.width, height:0};
                case Constants.TOP_TO_BOTTOM:
                    return {x:rect.x, y:(preP ? rect.y + rect.height : rect.y), width:rect.width, height:0};
                case Constants.LEFT_TO_RIGHT:
                    return {x:(preP ? rect.x + rect.width : rect.x), y:rect.y, width:0, height:rect.height};
                case Constants.RIGHT_TO_LEFT:
                    return {x:(preP ? rect.x : rect.x + rect.width), y:rect.y, width:0, height:rect.height};
            }
        },

        _getStackReShowPointInitRect:function (point) {
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;

            if(!preP && !sufP) {
                return point.initRect;
            }
            var element = (preP ? preP : sufP).graphic.node();
            var x = parseFloat(element.getAttribute("x")), y = parseFloat(element.getAttribute("y")),
                width = parseFloat(element.getAttribute("width")), height = parseFloat(element.getAttribute("height"));
            switch (point.location){
                case Constants.BOTTOM_TO_TOP:
                    return {x:x, y:(preP ? y : y + height), width:width, height:0};
                case Constants.TOP_TO_BOTTOM:
                    return {x:x, y:(preP ? y + height : y), width:width, height:0};
                case Constants.LEFT_TO_RIGHT:
                    return {x:preP ? x + width : x, y:y, width:0, height:height};
                case Constants.RIGHT_TO_LEFT:
                    return {x:preP ? x : x + width, y:y, width:0, height:height};
            }
        },

        getPointInitAttr:function(point){
            return point.initRect;
        },

        getPointReShowAttr:function (point) {
            var series = point.series;
            return series.stack ? series._getStackReShowPointInitRect(point) : point.initRect;
        },

        getPointInitAnimationAttr:function(point){
            return {
                ease:INIT_EASE,
                duration:INIT_ANIMATION_TIME,
                attr:point.rect}
        },

        getPointReShowAnimationAttr:function (point) {
            return point.series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:point.rect
                } : {
                    ease:RE_SHOW_EASE,
                    duration:RE_SHOW_ANIMATION_TIME,
                    attr:point.rect}
        },

        getPointUpdateAnimationAttr:function(point, delay){
            return  point.series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:point.rect
                } : {
                    delay:delay,
                    ease:UPDATE_EASE,
                    duration:UPDATE_ANIMATION_TIME,
                    attr:point.rect}
        },

        getPointDropAnimationAttr:function(point){
            var series = point.series;
            return series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:series._getStackExitPointDropRect(point)
                } : {
                    ease:EXIT_EASE,
                    duration:EXIT_ANIMATION_TIME,
                    attr:point.initRect}
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, style, true);
        },

        _onPointMouseOut:function(point){
            var series = point.series,style = series.getStyle(point);

            series._onState(point, style, false);
        },

        _onState:function (point, style, isChosen) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.OUTSIDE){
                var diffX = 0, diffY = 0;
                if(isChosen) {
                    switch (point.location) {
                        case Constants.BOTTOM_TO_TOP:
                            diffY -= 3;
                            break;
                        case Constants.TOP_TO_BOTTOM:
                            diffY += 3;
                            break;
                        case Constants.LEFT_TO_RIGHT:
                            diffX += 3;
                            break;
                        case Constants.RIGHT_TO_LEFT:
                            diffX -= 3;
                            break;
                    }
                }
                series._labelTransformState(point, diffX, diffY, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            } else {
                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, BezierEasing.css["ease"]);
            }
        },

        effectAnimation:function (point) {

            var options = point.options, series = point.series, vanchart = series.vanchart, renderer = vanchart.renderer;

            if(options.image){
                return;
            }

            var group = series._getPointEffectGroup(point), rect = point.rect;
            var style = {'fill':'none', 'stroke':point.color, 'stroke-opacity': 0, 'stroke-width':0};

            var width = (point.location === Constants.BOTTOM_TO_TOP || point.location === Constants.TOP_TO_BOTTOM) ? rect.width : rect.height;

            function createEffectG() {
                return renderer.rect().addTo(group).attr(rect).style(style);
            }

            function borderWidth(t) {
                return 0.5 * width * t;
            }

            function getPositiveNumber(num) {
                return num < 0 ? 0 : num; 
            }

            function ani(graphic, delay, time) {

                graphic.style(style)
                    .effectTransition()
                    .delay(delay)
                    .ease('linear')
                    .duration(time)
                    .styleTween('stroke-opacity', function(){return function (t) {return 0.8 * (1-t);}})
                    .styleTween('stroke-width', function(){return borderWidth})
                    .attrTween('x',function(){return function(t){return rect.x - borderWidth(t)/2 + 1;}})
                    .attrTween('y',function(){return function(t){return rect.y - borderWidth(t)/2 + 1;}})
                    .attrTween('width',function(){return function(t){ return getPositiveNumber(rect.width + borderWidth(t) - 2); }})
                    .attrTween('height',function(){return function(t){ return getPositiveNumber(rect.height + borderWidth(t) - 2) ;}})
                ;
            }

            var firstG = group.firstG = group.firstG || createEffectG(),
                secondG = group.secondG = group.secondG || createEffectG(),
                thirdG = group.thirdG = group.thirdG || createEffectG();

            var period = series._getEffectTime(point), scale = period/series.getDefaultEffectTime();
            ani(firstG, 0, 1600 * scale);
            ani(secondG, 600 * scale, 1600 * scale);
            ani(thirdG, 1200 * scale, 1600 * scale);
        },

        getDefaultEffectTime:function () {
            return 2800;
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor ,
                'fill':p.series.getFillFilter(p.mouseOverColor, p),
                'fill-opacity': p.opacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        }
    });

    require('../ChartLibrary').register(Constants.BAR_CHART, Bar);
    require('../ChartLibrary').register(Constants.COLUMN_CHART, Bar);

    return Bar;
});
/**
 * Created by Yuqian on 2017/3/20.
 */

// todo, separate chart in a folder is better

define('chart/PieSeries',['require','../utils/BaseUtils','./Series','../utils/PathGenerator','../utils/Interpolator','../Constants','../utils/BezierEasing'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Series = require('./Series');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');
    var HOVER_PERCENT = 1.1;
    var Constants = require('../Constants');
    var Bezier = require('../utils/BezierEasing');

    var LABEL_GAP = 2;
    var DECREASE = [0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5];
    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';
    var STEP = Math.PI / 180;

    return {

        // calculate pie/multiPie label position
        // 3 things: outside labels pos,
        //           inside labels pos,
        //           lead lines;
        //
        // outside labels may adjust the chart's radius
        // 3 steps for outside labels:
        // 1. ignore minimal arc labels to content each part's height (4 parts);
        // 2. place labels, no overlap (regardless of part bounds)
        // 3. (when not fixed) test if all labels' bounds are within this chart's bounds.
        //    if not, decrease the radius, return to step 1.

        /**
         * place outside labels, get new radius if needed
         * @param {Array} outPoints
         * @param {object} bounds
         * @param {Array} center
         * @param {number} [radius]
         * @returns {number} radius Original radius or new radius
         */
        calcOutsideLabel: function (outPoints, bounds, center, radius) {
            var series = this;

            var pointsGroups = {};

            outPoints.map(function (p) {
                var loc = series.getLocByArc(series.getCenterAngle(p));
                pointsGroups[loc] = pointsGroups[loc] || [];
                !p.isNull && pointsGroups[loc].push(p);   // @CHART-1369
            });

            if (radius) {
                pointsGroups = series.ignoreMin(pointsGroups, radius);// step 1
                series.placeOutSideLabels(pointsGroups, radius);// step 2
                return radius;

            } else {
                radius = Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    var usedR = radius * DECREASE[i];
                    var usedPointsG = series.ignoreMin(pointsGroups, usedR);// step 1
                    series.placeOutSideLabels(usedPointsG, usedR);// step 2

                    if (series.testWithinBounds(usedPointsG, center, bounds)) {// step 3
                        break;
                    }
                }
                return usedR;
            }
        },

        calculateInsideLabelBounds:function(inPoints){
            var series = this;
            inPoints.map(function (a,i) {
                var node = inPoints[i];
                var center = series.getCenterPoint(node);

                var x = center[0] - node.labelDim.width/2;
                var y = center[1] - node.labelDim.height/2;

                node.labelPos = {x:x, y:y};
            });
        },

        calculateLeadLineStartPos:function(outPoints){
            var series = this;
            outPoints.map(function(arcPoint){
                var radius = series._getOuterRadius(arcPoint);
                var centerArc = series.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x: (radius + 1) * Math.sin(centerArc),
                        y: (radius + 1) * Math.cos(centerArc + Math.PI)
                    }
                }
            });
        },

        getCenterAngle:function(node){
            var rotate = this.chartInfo.rotate || 0;
            var centerAngle = rotate + (this._getStartAngle(node) + this._getEndAngle(node)) / 2 ;
            return BaseUtils.makeValueInRange(0, 2 * Math.PI, centerAngle);
        },

        getCenterRadius:function (node) {
            var innerRadius = this._getInnerRadius(node),
                outerRadius = this._getOuterRadius(node);
            return innerRadius + (outerRadius - innerRadius) / 2;
        },

        getCenterPoint:function (node) {
            var centerAngle = this.getCenterAngle(node),
                centerR = this.getCenterRadius(node);
            return this._getArcPoint(centerR, centerAngle);
        },

        getLocByArc: function (arc) {
            arc = arc % (2 * Math.PI);
            if(arc < Math.PI / 2){
                return RIGHT_TOP;
            }else if(arc < Math.PI){
                return RIGHT_BOTTOM;
            }else if(arc < 3 * Math.PI / 2){
                return LEFT_BOTTOM;
            }else{
                return LEFT_TOP;
            }
        },

        // ignore min for 4 parts
        ignoreMin: function (pointsGroups, radius) {
            var result = {};
            for (var i in pointsGroups) {
                pointsGroups[i].map(function (p) { p.labelPos = null; });
                result[i] = this._ignoreMinArcLabel(radius, pointsGroups[i]);
            }
            return result;
        },

        // ignore 1 part
        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //高度不够，需要省略一些标签
            if(radius * 1.2 < totalHeight){

                var det = totalHeight - radius * 1.2;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            var series = this;
            arcs.sort(function(a, b){
                return series.getCenterAngle(a) - series.getCenterAngle(b);
            });

            return arcs;
        },

        placeOutSideLabels: function (pointsGroups, radius) {
            var series = this;
            Object.keys(pointsGroups).map(function (key) {
                series.findNiceBounds(true, pointsGroups[key], radius, key) ||
                series.findNiceBounds(false, pointsGroups[key], radius, key)
            });
            // here MUST be true.
            // for we have ignored min arcs, the problem is how to place them.
            // the solution now is incomplete though.
            // return true;
        },

        findNiceBounds:function(isAngleIncrease, arcPoints, usedR, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var angleRange = this._getStartAndEndAngle(location);

            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;

            var preBounds;
            var preArc;

            arcPoints.map(function (p) {
                p.labelPos = null;
            });

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var compare = isAngleIncrease ? Math.max : Math.min;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerArc = this.getCenterAngle(point);

                centerArc = preArc ? compare(centerArc, preArc) : centerArc;

                var found = false;
                for(var arc = centerArc; (isAngleIncrease ? arc < searchEnd : arc > searchEnd); arc += step){

                    var centerX = outerR * Math.sin(arc);
                    var centerY = outerR * Math.cos(arc + Math.PI);

                    var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);
                    if ((preBounds ? !this._isOverlapOrShadow(preBounds, bounds) : true)
                    ) {
                        found = true;
                        preArc = arc;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }

                var midPos = {x:centerX, y:centerY};
                var endPos;
                if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                    endPos = {x:centerX + hWidth, y:centerY};
                }else{
                    endPos = {x:centerX - hWidth, y:centerY};
                }

                preBounds = bounds;
                point.labelPos = {
                    x:bounds.x,
                    y:bounds.y,

                    midPos:midPos,
                    endPos:endPos
                };
            }

            return true;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LABEL_GAP;
            }else{
                x = centerX - hWidth - LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        // 1. judge overlapped
        // 2. the Y pos should not exceed the previous's half
        _isOverlapOrShadow: function (a, b) {
            var topHalfMinY = Math.max(a.y, b.y);
            var topHalfMaxY = Math.min(a.y + a.height / 2, b.y + b.height / 2);
            var bottomHalfMinY = Math.max(a.y + a.height / 2 , b.y + b.height / 2);
            var bottomHalfMaxY = Math.min(a.y + a.height, b.y + b.height);

            return BaseUtils.rectangleOverlapped(a, b) ||
                topHalfMinY <= topHalfMaxY || bottomHalfMinY <= bottomHalfMaxY;
        },

        testWithinBounds: function (pointsGroups, center, wholeBounds) {
            for (var i in pointsGroups) {
                var bounds, x, y, width, height;
                x = y = 0;
                switch (i) {
                    case RIGHT_TOP:
                    case RIGHT_BOTTOM:
                        y = wholeBounds.y - center[1];
                        width = wholeBounds.width + wholeBounds.x - center[0];
                        height = wholeBounds.height;
                        break;
                    case LEFT_BOTTOM:
                    case LEFT_TOP:
                        x = wholeBounds.x - center[0];
                        y = wholeBounds.y - center[1];
                        width = -x;
                        height = wholeBounds.height;
                        break;
                }
                bounds = {x: x, y: y, width: width, height: height};

                for (var j = 0; j < pointsGroups[i].length; j++) {
                    var p = pointsGroups[i][j];
                    if (!p.labelPos) {
                        continue;
                    }
                    var pBounds = {
                        x: p.labelPos.x,
                        y: p.labelPos.y,
                        width: p.labelDim.width,
                        height: p.labelDim.height
                    };
                    if (!BaseUtils.containsRect(bounds, pBounds)) {
                        return false;
                    }
                }
            }
            return true;
        },

        //多层饼图外面层内径也要变在数据点提示共享的情况下
        _changeInnerRadius:function (d) {
            return d.depth > 1 && d.options.tooltip && d.options.tooltip.shared;
        },

        _onPointState:function (d, isChosen, style, attr) {
            var series = this;
            var arc = PathGenerator.arc();
            var startAngle = series._getStartAngle(d), endAngle = series._getEndAngle(d),
                innerRadius = series._getInnerRadius(d), outerRadius = series._getOuterRadius(d);

            var inRadiusScale = series._changeInnerRadius(d) ? HOVER_PERCENT : 1;
            var outStartRadius = outerRadius * HOVER_PERCENT, outEndRadius = outerRadius,
                inStartRadius = innerRadius * inRadiusScale, inEndRadius = innerRadius, duration = 400;
            if(isChosen){
                outStartRadius = outerRadius;outEndRadius = outerRadius * HOVER_PERCENT; duration = 300;
                inStartRadius = innerRadius; inEndRadius = innerRadius * inRadiusScale;
            }
            var outInterpolate = Interpolate(outStartRadius, outEndRadius),
                inInterpolate = Interpolate(inStartRadius, inEndRadius),
                arcData = {startAngle:startAngle, endAngle:endAngle, innerRadius:innerRadius};

            d.graphic.style(style)
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    ease:Bezier.css["ease-out-back"],
                    duration:duration,
                    attr:attr,
                    attrTween:{'d':function(){return function (t) {return arc.outerRadius(outInterpolate(t)).innerRadius(inInterpolate(t))(arcData);};}}
                });
        },

        _onTextState:function (point, isChosen) {
            var series = this;
            if(!point.labelPos){
                return;
            }

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            var trans = series._labelTrans(point);

            var centerAngle = series.getCenterAngle(point);
            if(align == Constants.INSIDE && isChosen) {
                var inRadiusScale = series._changeInnerRadius(point) ? HOVER_PERCENT : 1;//多层饼图外面层内径也要变

                var innerR = series._getInnerRadius(point) * inRadiusScale,
                    outerR = series._getOuterRadius(point) * HOVER_PERCENT,
                    centerR = innerR + (outerR - innerR) / 2;
                trans = series._getArcPoint(centerR, centerAngle);
            } else if(align == Constants.OUTSIDE && isChosen){
                var diffR = series._getOuterRadius(point) * (HOVER_PERCENT - 1),
                    diffP = series._getArcPoint(diffR, centerAngle),
                    diffX = diffP[0], diffY = diffP[1];

                trans = {x:trans.x + diffX, y:trans.y + diffY};
            }

            var duration = isChosen ? 300 : 400, ease = Bezier.css["ease-out-back"];
            var paras = point.textGraphic.type === 'div' ? {duration: duration, ease: ease,
                    style: {'transform': 'translate(' + trans.x + 'px,' + trans.y + 'px)'}} : {duration: duration, ease: ease,
                    attr: {'transform': BaseUtils.makeTranslate(trans)}};

            point.textGraphic && point.textGraphic.animate(paras);

            if(align == Constants.OUTSIDE) {
                series._outSideLabelColorState(point, isChosen, duration, ease);
                series._leadLineState(point, diffX, diffY, isChosen, duration, ease);
            }
        },


        _getInnerRadius: function (d) {
            return d.innerRadius;
        },

        _getOuterRadius: function (d) {
            return d.outerRadius;
        },

        _getStartAngle: function (d) {
            return d.startAngle;
        },

        _getEndAngle: function (d) {
            return d.endAngle;
        },

        _getPositionInPie:function(absPos){

            var x = absPos.x - this.chartInfo.centerX;

            var y = absPos.y - this.chartInfo.centerY;

            return {x:x, y:y};
        },

        _isRotatable:function(){
            return BaseUtils.isSupportSVG() && this.options.rotatable;
        },

        onPanStart:function(ev){
            if(!this._isRotatable()){
                return;
            }

            this.initPos = ev.containerPoint;

            this.initRotate = BaseUtils.toDegree(this.chartInfo.rotate);
        },

        onPanMove:function(ev){
            if(!this._isRotatable()){
                return;
            }

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos));

            var newAngle = this._getAngle(this._getPositionInPie(ev.containerPoint));

            var rotate = newAngle - startAngle + this.initRotate;

            this._getPointGraphicGroup().attr("transform", "rotate(" + rotate + ")");

            this.chartInfo.rotate = BaseUtils.toRadian(rotate);

            this._calculateLabelPosWhenRadiusFixed();

            this._rotateLabels();
        },

        onPanEnd:function(ev){
            this.vanchart.handler.panTarget = null;
        },

        getEvents:function(){
            return BaseUtils.extend(Series.prototype.getEvents.call(this),
                {
                    'panstart':this.onPanStart,
                    'panmove':this.onPanMove,
                    'panend':this.onPanEnd
                });
        },

        _rotateLabels:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = this.textLabelGroup;
            series.getDataToDraw().forEach(function(point){

                if(point.textGraphic && !point.labelPos){
                    point.textGraphic.remove();
                    point.leadLine && point.leadLine.remove();
                    point.textGraphic = null, point.leadLine = null;
                }else if(point.textGraphic && point.labelPos){

                    point.textGraphic
                        .interrupt(Constants.SELECT_ANIMATION)
                        .attr('transform', BaseUtils.makeTranslate(series._labelTrans(point)));

                    if(point.labelPos.startPos){
                        if(point.leadLine){
                            point.leadLine.attr('d', series._getLeadLinePath(point));
                        }else{
                            point.leadLine = series._getLeadLine(point);
                        }
                    }
                }else if(!point.textGraphic && point.labelPos){
                    series._createTextGraphic(point);
                }
            });
        }
    }
});

/**
 * Created by shine on 2016/12/19.
 */
define('EffectHelper',['require','./utils/BaseUtils','./utils/PathGenerator','./utils/BezierEasing','./vector/Transition','./vector/shape/Path','./vector/shape/LayerGroup','./dom/Browser'],function(require) {
    var BaseUtils = require('./utils/BaseUtils');
    var PathGenerator = require('./utils/PathGenerator');
    var BezierEasing = require('./utils/BezierEasing');
    var Transition = require('./vector/Transition');
    var Path = require('./vector/shape/Path');
    var LayerGroup = require('./vector/shape/LayerGroup');
    var Browser = require("./dom/Browser");

    var PATH = 'M-56,0a56,16 0 1,0 112,0a56,16 0 1,0 -112,0';

    function pointMapEffectAnimation(layer, d) {
        var series = d.series, vanchart = series.vanchart;

        var period = series._getEffectTime(d);

        var getPosition = function (){
            var latlng = d.getLatLng(), pixels = latlng && vanchart.latLngToLayerPoint(latlng) || {x:0, y:0};
            return {
                x: pixels.x,
                y: pixels.y
            }
        };
        function bottom_to_top() {
            var pos = getPosition();   // 这边动画的位置，每次都重新算吧，不然缩放的时候，动画用的位置还是上次的，就可能导致闪烁
            return function (t) {
                return BaseUtils.makeTranslate3d({x:pos.x, y:pos.y - 25 * t});
            }
        }

        function top_to_bottom() {
            var pos = getPosition();
            return function (t) {
                return BaseUtils.makeTranslate3d({x:pos.x, y:pos.y - 25 * (1-t)});
            }
        }


        //todo:node element ?
        new Transition({node:function () {return layer._icon;}}, "point-map-effect")
        // .interrupt("point-map-effect")
            .ease(BezierEasing.css["ease-out-quint"])
            .duration(0.25 * period)
            .styleTween('transform', bottom_to_top)
            .transition()
            .ease(BezierEasing.css["ease-in-quint"])
            .duration(0.25 * period)
            .styleTween('transform', top_to_bottom)
            .transition()
            .ease(BezierEasing.css["ease-out-quint"])
            .duration(0.25 * period)
            .styleTween('transform', bottom_to_top)
            .transition()
            .ease(BezierEasing.css["ease-in-quint"])
            .duration(0.25 * period)
            .styleTween('transform', top_to_bottom);

        var initStyle = {'fill-opacity': 0, 'fill': d.color};

        var layerGroup = d.effectGraphic = d.effectGraphic || new LayerGroup().addTo(vanchart.getEffectLayer());

        function createEffectG() {
            return new Path().addTo(layerGroup)._path.style(initStyle).attr('d', PATH);
        }

        var iconSize = d.options.icon.iconSize, initScale = iconSize[0]/90;//90的原因，path是根据宽为90的图标画的

        var pos = getPosition();
        var trans = BaseUtils.makeTranslate({x: pos.x, y: pos.y}),
            initTrans = trans + ' scale(' + initScale + ')';

        function ani(graphic, delay, time) {
            graphic.style(initStyle).attr('transform', initTrans);

            graphic
                .effectTransition()
                .delay(delay)
                .ease('linear')
                .duration(time)
                .attrTween('transform', function () {
                    return function (t) {
                        return trans + 'scale(' + (initScale + initScale*1.4*t) + ')';
                    }
                })
                .styleTween('fill-opacity', function () {
                    return function (t) {
                        return 0.6 * (1-t);
                    }
                })
        }

        var firstG = layerGroup.firstG = layerGroup.firstG || createEffectG(),
            secondG = layerGroup.secondG = layerGroup.secondG || createEffectG(),
            thirdG = layerGroup.thirdG = layerGroup.thirdG || createEffectG();

        var scale = period / series.getDefaultEffectTime();
        ani(firstG, 0, 2000 * scale);
        ani(secondG, 600 * scale, 2000 * scale);
        ani(thirdG, 1200 * scale, 2000 * scale);

    }

    //区域类型的，漏斗、饼、矩形树图
    function areaStyleEffectAnimation(d, transX, transY) {
        var paras = _calculateParas(d, transX, transY);

        d.graphic
            .attr('transform-origin', 'center')
            .effectTransition()
            .ease(BezierEasing.css["ease-out-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.firstTweenFun)
            .attr('transform', paras.translate + 'scale(1.05)')
            .transition()
            .ease(BezierEasing.css["ease-in-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.secondTweenFun)
            .attr('transform', paras.translate + 'scale(1)')
    }

    function areaMapEffectAnimation(layer, d) {
        var paras = _calculateParas(d);

        layer._path
            .style("filter", null)  // 默认的style['filter']= "none"会导致阴影显示不出
            .effectTransition()
            .ease(BezierEasing.css["ease-out-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.firstTweenFun)
            .attr("fill-opacity", 1)   // 也不是webkit才支持attr:,而是只有chrome和opera支持，见https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
            .transition()
            .ease(BezierEasing.css["ease-in-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.secondTweenFun)
            .attr("fill-opacity", 0)
    }

    function _calculateParas(d, transX, transY) {
        var series = d.series, vanchart = series.vanchart, renderer = vanchart.renderer;

        d.effectShadowFilter = d.effectShadowFilter || renderer.createDropShadowFilter(3, 3, 0.75, 5, 91/255, 91/255, 91/255);
        var filterID = 'url(#' + BaseUtils.stamp(d.effectShadowFilter) + ')';
        var period = series._getEffectTime(d);

        var translate = (isNaN(transX) || isNaN(transY)) ? '' : BaseUtils.makeTranslate({x:transX, y:transY})

        function firstTweenFun() {
            return function (t) {
                renderer.updateDropShadowFilter &&
                renderer.updateDropShadowFilter(d.effectShadowFilter, 3 * t, 3 * t, t * 0.75, t * 5, 91/255, 91/255, 91/255);
                return filterID;
            }
        }

        function secondTweenFun() {
            return function (t) {
                renderer.updateDropShadowFilter &&
                renderer.updateDropShadowFilter(d.effectShadowFilter, 3 * (1-t), 3 * (1-t), (1-t) * 0.75, (1-t) * 5, 91/255, 91/255, 91/255);
                return filterID;
            }
        }

        return {
            period:period,
            translate:translate,
            firstTweenFun:firstTweenFun,
            secondTweenFun:secondTweenFun
        }
    }

    function bubbleEffectAnimation(d, isMap) {
        forceBubbleEffectAnimation(d, null, isMap);
    }

    function forceBubbleEffectAnimation(d, trans, isMap) {
        var style = {'fill-opacity': 0, 'stroke':'none', 'fill': d.color};

        var arc = PathGenerator.arc().innerRadius(d.radius).startAngle(0).endAngle(360);

        function path(t) {
            return arc({outerRadius:d.radius + t * d.radius * 1.5})
        }

        _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style, 'pathFun':path, 'trans':trans});
    }

    function markerEffectAnimation(d, isMap) {
        var marker = d.options.marker;

        if(marker && marker.symbol){
            var markerType = marker.symbol, radius = marker.radius;

            if (BaseUtils.isImageMarker(markerType)){
                return;
            }

            var style = {'fill':'none', 'stroke':marker.fillColor, 'stroke-width':0, 'stroke-opacity':0};

            function borderWidth(t) {
                return t * radius * 2.5;
            }

            function path(t) {
                return PathGenerator.getMarkerPath(markerType, radius + borderWidth(t)/2 - 1);
            }

            _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style,
                'opacityKey':'stroke-opacity', 'pathFun':path, 'borderFun':borderWidth});

        } else {
            _nullMarkerEffectAnimation(d, isMap);
        }
    }

    function _nullMarkerEffectAnimation(d, isMap) {
        var marker = d.options.marker, radius = marker.radius;

        var style = {'fill-opacity': 0, 'stroke':'none', 'fill': marker.fillColor};

        var arc = PathGenerator.arc().innerRadius(0).startAngle(0).endAngle(360);

        function path(t) {
            return arc({outerRadius: t * radius * 3.5})
        }

        _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style, 'pathFun':path});
    }

    //折线、气泡、散点等
    function _markerStyleAnimation(d, options) {
        var series = d.series, vanchart = series.vanchart, renderer = vanchart.renderer;
        var initStyle = options.initStyle, trans = options.trans || {x:d.posX, y:d.posY};

        var group, createEffectGFun;
        if(options.isMap) {
            var latlng = d.getLatLng(), pixels = vanchart.latLngToLayerPoint(latlng);
            trans = pixels;
            group = d.effectGraphic = d.effectGraphic || new LayerGroup().addTo(vanchart.getEffectLayer());

            createEffectGFun = function createEffectG() {
                return new Path().addTo(group)._path.style(initStyle)
                    .attr('transform', BaseUtils.makeTranslate(trans));
            }
        } else {
            group = series._getPointEffectGroup(d)
                .attr('transform', BaseUtils.makeTranslate(trans));
            createEffectGFun = function createEffectG() {
                return renderer.path().addTo(group).style(initStyle);
            }
        }

        function ani(graphic, delay, time) {
            graphic
                .style(initStyle)
                .effectTransition()
                .delay(delay)
                .ease('linear')
                .duration(time)
                .styleTween('stroke-width', function () {
                    return options.borderFun;
                })
                .styleTween(options.opacityKey || 'fill-opacity', function () {
                    return function (t) {
                        return 0.3 * (1-t);
                    }
                })
                .attrTween('d', function () {
                    return options.pathFun;
                })
        }

        var firstG = group.firstG = group.firstG || createEffectGFun(),
            secondG = group.secondG = group.secondG || createEffectGFun(),
            thirdG = group.thirdG = group.thirdG || createEffectGFun();

        var period = series._getEffectTime(d), scale = period / series.getDefaultEffectTime();
        ani(firstG, 0, 1600 * scale);
        ani(secondG, 440 * scale, 1600 * scale);
        ani(thirdG, 880 * scale, 1600 * scale);
    }

    return {
        MARKER_EFFECT_TIME:2560,
        markerEffectAnimation:markerEffectAnimation,
        bubbleEffectAnimation:bubbleEffectAnimation,
        AREA_STYLE_EFFECT_TIME:2000,
        areaStyleEffectAnimation:areaStyleEffectAnimation,
        areaMapEffectAnimation:areaMapEffectAnimation,
        POINT_MAP_EFFECT_TIME:3200,
        pointMapEffectAnimation:pointMapEffectAnimation,
        forceBubbleEffectAnimation:forceBubbleEffectAnimation
    };
});
/**
 * Created by eason on 15/7/13.
 */

define('chart/Pie',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','./Series','./PieSeries','../utils/BoundsManager','../utils/BezierEasing','../EffectHelper','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Series = require('./Series');
    var PieSeries = require('./PieSeries');
    var BoundsManager = require('../utils/BoundsManager');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');

    var CIRCLE = 2 * Math.PI;
    var HOVER_PERCENT = 1.1;
    var MAGIC_DET = 3;//很奇怪的3px
    
    var ANIMATION_TIME = 1000;
    var EASE = 'bounce';

    var SORT_EASE = Bezier.css.swing;
    var SORT_TIME = 400;

    var Pie = Series.extend({

        _getAxisTypes:function(){
            return [];
        },

        doLayout:function(){

            //计算整个圆的位置和大小
            var seriesBounds = this._calculateSeriesBounds(), pie = this;
            if(!seriesBounds && (!this.options.radius && !this.options.center)){
                throw new Error('pie has no bounds');
            }
            var centerX, centerY, radius;
            if(seriesBounds){
                radius = this.options.radius || Math.min(seriesBounds.width/2, seriesBounds.height/2);
                centerX = seriesBounds.x + seriesBounds.width/2;
                centerY = seriesBounds.y + seriesBounds.height/2;
                this.bounds = seriesBounds;
            }else{
                radius = this.options.radius;
                centerX = this._getPercentValue(this.options.center[0], this.vanchart.width);
                centerY = this._getPercentValue(this.options.center[1], this.vanchart.height);
            }
            var rotate = this.chartInfo && this.chartInfo.rotate || 0;
            this.chartInfo = {radius:radius, centerX:centerX, centerY:centerY, rotate:rotate};

            //计算每个扇形的大小
            var pieLayout = PieLayout()
                .value(function(d){
                    return pie.options.roseType == Constants.SAME_ARC ? 1 : Math.abs(d.getTargetValue());
                })
                .startAngle(pie.startAngle).endAngle(pie.endAngle);

            var points = this.points.filter(function(p){return p.isVisible()});
            var series = this;

            points.forEach(function(point){
                point.lastShape = series._getArcData(point);
            });

            pieLayout(points);
        },

        _getFixedPos:function(datum, divDim){

            var plotBounds = this.vanchart.bounds;

            var pieConfig = datum.series.chartInfo;

            var translateX = pieConfig.centerX;
            var translateY = pieConfig.centerY;

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.outerRadius * HOVER_PERCENT;

            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },

        // 12345，我们数一数：到底有多少种radius？
        // chartInfo.radius - 计算结果，来源：
        // 1. options.radius: 定义radius, 用户要什么给什么，省心省力；
        //    据此判断是否需要计算调整
        // 2. bounds/2 : 未定义radius，平分剩余区域
        // 3. chartInfo.seriesMinRadius: 多个系列自动计算取最小的radius (CHART-947)

        _calculateLabelPos:function(){
            var roseType = this.options.roseType, points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.options.dataLabels;
                if(point.visible && dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            //这步会改变半径
            this._calculateOutsideLabelBounds(outPoints);

            if (!this.options.radius) {
                //有标签在里面,没有标签在外面或者不显示标签
                if ((inPoints.length && !outPoints.length) || (!inPoints.length && !outPoints.length)) {
                    this.chartInfo.radius = this.chartInfo.radius / HOVER_PERCENT - MAGIC_DET;
                }
            }


            //内径可能是半径的占比
            var innerRadius = this.options.innerRadius, radius = this.chartInfo.radius;
            if(innerRadius){
                if(typeof innerRadius == 'string' && innerRadius.indexOf('%') != -1){
                    innerRadius = parseFloat(innerRadius) * radius / 100;
                }else{
                    innerRadius = parseFloat(innerRadius);
                }
            }

            this.chartInfo.innerRadius = innerRadius;

            this.points.forEach(function(d){
                d.innerRadius = innerRadius;
            });

            //玫瑰图根据最后的半径值来确定不同扇形的半径
            if(roseType){
                var radiusGap = radius - innerRadius;
                var maxValue = 0;
                points.forEach(function(d){
                    maxValue = Math.max(maxValue, Math.abs(d.getTargetValue()));
                });
                var sizePerValue = radiusGap / maxValue;
                //maxValue为0之类的情况
                if(isNaN(sizePerValue) || !isFinite(sizePerValue)){
                    sizePerValue = 0;
                }
                points.forEach(function(d){
                    d.outerRadius = innerRadius + sizePerValue * Math.abs(d.getTargetValue());
                })
            }else{
                this.points.forEach(function(d){d.outerRadius = radius;});//inVisible也要给最新的out，动画需要
            }

            this.calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this.calculateInsideLabelBounds(inPoints);
        },

        // in fact, seriesMinRadius is like a flag
        // chartInfo.radius is the value key
        // see _calculateOutsideLabelBounds
        adjustRadius: function (radius) {
            if (this.chartInfo.radius !== radius) {
                this.chartInfo.seriesMinRadius = radius;
                this.chartInfo.radius = radius;
                this._calculateLabelPos();
            }
        },

        _calculateLabelPosWhenRadiusFixed:function(){
            var points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            this._calculateLabelBoundsForFixed([this.chartInfo.centerX, this.chartInfo.centerY], this.chartInfo.radius, outPoints);

            this.calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this.calculateInsideLabelBounds(inPoints);
        },

        _calculateOutsideLabelBounds:function(outPoints){
            if(!outPoints.length){
                return ;
            }

            var configRadius = this.options.radius || this.chartInfo.seriesMinRadius;

            //清空计算结果
            outPoints.forEach(function(arc){arc.labelPos = null;});

            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            if(!configRadius){
                this.chartInfo.radius = this.calcOutsideLabel(outPoints, this.bounds, center);
            }else{
                this.calcOutsideLabel(outPoints, this.bounds, center, radius);
            }

        },

        //对于固定半径和圆心,计算牵引线的位置
        _calculateLabelBoundsForFixed:function(center, radius, outPoints){
            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            this.calcOutsideLabel(outPoints, this.bounds, center, radius);
        },

        //计算每个系列的边界,要么定义了圆心和半径,作为悬浮元素处理,要么两者都不定义,自定平分区域
        //只定义半径没定义圆心,或者只定义了圆心没有定义半径,效果都是未知的
        _calculateSeriesBounds:function(){
            var series = this.vanchart.seriesOfType(Constants.PIE_CHART);
            var plotBounds = this.vanchart.bounds;
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].options.center && series[i].options.radius){
                    fixedSize++;
                }
            }

            //平均半径
            var averageSize = plotBounds.width / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.options.center){
                        return {
                            x:plotBounds.x + i * averageSize,
                            y:plotBounds.y,
                            width:averageSize,
                            height:plotBounds.height
                        }
                    }
                }
            }
        },

        _getTranslate:function(){
            return [this.chartInfo.centerX, this.chartInfo.centerY];
        },

        _getArcData:function(d){
            if(BaseUtils.hasDefined(d.startAngle)){
                return {
                    startAngle: d.startAngle,
                    endAngle: d.endAngle,
                    outerRadius:d.outerRadius,
                    innerRadius:d.series.chartInfo.innerRadius
                };
            }
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point  [description]
         * @param  {[type]} divDim [description]
         * @return {[type]}        [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var pieConfig = point.series.chartInfo; 
 
            var translateX = pieConfig.centerX; 
            var translateY = pieConfig.centerY; 
 
            var centerAngle = this.getCenterAngle(point); 
            var tmpR = point.series.chartInfo.innerRadius + (point.outerRadius - point.series.chartInfo.innerRadius) / 2; 
            var pos = this._getArcPoint(tmpR, centerAngle); 
 
            return { 
                startX: translateX + pos[0], 
                startY: translateY + pos[1], 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getHighLightStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.mouseOverColor || p.color, p),
                'fill-opacity': p.opacity,
                'stroke': p.borderColor || p.mouseOverColor || p.color,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity': p.borderOpacity
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke': p.borderColor || p.mouseOverColor || p.color,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity': p.borderOpacity
            }
        },

        getAttrs:function(p){
            var arc = PathGenerator.arc().innerRadius(p.innerRadius);
            return {'d':arc(this._getArcData(p))};
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _calculateAnimationDelay:function(){

            var visiblePoint = 0, graphicCount = 0;
            for(var i = 0, len = this.points.length; i < len; i++){
                var point = this.points[i];
                if(point.visible && point.series.visible){
                    visiblePoint++;
                }

                if(point.graphic){
                    graphicCount++;
                }
            }

            return graphicCount == visiblePoint ? 0 : 1;
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series;

            var arc = PathGenerator.arc();

            return {
                ease:series.initialAnimationMoving ? Bezier.css["ease-out-cubic"] : EASE,
                duration:ANIMATION_TIME,
                attrTween:{'d':function(){
                    var currentArc;

                    if(series.initialAnimationMoving) {
                        currentArc = {startAngle: point.startAngle - CIRCLE, endAngle: point.endAngle - CIRCLE, outerRadius:0, innerRadius:0};
                    } else {
                        var prePoint = series.getPreVisiblePoint(point);
                        if(prePoint == 'first'){
                            currentArc = {startAngle: series.startAngle, endAngle: series.startAngle, outerRadius:point.outerRadius};
                        } else if(prePoint.lastShape){
                            var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                            var sliceStart = point.startAngle + preGap;
                            currentArc = {startAngle: sliceStart, endAngle: sliceStart, outerRadius: point.outerRadius};
                        } else {
                            currentArc = {startAngle: point.startAngle, endAngle: point.endAngle, outerRadius: point.outerRadius, innerRadius: point.innerRadius};
                        }
                    }

                    var interpolate = Interpolate(currentArc, series._getArcData(point));
                    this._current_ = interpolate(1);

                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            }
        },

        getPointUpdateAnimationAttr:function(point, delay){
            var series = point.series, vanchart = series.vanchart;
            var arc = PathGenerator.arc();
            var easeFunc = EASE, animationTime = ANIMATION_TIME;
            if(vanchart.orderType === Constants.DESCENDING || vanchart.orderType == Constants.ASCENDING){//排序的动画
                easeFunc = SORT_EASE; animationTime = SORT_TIME;
            }
            return {
                ease:easeFunc,
                duration:animationTime,
                attrTween:{'d':function(){
                    var arcData = series._getArcData(point), currentArc = this._current_ || arcData;
                    var interpolate = Interpolate(currentArc, arcData);
                    this._current_ = interpolate(1);
                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            }
        },

        getPointDropAnimationAttr:function(point){
            var series = point.series, options = series.options, startAngle = series.startAngle;
            var arc = PathGenerator.arc();

            return {
                ease:EASE,
                duration:ANIMATION_TIME,
                attrTween:{'d': function(){
                    var current = this._current_;

                    var prePoint = series.getPreVisiblePoint(point);

                    var terminateAngle = startAngle;

                    if(prePoint != 'first' && prePoint.lastShape){
                        var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                        terminateAngle = point.startAngle + preGap;
                    }

                    var end = series._getArcData(point);
                    end.startAngle = end.endAngle = terminateAngle;

                    var interpolate = Interpolate(current , end);
                    this._current_ = interpolate(1);    
                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            };
        },

        getPreVisiblePoint:function(point){
            var points = point.series.points, prePoint = 'first';
            for(var i = 0, len = points.length; i < len; i++){
                if(points[i] != point){
                    if(points[i].visible){
                        prePoint = points[i];
                    }
                }else{
                    return prePoint;
                }
            }
            return prePoint;
        },

        getFillFilter:function(color, p){
            var series = this, options = series.vanchart.options;
            if(options.style == Constants.STYLE_GRADUAL && BaseUtils.isSupportSVG()){

                var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

                var attrs = {'cx':"0%", 'cy':"0%", 'r':Math.max(p.outerRadius, 0) + 'px', "gradientUnits":"userSpaceOnUse"};
                var stop1 = {'offset':(p.innerRadius / Math.max(p.outerRadius, 1)) * 100 + '%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.8)};
                var stop2 = {'offset':'100%', 'stop-color':color};

                if(p.colorGradient){
                    renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                }else{
                    p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2], 'radialGradient');
                }

                return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
            }

            return color;
        },

        _onPointMouseOver:function(point){
            this._onState(point, true);
        },

        _onPointMouseOut:function(point){
            this._onState(point, false);
        },

        _onState:function(point, isChosen){
            var series = this;
            var style = isChosen ? series.getHighLightStyle(point) : series.getStyle(point);
            series._onPointState(point, isChosen, style);

            series._onTextState(point, isChosen)
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.vanchart.renderer.group().addTo(this.group);
            }
            return this.pathGroup;
        },

        _getPointTextLabelGroup:function(){

            if(!this.textLabelGroup){
                this.textLabelGroup = this.vanchart.renderer.vgroup().add();
                this.group.append(this.textLabelGroup.renderG);
            }
            this.textLabelGroup.divG.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));

            return this.textLabelGroup;
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    function PieLayout(){
        var value = Number, startAngle = 0, endAngle = 2 * Math.PI, sum = 0;

        function pie(points) {
            var values = points.map(function(point, i) {
                var v = +value.call(pie, point, i);
                sum += v;
                return v;
            });
            var a = startAngle, da = endAngle - a, k = da / sum;
            points.forEach(function(point, i) {
                point.startAngle = isNaN(a) ? 0 : a;
                point.endAngle = (a += isNaN(values[i] * k) ? 0 : values[i] * k);   // 这里k可能为Infinity，从而导致startAngle和endAngle为NaN
            });
        }

        pie.value = function(_) {
            if (!arguments.length) {
                return value;
            }
            value = _;
            return pie;
        };

        pie.startAngle = function(_) {
            if (!arguments.length) {
                return startAngle;
            }
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) {
                return endAngle;
            }
            endAngle = _;
            return pie;
        };

        return pie;
    }

    Pie.include(PieSeries);

    require('../ChartLibrary').register(Constants.PIE_CHART, Pie);

    return Pie;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Line',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Series','../utils/Class','../utils/BezierEasing','../utils/ColorUtils','../dom/DomUtils','../EffectHelper','../utils/PathGenerator','../ChartLibrary','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Series = require('./Series');
    var Class = require('../utils/Class');
    var Bezier = require('../utils/BezierEasing');
    var ColorUtils = require('../utils/ColorUtils');
    var DomUtils = require('../dom/DomUtils');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');

    var LABEL_GAP = 2;

    var LINE_SHOW_TIME = 1200;
    var LINE_SHOW_EASE = Bezier.css['ease-out-cubic'];

    var LINE_UPDATE_TIME = 250;

    var CHOSEN_AREA_ADD_ALPHA = 0.35;

    var UPDATE_EASE = Bezier.css.swing;

    //for ease-out-cubic
    var calculateT = function(point){
        var det = point.indexFromLeft / (point.series.points.length - 1) || 0; //考虑系列下只有一个点的情况
        return LINE_SHOW_TIME * Bezier.calculateCubicOutT(det);
    };

    var isValidNumber = function (num){
        return isFinite(num) && !isNaN(num);
    };

    var Line = Series.extend({

        doLayout:function(){

            var series = this, vanchart = series.vanchart, options;

            var xAxis = series.xAxis, yAxis = series.yAxis, connectNulls = series.options.connectNulls;
            var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand()/2 : 0;
            var inverted = vanchart.isInverted(), orderKey = inverted ? 'posY' : 'posX';
            var startValue = yAxis.getStartPosValue();

            var validPoints = [];
            if(this.options.large){
                var xMap = {}, yMap = {};
                series.points.forEach(function(point){
                    options = point.options;
                    var x = xAxis.scale(xAxis.getAxisValue(options.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(options.y, point) + options.y0 - startValue), y0 = yAxis.scale(options.y0);
                    
                    // todo 对数值轴的时候，取0计算出Infinity，导致折线中断，后面正常的point连不起来。
                    if(!isValidNumber(y)) {
                        point.isNull = true;
                    }

                    if (inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posX0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                    if(!xMap[parseInt(point.posX)] || !yMap[parseInt(point.posY)]){
                        xMap[parseInt(point.posX)] = true;
                        yMap[parseInt(point.posY)] = true;
                        validPoints.push(point);
                    }
                }, this);
            }else{
                validPoints = series.points;
            }

            //大数据折线图的points为每个像素点只有一个标记点
            series.points = validPoints;

            var inOrder = true, points = [];

            //计算系列最值,面积图渐变时用得到
            series.y0 = Number.MAX_VALUE;  series.y = -Number.MAX_VALUE;

            validPoints.forEach(function(point, i){

                options = point.options;

                if(this.options.large){
                    x = point.posX; y = point.posY;
                }else{
                    var x = xAxis.scale(xAxis.getAxisValue(options.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(options.y, point) + options.y0  - startValue), y0 = yAxis.scale(options.y0);

                    if(!isValidNumber(y)) {
                        point.isNull = true;
                    }

                    if (inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posX0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                }

                point.indexFromLeft = i;//用来计算delay

                if(!connectNulls || (connectNulls && !point.isNull)){
                    if(points.length > 0){
                        inOrder = inOrder && points[points.length - 1][orderKey] <= x;
                    }
                    points.push(point);
                }

                if (Math.abs(options.y0) < Math.abs(series.y0)){
                    series.y0 = Math.abs(options.y0);
                }
                if (Math.abs(options.y + options.y0) > series.y){
                    series.y = Math.abs(options.y + options.y0);
                }

            }, this);

            if(!inOrder){
                points.sort(function(p1, p2){return p1[orderKey] - p2[orderKey];});
                points.forEach(function(point, i){
                    point.indexFromLeft = i;
                });
            }

            var lineGenerator = PathGenerator.line().interpolate(series.interpolate)
                .x(function (d) {return d.posX;}).y(function (d) {return d.posY;})
                .defined(function (d) {return !d.isNull;});

            var areaGenerator =  PathGenerator.area().interpolate(series.interpolate);
            if (inverted) {
                areaGenerator = areaGenerator
                    .y(function (d) { return d.posY })
                    .x0(function (d) {
                        var pre = series._getPreviousStackingPoint(d);
                        return pre ? pre.posX : d.posX0;
                    })
                    .x1(function (d) { return d.posX })
            } else {
                areaGenerator = areaGenerator
                    .x(function (d) { return d.posX })
                    .y0(function (d) {
                        var pre = series._getPreviousStackingPoint(d);
                        return pre ? pre.posY : d.posY0;
                    })
                    .y1(function (d) { return d.posY })
            }

            areaGenerator = areaGenerator.defined(function (d) {return !d.isNull;});

            this.linePath = lineGenerator(points); this.areaPath = areaGenerator(points);

            this.dataBands = this._calculateDataBands();
        },

        _getPreviousStackingPoint:function(point){

            if(BaseUtils.hasDefined(point.series.stack)){
                var points = point.points;
                for(var i = 0, len = points.length; i < len; i++){
                    var preSeries = points[i].series;
                    if(preSeries.stack == point.series.stack && preSeries.visible && points[i + 1] == point){
                        return points[i];
                    }
                }
            }

        },

        _calculateDataBands:function(){
            var plotBounds = this.vanchart.bounds, series = this, bands = this.options.bands || [];
            var dColor = series.color, dOpacity = series.opacity;
            var dFillColor = series.fillColor, dFillColorOpacity = series.fillColorOpacity;
            var yAxis = series.yAxis, domain = yAxis.scale.domain(), isHorizontal = yAxis.isHorizontal();
            var width = plotBounds.width, height = plotBounds.height;

            var resultRanges = [];

            var isLineChart = this.type === Constants.LINE_CHART;
            var isInverted  = this.vanchart.isInverted();
            var left = 0,
                right = width,
                top = 0,
                bottom = height,
                positionPoints,
                len;
            // 面积图不用考虑以点的范围来做裁剪
            if(isLineChart){
                // 坐标系反转按Y轴坐标计算
                if(isInverted){
                    positionPoints = series.points.sort(function (p1, p2){
                        return p1.posY - p2.posY;
                    }), len = positionPoints.length;
                    left = 0;
                    right = width;
                    top = positionPoints[0] ? positionPoints[0].posY - 1 : 0;
                    bottom = positionPoints[len - 1] ? positionPoints[len - 1].posY + 1 : width;
                } else {
                    // 正常坐标系按X轴坐标计算
                    positionPoints = series.points.sort(function (p1, p2){
                        return p1.posX - p2.posX;
                    }), len = positionPoints.length;

                    left = positionPoints[0] ? positionPoints[0].posX - 1 : 0;
                    right = positionPoints[len - 1] ? positionPoints[len - 1].posX + 1 : width;
                    top = 0;
                    bottom = height;
                }
            }

            resultRanges.push({
                clipBounds:{x:left, y:top, width:right - left, height:bottom - top},
                color:dColor, fillColor:dFillColor, fillColorOpacity:dFillColorOpacity
            });

            if(!bands || !bands.length){
                return resultRanges;
            }

            for(var i = 0, len = bands.length; i < len; i++){
                var from = Math.max(domain[0], bands[i].from);
                var to = Math.min(domain[1], bands[i].to);

                from = yAxis.scale(from); to = yAxis.scale(to);

                var clipBounds = {x:0, y:Math.min(from, to), width: width, height: Math.abs(from - to)};

                if(isHorizontal){
                    clipBounds = {x:Math.min(from, to), y:0, width:Math.abs(from - to), height:height};
                }

                resultRanges.push({
                    clipBounds:clipBounds,
                    color:bands[i].color || dColor,
                    opacity:bands[i].opacity || dOpacity,
                    fillColor:bands[i].fillColor || dFillColor,
                    fillColorOpacity:bands[i].fillColorOpacity || dFillColorOpacity
                });
            }

            return resultRanges;
        },

        _getFixedPos:function(datum){

            var radius = datum.options.marker.radius || 4.5;

            var plotBounds = this.vanchart.bounds;

            var x = plotBounds.x + datum.posX + radius;
            var y = plotBounds.y + datum.posY + radius;

            return [x, y];
        },

        //计算点的位置的时候就能确定标签的位置
        _calculateLabelPos:function(){

            var series = this, isInverted = this.vanchart.isInverted(), count = series.points.length;
            var plotBounds = this.vanchart.bounds;

            series.points.forEach(function(point, i){
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    var x, y;
                    var alignTop = dataLabels.align == Constants.TOP, labelDim = point.labelDim;
                    var gap = LABEL_GAP;

                    if(!labelDim){
                        return
                    }
                    
                    var marker = point.options.marker;
                    if(marker && marker.symbol){
                        gap += (marker.radius || 4.5);
                    }

                    if(isInverted){
                        x = alignTop ? (point.posX + gap) : (point.posX - gap - labelDim.width);
                        y = point.posY - labelDim.height/2;

                        if(y <= 0){
                            y = point.posY;
                        }else if(y + labelDim.height >= plotBounds.height){
                            y = point.posY - labelDim.height;
                        }

                    }else{
                        x = point.posX - labelDim.width/2;
                        y = alignTop ? (point.posY - gap - labelDim.height) : (point.posY + gap);

                        if(x <= 0){
                            x = point.posX;
                        }else if(x + labelDim.width >= plotBounds.width){
                            x = point.posX - labelDim.width;
                        }
                    }

                    point.labelPos = {x:x, y:y};
                }
            });

        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        getAttrs:function(point){
            return {'transform':BaseUtils.makeTranslate([point.posX, point.posY])};
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            return { 
                startX: point.posX + chartBounds.x, 
                startY: point.posY + chartBounds.y, 
                direction: "top" 
            } 
        }, 
 
        calcMoreLabelStartPosition: function(startX, startY, moreLabelWidth, moreLabelHeight){ 
            var direction = "top"; 
 
            if(startY - moreLabelHeight < 0){ 
                direction = "bottom"; 
            } 
 
            return { 
                startX: startX, 
                startY: startY, 
                direction: direction 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        getHighLightStyle:function(){

        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.options.marker && p.options.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point);
        },

        _onPointMouseOver:function(point){
            point.series._onMarkerMouseOver(point);
        },

        _onPointMouseOut:function(point){
            point.series._onMarkerMouseOut(point);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            }
        },

        getPointInitAnimationAttr:function(point){

            return [{
                delay:calculateT(point),
                ease:'swing',
                duration:150,
                attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(1.5)'}
            }, {
                duration:150,
                ease:'swing',
                attr:{'transform': 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }];

        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:UPDATE_EASE,
                duration:LINE_UPDATE_TIME,
                attr:{'transform': 'translate(' + point.posX + ',' + point.posY + ')'}
            };
        },

        getClosestPoint:function(pos){
            var isInverted = this.vanchart.isInverted();
            var key = isInverted ? 'y' : 'x', posKey = isInverted ? 'posY' : 'posX';
            var selectedPoint, minDistance = Number.MAX_VALUE;

            var series = this.vanchart.hoverSeries, plotBounds = this.vanchart.bounds;
            var rePos = plotBounds[key] - (isInverted ? pos.y : pos.x);

            series.points.forEach(function(point){
                var dis = Math.abs(point[posKey] + rePos);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        },

        _onSeriesMouseOver:function(ev){

            Series.prototype._onSeriesMouseOver.call(this, ev);

            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesMouseOver();
            });

            BaseUtils.toFront(this.group.node());
        },

        //dom event do nothing
        _onSeriesMouseOut:function(ev){
        },

        //point.series.fire
        _seriesUnChosen:function (ev) {
            //这里只负责撤销系列的选中效果...
            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesMouseOut();
            });
        },

        drawPoints:function(){

            Series.prototype.drawPoints.call(this);

            for(var i = this.dataBandsGraphic.length - 1; i >= 0; i--){
                this.dataBandsGraphic[i].toBack();
            }

        },

        drawSeries:function(){

            var series = this, vanchart = this.vanchart;
            var dataBands = this.dataBands, i, len;

            series.removeDefaultMarker();

            this.dataBandsGraphic = this.dataBandsGraphic || [];

            for(i = dataBands.length, len = this.dataBandsGraphic.length; i < len; i++){
                this.dataBandsGraphic[i].remove();
                this.dataBandsGraphic[i] = null;
            }

            for(i = 0, len = dataBands.length; i < len; i++){
                if(this.dataBandsGraphic[i]){
                    this.dataBandsGraphic[i].refresh(dataBands[i]);
                }else{
                    this.dataBandsGraphic[i] = new DataBand(dataBands[i], series);
                }
            }

            this.dataBandsGraphic.length = dataBands.length;
        }
    });

    //dataBand that draw part of the series
    var DataBand = Class.extend({

        initialize:function(options, series){
            this.series = series;
            this.refresh(options)
        },

        refresh:function(options){
            this.options = options;

            this.render();
        },

        render:function(){

            var options = this.options, series = this.series;
            var group = series.group, vanchart = series.vanchart, renderer = vanchart.renderer;

            var lineStyle = this._getLineStyle(series, options);
            var style = this._getAreaStyle(series, options);
            var isSupportSvg = BaseUtils.isSupportSVG();

            var clipBounds = options.clipBounds, isArea = series.type == Constants.AREA_CHART, isInit = !this.linePath || this.linePath.removed();

            if(!this.clipRect){
                this.clipRect = renderer.createClip({x:clipBounds.x, y:clipBounds.y,width:clipBounds.width, height:clipBounds.height});
            }else {
                renderer.updateClip(this.clipRect, clipBounds);
            }

            if(!series.visible){
                this.linePath && this.linePath.remove();
                this.areaPath && this.areaPath.remove();
                this.linePath = this.areaPath = null;

                return;
            }

            this.linePath = this.linePath || renderer.path().attr('d', series.linePath).addTo(group);
            this.linePath.style(lineStyle);
            this.linePath.isLineChart = true;//todo ie clip的bug

            isSupportSvg && renderer.clip(this.linePath, this.clipRect);

            if(isArea){
                this.areaPath = this.areaPath || renderer.path().attr('d', series.areaPath);
                this.areaPath.style(style).addTo(group);
                this.areaPath.isLineChart = true;//todo ie clip的bug
                isSupportSvg && renderer.clip(this.areaPath, this.clipRect);
            }

            if(isInit){
                this.linePath.attr('d', series.linePath);
                this.areaPath && this.areaPath.attr('d', series.areaPath);

                isSupportSvg &&
                this.clipRect.rect.attr(vanchart.isInverted() ? 'height' : 'width', 0)
                    .animate({'ease':LINE_SHOW_EASE, 'duration':LINE_SHOW_TIME, 'attr':clipBounds});
            }else{

                this.linePath.animate({
                    'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':{'d':series.linePath}
                });

                if(this.areaPath){
                    this.areaPath.animate({
                        'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':{'d':series.areaPath}
                    });
                }

                isSupportSvg &&
                this.clipRect.rect.animate({
                    'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':clipBounds
                });
            }
        },

        toBack:function(){

            DomUtils.toBack(this.linePath && this.linePath.node());

            DomUtils.toBack(this.areaPath && this.areaPath.node());
        },

        _getAreaStyle:function(series, options){
            var target = series.vanchart.highlightTarget;
            var fill, fillOpacity;
            if(target){
                fill = options.fillColor;
                fillOpacity = target == series.name ? 1 : 0.3;
            }else{
                fill = this._getFillFilter(options.fillColor, series);
                fillOpacity = series.vanchart.options.style == Constants.STYLE_GRADUAL ? 1.0 : options.fillColorOpacity;
            }
            return {'fill': fill, 'fill-opacity':fillOpacity};
        },

        _getLineStyle:function(series, options){
            var opacity = options.opacity, target = series.vanchart.highlightTarget;

            if(target){
                opacity = target == series.name ? 1 : 0.3;
            }

            return {'fill':'none','stroke':options.color, 'stroke-width':series.options.lineWidth, 'stroke-opacity':opacity};
        },

        _getFillFilter:function(color, series){

            if(BaseUtils.isSupportSVG()){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var options = series.vanchart.options;

                if(options.style == Constants.STYLE_GRADUAL){
                    //翻转情况
                    var x1, y1, x2, y2;
                    x1 = y1 = x2 = y2 = '0%';
                    var percent = Math.abs(series.y) / Math.abs(series.y - series.y0) || 0;
                    if (vanchart.isInverted() === true){
                        x1 = (1 - percent)*100 + '%';
                        x2 = '100%';
                    }else {
                        y1 = percent * 100 + '%';
                    }

                    var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
                    var stop1 = {'offset':'0%', 'stop-color':color, 'stop-opacity':0};
                    var stop2 = {'offset': '100%', 'stop-color':color, 'stop-opacity':0.8};

                    if(this.colorGradient){
                        renderer.updateColorGradient(this.colorGradient, attrs, [stop1, stop2])
                    }else{
                        this.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                    }

                    return "url(#" + BaseUtils.stamp(this.colorGradient) +")";
                }
            }

            return color;
        },

        _onSeriesMouseOver:function(){
            this.linePath.style({
                'stroke':ColorUtils.getHighLightColor(this.options.color),
                'stroke-width':this.series.options.lineWidth + 1
            });

            if(this.series.type == Constants.AREA_CHART){
                this.areaPath.animate({
                    duration:200,
                    ease:Bezier.custom["ease-out-back"],
                    style:{
                        'fill':this._getFillFilter(ColorUtils.getHighLightColor(this.options.fillColor), this.series),
                        'fill-opacity': this.options.fillColorOpacity === 0 ? 0 : (this.options.fillColorOpacity + CHOSEN_AREA_ADD_ALPHA)
                    },
                    // 鼠标拖拽zoom的时候，this.areaPath会发生animate更新path，这时如果某个series发生mouseOver，那么mouseOver的事件就会盖住update的动画
                    // 从而导致update的path不能更新，因此这里hack一下，mouseOver的时候，也更新areaPath,保证面积位置不出错
                    // 当然比较好的做法时doLayout的时候计算areaPath改变时加一个判断值，changedAreaPath，然后这里判断是否有变化再更新，
                    // 但那样又得多牵扯一些东西，倒不如这样来的利索
                    attr: {
                        "d": this.series.areaPath
                    }
                });
            }
        },

        _onSeriesMouseOut:function(){

            if(this.linePath){
                this.linePath.style(this._getLineStyle(this.series, this.options));
            }

            if(this.areaPath){
                this.areaPath.animate({
                    duration:200,
                    ease:Bezier.custom["ease-out-back"],
                    style:this._getAreaStyle(this.series, this.options)
                });
            }
        },

        remove:function(){
            this.linePath && this.linePath.remove();
            this.areaPath && this.areaPath.remove();
            this.clipRect && this.clipRect.remove();
            this.linePath = this.areaPath = this.clipRect = null;
        }
    });

    require('../ChartLibrary').register(Constants.LINE_CHART, Line);
    require('../ChartLibrary').register(Constants.AREA_CHART, Line);

    return Line;
});
/**
 * Created by eason on 15/12/31.
 */
define('chart/Radar',['require','./Series','../utils/BaseUtils','../utils/QueryUtils','../utils/BoundsManager'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');

    var Radar = Series.extend({

        refresh:function(options, index){

            Series.prototype.refresh.call(this, options, index);

            this.columnType = this.options.columnType;

            this.stack = this.columnType ? 'radar-column' + this.options.stack : this.options.stack;

            return this;
        },

        _getAxisTypes:function(){
            return ['angleAxis', 'radiusAxis', 'polar'];
        },

        getBaseAxisType: function () {
            return 'angleAxis';
        },

        _bindAxis:function(){
            var series = this,
                seriesOptions = series.options,
                vanchart = series.vanchart;

            series._getAxisTypes().forEach(function(axisType){

                if(vanchart[axisType]){
                    var targetAxis = vanchart[axisType](seriesOptions['polar']);
                    if(targetAxis){
                        targetAxis.series.push(series);
                        series[axisType] = targetAxis;
                    }
                }

            });
        },

        _getDefaultFillColorOpacity: function () {
            return this.options.columnType ? 1 : 0.15;
        },

        _getTranslate:function(){
            return this.getCenter();
        },

        getCenter:function(){
            return this.polar && this.polar.center;
        },

        getRadius:function(){
            return this.polar && this.polar.radius;
        },
        
        doLayout:function(){
            var series = this, polar = series.polar, radiusAxis = polar.radiusAxis, angleAxis = polar.angleAxis;
            var center = this.getCenter(), radius = this.getRadius(), piece = angleAxis.piece, valueScale = radiusAxis.scale, cateScale = angleAxis.scale;

            var indicator = radiusAxis.indicator;

            var scaleValueNotNaN = function (num) {
                return isNaN(valueScale(num)) ? 0 : valueScale(num);
            }

            //todo 先排序作用是
            series.points.sort(function(pointA, pointB){
                return cateScale(pointA.category) - cateScale(pointB.category);
            });

            var options;
            series.points.forEach(function(point){

                options = point.options;
                var category = point.category,
                    innerValue = options.y0,
                    outerValue = point.value + options.y0;

                // calc point inner-outer radius for every categroy when use indicastor 
                point.innerRadius = indicator ? series._cateValueScale(category, innerValue) : scaleValueNotNaN(innerValue);    

                point.outerRadius = indicator ? series._cateValueScale(category, outerValue) : scaleValueNotNaN(outerValue);

                point.animateInitRadius = radiusAxis.getStartPos();

                point.radian = cateScale(point.category) * piece;

                var pos = series._getArcPoint(point.outerRadius, point.radian);
                point.posX = pos[0];

                point.posY = pos[1];

                this._calcLabelPos(point);

            }, this);

            series.pathSegment = series._getPathSegment(series.points, series.options.connectNulls);
        },

        _calculateLabelPos:function () {

        },

        getTargetKey: function () {
            return 'y';
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },
        
        _getPathSegment:function(dataPoints, connectNulls){

            var series = this, polar = series.polar, angleAxis = polar.angleAxis, cateScale = angleAxis.scale;

            dataPoints = [].concat(dataPoints);

            dataPoints.sort(function(pointA, pointB){
                return cateScale(pointA.category) - cateScale(pointB.category);
            });

            var pathSeg = [];

            var tmp = [];

            if(connectNulls){

                pathSeg.push(tmp);

                dataPoints.forEach(function(dataPoint){

                    if(!dataPoint.isNull){
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                });
            }else{

                var startIndex = 0;
                var count = dataPoints.length;

                for(var index = count - 1; index > 0; index--){

                    var current = dataPoints[index];
                    var pre = dataPoints[index - 1];

                    if(!current.isNull && pre.isNull){
                        startIndex = index;
                    }
                }

                for(var index = 0; index < count; index++){

                    var dataPoint = dataPoints[(index + startIndex) % count];

                    if(dataPoint.isNull && tmp.length){

                        if(tmp.length > 1){
                            pathSeg.push(tmp)
                        };

                        tmp = [];
                    }else if(!dataPoint.isNull){
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                }

                if(tmp.length){
                    pathSeg.push(tmp);
                }
            }

            return pathSeg;
        },

        _getRadarSeriesPath:function(pathSeg, connectNulls, toCenter){

            var path = '';
            var tmp = [];
            if(pathSeg.length === 1){

                tmp = pathSeg[0];

                var fullShape = tmp.length == this.angleAxis.getCategoryCount() || connectNulls;

                toCenter = (!fullShape && toCenter);

                path = toCenter ? 'M0,0' : '';

                for(var i = 0, count = tmp.length; i < count; i++){

                    var mOrl = (i || toCenter) ? 'L' : 'M';

                    path += (mOrl + BaseUtils.dealFloatPrecision(tmp[i][0]) + "," + BaseUtils.dealFloatPrecision(tmp[i][1]));
                }

                path += (fullShape || toCenter) ? 'Z' : '';

            }else{
                pathSeg.forEach(function(tmp){

                    path += toCenter ? 'M0,0' : '';

                    tmp.forEach(function(pos, i){
                        path += (((i || toCenter) ? 'L' : 'M') + BaseUtils.dealFloatPrecision(pos[0]) + "," + BaseUtils.dealFloatPrecision(pos[1]));
                    });

                    path += toCenter ? 'Z' : '';
                });
            }

            return path;
        },

        _getInitPathSegment:function(pathSeg){
            var init = [];
            pathSeg.forEach(function(seg){
                var tmp = [];
                init.push(tmp);

                seg.forEach(function(){
                    tmp.push([0,0])
                })
            });
            return init;
        },
        // when use indicator, domain of each categroy need to calc one by one
        _cateValueScale : function(cate, value) {
            var series = this, radiusAxis = series.radiusAxis, cateScale = radiusAxis._cateScale;

            var domain;
            // get domain value of specific category
            radiusAxis._cateDomain.forEach(function (d) {
                if(d.name === cate) {
                    domain = d.domain;
                }
            });
            // calc scale value
            cateScale.domain(domain);
            return isNaN(cateScale(value)) ? 0 : cateScale(value);
        }
    });
    
    return Radar;
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/LineRadar',['require','../utils/BaseUtils','../dom/DomUtils','../utils/ColorUtils','../utils/BezierEasing','../EffectHelper','../utils/Interpolator','../Constants','./Radar','../ChartLibrary'],function(require){

    var BaseUtils  = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var Interpolator = require('../utils/Interpolator');
    var Constants = require('../Constants');
    var Radar = require('./Radar');

    var LINE_SHOW_TIME = 400;
    var LINE_SHOW_EASE = 'back-out';

    var MARKER_INIT_TIME = 200;
    var MARKER_INIT_EASE = 'back-out';

    var EXIT_TIME = 250;
    var EXIT_EASE = 'back-in';

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    var LineRadar = Radar.extend({
        columnType:false,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius + LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        drawPoints:function(){
            Radar.prototype.drawPoints.call(this);

            DomUtils.toBack(this.radarPath && this.radarPath.node());
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

            series.removeDefaultMarker();

            var toCenter = series.fillColor && series.fillColorOpacity;
            var pathStyle = this._getRadarPathStyle();

            if(series.visible && series.pathSegment.length > 0){
                this.radarPath = this.radarPath || renderer.path().addTo(series.group);
                this.radarPath.style(pathStyle);
                this.radarPath.animate({
                    duration:LINE_SHOW_TIME,
                    ease:LINE_SHOW_EASE,
                    attrTween:{'d':function(){
                        var useLastPathSeg = !!this._pathSegment_;
                        if(useLastPathSeg && this._pathSegment_.length == series.pathSegment.length){
                            var last = this._pathSegment_;
                            for(var i = 0, count = last.length; i < count && useLastPathSeg; i++){
                                if(last[i].length != series.pathSegment[i].length){
                                    useLastPathSeg = false;
                                }
                            }
                        }
                        var initPathSeg = useLastPathSeg ? this._pathSegment_ : series._getInitPathSegment(series.pathSegment);
                        var interpolate  = Interpolator.interpolateArray(initPathSeg, series.pathSegment);
                        this._pathSegment_ = series.pathSegment;
                        return function(t){
                            return series._getRadarSeriesPath(interpolate(t), series.options.connectNulls, toCenter);
                        };
                    }}
                });
            }else{
                if(this.radarPath){
                    this.radarPath.animate({
                        duration:EXIT_TIME,
                        ease:EXIT_EASE,
                        attrTween:{'d':function(){
                            var initPathSeg = series._getInitPathSegment(series.pathSegment);
                            var interpolate  = Interpolator.interpolateArray(series.pathSegment, initPathSeg);
                            return function(t){
                                return series._getRadarSeriesPath(interpolate(t), series.options.connectNulls, toCenter);
                            };
                        }}
                    }).remove();
                }

                this.radarPath = null;
            }
        },

        _getRadarPathStyle:function(){
            var series = this, hasFill = series.fillColor && series.fillColorOpacity;
            var fillOpacity = series.fillColorOpacity, strokeOpacity = series.opacity;
            var target = series.vanchart.highlightTarget;

            // target为""也可触发高亮
            if(BaseUtils.hasDefined(target)){
                fillOpacity = target == series.name ? 1 : 0.3;
                strokeOpacity = target == series.name ? 1 : 0.3;
            }

            return {
                'fill': hasFill ? series.fillColor : 'none',
                'fill-opacity': fillOpacity,
                'stroke': series.color,
                'stroke-width': series.options.lineWidth,
                'stroke-opacity':strokeOpacity
            };
        },

        _getFillHighLightStyle:function(){
            var series = this, hasFill = series.fillColor && series.fillColorOpacity;

            return {
                'fill': hasFill ? ColorUtils.getHighLightColor(series.fillColor) : 'none',
                'fill-opacity': series.fillColorOpacity === 0 ? 0 : (series.fillColorOpacity + 0.35)
            };
        },

        _getStrokeHighLightStyle:function () {
            var series = this;
            return {
                'stroke':ColorUtils.getHighLightColor(series.color),
                'stroke-width': series.options.lineWidth + 1,
                'stroke-opacity':series.opacity
            };
        },

        _getStrokeStyle:function () {
            var series = this;
            return {
                'stroke': series.color,
                'stroke-width': series.options.lineWidth,
                'stroke-opacity':series.opacity
            };
        },

        getStyle:function(){
            return {};
        },

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.options.marker && p.options.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point);
        },

        _calculateLabelPos:function(){

        },

        _getFixedPos:function(datum){
            var radius = isNaN(datum.options.marker.radius) ? 4.5 : datum.options.marker.radius, center = this.getCenter();
            var x, y;
            x = center[0] + datum.posX + radius;
            y = center[1] + datum.posY + radius;

            return [x, y];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition :function(point, moreLabelDim){
            var chartCenter = this.getCenter();
            var startX = point.posX + chartCenter[0],
                startY = point.posY + chartCenter[1];
            return {
                startX: startX,
                startY: startY,
                direction: "top"
            }
        },

        _onSeriesMouseOver:function(ev){
            Radar.prototype._onSeriesMouseOver.call(this, ev);

            var series = this;
            if(series.radarPath){
                series.radarPath
                    .style(series._getStrokeHighLightStyle())
                    .animate({
                        duration:200,
                        ease:Bezier.custom["ease-out-back"],
                        style:series._getFillHighLightStyle()
                    });
            }

            BaseUtils.toFront(series.group.node());
        },

        _onSeriesMouseOut:function(){
            var series = this;

            if(series.radarPath){
                series.radarPath.style(series._getStrokeStyle())
                    .animate({
                        duration:200,
                        ease:Bezier.custom["ease-out-back"],
                        style:series._getRadarPathStyle()
                    });
            }
        },

        _onPointMouseOver:function(point){
            point.series._onMarkerMouseOver(point);
        },

        _onPointMouseOut:function(point){
            point.series._onMarkerMouseOut(point);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            }
        },

        getPointInitAnimationAttr:function(point){

            return {
                delay:LINE_SHOW_TIME,
                duration:MARKER_INIT_TIME,
                ease:MARKER_INIT_EASE,
                attr:{'transform': 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            };

        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:LINE_SHOW_EASE,
                duration:LINE_SHOW_TIME,
                attr:{'transform': 'translate(' + point.posX + ',' + point.posY + ') scale(1)'}
            };
        },

        getPointDropAnimationAttr:function(){
            return {
                ease:EXIT_EASE,
                duration:EXIT_TIME,
                attr:{'transform': 'translate(' + 0 + ',' + 0 + ') scale(0.01)'}
            };
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        getClosestPoint:function(pos){

            var center = this.getCenter(), minDistance = Number.MAX_VALUE;
            var selectedPoint;

            this.points.forEach(function(point){
                var detX = point.posX + center[0] - pos.x;
                var detY = point.posY + center[1] - pos.y;
                var dis = Math.sqrt(detX * detX + detY * detY);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        }
    });

    require('../ChartLibrary').register(Constants.LINE_RADAR, LineRadar);

    return LineRadar;
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/ColumnRadar',['require','../EffectHelper','../utils/Interpolator','../utils/PathGenerator','../Constants','./Radar','../ChartLibrary'],function(require){
    var EffectHelper = require('../EffectHelper');
    var Interpolate = require('../utils/Interpolator');
    var PathGenerator = require('../utils/PathGenerator');
    var Constants = require('../Constants');
    var Radar = require('./Radar');

    var STACK_ANIMATION_TIME = 600;//堆积柱形图，点击图例消失、更新、重新出现时间
    var STACK_EASE = "cubic-out";//堆积柱形图，点击图例消失、更新、重新出现缓动函数

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    var ColumnRadar = Radar.extend({

        columnType:true,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius - LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getStyle:function(p){
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke':p.borderColor,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity':1
            };
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor || p.color,
                'fill':p.color,
                'fill-opacity': 1,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getRadarColumnPath:function(innerRadius, radius, radian){

            var halfSize = this.polar.angleAxis.piece * 0.375;

            var startRadian = radian - halfSize;

            var endRadian = radian + halfSize;

            var arc = PathGenerator.arc()
                .innerRadius(innerRadius).outerRadius(radius)
                .startAngle(startRadian).endAngle(endRadian);

            return arc();
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series;
            var innerInterpolate = Interpolate(point.animateInitRadius, point.innerRadius);
            var outerInterpolate = Interpolate(point.animateInitRadius, point.outerRadius);

            return series._pointAnimateAttr(EASE, ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointReShowAnimationAttr:function (point) {
            var series = point.series;
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;
            var start = point.animateInitRadius;
            if(preP) {
                start = preP._lastOuterRadius_;
            } else if(sufP) {
                start = sufP._lastInnerRadius_;
            }

            var innerInterpolate = Interpolate(start, point.innerRadius);
            var outerInterpolate = Interpolate(start, point.outerRadius);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointUpdateAnimationAttr:function(point){
            var series = this;
            // 现在的设计器里面，会先initChart然后又initPaddingScale，使得initAnimation还没开始就又开始updateAnimation,
            // 接着导致point._lastInnerRadius的值undefined，所以应该有一个默认的值
            var innerInterpolate = Interpolate(point._lastInnerRadius_ || point.animateInitRadius, point.innerRadius);
            var outerInterpolate = Interpolate(point._lastOuterRadius_ || point.animateInitRadius, point.outerRadius);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointDropAnimationAttr:function(point){
            var series = this;
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;
            var end = point.animateInitRadius;

            if(preP){//里面一个
                end = preP.outerRadius;
            } else if(sufP){
                end = sufP.innerRadius;
            }

            var innerInterpolate = Interpolate(point.innerRadius, end);
            var outerInterpolate = Interpolate(point.outerRadius, end);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        _pointAnimateAttr:function (ease, duration, point, innerInterpolate, outerInterpolate) {
            var series = point.series;
            return {
                ease:ease,
                duration:duration,
                attrTween: {
                    'd': function () {
                        return function (t) {
                            point._lastInnerRadius_ = innerInterpolate(t);
                            point._lastOuterRadius_ = outerInterpolate(t);

                            return series._getRadarColumnPath(point._lastInnerRadius_, point._lastOuterRadius_, point.radian);
                        };
                    }
                }
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series,style = series.getStyle(point);
            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point.graphic.animate({duration:CHOSEN_TIME, ease:CHOSEN_EASE, style:style});
            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
        },

        _getFixedPos:function(datum, divDim){

            var centerAngle = datum.radian, center = this.getCenter();

            var x = datum.posX + center[0];
            var y = datum.posY + center[1];

            if(centerAngle < Math.PI / 2){
                y -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                x -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < Math.PI * 2){
                y -= divDim.height;
                x -= divDim.width;
            }

            return [x, y];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition :function(point, moreLabelDim){
            var toCenterRadius = point.innerRadius + (point.outerRadius - point.innerRadius) / 2;
            var pointCenter = this._getArcPoint(toCenterRadius, point.radian),
                chartCenter = this.getCenter();

            var startX = pointCenter[0] + chartCenter[0],
                startY = pointCenter[1] + chartCenter[1];
            return {
                startX: startX,
                startY: startY,
                direction: "top"
            }
        }
    });

    require('../ChartLibrary').register(Constants.COLUMN_RADAR, ColumnRadar);

    return ColumnRadar;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('chart/Bubble',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../EffectHelper','../utils/BezierEasing','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var EffectHelper = require('../EffectHelper');
    var BezierEasing = require('../utils/BezierEasing');

    var BUBBLE_INIT_TIME = 500;
    var BUBBLE_UPDATE_TIME = 500;
    var BUBBLE_EXIT_TIME = 300;
    var BUBBLE_RE_SHOW_TIME = 300;

    var CHOSEN_TIME = 200;
    var CHOSEN_EASE = BezierEasing.custom["ease-out-back"];
    var OUT_EASE = BezierEasing.css["ease-out"];

    var Bubble = Series.extend({

        doLayout:function(){
            this._calculateBubblePosition();
        },

        useCanvas:function(){
            return this.options.large
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {
            var options = point.options;

            if(this.vanchart.isMap()){
                return options.size == '-' || BaseUtils.hasNotDefined(options.size);
            } else {
                return options.x == '-' || options.y == '-' || options.size == '-' || BaseUtils.hasNotDefined(options.size);
            }
        },

        _getPointKey: function (point) {
            var option = point.options || point;
            return this.vanchart.isMap() ? point.name : ('' + option.x + option.y);
        },

        //计算位置的时候 顺道儿就给了
        _calculateLabelPos:function() {

        },

        //shine:这边的系列最大最小值用来算气泡半径，特殊：绝对值等
        _calculateMinMax4Radius:function(){
            var series = this, points = series.points;
            var seriesMinSize = Number.MAX_VALUE, seriesMaxSize = -Number.MAX_VALUE;

            for(var index = 0, len = points.length; index < len; index++){
                var point = points[index];
                var value = point.getTargetValue();

                if(!point.visible || point.isNull){
                    continue;
                }

                //shine:这个就是当前点要不要展示负气泡，拿系列的属性做什么
                //过滤 是负气泡且不展示负气泡的点
                if(value < 0 && !point.options.displayNegative){
                    continue;
                }

                //过滤 设置了直径，不参与计算的点
                if(point.options.minSize || point.options.maxSize){
                    continue;
                }

                //todo:这个0目测有问题，可能因为这个奇怪的点把100-200扩展成0-200
                seriesMaxSize = Math.max(seriesMaxSize, isNaN(value) ? 0 : Math.abs(value));
                seriesMinSize = Math.min(seriesMinSize, isNaN(value) ? 0 : Math.abs(value));
            }

            series.seriesAbsMinValue = seriesMinSize;
            series.seriesAbsMaxValue = seriesMaxSize;
        },

        _calculateBubbleRadius:function(){
            var series = this, options = series.options;
            //这边需要的是合并后的属性
            var seriesMaxDiameter = Math.max(series.maxSize, series.minSize);
            var seriesMinDiameter = Math.min(series.minSize, series.maxSize);
            var sizeByArea = options.sizeBy == Constants.SIZE_BY_AREA;

            //系列条件属性设置最大最小半径，则气泡半径根据该系列最大最小size计算
            var max = this.seriesAbsMaxValue, min = this.seriesAbsMinValue;

            if(!this._sizeByCurrentSeries()){//系列没有单独设置最大最小值，去算整个图表的。
                var minMax = this._calculateChartMinMax();
                max = BaseUtils.pick(minMax.max, minMax[1]);
                min = BaseUtils.pick(minMax.min, minMax[0]);
            }

            var denominator = max - min;
            var unit = sizeByArea ? (seriesMaxDiameter * seriesMaxDiameter - seriesMinDiameter * seriesMinDiameter) / denominator
                : (seriesMaxDiameter - seriesMinDiameter ) / denominator;
            unit = isFinite(unit) ? unit : 0;

            var scale = BaseUtils.pick(this.vanchart.scale, 1);
            var targetKey = this.getTargetKey();

            this.points.forEach(function(point) {
                var temp = unit * (Math.abs(point.value) - min);
                var diameter = sizeByArea ? Math.sqrt(seriesMinDiameter * seriesMinDiameter + temp) : seriesMinDiameter + temp;
                if(point.options.minSize || point.options.maxSize){
                    //shine:这个判断的意思是如果气泡图的某个点里面设置了最大最小半径，就用它自己的，不用和其他点一起算半径了
                    //所以不要乱改逻辑
                    var _tmp = isNaN(point.options.minSize) ? point.options.maxSize : point.options.minSize;
                    diameter = sizeByArea ? Math.sqrt(_tmp) * 2 : _tmp;
                }
                diameter = (point[targetKey] < 0 && !point.options.displayNegative) ? 0 : diameter;
                point.radius = (diameter/2) * scale;
            });
        },

        //这边需要的是合并属性前的原始属性
        _sizeByCurrentSeries: function () {
            return BaseUtils.hasDefined(this.options.minSize) && BaseUtils.hasDefined(this.options.maxSize);
        },

        //这个是用来算半径的，特殊：绝对值&不包含自定义直径的系列
        _calculateChartMinMax: function () {
            var series = this.vanchart.seriesOfType(this.type);

            var minSize = Number.MAX_VALUE;//所有数据的最大最小值
            var maxSize = -minSize;

            series.forEach(function(sery) {
                if(!sery._sizeByCurrentSeries()) {
                    minSize = Math.min(minSize, sery.seriesAbsMinValue);
                    maxSize = Math.max(maxSize, sery.seriesAbsMaxValue);
                }
            });

            return{
                min:minSize,
                max:maxSize
            }
        },

        _calculateBubblePosition:function(){
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;

            this.points.forEach(function(point){
                var options = point.options;

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand() / 2 : 0;
                var t1 = xAxis.scale(xAxis.getAxisValue(options.x)) + det;
                var t2 = yAxis.scale(yAxis.getAxisValue(options.y));

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                var valid = point.labelDim && !point.isNull && !(point.getTargetValue() < 0 && !options.displayNegative);

                if(valid && options.dataLabels && options.dataLabels.enabled){

                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.labelDim.height/2
                    };
                }
            });
        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function(point){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, radius = point.radius || 0;

            var pos;
            if(vanchart.isMap()){
                var latlng = point.getLatLng();

                if(!latlng){
                    return;
                }

                pos = vanchart.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;

            return [pos.x + radius, pos.y + radius];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var chartBounds = this.vanchart.bounds; 
            var startX = point.posX, 
                startY = point.posY;
            
            return { 
                startX: startX + chartBounds.x, 
                startY: startY + chartBounds.y, 
                direction: "top" 
            }
        },

        getPointGraphicKey:function(){
            return 'circle';
        },

        effectAnimation:function (d) {
            EffectHelper.bubbleEffectAnimation(d, this.vanchart.isMap());
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        getPointInitAttr:function(point){
            return {
                'transform':BaseUtils.makeTranslate([point.posX, point.posY]),
                'r':0
            }
        },

        getPointInitAnimationAttr:function(point){
            return {
                delay:point.delayTime || 0,
                ease:'bounce',
                duration:BUBBLE_INIT_TIME,
                attr:{'r': point.radius}
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:'bounce',
                duration:BUBBLE_RE_SHOW_TIME,
                attr:{'r': point.radius}
            }
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:'back-out',
                duration:BUBBLE_UPDATE_TIME,
                attr:{
                    'r':point.radius,
                    'transform': BaseUtils.makeTranslate({x:point.posX, y:point.posY})
                }
            }
        },

        getPointDropAnimationAttr:function(){
            return {
                ease:'back-in',
                duration:BUBBLE_EXIT_TIME,
                attr:{'r':0}
            }
        },

        _getShadowFilter:function () {
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;
            vanchart.bubbleShadowFilter = vanchart.bubbleShadowFilter || renderer.createDropShadowFilter(0, 0, 0.2, 2);
            return 'url(#' + BaseUtils.stamp(vanchart.bubbleShadowFilter) + ')';
        },

        getStyle:function(p){
            var series = p.series;
            var style = {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0,
                'stroke-width':0,
                'fill':p.color,
                'fill-opacity':p.opacity
            };

            //todo ie10加阴影报错
            if(!BaseUtils.isMS) {
                style.filter = p.options.shadow ? series._getShadowFilter() : 'none';
            }

            return style;
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0.35,
                'stroke-width':6,
                'fill':p.mouseOverColor,
                'fill-opacity': p.opacity + 0.35
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0.35,
                'stroke-width':6,
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, true, CHOSEN_EASE, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);
            series._onState(point, false, OUT_EASE, style);
        },

        _onState:function (point, isChosen, ease, style) {
            var series = point.series, vanchart = series.vanchart;
            if(series.vanchart.isLargeMode()){
                return;
            }

            if(vanchart.isMap()){
                point._mapPointOnMouseState(isChosen, CHOSEN_TIME, ease, style);

                point.textLayers && point.textLayers.forEach(function(layer){
                    layer._fontSizeState(isChosen, CHOSEN_TIME, CHOSEN_EASE);
                });
            } else {
                point.graphic
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .animate({
                        ease: ease,
                        duration: CHOSEN_TIME,
                        style: style,
                        attr: {'r': point.radius + (isChosen ? 1 : 0)}
                    });

                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, ease);
            }
        }

    });

    require('../ChartLibrary').register(Constants.BUBBLE_CHART, Bubble);

    return Bubble;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('chart/Scatter',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../EffectHelper','../utils/PathGenerator','../ChartLibrary'],function (require) {

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');

    var SCATTER_INIT_TIME = 300;
    var SCATTER_UPDATE_TIME = 500;
    var LABEL_GAP = 2;

    var Scatter = Series.extend({

        doLayout: function () {
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;
            this.points.forEach(function (point) {

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand() / 2 : 0;
                var t1 = xAxis.scale(xAxis.getAxisValue(point.options.x)) + det;
                var t2 = yAxis.scale(yAxis.getAxisValue(point.options.y));

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                if (point.labelDim) {
                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.options.marker.radius - LABEL_GAP - point.labelDim.height
                    };
                }

            });

            var series = this;

            var lineSvg = PathGenerator.line()
                .interpolate(series.interpolate)
                .x(function (d) {
                    return d.posX;
                })
                .y(function (d) {
                    return d.posY;
                })
                .defined(function (d) {
                    return !d.isNull;
                });

            this.points.sort(function (pointA, pointB) {
                return pointA.posX - pointB.posX;
            });

            this.linePath = lineSvg(this.points);
        },

        useCanvas:function(){
            return this.options.large;
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {
            var options = point.options;

            if(this.vanchart.isMap()){
                return options.size == '-' || BaseUtils.hasNotDefined(options.size);
            }else{
                return options.x == '-' || options.y == '-' || BaseUtils.hasNotDefined(options.y);
            }
        },

        _calculateLabelPos: function (point) {

        },

        getTrendLineXYValues: function (sery) {
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function (point) {
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, radius = (point.options.marker &&  point.options.marker.radius) || 0;

            var pos;
            if(vanchart.vanChartType == 'vanChartMap'){
                var latlng = point.getLatLng();

                if(!latlng){
                    return;
                }

                pos = vanchart.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;

            return [pos.x + radius, pos.y + radius];
        },

        _animateEnd: function () {
            this._showLabels();
            this._drawEffectPoints();

            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;
            if(!series.group){
                series.group = series._createGroup(renderer, vanchart)
                    .attr('transform', BaseUtils.makeTranslate(series._getTranslate()))
                    .attr('class', series.className + ' ' + series.type);
            }

            // 当系列visible为true且linePath存在的时候，再去绘制lineGraphic
            if(series.visible && series.linePath) {
                series.lineGraphic = series.lineGraphic || renderer.path({'d':series.linePath})
                    .addTo(series.group)
                    .style({'fill':'none', 'pointer-events': 'none', 'stroke-width': series.options.lineWidth, 'stroke': series.color});
            }
            
        },

        calcMoreLabelPosition: function(point, moreLabelDim) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.posX + chartBounds.x, 
                startY = point.posY + chartBounds.y; 
                
            return { 
                startX: startX, 
                startY: startY, 
                direction:"top" 
            } 
        },

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d, this.vanchart.isMap());
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        _getPointKey: function (point) {
            var option = point.options || point;
            return this.vanchart.isMap() ? point.name : ('' + option.x + option.y);
        },

        getAttrs:function(p){
            return {'transform': BaseUtils.makeTranslate({x:p.posX, y:p.posY})};
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            };
        },

        getPointInitAnimationAttr:function(point){
            return {
                delay:point.delayTime,
                ease:'back-out',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:'back-out',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:'back-out',
                duration:SCATTER_UPDATE_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointDropAnimationAttr:function(point){
            return {
                ease:'back-in',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(0)'}
            }
        },

        drawSeries: function () {
            var series = this;

            series.visible && series.lineGraphic && series.lineGraphic.animate({
                duration:SCATTER_UPDATE_TIME, 
                ease:'back-out', 
                attr: {
                    'd': series.linePath
                }
            });

            if(!series.visible){
                series.lineGraphic && series.lineGraphic.remove();
                series.lineGraphic = null;
            }
        },

        getStyle:function(point){
            var marker = point.options.marker;
            var isHollow = this._isHollowMarker(marker.symbol);

            return isHollow ?
            {
                'fill-opacity':0,
                fill:'white',
                stroke:marker.fillColor,
                'stroke-opacity':marker.fillColorOpacity,
                'stroke-width':2
            } :
            {
                fill:marker.fillColor,
                'fill-opacity':marker.fillColorOpacity,
                stroke:'none'
            };
        },

        _onPointMouseOver:function(point){

            var series = point.series;

            if(series.vanchart.isLargeMode()){
                return;
            }

            if(series.vanchart.isMap()){
                series._onMapPointState(point, true);
            }else {
                series._onMarkerMouseOver(point);
            }
        },

        _onPointMouseOut:function(point){
            var series = point.series;

            if(series.vanchart.isLargeMode()){
                return;
            }

            if(series.vanchart.isMap()){
                series._onMapPointState(point, false);
            }else {
                series._onMarkerMouseOut(point);
            }
        },

        _onMapPointState:function (point, isChosen) {
            point._mapPointOnMouseState(isChosen);

            point.textLayers && point.textLayers.forEach(function(layer){
                layer._transformState(isChosen);
            });
        }

    });

    require('../ChartLibrary').register(Constants.SCATTER_CHART, Scatter);
    
    return Scatter;
});

/**
 * Created by eason on 15/12/2.
 */
define('chart/Gauge',['require','../Constants','../utils/BaseUtils','./Series','../utils/QueryUtils','../utils/BoundsManager','../utils/ColorUtils','../component/FormattedText','../utils/BezierEasing'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Series = require('./Series');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var ColorUtils = require('../utils/ColorUtils');
    var FormattedText = require('../component/FormattedText');
    var Bezier = require('../utils/BezierEasing');

    var isSupportSVG = BaseUtils.isSupportSVG()

    var Gauge = Series.extend({

        DEFAULT_PADDING:5,
        LINE_GAP:0.3,
        VERTICAL_GAP:0.3,
        HORIZONTAL_GAP:0.8,

        ANIMATION_TIME:1200,
        EASE_TYPE:'cubic-out',

        CHOSEN_EASE : Bezier.css['ease'],
        CHOSEN_TIME : 200,
        OUT_EASE : Bezier.css['ease-out'],
        OUT_TIME : 900,

        refresh:function(options, index){

            Series.prototype.refresh.call(this, options, index);

            options = this.options;

            this.gaugeType = options.style;

            this.center = null;
            if(options.center){
                this.center = [this._getPercentValue(options.center[0], this.vanchart.width), this._getPercentValue(options.center[1], this.vanchart.height)];
            }

            BaseUtils.calculateFontSizeWithScale(options.seriesLabel && options.seriesLabel.style);
            BaseUtils.calculateFontSizeWithScale(options.valueLabel && options.valueLabel.style);
            BaseUtils.calculateFontSizeWithScale(options.percentageLabel && options.percentageLabel.style);

            return this;
        },

        doLayout:function(){
            var seriesBounds = this._calculateGaugeBounds(), series = this, options = series.options;
            if(!seriesBounds && (!options.radius && !series.center)){
                throw new Error('gauge has no bounds');
            }

            this.bounds = seriesBounds;

            this._calculatePercentage();

            //bands和color这两个属性放在doLayout原因：default bands depend on gauge axis domain.
            series.defaultBands = (options.bands || []).concat(series._getDefaultBands(series.gaugeAxis.scale.domain()));

            series.points.forEach(function (point) {
                var bandsColor = series._getColorFromBands(point.getTargetValue(), series.defaultBands);
                if(bandsColor){
                    bandsColor = ColorUtils.getStandardColorAndOpacity(bandsColor);
                    point.color = bandsColor.hex;
                    point.opacity = bandsColor.alpha;
                }
                point.mouseOverColor = ColorUtils.getHighLightColor(point.color);
                point.clickColor = ColorUtils.getClickColor(point.color);
            });

            this._doLayout();
        },

        _doLayout:function(){
            this._dealPercentLabel();

            this._dealValueLabel();

            this._fixCenterAndRadius();
        },

        calculateLabelInfo:function(point){

        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        _getAxisTypes:function(){
            return ['gaugeAxis'];
        },

        getDataToDraw:function(){
            return [];
        },

        _calculatePercentage:function(){
            if(this.points.length){
                var gaugeAxis = this.gaugeAxis, minMax = gaugeAxis.scale.domain();
                var points = this.points;
                points.forEach(function(point){
                    point.points = points;
                    point.percentage = (point.value - minMax[0]) / (minMax[1] - minMax[0]);
                });
            }
        },

        _calculateLabelPos:function(){

        },

        _getTranslate:function(){
            return [Math.round(this.centerX), Math.round(this.centerY)];
        },

        _validPoint:function () {
            var validPoints = this.points.filter(function (point) {return !point.isNull;});
            return validPoints[0] || this.points[0];
        },

        _dealSeriesLabel:function(){
            var series = this, options = series.options;
            series.seriesLabelContent = ''; series.seriesLabelDim = {width:0, height:0};

            if(options.seriesLabel && options.seriesLabel.enabled){
                var style = options.seriesLabel.style;
                
                var point = series._validPoint();
                FormattedText.dataLabelGenerator(point, options.seriesLabel); // 该步计算不会返回labelContent，只是将其绑定在point上

                var labelContent = point.labelContent;
                var labelDim = point.labelDim;

                series.seriesLabelContent = labelContent && labelContent[0] ? labelContent[0].text : '';
                series.seriesLabelStyle = style;
                series.seriesLabelDim = labelDim;
            }
        },
        
        _dealPercentLabel:function () {
            var series = this, options = series.options, percentageLabel = options.percentageLabel;
            series.percentageLabelContent = ''; series.percentageLabelDim = {width:0, height:0};
            var point = series.points[0];

            if(!point || point.isNull){
                return;
            }

            if(percentageLabel && percentageLabel.enabled){

                var labelStyle = BaseUtils.clone(percentageLabel.style);

                if(!labelStyle.color){
                    labelStyle.color = point.color;
                }
                FormattedText.dataLabelGenerator(point, percentageLabel);
                
                var labelContent = point.labelContent;
                var labelDim = point.labelDim;
                series.percentageLabelContent = labelContent && labelContent[0] ? labelContent[0].text : '';
                series.percentageLabelStyle = labelStyle;
                series.percentageLabelDim = labelDim;
            }
        },

        _dealValueLabel:function(){
            var series = this, options = series.options, valueLabel = options.valueLabel, style = valueLabel.style, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;

            series.valueLabelContent = ''; series.valueLabelDim = {width:0, height:0};
            
            if(valueLabel && valueLabel.enabled){
                var valueLabelContent = [];
                for(var i = 0, len = series.points.length; i < len; i++){
                    var point = series.points[i];
                    if(point.isNull){
                        continue;
                    }
                    var labelContent = FormattedText.calculateSingleLineLabelContent(formatter, point);
                    var labelDim = BaseUtils.getTextDimension(labelContent, style, useHtml);
                    valueLabelContent.push({
                        labelContent:labelContent,
                        labelDim:labelDim,
                        labelStyle:style
                    });
                }

                series.valueLabelContent = valueLabelContent;
            }
        },

        _getDefaultBands:function(domain){
            var color = this.options.color, bands = [];
            if(color){
                bands.push({
                    from:domain[0],
                    to:domain[1],
                    color:color
                });
            }else{
                var min = domain[0], max = domain[1];
                var band = BaseUtils.accDiv((max - min), 3);
                var fStop = BaseUtils.accAdd(min, band);
                var sStop = BaseUtils.accAdd(fStop, band);
                var colors = this.vanchart.options.colors;

                bands = [
                    {
                        from:min,
                        to:fStop,
                        color:colors[0]
                    },
                    {
                        from:fStop,
                        to:sStop,
                        color:colors[1]
                    },
                    {
                        from:sStop,
                        to:max,
                        color:colors[2]
                    }];
            }

            return bands;
        },

        _getColorFromBands:function(value, bands){
            if(bands && bands.length){

                for(var i = 0, len = bands.length; i < len; i++){
                    var band = bands[i];
                    var min = Math.min(band.from, band.to);
                    var max = Math.max(band.from, band.to);

                    if(value >= min && value <= max){
                        return band.color;
                    }
                }
            }
        },

        //计算每个系列的边界,要么定义了圆心和半径,作为悬浮元素处理,要么两者都不定义,自定平分区域
        //只定义半径没定义圆心,或者只定义了圆心没有定义半径,效果都是未知的
        _calculateGaugeBounds:function(){
            var series = this.vanchart.seriesOfType(Constants.GAUGE_CHART);
            var plotBounds = this.vanchart.bounds;
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].center && series[i].options.radius){
                    fixedSize++;
                }
            }

            //平均半径
            var isHorizontalLayout = this.options.layout == Constants.HORIZONTAL_LAYOUT;
            var divideDimKey =  isHorizontalLayout ? 'width' : 'height';
            var averageSize = plotBounds[divideDimKey] / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.center){
                        if(isHorizontalLayout){
                            return {
                                x:plotBounds.x + i * averageSize,
                                y:plotBounds.y,
                                width:averageSize,
                                height:plotBounds.height
                            }
                        }else{
                            return {
                                x:plotBounds.x,
                                y:plotBounds.y + i * averageSize,
                                width:plotBounds.width,
                                height:averageSize
                            }
                        }
                    }
                }
            }

            return{x:0,y:0,width:0,height:0};
        },

        //试管的重写了
        _getFixedPos:function(datum, divDim){
            var gauge = datum.series, style = gauge.style;
            var x, y;
            if(style == 'pointer_semi'){
                x = gauge.centerX - divDim.width/2;
                y = gauge.centerY + 0.14 * gauge.radius + 10;
            }else{
                x = gauge.centerX + gauge.radius + 10;
                y = gauge.centerY - divDim.height/2;
            }
            return [x, y];
        },

        _animateEnd: function () {
        },

        _getPointTextLabelGroup:function(){

            if(!this.textGraphicGroup){
                var vanchart = this.vanchart, textRenderGroup = vanchart.seriesTextRenderGroup, textDivGroup = vanchart.seriesTextDivGroup;
                this.textGraphicGroup = vanchart.renderer.vgroup();
                this.textGraphicGroup.renderG.addTo(this.group);
                textDivGroup.append(this.textGraphicGroup.divG);
            }

            this.textGraphicGroup.divG.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));

            return this.textGraphicGroup;
        },

        _drawGaugeLabels: function (labelG) {
            var series = this, vanchart = series.vanchart;

            series._removeNormalLabels(labelG);
            series._drawNormalLabels(labelG);

            // 试管仪表盘更新一下标签动画Init的偏移，
            // 下一次标签绘制时动画应从上一次的位置开始
            series.updateLastLabelPos && series.updateLastLabelPos();

            // 标签和系列绘制完成再绘制MoreLabel
            if(vanchart._needShowMoreLabel() && series.visible){
                series._drawDiffMoreLabels(); 
            }

            // 改回vanchart._changeDataState
            vanchart._removeChangeDataState(series)
        },

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var series = this, point = this.points[0];

            if(!point || point.isNull){
                return;
            }

            this._showMoreLabel(point, series.centerX, series.centerY);
        },

        _removeNormalLabels: function (labelG) {
            //简化代码,标签每次都重画
            var labels = labelG.labels || [];
            for(var i = 0, len =  labels.length; i < len; i++){
                labels[i] && labels[i].remove();
                labels[i] = null;
            }

            this._drawExitValueLabel && this._drawExitValueLabel();  // 仪表盘的valueLabel单独拿出来画了，因此也要单独移除
        },
        
        _drawNormalLabels:function(labelG){
            var series = this, options = series.options, vanchart = series.vanchart, renderer = vanchart.renderer;

            labelG.labels = [];

            if (series.seriesLabelContent) {
                series._drawLabel(labelG, series.seriesLabelContent, series.seriesLabelPos,
                    series.seriesLabelStyle, options.seriesLabel.useHtml);
            }

            if (series.percentageLabelContent) {
                series._drawLabel(labelG, series.percentageLabelContent, series.percentageLabelPos,
                    series.percentageLabelStyle, options.percentageLabel.useHtml, series.animateLabelPara());
            }

            if (series.valueLabelContent && series.valueLabelContent.length) {
                //指针类型的仪表盘值标签后面有背景
                if (series.valueLabelBackground) {
                    var background = BaseUtils.rectSubPixelOpt(series.valueLabelBackground, 0);
                    background.rx = background.rx = series.radius * 0.02;
                    
                    var valueLabelCfg = series.options.valueLabel;

                    // @Cmen:这里注明一下，仪表盘刷新的时候，旧的ValueLabel和新的ValueLabel要同时存在，且应该在backgroundRect上面，因此这里只更新，不重绘
                    series.valueLabelBackgroundRect = series.valueLabelBackgroundRect || renderer.rect().addTo(labelG);
                    series.valueLabelBackgroundRect
                        .attr(background)
                        .style({
                            'fill':valueLabelCfg.backgroundColor,
                            'fill-opacity':ColorUtils.getColorOpacity(valueLabelCfg.backgroundColor),
                            'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
                        });

                    series.lastValueLabelG = series.valueLabelG; // 把旧的存起来,移除的时候可能需要等到动画结束后
                    var valueLabelG = series.valueLabelG = renderer.group().addTo(labelG);
                    if(!series.clipRect){
                        series.clipRect = renderer.createClip(series.valueLabelBackground);
                    }else {
                        renderer.updateClip(series.clipRect, series.valueLabelBackground);
                    }
                    renderer.clip(valueLabelG, series.clipRect);
                }

                var isPointerGaugeValueLabel = series.isPointerGauge();

                for (var i = 0, len = series.valueLabelContent.length; i < len; i++) {
                    var valueLabel = series.valueLabelContent[i];

                    series._drawLabel(labelG, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelStyle, options.valueLabel.useHtml, series.animateLabelPara(), valueLabelG, isPointerGaugeValueLabel);
                }
            }
        },

        animateLabelPara:function () {
        },

        _drawLabel:function(labelG, labelContent, labelPos, labelStyle, useHtml, animatePara, parentG, isPointerGaugeValueLabel){
            if(!labelPos){
                return;
            }
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, textHeight = BaseUtils.getTextHeight(labelStyle);

            var textG = renderer
                .vtext(useHtml)
                .attr({'x': labelPos.x, 'y': labelPos.y, 'dy': 0.85 * textHeight})
                .textContent(labelContent)
                .style(labelStyle)
                .addTo(useHtml ? labelG : (parentG || labelG));

            // 指针仪表盘的ValueLabel要单独对待
            if(isPointerGaugeValueLabel) {
                series.valueLabels = series.valueLabels || [];
                series.valueLabels.push(textG);
            } else {
                labelG.labels.push(textG);
            }

            // IE8及以下有动画也不执行
            if(isSupportSVG && animatePara && animatePara.enabled) {
                if(!series.hasChangedPoint()){ return; }  // 未发生值变化，不执行动画
                textG
                    .attr(animatePara.initAttr || {})
                    .style(animatePara.initStyle || {})
                    .animate({
                        ease: series.EASE_TYPE,
                        duration: series.ANIMATION_TIME,
                        style:{'opacity':1},
                        attr:{'transform':BaseUtils.makeTranslate({x:0, y:0})}
                    });
            }

        },

        _onState:function (graphic, isChosen, style) {
            var series = this;
            graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    ease:isChosen ? series.CHOSEN_EASE : series.OUT_EASE,
                    duration:isChosen ? series.CHOSEN_TIME : series.OUT_TIME,
                    style:style
                })
        },

        isPointerGauge: function(){
            return false;
        },

        _onSinglePointerTap:function(ev){
            //单个指针的时候点击触发超链
            if(this.points && this.points.length === 1){
                this.points[0].onClick(ev.srcEvent);
            }
        },

        _onSeriesMouseOver:function(ev){
            if(this.points && this.points.length === 1){
                this.vanchart.showTooltip(this.points[0], ev);
            }
        },

        _onSeriesMouseOut:function(){
            this.vanchart.hideTooltip();
        },

        getClosestPoint:function(){
            return this.points.length === 1 ? this.points[0] : null;
        },

        _getStroke:function(gradient){
            return BaseUtils.isSupportSVG() ? "url(#" + BaseUtils.stamp(gradient) + ")" : gradient;
        },

        //一个点一个系列
        getEvents:function(){
            return {
                'pointMouseOver':this._onPointMouseOver,
                'pointMouseOut':this._onPointMouseOut,
                'mousemove':this._onSeriesMouseOver,
                'mouseout':this._onSeriesMouseOut,
                'tap':this._onSinglePointerTap,
                'press':this.onSeriesPress,
                'pressup':this.onSeriesPressUp
            }
        },

        isSupportLegendHighlight:function(){
            return false;
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    return Gauge;
});
/**
 * Created by eason on 16/8/9.
 * 指针类型的仪表盘
 */


define('chart/PointerGauge',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','../utils/BoundsManager','../utils/PathGenerator','../utils/Interpolator','../utils/Scale','./Gauge','../ChartLibrary','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolator = require('../utils/Interpolator');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');

    var POINTER_ANGLE = 150;
    var POINTER_SEMI_ANGLE = 90;

    var LABEL_EXIT_DURATION = 900; // 监控刷新最快的是1000ms刷新一次，这边移除的速度比刷新的稍微快一些

    var PointerGauge = Gauge.extend({

        gaugeType:Constants.POINTER_GAUGE,

        _doLayout:function(){

            this._dealSeriesLabel();

            this._dealValueLabel();

            this.options.style == 'pointer' ? this._fixPointerCenter() : this._fixPointerSemiCenter();
        },

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var series = this, points = series.points;

            points.forEach(function (point) {
                series._showMoreLabel(point, series.centerX, series.centerY ); 
            });
        },

        getDataToDraw:function(){
            return this.points;
        },

        _fixPointerCenter:function(){
            var gauge = this, options = gauge.options, radius = options.radius, center = gauge.center;
            var align = options.seriesLabel.align || Constants.BOTTOM;
            if (!center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;
                radius = radius || (Math.min(bounds.width, usedHeight) / 2 - gauge.DEFAULT_PADDING);

                if (align == Constants.BOTTOM) {

                    if (centerY + radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    } else {
                        centerY -= labelHeight / 2;   // 考虑标签在内，整体居中
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    } else {
                        centerY += labelHeight / 2;  // 考虑标签在内，整体居中
                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = center[0];
                gauge.centerY = center[1];
                gauge.radius = radius;
            }

            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius+20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                this._dealValueLabelContent(gauge, radius);
            }
        },

        _fixPointerSemiCenter:function(){
            var gauge = this, options = gauge.options, radius = options.radius, align = options.seriesLabel.align;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;
                radius = radius || (Math.min(bounds.width / 2, usedHeight / 1.14) - gauge.DEFAULT_PADDING);

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2 + radius / 2;
                if (align == Constants.BOTTOM) {

                    if (centerY + 0.14 * radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2; // 此时计算的centerY，已经把标签和0.14*radius考虑在内了,
                        }
                    } else {
                        centerY -= (labelHeight / 2  + radius * 0.07);  // @Cmen:CHART-798,半圆仪表盘还得考虑圆心到底边即radius*0.14的距离
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    } else {
                        centerY += (labelHeight / 2 - radius * 0.07); // @Cmen:CHART-798 半圆仪表盘还得考虑圆心到底边即radius*0.14的距离
                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius * 0.14 + 20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                this._dealSemiValueLabelContent(gauge, radius);
            }
        },

        _dealValueLabelContent:function(gauge, radius){
            var options = gauge.options, gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
            var domain = gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);
            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var startY = 0.16 * radius + tickHeight/2;

            var valueLabelStyle = options.valueLabel.style;
            var useHtml = options.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight),
                heightBoundsManager = boundsManager.heightBoundsManager,
                widthBoundsManager = boundsManager.widthBoundsManager;

            var visibleCount = 0;
            var valueBackgroundY = startY;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0, totalCount = gauge.valueLabelContent.length; i < totalCount; i++){
                var singleLabel = gauge.valueLabelContent[i];

                var tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:startY + valueLabelHeight * (2 + this.LINE_GAP) - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;

                if(!gauge._boundsInCircle(tmpBounds)) {//主要是处理没有标签刻度的地方
                    break;
                } else if(heightBoundsManager.isOverlapped(tmpBounds)){
                    break;
                }

                while(widthBoundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);

                    tmpX = Math.min(-tmpDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:startY + valueLabelHeight * (1 + this.LINE_GAP) - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){//宽度上截断，省略处理
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);
                }

                singleLabel.labelPos = {
                    x:-singleLabel.labelDim.width/2,
                    y:startY + valueLabelHeight/2
                };

                startY += valueLabelHeight * (1 + this.LINE_GAP);

                valueBackgroundX = tmpX;

                visibleCount++;
            }

            gauge.valueLabelContent.length = visibleCount;

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height: valueLabelHeight * (1 + this.LINE_GAP) * visibleCount + valueLabelHeight
            };
        },

        /**
         * 移除valueLabel
         * @return {[type]} [description]
         */
        _drawExitValueLabel: function(){
            var series = this, vanchart = series.vanchart;

            series.valueLabels = series.valueLabels || [];

            // 有发生值变化的点时，向右移出LastValueLabel
            if(series.hasChangedPoint()){
                var backgroundWidth = BaseUtils.rectSubPixelOpt(series.valueLabelBackground, 0).width;
                series.valueLabels.forEach(function (text){
                    text
                        .animate({
                            ease: series.EASE_TYPE,
                            duration: LABEL_EXIT_DURATION,
                            style:{'opacity':1},
                            attr:{'transform':BaseUtils.makeTranslate({x:backgroundWidth, y:0})}
                            })
                });
                vanchart.setTimeout('pointer_gague_valueLabel_removetimer', function (){
                    removeLastValueLabelGroup(series.lastValueLabelG);
                },LABEL_EXIT_DURATION)
            }
            // 没有点发生值变化的话，直接移除
            else {
                series.valueLabels.forEach(function (text){
                    text.remove();
                });
                removeLastValueLabelGroup(series.lastValueLabelG);
            }
            series.valueLabels = [];

            function removeLastValueLabelGroup(labelG){
                labelG && labelG.remove();
            }
        },

        isPointerGauge: function(){
            return true;
        },


        _dealSemiValueLabelContent:function(gauge, radius){
            var options = gauge.options, gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
            var domain = gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);
            var valueLabelStyle = options.valueLabel.style;
            var useHtml = options.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var endY = -(0.22 * radius + tickHeight/2) - valueLabelHeight;

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight),
                heightBoundsManager = boundsManager.heightBoundsManager,
                widthBoundsManager = boundsManager.widthBoundsManager;

            var visibleCount = 0;
            var valueBackgroundY = endY;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0, totalCount = gauge.valueLabelContent.length; i < totalCount; i++){
                var singleLabel = gauge.valueLabelContent[i];

                valueBackgroundY -= valueLabelHeight * (1 + this.LINE_GAP);

                var tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:endY - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;

                if(!gauge._boundsInCircle(tmpBounds)) {//主要是处理没有标签刻度的地方
                    valueBackgroundY += valueLabelHeight * (1 + this.LINE_GAP);
                    break;
                } else if(heightBoundsManager.isOverlapped(tmpBounds)){
                    valueBackgroundY += valueLabelHeight * (1 + this.LINE_GAP);
                    break;
                }

                while(widthBoundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);

                    tmpX = Math.min(-tmpDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:endY - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){//宽度上截断，省略处理
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);
                }

                valueBackgroundX = tmpX;

                visibleCount++;
            }

            gauge.valueLabelContent.length = visibleCount;

            for(var i = 0; i < visibleCount;i++){
                var singleLabel = gauge.valueLabelContent[i];
                singleLabel.labelPos = {
                    x:-singleLabel.labelDim.width/2,
                    y:valueBackgroundY + valueLabelHeight/2 + i * valueLabelHeight * (1 + this.LINE_GAP)
                };
            }

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height: valueLabelHeight * (1 + this.LINE_GAP) * visibleCount + valueLabelHeight
            };
        },

        _boundsInCircle: function (bounds) {
            var radius = this.radius, points = [
                {x:bounds.x, y:bounds.y},
                {x:bounds.x + bounds.width, y:bounds.y},
                {x:bounds.x, y:bounds.y + bounds.height},
                {x:bounds.x + bounds.width, y:bounds.y + bounds.height}];

            for(var i = 0; i < 4; i++){
                var point = points[i], diffX = Math.abs(point.x), diffY = Math.abs(point.y);
                if(Math.pow(diffX * diffX + diffY * diffY, 0.5) > radius){
                    return false;
                }
            }

            return true;
        },

        _getPointerTickBoundsManager:function(gaugeAxis, radius, scale, tickHeight){

            var widthBoundsManager = new BoundsManager();
            var heightBoundsManager = new BoundsManager();

            var labelR = (1 - 0.05 - 0.1 - 0.01) * radius;
            var tickData = gaugeAxis.tickData;
            var gauge = this, gap = tickHeight * 0.5;

            tickData.forEach(function(tick){

                var radian = scale(tick.tickValue);

                var center = gauge._getPointerTickCenter(tick, labelR, scale);

                gauge._addToBoundsManager(radian, {
                    x:center.x - tick.tickDim.width/2 - gap,
                    y:center.y - tick.tickDim.height/2 - gap,
                    width:tick.tickDim.width + gap,
                    height:tick.tickDim.height + gap
                }, widthBoundsManager, heightBoundsManager);

            });

            var minorTickData = gaugeAxis.getMinorTickData() || [];

            var minorTickR = (1 - 0.05 - 0.1) * radius;
            var minorTickSize = 0.1 * radius;

            minorTickData.forEach(function(minorTickValue){

                var radian = scale(minorTickValue);

                var point = gauge._getArcPoint(minorTickR, radian);

                var x, y;
                if(radian < Math.PI){
                    //右边
                    x = point[0];
                    y = point[1];

                }else{
                    //左边
                    x = point[0] - minorTickSize;
                    y = point[1];
                }

                gauge._addToBoundsManager(radian, {
                    x:x,
                    y:y,
                    width:minorTickSize,
                    height:minorTickSize
                }, widthBoundsManager, heightBoundsManager);
            });

            return {
                widthBoundsManager:widthBoundsManager,
                heightBoundsManager:heightBoundsManager
            };
        },

        //-45to45 -135to-180 135to180 控制高
        _addToBoundsManager: function (radian, bounds, widthBoundsManager, heightBoundsManager) {
            if(radian > -Math.PI/4 && radian < Math.PI/4){
                heightBoundsManager.addBounds(bounds);
            }
            if(radian < -Math.PI * 3/4 || radian > -Math.PI * 3/4){
                heightBoundsManager.addBounds(bounds);
            }
            widthBoundsManager.addBounds(bounds);
        },

        //指针仪表盘刻度标签相对于圆心的标签中心的位置
        _getPointerTickCenter:function(tick, labelR, scale){

            var radian = scale(tick.tickValue);

            var joinPoint = this._getArcPoint(labelR, radian);
            var x = joinPoint[0];
            var y = joinPoint[1];

            var tickDim = tick.tickDim;

            var angle = Math.atan(tickDim.width / tickDim.height);

            var labelCenterX, labelCenterY;
            if(Math.abs(radian) < angle){

                var gap = tickDim.height/2;
                labelCenterX = x + gap * x / y;
                labelCenterY = y + gap;

            }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                var gap = tickDim.width/2;
                labelCenterX = x - gap;
                labelCenterY = y - gap * y / x;

            }else if(radian >= angle - Math.PI && radian <= -angle){//左

                var gap = tickDim.width/2;
                labelCenterX = x + gap;
                labelCenterY = y + gap * y / x;

            }else{
                //下
                var gap = tickDim.height/2;
                labelCenterX = x - gap * x / y;
                labelCenterY = y - gap;
            }

            return {
                x:labelCenterX,
                y:labelCenterY
            }
        },

        animateLabelPara:function () {
            var series = this;
            return{enabled:true, initAttr:{'transform': BaseUtils.makeTranslate({x:-series.valueLabelBackground.width, y:0})}};
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
                this.hingePath = renderer.path().addTo(group);

                this.labelGroup = this._getPointTextLabelGroup();

                this.axisGroup = this.labelGroup;
                this.needleGroup = renderer.group().addTo(group);
                this.pointerHingePath = renderer.path().addTo(group);
            }

            // 注册series的events
            vanchart.registerInteractiveTarget(this, group);

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.dropFilter){
                this.dropFilter =  renderer.createDropShadowFilter(0, 2, 0.1, 2);
                this.innerFilter = renderer.createInnerShadowFilter(0, 2, 0.1, 2);
            }

            this.options.style == 'pointer' ? this._drawPointer(180,0.16,0.07) : this._drawPointer(98,0.11,0.055);
        },

        onSeriesPress:function(){

            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.options.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.options.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius * 1.25);
            this.hingePath.attr('d', circle());

            //枢纽
            circle.outerRadius(hinge * this.radius * 1.25);
            this.pointerHingePath.attr('d', circle());
        },

        onSeriesPressUp:function(){

            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.options.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.options.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius);
            this.hingePath.attr('d', circle());

            //枢纽
            circle.outerRadius(hinge * this.radius);
            this.pointerHingePath.attr('d', circle());
        },

        _getScale:function(){
            var series = this, style = series.options.style, scaleAngle = style == 'pointer' ? POINTER_ANGLE : POINTER_SEMI_ANGLE;
            var domain = series.gaugeAxis.scale.domain();
            return Scale.linear().domain(domain).range([BaseUtils.toRadian(-scaleAngle), BaseUtils.toRadian(scaleAngle)]);
        },

        getStyle:function(point){
            var options = point.options;
            return {
                'fill':options.needle,
                'fill-opacity':ColorUtils.getColorOpacity(options.needle)
            };
        },

        getHighLightStyle:function(point){
            var options = point.options;
            return {
                'fill':ColorUtils.getHighLightColor(options.needle)
            };
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getPointGraphicGroup:function(){
            return this.needleGroup;
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series, scale = series._getScale();

            return {
                duration:series.ANIMATION_TIME,
                ease:series.EASE_TYPE,
                attrTween:{'d':function(){

                    var lastAngle = this._current_ || scale.domain()[0];
                    this._current_ = BaseUtils.getValueInDomain(point.value, scale.domain());

                    var interpolate = Interpolator(lastAngle, this._current_);

                    return function(t){
                        return series._getArrowPath(interpolate(t));
                    }
                }}
            };
        },

        getPointUpdateAnimationAttr:function(point){
            return this.getPointInitAnimationAttr(point)
        },

        _getArrowPath:function(y){
            var initRadian = this._getScale()(y);
            var radius = this.radius;
            var p0 = this._getArcPoint(0.9 * radius, initRadian);
            var p1 = this._getArcPoint(0.02 * radius, initRadian + Math.PI/2);
            var p2 = this._getArcPoint(0.02 * radius, initRadian - Math.PI/2);
            return 'M' + p0[0] + ',' + p0[1] + 'L' + p1[0] + ',' + p1[1] + 'L' + p2[0] + ',' + p2[1] + 'Z';
        },

        _drawPointer:function(baseAngle, hBackground, hinge){
            var series = this, options = series.options, radius = series.radius;
            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = PathGenerator.arc().startAngle(BaseUtils.toRadian(-baseAngle))
                .endAngle(BaseUtils.toRadian(baseAngle))
                .innerRadius(0).outerRadius(radius).toCenter(false);

            series.backgruondPath.attr('d', arc()).style({
                'fill':options.paneBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.paneBackgroundColor),
                'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });

            //枢纽背景
            circle.outerRadius(hBackground * radius);
            series.hingePath.attr('d', circle()).style({
                'fill' : options.hingeBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.hingeBackgroundColor),
                'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
            });

            this._drawPointerTicks();

            this._drawGaugeLabels(series.labelGroup);
            //枢纽
            circle.outerRadius(hinge * radius);
            series.pointerHingePath.attr('d', circle()).style({
                'fill':options.hinge,
                'fill-opacity':ColorUtils.getColorOpacity(options.hinge),
                'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });
        },

        _drawPointerTicks:function(){
            var series = this, bands = series.defaultBands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.axisGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var tickR = (1 - 0.05) * series.radius, labelR = (1 - 0.05 - 0.1 - 0.01) * series.radius;

            var scale = this._getScale();

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function(d){return scale(d.tickValue);});
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (BaseUtils.hasDefined(d.tickContent)) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for(i = 0, len = currentTickLines.length; i < len; i++){

                var tick = currentTickLines[i], tickD = tick.datum();

                var radian = scale(tickD.tickValue);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.1 * series.radius, radian);

                var color = series._getColorFromBands(tickD.tickValue, bands);

                tick.attr('x1', start[0]).attr('y1', start[1]).attr('x2', end[0]).attr('y2', end[1])
                    .style({'stroke':color, 'stroke-width':1});

                var center = series._getPointerTickCenter(tickD, labelR, scale);

                tick.text && tick.text
                    .textContent(tickD.tickContent).style(BaseUtils.clone(labelStyle))
                    .attr({
                        x: center.x - tickD.tickDim.width/2,
                        y: center.y - tickD.tickDim.height/2,
                        dy: '.85em'
                    });
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for(i = 0, len = currentTickLines.length; i < len; i++){
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var radian = scale(value);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.05 * series.radius, radian);
                var color = series._getColorFromBands(value, bands);
                tickLine.attr('x1', start[0]).attr('y1', start[1])
                    .attr('x2', end[0]).attr('y2', end[1]).style({'stroke':color, 'stroke-width':1});
            }
        },

        _onPointMouseOver:function(point) {
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point.graphic, true, style);
        },

        _onPointMouseOut:function(point) {
            var series = point.series, style = series.getStyle(point);

            //arguments[1]主要是控制ease && duration.指针类型的over out都是0.2 ease，所以第二个参数也用true
            series._onState(point.graphic, true, style);
        }

    });

    require('../ChartLibrary').register(Constants.POINTER_GAUGE, PointerGauge);
    require('../ChartLibrary').register(Constants.POINTER_SEMI_GAUGE, PointerGauge);

    return PointerGauge;
});


/**
 * Created by eason on 16/8/9.
 * 刻度槽仪表盘
 */

define('chart/SlotGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','../utils/PathGenerator','../utils/Scale','./Gauge','../utils/Interpolator','../component/FormattedText','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var PathGenerator = require('../utils/PathGenerator');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');
    var Interpolator = require('../utils/Interpolator');
    var FormattedText = require('../component/FormattedText');

    var SlotGauge = Gauge.extend({

        gaugeType:Constants.SLOT_GAUGE,

        _getFixedPos:function(datum, divDim){
            var gauge = datum.series;
            var x = gauge.centerX + gauge.radius * 1.08 + 10;
            var y = gauge.centerY - divDim.height/2;
            return [x, y];
        },

        _dealValueLabel:function(){
            var series = this, options = series.options, point = series.points[0];

            var valueLabel = options.valueLabel, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;

            series.valueLabelContent = '';

            if(!point || point.isNull){
                return;
            }

            if(valueLabel && valueLabel.enabled) {
                var labelContent = FormattedText.createMultiLineLabelContent(formatter, point);
                var labelStyle = valueLabel.style;
                var valueLabelContent = [];
                for(var i = 0, len = labelContent.length; i < len; i++){
                    valueLabelContent.push({
                        labelContent:labelContent[i],
                        labelStyle:labelStyle,
                        labelDim:BaseUtils.getTextDimension(labelContent[i], labelStyle, useHtml)
                    });
                }
                series.valueLabelContent = valueLabelContent;
            }
        },

        _fixCenterAndRadius:function(){
            var gauge = this, options = gauge.options, radius = options.radius;
            if (!gauge.center) {
                var bounds = gauge.bounds;

                if(!radius){
                    radius = Math.min(bounds.width / 2, bounds.height / 2);
                    //刻度槽的宽度是0.16倍的半径
                    radius = radius / 1.08 - gauge.DEFAULT_PADDING;
                }

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }else{
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
                gauge.radius = radius;
            }

            if(gauge.percentageLabelContent && gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                };

                var startY = 0;
                for(var i = 0, count = gauge.valueLabelContent.length; i < count; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };

                    startY += (valueLabel.labelDim.height * (1 + gauge.LINE_GAP))
                }

            }else if(gauge.percentageLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height/2
                };

            }else if(gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                var labelHeight = BaseUtils.getTextHeight(options.valueLabel.style);
                var labelCount = gauge.valueLabelContent.length;

                var totalHeight = labelHeight * labelCount + labelHeight * (labelCount - 1) / 2;

                var startY = - totalHeight / 2;

                for(var i = 0; i < labelCount; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };
                    startY += (labelHeight * (1 + gauge.LINE_GAP));
                }
            }
        },

        drawSeries:function(){
            var series = this, options = series.options, point = series.points[0],
                vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
            }

            if (!this.slotBackground) {
                this.slotBackground = renderer.path().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.innderShadow){
                this.innderShadow = renderer.createInnerShadowFilter(0, 2, 0.05, 0);
                this.dropShadow = renderer.createDropShadowFilter(0, 2, 0.05, 0);
            }

            var arc = PathGenerator.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var circle = PathGenerator.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var domain = series.gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-135), BaseUtils.toRadian(135)]);

            series.backgruondPath.attr('d', circle())
                .style({
                    'fill':'none',
                    'stroke': options.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': series.radius * 0.16,
                    'filter':'url(#'+ BaseUtils.stamp(this.innderShadow) +')'
                });

            if(!point || point.isNull){
                if (series.slotBackground) {
                    series.slotBackground.remove();
                    series.needlePath.remove();
                    series.slotBackground = series.needlePath = null;
                }
                series._removeNormalLabels(this.labelGroup);
            } else {

                var initRadian = scale(domain[0]), endRadian = scale(BaseUtils.getValueInDomain(point.value, domain));
                var endDegree = BaseUtils.toDegree(endRadian - initRadian);
                var startStroke = series._getColorFromBands(domain[0], series.defaultBands);
                var endStroke = point.color;

                series.slotBackground.style({
                    'fill': 'none',
                    'stroke': ColorUtils.colorToHex(endStroke),
                    'stroke-linecap': 'round',
                    'stroke-width': series.radius * 0.16
                });

                //白色指针
                var cP = this._getArcPoint(series.radius, initRadian);
                series.needlePath.attr('cx', cP[0]).attr('cy', cP[1])
                    .attr('r', 0.048 * series.radius)
                    .style({
                        'fill': options.needle,
                        'fill-opacity': ColorUtils.getColorOpacity(options.needle),
                        'filter': 'url(#' + BaseUtils.stamp(this.dropShadow) + ')'
                    });

                if (series.vanchart.renderer.isAnimation) {

                    series.slotBackground.animate({
                        duration: series.ANIMATION_TIME,
                        ease: series.EASE_TYPE,
                        attrTween: {
                            'd': function () {
                                this._lastRadian_ = this._lastRadian_ || initRadian;
                                var interpolate = Interpolator(this._lastRadian_, endRadian);
                                this._lastRadian_ = endRadian;
                                return function (t) {
                                    return arc.endAngle(interpolate(t))();
                                }
                            }
                        }
                    });

                    series.needlePath.animate({
                        duration: series.ANIMATION_TIME,
                        ease: series.EASE_TYPE,
                        attrTween: {
                            'transform': function () {
                                this._lastRotate_ = this._lastRotate_ || 0;
                                var interpolate = Interpolator(this._lastRotate_, endDegree);
                                this._lastRotate_ = endDegree;
                                return function (t) {
                                    return "rotate(" + interpolate(t) + ")";
                                }
                            }
                        }
                    });

                } else {
                    //todo ie bug
                    var pathStr = arc.endAngle(endRadian)();
                    var pos = series._getArcPoint(series.radius, endRadian);
                    var x = pos[0], y = pos[1], r = series.radius * 0.008;

                    if (Math.abs(endRadian - initRadian) < 1e-6) {
                        var arc = 'a' + r + ',' + r + ' 0 1,0 ';
                        pathStr = 'M' + (x - r) + ',' + y + arc + (r * 2) + ',0 ' + arc + (-r * 2) + ',0 ';
                    }

                    series.slotBackground.attr('d', pathStr);
                    series.needlePath.attr({'cx': pos[0], 'cy': pos[1]});
                }
            }

            this._drawGaugeLabels(this.labelGroup);
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var point = this.points[0];
            if(point){

                var backgroundColor = ColorUtils.getHighLightColor(point.color);
                var needleColor = ColorUtils.getHighLightColor(this.options.needle);

                this._onState(this.slotBackground, true, {'stroke':ColorUtils.colorToHex(backgroundColor)});
                this._onState(this.needlePath, true, {'fill':needleColor});
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.slotBackground, false, {'stroke':point.color});
                this._onState(this.needlePath, false, {'fill':point.options.needle});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                var backgroundColor = ColorUtils.getColorWithDivider(point.color, 1/0.95);
                var needleColor = ColorUtils.getColorWithDivider(this.options.needle, 1/0.95);

                this.slotBackground.style({'stroke':ColorUtils.colorToHex(backgroundColor)});

                this.needlePath.style({'fill':needleColor});
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.SLOT_GAUGE, SlotGauge);

    return SlotGauge;
});

/**
 * Created by eason on 16/8/9.
 * 环形仪表盘
 */

define('chart/RingGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','./Gauge','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var Gauge = require('./Gauge');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolator = require('../utils/Interpolator');

    var RingGauge = Gauge.extend({

        gaugeType:Constants.RING_GAUGE,

        _fixCenterAndRadius:function(){
            var gauge = this, options = gauge.options, radius = options.radius, centerX, centerY;
            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
            }else{
                var bounds = gauge.bounds;
                radius = radius || (Math.min(bounds.width/2, bounds.height/2) - gauge.DEFAULT_PADDING);
                centerX = bounds.x + bounds.width/2;
                centerY = bounds.y + bounds.height/2;
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;

            var totalHeight = 0;
            var valueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            if(gauge.percentageLabelContent && valueLabel){
                totalHeight = gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP) + valueLabel.labelDim.height;
            }else if(gauge.percentageLabelContent){
                totalHeight = gauge.percentageLabelDim.height;
            }else if(valueLabel){
                totalHeight = valueLabel.labelDim.height;
            }

            var startY = -totalHeight/2;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos = {
                    x: -gauge.percentageLabelDim.width/2,
                    y:startY
                };

                startY += gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP);
            }

            if(valueLabel){
                valueLabel.labelPos = {
                    x:-valueLabel.labelDim.width/2,
                    y:startY
                };
            }
        },

        drawSeries:function(){
            var series = this, options = series.options,  vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
            }

            if (!this.ringPath) {
                this.ringPath = renderer.path().addTo(group);
            }

            if (!this.innerBackgroundPath) {
                this.innerBackgroundPath = renderer.path().addTo(group);
                this.innerStroke = renderer.path().addTo(group);
                this.outerStroke = renderer.path().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.colorGradient){
                var attrs = {'x1':'0%', 'y1':"0%", 'x2':"0%", 'y2':"100%"};
                var stop1 = {'offset':'0%', 'stop-color':'#ffffff'};
                var stop2 = {'offset':'100%', 'stop-color':'#dddddd'};
                this.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);


                stop1['stop-color'] = '#dddddd';
                stop2['stop-color'] = '#ffffff';
                this.clickedGradient = renderer.colorGradient(attrs, [stop1, stop2]);

                if(!BaseUtils.isSupportSVG()){
                    this.colorGradient = '#ffffff';
                    this.clickedGradient = '#dddddd';
                }
            }
            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0).outerRadius(series.radius);
            var domain = series.gaugeAxis.scale.domain();
            var startFill = series._getColorFromBands(domain[0], series.defaultBands);
            var innerR = series.radius * 0.8;
            var outerStrokeR = innerR + 2, innerStrokeR = innerR - 1.5;

            this.backgruondPath.attr('d', circle()).style({
                'fill':options.paneBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.paneBackgroundColor)
            });

            var point = series.points[0];
            if(point) {
                var arc = PathGenerator.arc().startAngle(0).innerRadius(0).outerRadius(series.radius);
                var endFill = point.color, arcPercentage = Math.max(point.percentage, 0);
                var endRadian = 2 * Math.PI * arcPercentage * (options.clockwise ? 1 : -1);
                this.ringPath.style({
                    'fill': ColorUtils.colorToHex(endFill),
                    'fill-opacity': ColorUtils.getColorOpacity(endFill)
                });

                this.ringPath.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attrTween:{'d':function(){
                        this._lastRadian_ = this._lastRadian_ || 0;
                        var interpolate = Interpolator(this._lastRadian_, endRadian);
                        this._lastRadian_ = endRadian;

                        return function (t) {
                            return arc.endAngle(interpolate(t))();
                        }
                    }}
                });
            } else {
                if (this.ringPath) {
                    this.ringPath.remove();
                    this.ringPath = null;
                }
            }

            this.innerBackgroundPath.attr('d', circle.outerRadius(innerR)())
                .style({
                    'fill':options.innerPaneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(options.innerPaneBackgroundColor)
                });

            this.outerStroke.attr('d', circle.outerRadius(outerStrokeR)())
                .style({'fill': 'none', 'stroke':'#000000', 'stroke-opacity':0.05, 'stroke-width':4 });

            this.innerStroke.attr('d', circle.outerRadius(innerStrokeR)())
                .style({
                    'fill': 'none',
                    'stroke':this._getStroke(this.colorGradient),
                    'stroke-width':3
                });


            this._drawGaugeLabels(this.labelGroup);
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.innerStroke, true, {'stroke':this._getStroke(this.colorGradient)});
                this._onState(this.ringPath, true, {'fill': point.mouseOverColor});
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.innerStroke, false, {'stroke':this._getStroke(this.colorGradient)});
                this._onState(this.ringPath, false, {'fill': point.color});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.innerStroke.style({'stroke':this._getStroke(this.clickedGradient)});
                this.ringPath.style({'fill': point.clickColor});
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.RING_GAUGE, RingGauge);

    return RingGauge;
});
/**
 * Created by eason on 16/8/9.
 * 
 */

define('chart/ThermometerGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','../utils/Scale','./Gauge','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;
    var DEFAULT_RADIUS = 100;
    var MAGIC_DET = 0.001;

    var lastLabelShiftLength;  // 上一次标签绘制时距离端点的长度

    var ThermometerGauge = Gauge.extend({

        gaugeType:Constants.THERMOMETER_GAUGE,

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var point = this.points[0];

            if(!point || point.isNull){
                return;
            }

            var domain = this.gaugeAxis.scale.domain();

            var vertical = this.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var scale = Scale.linear().domain(domain).range(
                vertical ? [this.radius , -this.radius] : [ -this.radius , this.radius]);
            var index = scale(point.y);

            var centerX = vertical ? 0 - THERMOMETER_R * 2 + 10 : index;
            var centerY = vertical ? index : 0 - THERMOMETER_R * 2 + 10;

            function f(a, b) {
                return a - b/2;
            }

            var gauge = this; 
            var baseX = gauge.centerX; 
            var baseY = gauge.centerY; 
 
            this._showMoreLabel(point, centerX + baseX, centerY + baseY, f, f); 
        },

        _fixCenterAndRadius:function(){
            var point = this.points[0];
            var gauge = this;
            var para = gauge.options.thermometerLayout == Constants.HORIZONTAL_LAYOUT ?
                this._fixHorizontalThermometerCenter() : this._fixVerticalThermometerCenter();

            var centerX = para.centerX;
            var centerY = para.centerY;
            var radius = para.radius;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos.x -= centerX;
                gauge.percentageLabelPos.y -= centerY;

                //与底边对齐
                gauge.percentageLabelPos.y = Math.min(gauge.percentageLabelPos.y, radius - gauge.percentageLabelDim.height);
            }

            if(showValueLabel){
                showValueLabel.labelPos.x -= centerX;
                showValueLabel.labelPos.y -= centerY;

                var gap = (radius - showValueLabel.labelDim.height) - showValueLabel.labelPos.y;

                //与底边对齐
                if(gap < 0){
                    showValueLabel.labelPos.y += gap;

                    if(gauge.percentageLabelContent){
                        gauge.percentageLabelPos.y += gap;
                    }
                }
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;
        },

        _fixHorizontalThermometerCenter:function(){

            var gauge = this, options = gauge.options, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = options.percentageLabel, valueLabel = options.valueLabel;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var centerX, centerY, radius = gauge.options.radius;

            var totalHeight = this._getThermometerSize();
            var startY;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                startY = centerY;
            } else {
                var bounds = gauge.bounds;
                startY = bounds.y + (bounds.height - totalHeight)/2;
                centerX = bounds.x + bounds.width/2;
                radius = radius || (bounds.width/2 - gaugeAxis.getMaxTickWidth() - gauge.DEFAULT_PADDING);
            }

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.TOP && valueLabel.align == Constants.TOP){

                    if (gauge.center) {
                        startY -= (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));
                        startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                        startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                    }

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));


                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }

                    if(showValueLabel && valueLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }
                }
            }

            if (gauge.center) {
                startY = centerY + 5;
            } else {
                startY += (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R * 2);
                centerY = startY - 5;
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.BOTTOM && valueLabel.align == Constants.BOTTOM){
                    startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.BOTTOM){

                        startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                    }

                    if(showValueLabel && valueLabel.align == Constants.BOTTOM){

                        startY += (showValueLabel.labelDim.height * gauge.HORIZONTAL_GAP);

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                    }
                }

            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixVerticalThermometerCenter:function(){
            var gauge = this, options = gauge.options, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = options.percentageLabel, valueLabel = options.valueLabel;
            var centerX, centerY, radius = options.radius;

            var point = gauge.points[0];
            var domain = gaugeAxis.scale.domain();
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            //纵向布局
            var totalWidth = this._getThermometerSize();
            var startX;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                startX = centerX - THERMOMETER_R * 2;
            } else {
                var bounds = gauge.bounds;
                startX = bounds.x + (bounds.width - totalWidth)/2;
                centerY = bounds.y + bounds.height/2;
                radius = radius || (bounds.height/2 - gaugeAxis.getTickHeight() - gauge.DEFAULT_PADDING);
            }

            var scale = Scale.linear().domain(domain).range([radius, -radius]);
            var labelY = centerY + scale(BaseUtils.getValueInDomain(point.value, domain));

            if(gauge.percentageLabelDim){
                labelY -= gauge.percentageLabelDim.height/3;//差不多居中的位置
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.LEFT && valueLabel.align == Constants.LEFT){

                    if (!gauge.center) {
                        startX += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        centerX = startX + THERMOMETER_R;
                    }

                    gauge.percentageLabelPos = {
                        x:startX - gauge.percentageLabelDim.width,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX - showValueLabel.labelDim.width,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                        }

                        gauge.percentageLabelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                    }

                    if(showValueLabel && valueLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                        }

                        showValueLabel.labelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                    }
                }
            }

            if (gauge.center) {
                startX = centerX - THERMOMETER_R;
            } else {
                centerX = startX + THERMOMETER_R;
            }

            startX += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getMaxTickWidth());

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.RIGHT && valueLabel.align == Constants.RIGHT){

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                    gauge.percentageLabelPos = {
                        x:startX,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.RIGHT){
                        gauge.percentageLabelPos = {
                            x:startX + gauge.LINE_GAP * gauge.percentageLabelDim.height,
                            y:labelY
                        };
                    }

                    if(showValueLabel && valueLabel.align == Constants.RIGHT){

                        showValueLabel.labelPos = {
                            x:startX + gauge.LINE_GAP * showValueLabel.labelDim.height,
                            y:labelY
                        };
                    }
                }
            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        //试管仪表盘占据的大小,不算间隔
        _getThermometerSize:function(){

            var gauge = this, options = gauge.options, valueLabel = options.valueLabel, gaugeAxis = gauge.gaugeAxis;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var percentageLabel = options.percentageLabel;

            if(gauge.options.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                var totalHeight = 0;

                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalHeight += (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                        totalHeight += gauge.LINE_GAP * gauge.percentageLabelDim.height;

                        totalHeight += gauge.HORIZONTAL_GAP * (valueLabel.align == Constants.TOP
                                ? showValueLabel.labelDim.height : gauge.percentageLabelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * gauge.percentageLabelDim.height;
                }else if(showValueLabel){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * showValueLabel.labelDim.height;
                }

                totalHeight += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getTickHeight());

                return totalHeight;

            }else{

                var totalWidth = 0;
                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalWidth += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);
                    }else{
                        totalWidth += (gauge.percentageLabelDim.width + showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalWidth += (gauge.percentageLabelDim.width + gauge.VERTICAL_GAP * gauge.percentageLabelDim.height);
                }else if(showValueLabel){
                    totalWidth += (showValueLabel.labelDim.width + gauge.VERTICAL_GAP * showValueLabel.labelDim.height);
                }

                totalWidth += gaugeAxis.getMaxTickWidth();

                totalWidth += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP);

                return totalWidth;
            }

            return DEFAULT_RADIUS;
        },

        /**
         * 在绘制标签的过程中，我们需要计算标签相对当前位置的偏移位置，来作为标签数是动画初始的位置
         * 在试管横放的时候，标签的位置为试管长度的一半，即试管中心位置，
         * 试管竖放的时候，标签的位置与当前的数据点高度齐平。
         * 而默认的标签起始位置为试管的最小的一端端点，这样就可以计算出相对于当前位置的动画初始偏移位置
         * 这里值得一提的是，数据刷新时，标签的位置，应该从上次的位置开始，而非试管的端点，
         * 由于该方法可能会被seriesLabel和valueLabel调用，因此只在绘制标签后更新lastShiftLength（上一次的标签距离端点的偏移长度）
         * @returns {{enabled: boolean, initAttr: {transform: *}, initStyle: {opacity: number}}}
         */
        animateLabelPara:function () {
            var series = this, point = series.points[0];
            var gaugeAxis = series.gaugeAxis, domain = gaugeAxis.scale.domain(), isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var valueInDomain = BaseUtils.getValueInDomain(point.value, domain), radius = series.radius;
            var scale = Scale.linear().domain(domain).range([0, 2 * radius]);

            // 标签位置距离端点的长度
            var shiftLength = isVertical ? scale(valueInDomain) : -radius;
            // 实时更新lastLabelShiftLength
            lastLabelShiftLength = shiftLength;
            // 使用和上一次偏移距离的差值，作为drawLabel动画的initAttr
            shiftLength -= this._lastShiftLength || 0;
            // 摆放方向不同，对应的偏移属性也不一样
            var pos = isVertical ? {x: 0, y: shiftLength} : {x: shiftLength, y: 0};

            return{enabled:true, initAttr:{'transform': BaseUtils.makeTranslate(pos)}, initStyle:{'opacity':0}};
        },

        // 标签绘制结束时，更新lastLabelPos
        updateLastLabelPos: function (){
            this._lastShiftLength = lastLabelShiftLength;
        },

        _fillFilter:function (color, useAlpha) {
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer,
                isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            if(BaseUtils.isSupportSVG()) {
                var endColor = color;
                var startColor = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);
                if(useAlpha) {
                    var alpha = ColorUtils.getStandardColorAndOpacity(endColor).alpha;
                    if (alpha < 1) {
                        startColor = ColorUtils.mixColorWithAlpha(startColor, alpha);
                    }
                }

                var x2 = '0%', y2 = '0%';
                isVertical ? y2 = '100%' : x2 = '100%';
                var stop1 = {'offset': '0%', 'stop-color': isVertical ? endColor : startColor};
                var stop2 = {'offset': '100%', 'stop-color': isVertical ? startColor : endColor};
                var attr = {'x1': '0%', 'y1': '0%', 'x2': x2, 'y2': y2};
                if (this.colorGradient) {
                    renderer.updateColorGradient(this.colorGradient, attr, [stop1, stop2]);
                } else {
                    this.colorGradient = renderer.colorGradient(attr, [stop1, stop2]);
                }

                return "url(#" + BaseUtils.stamp(this.colorGradient) + ")";
            }
            return color;
        },

        _clickEndColor:function (point) {
            return ColorUtils.getColorWithDivider(point.color, 1/0.95);
        },

        _mouseOverEndColor:function (point) {
            return ColorUtils.getColorWithDivider(point.mouseOverColor, 1/0.95);
        },

        drawSeries:function(){
            var series = this, options = series.options, point = series.points[0],
                vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            var gaugeAxis = series.gaugeAxis, domain = gaugeAxis.scale.domain(), isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var valueInDomain = BaseUtils.getValueInDomain(point.value, domain), radius = series.radius;

            if(!this.backgruondLine){
                this.backgruondLine = renderer.line().addTo(group);
                this.axisGroup = renderer.group().addTo(group);
            }

            if (!this.thermometerLine) {
                this.thermometerLine = renderer.line().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            var scale = Scale.linear().domain(domain).range([-radius, radius]);
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', cx = 'cx', cy = 'cy';

            var endX = scale(valueInDomain);
            var initX = -radius;

            if(isVertical){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';cx = 'cy'; cy = 'cx';
                initX = radius;
                endX = scale.range([radius, -radius])(valueInDomain);
            }

            var lastX = BaseUtils.pick(series.thermometerLine.node()._lastX_, initX);
            series.thermometerLine.node()._lastX_ = endX;

            series.backgruondLine.attr(x1, -radius).attr(y1, 0).attr(x2, radius).attr(y2, MAGIC_DET)
                .style({'fill':'none', 'stroke': options.slotBackgroundColor,
                    'stroke-width':THERMOMETER_R * 2, 'stroke-linecap':'round'});

            if (point.isNull) {
                if (this.thermometerLine) {
                    this.thermometerLine.remove();
                    this.needlePath.remove();
                    this.thermometerLine = this.needlePath = null;
                }

            } else {//为空的时候不画指针

                series.thermometerLine.attr(x1, initX).attr(y1, 0).attr(y2, MAGIC_DET).attr(x2, lastX)
                    .style({
                        'stroke':series._fillFilter(point.color, true),
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    });

                series.needlePath.attr('r', THERMOMETER_R * 0.9).attr(cx, lastX).attr(cy, 0)
                    .style({
                        'fill': options.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(options.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke': series._needleStrokeColor(point)
                    });

                var attr = {}; attr[x2] = endX;
                series.thermometerLine.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attr:attr
                });

                attr = {}; attr[cx] = endX;
                series.needlePath.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attr:attr
                });
            }

            this._drawGaugeLabels(this.labelGroup);
            this._drawThermometerTicks(scale);
        },

        _needleStrokeColor:function(point){
            //文档
            return ColorUtils.mixColorWithHSB(point.color, 0, 0.1, -0.1);
        },

        _drawThermometerTicks:function(scale) {
            var series = this, bands = series.options.bands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.labelGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';

            var startY = -9, endY = -15, endMinorY = -13;
            var textY = -19;

            var attrFunc = function (tickD, posX) {
                return {
                    x: posX - tickD.tickDim.width / 2,
                    y: textY - tickD.tickDim.height * 0.85,
                    dy: '0.85em'
                }
            };

            if (series.options.thermometerLayout == Constants.VERTICAL_LAYOUT) {
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                startY = 9; endY = 15; endMinorY = 13;
                textY = 19;
                attrFunc = function (tickD, posX) {
                    return {
                        x: textY,
                        y: posX - tickD.tickDim.height / 2,
                        dy: '.85em'
                    }
                }
            }

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function (d) {
                return scale(d.tickValue);
            });
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (BaseUtils.hasDefined(d.tickContent)) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tick = currentTickLines[i], tickD = tick.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(tickD.tickValue), 1);

                tick.attr(x1, posX).attr(y1, startY).attr(x2, posX).attr(y2, endY)
                    .style({'stroke': axisOption.tickColor, 'stroke-width': axisOption.tickWidth});

                tick.text && tick.text.textContent(tickD.tickContent).style(labelStyle).attr(attrFunc(tickD, posX));
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for (i = 0, len = selection.exit.length; i < len; i++) {
                selection.exit[i].remove();
            }

            for (i = 0, len = selection.enter.length; i < len; i++) {
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(value), 1);
                tickLine.attr(x1, posX).attr(y1, startY)
                    .attr(x2, posX).attr(y2, endMinorY).style({
                    'stroke': axisOption.minorTickColor,
                    'stroke-width': axisOption.minorTickWidth
                });
            }
        },

        _getFixedPos:function(datum, divDim) {
            var gauge = datum.series, options = gauge.options;
            var thermometerLayout = gauge.options.thermometerLayout;
            var percentContent = gauge.percentageLabelContent, valueContent = gauge.valueLabelContent;

            var x, y;

            if(thermometerLayout == Constants.HORIZONTAL_LAYOUT){
                x = gauge.centerX - divDim.width/2;
                var baseY = gauge.centerY;
                y = baseY + THERMOMETER_R + 10;

                if(percentContent && percentContent.length && options.percentageLabel.align == Constants.BOTTOM){
                    y = baseY + gauge.percentageLabelPos.y + gauge.percentageLabelDim.height + 10;
                }

                if(valueContent && valueContent.length && options.valueLabel.align == Constants.BOTTOM){
                    var valueLabel = gauge.valueLabelContent[0];
                    y = baseY + valueLabel.labelPos.y + valueLabel.labelDim.height + 10;
                }

            }else{

                y = gauge.centerY - divDim.height/2;

                var tickWidth = gauge.gaugeAxis.getMaxTickWidth();

                var baseX = gauge.centerX;
                x = baseX + THERMOMETER_R + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + tickWidth + 10;

                if(percentContent && percentContent.length && options.percentageLabel.align == Constants.RIGHT){
                    x = baseX + gauge.percentageLabelPos.x + gauge.percentageLabelDim.width + 10;
                }

                if(valueContent && valueContent.length && options.valueLabel.align == Constants.RIGHT){
                    var valueLabel = gauge.valueLabelContent[0];
                    x = Math.max(x, baseX + valueLabel.labelPos.x + valueLabel.labelDim.width + 10)
                }
            }

            return [x, y];
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var series = this, point = this.points[0];
            if(point){
                series._onState(series.thermometerLine, true, {'stroke':series._fillFilter(series._mouseOverEndColor(point))});
                series._onState(series.needlePath, true, {
                    'stroke':ColorUtils.getHighLightColor(this._needleStrokeColor(point)),
                    'fill': ColorUtils.getHighLightColor(series.options.needle)
                });
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var series = this, point = series.points[0];
            if(point){
                series._onState(series.thermometerLine, false, {'stroke':series._fillFilter(point.color, true)});
                series._onState(series.needlePath, false, {'stroke': this._needleStrokeColor(point), 'fill': this.options.needle});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.thermometerLine.style('stroke', this._fillFilter(this._clickEndColor(point)));

                this.needlePath
                    .style({
                        'stroke':ColorUtils.getClickColor(point.color),
                        'fill': ColorUtils.getClickColor(this.options.needle)
                    });
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.THERMOMETER_GAUGE, ThermometerGauge);

    return ThermometerGauge;
});
/**
 * Created by Yuqian on 16/8/9.
 * 树状系列
 */

define('chart/TreeSeries',['require','./Series','../utils/BaseUtils','../utils/QueryUtils','../Constants','./Point','../dom/Evented'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');

    var LABEL_GAP = 2;

    var TreeSeries = Series.extend({

        refresh: function (options, index) {

            Series.prototype.refresh.call(this, options, index);

            //chart type specific attributes
            this._refresh();

            this._initChildren();

            return this;
        },

        // Tree data's key of children is varied,
        // so '_initChildren' may be varied;
        // 'visitBefore' is intended for initializing some property like colors;
        // 'visitAfter' for calculating.
        _initChildren: function () {

            this.traverseInitData(this.visitBefore, null);

            // make it as normal series
            this.points = this.root.children;
            this.root.options.tooltip = null;
        },

        _getPointKey: function (point) {
            return point.name;
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'value';
        },

        _getChildrenKey: function () {
            return 'children';
        },

        traverseData: function (root, visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            function dfsData(node, depth, parent, ancestor) {
                if (!node.children) {
                    node.children = node.options[series._getChildrenKey()];
                }
                var c = node.children;

                node.parent = parent;
                node.depth = depth;
                node.level = depth;
                node.height = 0;
                node.ancestor = ancestor;

                visitBefore && visitBefore.call(series, node);

                if (c && (n = c.length)) {
                    var i = -1, n;
                    while (++i < n) {

                        if ((c[i] instanceof  Point)) {
                            // c[i].refresh();
                        } else {
                            c[i] = new Point(c[i], root.series);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = c[i];
                        }

                        dfsData(c[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, c[i].visible ? c[i].height + 1 : 0);
                    }
                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(root, 0, null, null);
        },

        traverseInitData: function (visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            var rootOptions = {children:this.options.data, name:this.name};
            if(this.root){
                this.root.refresh(rootOptions);
            } else {
                this.root = new Point(rootOptions, series);
            }
            function dfsData(node, nodeOptions, depth, parent, ancestor) {

                var data = nodeOptions[series._getChildrenKey()];

                node.parent = parent;
                node.depth = depth;
                node.level = depth; // 下次全改成level好了→_→
                node.height = 0;
                node.ancestor = ancestor;
                node.seriesName = series.name;

                node.children = node.children || [];

                visitBefore && visitBefore.call(series, node);

                // todo, diff algorithm and unit test
                if(BaseUtils.hasDefined(data)) {
                    var newChildrens = [];
                    for (var i = 0, len = data.length; i < len; i++) {

                        var refresh = false;
                        var child;
                        if (node.children.length) {
                            node.children.forEach(function (point) {

                                var pointkey = series._getPointKey(point);

                                if (BaseUtils.hasDefined(pointkey) && (pointkey == series._getPointKey(data[i]))) {
                                    point._lastValue = point.options[series.getTargetKey()];
                                    point.refresh(data[i]);
                                    refresh = true;
                                    child = point;
                                    newChildrens.push(point);
                                }
                            });
                        }

                        if (!refresh) {
                            child = new Point(data[i], series);
                            newChildrens.push(child);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = child;
                        }

                        child.index = i;

                        dfsData(child, data[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, child.visible ? child.height + 1 : 0);
                    }

                    for (var j = 0, size = node.children.length; j < size;) {

                        if (BaseUtils.indexOf(newChildrens, node.children[j]) === -1) {
                            node.children[j].clearChild();
                            // child is removed in clearChild;
                            size--;
                        } else {
                            j++;
                        }
                    }

                    // parent: {value: 123} ----> parent: {children: [1,2,3], value: 123}
                    if (series.type === Constants.TREEMAP_CHART
                    && node.children.length === 0
                    && newChildrens.length) {
                        node.remove();
                        node.visible = true;
                    }

                    /**
                     * TODO
                     * 不好好搞个diff后患无穷……
                     *  I. data diff:
                     *     树状结构添删改
                     * II. data - dom diff:
                     *     现在data = dom，data删除即dom删除
                     *     但是如上，data保留，dom不需要，所以一一严格对应并不完全对
                     *     还是正紧搞diff好，也可提高dom效率
                     */


                    node.children = newChildrens;

                } else {
                    // parent: {children: [1,2,3], value: 123} ----> parent: {value: 123}
                    
                    var len = node.children.length;
                    while (--len > -1) {
                        node.children[len].clearChild();
                    }

                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(this.root, rootOptions, 0,  null, null);
        },


        visitBefore: function (node) {
            if (node.depth === 1) {
                node.color = this.vanchart.getDefaultSeriesColor(node.name);
            }
        },

        visitAfter: function () {

        },

        drawPoint:function (point, delay) {

            delay = delay || 0;

            var shouldBeVisible = point.isVisible();
            var currentVisibleState = point.graphic && point.graphic.isVisible();

            if (shouldBeVisible === currentVisibleState){

                point.graphic && this._drawUpdatePoints(point, delay);

            } else if (shouldBeVisible && !currentVisibleState) {

                this._drawEnterPoints(point);

            } else if (!shouldBeVisible && currentVisibleState){

                this._drawExitPoints(point);

            }
        },

        _calculatePercentage:function(points, key){
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d[key]);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.percentage = Math.abs(point[key]) / total;
            });
        },

        _onPointMouseOver: function (point) {
            var series = point.series,
                vanchart = series.vanchart, hoverPoint = vanchart.hoverPoint;
            
            if (hoverPoint) {
                this._onPointMouseOut(hoverPoint);
            }

            if (!point.depth) {
                return;
            }
            series.onPointMouseOver(point);
            vanchart.hoverPoint = point;
        },

        _onPointMouseOut: function (point) {
            var series = point.series;
            series.onPointMouseOut(point);
            series.vanchart.hideTooltip();
        },

        isSeriesAccumulated:function(){
            return true;
        },

        getLegendKey:function(point){
            var parent = point.parent;
            while(parent && parent.parent != this.root){
                parent = parent.parent;
            }
            return parent ? parent.name : '';
        },

        isTreeSeries:function(){
            return true;
        }
    });

    return TreeSeries;
});
/**
 * Created by Jeffrey on 16/6/15.
 */

define('chart/MultiPie',['require','../Constants','../utils/BaseUtils','../utils/Scale','./TreeSeries','./PieSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','./Point','../utils/BezierEasing','../EffectHelper','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var TreeSeries = require('./TreeSeries');
    var PieSeries = require('./PieSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Point = require('./Point');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');

    var INNER_RADIUS_PCT = 2 / 3;
    var INNER_RING_RADIUS = 15;
    var INNER_RING_STROKE_WIDTH = 5;

    var CIRCLE = 2 * Math.PI;

    var HOVER_PERCENT = 1.1;

    var VIS_MIN = 1E-10;

    var ANIMATION_TIME = 1000;
    var INNER_HOVER_TIME = 300;
    var SORT_TIME = 400;

    var EASE = 'bounce';
    var INNER_HOVER_EASE = Bezier.css.swing;
    var SORT_EASE = Bezier.css.swing;

    var MultiPie = TreeSeries.extend(PieSeries).extend({

        // prop list
        //
        // nodes: [],
        //
        // root: null,
        //
        // ordered: null,
        //
        // drilldownNow: null,
        //
        // // for convenient
        // center: [],
        // innerRadius: null,
        // radius: null,
        // startAngle: null,
        // endAngle: null,
        // drilldown: null,
        // rotatable: null,
        //
        // chartInfo: {},

        arc: PathGenerator.arc()
            .startAngle(function (d) { return d.x; })
            .endAngle(function (d) { return d.x + d.dx; })
            .innerRadius(function(d) { return d.y;})
            .outerRadius(function(d) { return d.y + d.dy;}),

        _refresh: function () {

            this.chartInfo = {rotate: 0};
            this.sx = Scale.linear();
            this.sy = Scale.linear();

        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                var orderType = this.orderType;

                // #orderData
                c.sort(function(a, b){
                    if (orderType && a.value != null && b.value != null) {
                        return orderType * (Math.abs(a.value) - Math.abs(b.value));
                    } else {
                        return a.index - b.index;
                    }
                });

                node.chSum = Math.max(chSum, Math.abs(_value || 0));
            }

            node.value = _value || node.chSum || 0;

            if (!node.visible) {
                // value is visible size
                // chSum is hold size(include blank)
                node.value = 0;
                node.chSum = 0;
            }
        },

        _visitBefore: function (node) {
            node.isNull = false;
            if (!node.depth) {
                return;
            }

            if (node.depth === 1) {
                node.points = [node];
            } else {
                node.points = node.parent.points.slice();
                node.points.push(node);
            }
        },

        doLayout: function () {

            var series = this;

            var center = [], bounds;
            var plotBounds = this.vanchart.bounds;
            var options = series.options;
            if (!options.center || options.center.length === 0) {
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            } else {
                center[0] = this._getPercentValue(options.center[0], this.vanchart.width);
                center[1] = this._getPercentValue(options.center[1], this.vanchart.height);
            }

            bounds = {x: plotBounds.x, y: plotBounds.y, width: plotBounds.width, height: plotBounds.height};

            series.chartInfo.innerRadius = options.innerRadius;
            series.chartInfo.center = center;
            series.chartInfo.bounds = bounds;

            this.traverseData(this.root, this._visitBefore, this.visitAfter);

            this._initData(series);

            // recover when series dis/hide,
            this.drilldownNow = this.root;

        },

        _initData: function (series) {

            series.nodes = series._bfsTraverseData(series.root);

            // #orderData
            var oldGraphics = series.graphics;
            if (this._isOrderChanged()
                && oldGraphics
                && oldGraphics.length === series.nodes.length) {
                series.nodes.map(function (node, i) {
                    // exchange the displayed graphic
                    node._view = oldGraphics[i];
                });
            }

            var chartInfo = series.chartInfo;
            var options = series.options;

            var radius = chartInfo.radius || options.radius;

            if (radius) {
                series._calcData(series.root);
                series._calculateLabelPos();

            } else {
                // if no radius
                // calculated radius
                // thus calc only once

                var bounds = chartInfo.bounds;
                var center = chartInfo.center;
                chartInfo.radius = Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

                series._calcData(series.root);

                var outPoints = series.nodes.filter(function (node) {
                    return (node.depth &&
                        node.dx &&
                        node.options.dataLabels &&
                        node.options.dataLabels.enabled &&
                        node.options.dataLabels.align === Constants.OUTSIDE)
                });

                if (outPoints.length) {
                    chartInfo.radius = series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center);
                } else {
                    chartInfo.radius = Math.round(chartInfo.radius / HOVER_PERCENT);
                }

                series._calcData(series.root);

                series._calculateLabelPos();
            }

            series.sx = this.sx.range([this.startAngle, this.endAngle]).domain([this.startAngle, this.endAngle]);
            series.sy = this.sy.range([0, this.innerRadius, this.radius]).domain([0, this.innerRadius, this.radius]);

        },

        getDataToDraw: function () {
            return this.nodes;
        },

        orderData: function (para) {
            // #orderData
            // search '#orderData' in this file to get hint
            // some explain:
            // http://www.finedevelop.com/pages/viewpage.action?pageId=11243711
            this.orderType = para === true ?
                1 : para === false ?
                -1 : null;
            this._saveLastView();
        },

        _saveLastView: function () {
            this.graphics = this.nodes.map(function (node) {
                return node._view;
            });
        },

        _bfsTraverseData: function (root) {
            var queue = [];
            var stack = [];
            queue.push(root);

            while (node = queue.shift()) {
                var node;
                stack.push(node);
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        queue.push(children[i]);
                    }
                }
            }
            return stack;
        },

        _calcData: function (root) {
            var series = this;

            if (series.chartInfo.radius && series.options.innerRadius) {
                series.chartInfo.innerRadius = this._getPercentValue(series.options.innerRadius, series.chartInfo.radius);
            }

            var height = root.height;

            var radius = series.chartInfo.radius;
            var innerRadius = series.chartInfo.innerRadius;
            var gradual = series.options.gradual;
            var startAngle = series.startAngle;
            var endAngle = series.endAngle;

            var arc = endAngle - startAngle;

            var dRadius, innerPieR;

            // display !== options value
            // the first ring (depth = 1) radius depends on innerRadius
            if (innerRadius) {
                dRadius = height ? (radius - innerRadius) / height : 0;
                innerPieR = dRadius;
            } else {
                dRadius = (height > 1) ? radius * (1 - INNER_RADIUS_PCT) / (height - 1) : 0;
                innerPieR = (height > 1) ? radius * INNER_RADIUS_PCT : radius;
            }

            // hdx is 'hold dx', hdx >= dx, may leave blank.
            function dfsData(node, x, dx, hdx, dy, ir, iPr) {
                var children = node.children;

                // save last value for enter (dx 0)
                // note: if calculate twice,
                // it has no meaning
                node.x1 = node.x;
                node.y1 = node.y;
                node.dx1 = node.dx;
                node.dy1 = node.dy;

                // going to display
                node.x = x;
                node.y = (node.depth - 2) * dy + ir + iPr;
                node.dx = dx;
                node.hdx = hdx;
                node.dy = dy;

                // adjust values
                if (node.depth) {

                    if (node.depth === 1 && !ir) {
                        node.y = 0;
                        node.dy = iPr;
                    }

                    // outside label may be revised to inside,
                    // otherwise do nothing
                    var options = node.options;
                    if (options.dataLabels && options.dataLabels.enabled) {
                        // clone once only
                        if (!options.dataLabels._align && options.dataLabels.align === Constants.OUTSIDE) {
                            options.dataLabels = BaseUtils.clone(options.dataLabels);
                            options.dataLabels._align = options.dataLabels._align || options.dataLabels.align;
                        }
                        if (options.dataLabels._align === Constants.OUTSIDE) {
                            if (node.depth === height) {
                                options.dataLabels.align = Constants.OUTSIDE;
                            } else {
                                options.dataLabels.align = Constants.INSIDE;
                            }
                        }
                    }

                    series._setColor(node, gradual, height);
                    series.calculateLabelInfo(node);

                } else {
                    // -1 to avoid dy=0, thus invalidate drill down scale
                    node.y = -1;
                    node.dy = ir + 1;
                }

                // save origin for drillDown
                node._x = node.x;
                node._dx = node.dx;
                node._hdx = node.hdx;
                node._y = node.y;
                node._dy = node.dy;

                if (children && (n = children.length)) {
                    var i = -1, n, c, d, hd;
                    dx = node.value ? dx / Math.abs(node.value) : 0;
                    hdx = node.chSum ? hdx / Math.abs(node.chSum) : 0;
                    while (++i < n) {
                        c = children[i];
                        d = Math.abs(c.value) * dx;
                        hd = Math.abs(c.chSum) * hdx;
                        dfsData(c, x, d, hd, dy, ir, iPr);
                        x += hd;
                    }

                }
            }

            dfsData(root, startAngle, arc, arc, dRadius, innerRadius, innerPieR);
        },

        _setColor: function (node, gradual, height) {
            if (!(node && gradual && height)) {
                return;
            }
            if (node.options.color) {
                node.color = node.options.color;
            } else {
                var rgba = ColorUtils.getRGBAColorArray(node.ancestor.color);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var detS, detB;

                var ratio = (node.depth - 1) / height;

                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = -hsb[1] * ratio;
                    detB = (1 - hsb[2]) * ratio;
                } else {
                    detS = (1 - hsb[1]) * ratio;
                    detB = -hsb[2] * ratio;
                }

                node.color = ColorUtils.mixColorWithHSB(node.ancestor.color, 0, detS, detB);
            }


            if (node.options.mouseOverColor) {
                node.mouseOverColor = node.options.mouseOverColor;
            } else {
                var detS, detB;
                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = +0.1;
                    detB = -0.05
                } else {
                    detS = -0.1;
                    detB = +0.05;
                }
                
                node.mouseOverColor = ColorUtils.mixColorWithHSB(
                    (node.options.tooltip && node.options.tooltip.enabled && node.options.tooltip.shared) ?
                        node.ancestor.color :
                        node.color,
                    0, detS, detB);
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
        },

        _calculateLabelPos: function () {
            var series = this;
            var outPoints = [];
            var inPoints = [];

            series.nodes.map(function (node) {
                node.labelPos = null;
                if (node.dx < VIS_MIN) {
                    return;
                }

                if (node.name &&
                    node.depth &&
                    node.dx &&
                    node.dy &&
                    (series.drilldownNow ? node !== series.drilldownNow.parent : true) &&
                    node.options.dataLabels && node.options.dataLabels.enabled) {

                    if (node.options.dataLabels.align === Constants.OUTSIDE) {
                        outPoints.push(node);
                    } else {
                        inPoints.push(node);
                    }
                }
            }, series);

            var chartInfo = series.chartInfo;

            series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center, chartInfo.radius);

            series.calculateLeadLineStartPos(outPoints);

            series.calculateInsideLabelBounds(inPoints);
        },

        _getInnerRadius: function (d) {
            return d.y;
        },

        _getOuterRadius: function (d) {
            return d.y + d.dy;
        },

        _getStartAngle: function (d) {
            return d.x;
        },

        _getEndAngle: function (d) {
            return d.x + d.dx;
        },

        _getPositionInPie: function(absPos){

            var x = absPos.x - this.chartInfo.center[0];

            var y = absPos.y - this.chartInfo.center[1];

            return {x: x, y: y};
        },

        _getFixedPos: function(datum, divDim){

            var translateX = this.chartInfo.center[0];
            var translateY = this.chartInfo.center[1];

            var centerAngle = this.getCenterAngle(datum);
            var radius = (datum.y + datum.dy) * HOVER_PERCENT;



            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },
        
        drillDown: function (d) {
            if (this.drilldownNow === d) {
                return;
            }

            var p, node = d;
            while ((p = node.parent) && p.depth) {
                node = p;
                if (!p.name) {
                    return;
                }
            }

            this.drilldownNow = d;

            var radius = this.chartInfo.radius;
            var innerRadius = this.chartInfo.innerRadius;

            function deepest(node) {
                var children = node.children;
                var dc = node;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        var c = deepest(children[i]);
                        if (c.depth > dc.depth) {
                            dc = c;
                        }
                    }
                }
                return dc;
            }

            var yDomain, yRange;

            if (d.depth) {
                var rootHeight = d.ancestor.parent.height;

                // outer ring
                if (d.height === 0) {
                    yDomain = [d.parent._y, d._y, d._y + d._dy];
                    yRange = [0, INNER_RING_RADIUS, radius];

                } else
                // deepest child is not outer ring
                if (d.height + d.depth !== rootHeight) {
                    var dc = deepest(d);
                    yDomain = [d.parent._y, d._y, d._y + d._dy, dc._y + dc._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius, radius];

                } else {
                    yDomain = [d.parent._y, d._y, d._y + d._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius];
                }

            } else {
                yDomain = [0, innerRadius, radius];
                yRange = [0, innerRadius, radius];
            }

            var h = d.depth + d.height;

            this.sx.domain([d._x, d._x + d._dx]);
            this.sy.domain(yDomain).range(yRange);

            this.nodes.map(function (node) {
                if (node.depth &&
                    node.dataLabels &&
                    node.dataLabels.enabled &&
                    node.dataLabels._align === Constants.OUTSIDE) {
                    if (node.depth === h) {
                        node.dataLabels.align = Constants.OUTSIDE;
                    } else {
                        node.dataLabels.align = Constants.INSIDE;
                    }
                    QueryUtils.merge(node, this.calculateLabelInfo(node), true)
                }
                node.x = this.safeAngle(node._x);
                node.dx = this.safeAngle(node._x + node._dx) - node.x;
                node.y = this.safeRadius(node._y);
                node.dy = this.safeRadius(node._y + node._dy) - node.y;

                if (node === this.drilldownNow.parent) {
                    node.dx = this.safeAngle(7);// to ensure inner pie fill the circle.
                }

            }, this);

            this._calculateLabelPos();
            
            this.drawDrillDown(d);
        },

        safeAngle: function (x) {
            return Math.max(this.startAngle, Math.min(this.endAngle, this.sx(x)));
        },

        safeRadius: function (y) {
            return Math.max(0, this.sy(y));
        },

        _getTranslate:function(){
            return this.chartInfo.center;
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var translateX = this.chartInfo.center[0]; 
            var translateY = this.chartInfo.center[1]; 
 
            var rotate = point.rotate || 0; 
            var angle = rotate + point.x + point.dx / 2 ; 
            var r = point.y + point.dy / 2; 
            var center = this._getArcPoint(r, angle); 
 
            return { 
                startX: center[0] + translateX, 
                startY: center[1] + translateY, 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (dom, d) {
            EffectHelper.areaStyleEffectAnimation(dom, d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getStyle:function(p){
            return {
                'display': (p.name || p.depth < 2) ? '' : 'none',  // 第一层name为空字符串显示，第二层及以上name为空字符串不显示
                'fill':p.color,
                'fill-opacity': p.depth ? p.opacity : 0,
                'stroke': p.options.borderColor,
                'stroke-opacity':p.options.borderOpacity,
                'stroke-width':p.options.borderWidth
            }
        },

        getAttrs:function(p){
            return {'d':this.arc(p)};
        },

        getPointGraphicKey:function(){
            return 'path';
        },
        
        getChartNodes: function () {
            return this.nodes;
        },

        getCenter: function () {
            return this.center;
        },

        getRadius: function () {
            return this.radius;
        },
        
        getDrilldown: function () {
            return this.options.drilldown;
        },

        _getPointGraphicGroup:function(){
            if (!this.wrapGroup) {
                this.wrapGroup = this.group.append(this.vanchart.renderer.group());
                this.drawRing();
            }
            return this.wrapGroup;
        },

        // don't know why here ...
        // _getPointTextLabelGroup:function(){
        //     if(!this.textLabelGroup){
        //         this.textLabelGroup = this.group.append(this.vanchart.renderer.group());
        //     }
        //     return this.textLabelGroup;
        // },

        drawRing: function () {
            if (this.ringPath) {
                return;
            }
            this.ringPath = this.group.append(this.vanchart.renderer.path());
            this.ringPath
                .attr({
                    'd':PathGenerator.arc()
                        .startAngle(0)
                        .endAngle(Math.PI * 2)
                        .innerRadius(INNER_RING_RADIUS)
                        .outerRadius(INNER_RING_RADIUS + INNER_RING_STROKE_WIDTH)()
                })
                .style({
                    'display': 'none',
                    'fill': 'rgba(0,0,0,0.1)',
                    'pointer-events': 'none'
                })

        },

        drawDrillDown: function (target) {
            var series = this;
            var supportAnimation = series.vanchart.renderer.isAnimation;

            series._removeDataLabels();

            var arc = series.arc;
            if (supportAnimation) {
                var n = 0;
                series.nodes
                .filter(function (node) {return node.graphic;})
                .map(function (p) {
                    p.graphic
                        .transition()
                        .ease('cubic-in-out')
                        .each('start', function () { ++n; })
                        .duration(ANIMATION_TIME)
                        .style('fill', function(){
                            return p.color;
                        })
                        .attrTween("d", function () {
                            var i = Interpolate(p._view, {x:p.x, y:p.y, dx:p.dx, dy:p.dy});

                            return function (t) {
                                var b = i(t);
                                p._view = b;
                                return arc(b);
                            };
                        })
                        // following handle the small edge things,
                        // doesn't matter to the main animation...
                        .attrTween('opacity', function () {
                            return function (t) {
                                return (p.depth && (p._view.y + p._view.dy) >= INNER_RING_RADIUS) ? 1 : 0
                            }
                        })
                        .each('end', function () {
                            p.graphic.attr('opacity', (p.depth && p.dx && (p.y + p.dy) > INNER_RING_RADIUS) ? 1 : 0);
                            if (!--n) {
                                series._animateEnd();
                                series.ringPath.style('display', (target && target.depth) ? '' : 'none');
                            }
                        });
                });

                if (!target.depth) {
                    series.ringPath
                        .transition()
                        .style('display', 'none');
                }

            } else {

                series.nodes.map(function (d) {
                    d.graphic
                        .attr({
                            'd': arc(d),
                            'opacity': (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0
                        });

                });

                series._animateEnd(target);

                if (!BaseUtils.isSupportSVG()) {
                    series.root.graphic.style({
                        'fill': 'rgba(0,0,0,0)'
                    });
                }

                series.ringPath.style('display', target.depth ? '' : 'none');

            }

        },

        _animateEnd: function () {

            if(!this.vanchart.renderer){
                return; //has been removed
            }

            // for mPie's order animation
            this.ordered = this.orderType;
            this._showLabels();
            this._drawEffectPoints();
        },

        _isOrderChanged: function () {
            return this.ordered !== this.orderType
        },

        // animation
        initialAnimation: function () {

            this.wrapGroup
                .animate({
                    duration:ANIMATION_TIME,
                    ease: Bezier.css["ease-out-cubic"],
                    attrTween: {
                        transform:function () {
                            var i = Interpolate(-360, 0);
                            var j = Interpolate(0, 1);
                            return function (t) {
                                var rotate = i(t), scale = j(t);
                                return 'rotate(' + rotate + ')'+'scale(' + scale + ')';
                            };
                        }
                    }
                });
        },

        getPointUpdateAnimationAttr:function(p){

            var arc = this.arc;

            var isChanged = this._isOrderChanged();
            var ease = isChanged ? SORT_EASE : EASE;
            var aTime = isChanged ? SORT_TIME : ANIMATION_TIME;

            p.graphic
                .attr("opacity", p.depth ? 1 : 0);// hide inner circle

            this.ringPath.style('display', this.drilldownNow.depth ? '' : 'none');

            return {
                ease: ease,
                duration: aTime,
                attrTween: {
                    d: function () {
                        var self = this;
                        var i = Interpolate(p._view, {x:p.x, y:p.y, dx:p.dx, dy:p.dy});
                        return function (t) {
                            var b = i(t);
                            p._view = b;
                            return arc(b);
                        };
                    }
                }
            }
        },

        getPointInitAnimationAttr:function(p){

            var arc, data, series = p.series;

            if (series.initialAnimationMoving) {
                // this.initialAnimation();
                // Interpolator will check every key in b,
                // so give it a simple object is better
                data = {x:p.x, y:p.y, dx:p.dx, dy:p.dy};
            } else {
                data = {x:p.x1, y:p.y1, dx:p.dx1, dy:p.dy1};
            }
            arc = series.arc(data);

            // for animation calc and #orderData
            p._view = data;

            var attr = {
                d: arc,
                opacity: p.depth ? 1 : 0 // hide inner circle
            };

            if (!series.initialAnimationMoving) {
                p.graphic.attr(attr);
                return series.getPointUpdateAnimationAttr(p);
            }

            return {
                attr: attr
            }

        },

        getPointDropAnimationAttr:function(d){
            return this.getPointUpdateAnimationAttr(d);
        },

        // event
        onPointMouseOver:function(point){
            this._onState(point, true);
        },

        onPointMouseOut:function(point){
            this._onState(point, false);
        },

        _onState: function (point, isChosen) {
            if (point.options.tooltip && point.options.tooltip.shared) {
                var p, node = point;
                while ((p = node.parent) && p.depth && p.y+p.dy !== INNER_RING_RADIUS) {
                    node = p;
                    p.series._onSingleState(p, isChosen);
                }
            }
            point.series._onSingleState(point, isChosen);
        },

        _onSingleState:function(point, isChosen){
            var series = point.series, animation = series.options.animation;
            // var pathNode = point.graphic.rawElement;
            var style = {}, attr = {};
            if (point.depth && point._view.y1+point._view.dy1 === INNER_RING_RADIUS) {
                attr = {'opacity': isChosen ? 1 : 0};
            } else {
                style = {
                    'fill-opacity': isChosen ? 1 : point.opacity,
                    'fill': isChosen ? point.mouseOverColor : point.color
                };
            }

            if(animation){
                series._onPointState(point, isChosen, style, attr);
                series._onTextState(point, isChosen);
            }else{
                point.graphic.attr(attr).style(style);
                if (!point.depth && !BaseUtils.isSupportSVG()) {
                    point.graphic.style('fill', 'rgba(0,0,0,0)');
                }
            }
        },

        onPointTap: function (point) {
            if (this.getDrilldown()) {
                this.drillDown(point);
            }
        },

        isSupportLegendHighlight:function(){
            return false;
        }

    });

    MultiPie.prototype._calculateLabelPosWhenRadiusFixed = MultiPie.prototype._calculateLabelPos;
    
    require('../ChartLibrary').register(Constants.MULTIPIE_CHART, MultiPie);

    return MultiPie
});
/**
 * Created by Yuqian on 16/7/19.
 */

define('chart/TreeMap',['require','../Constants','../utils/BaseUtils','./TreeSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','./Point','../EffectHelper','../vans/TreeMapLayout','../utils/Scale','../utils/Interpolator','../dom/DomUtils','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var TreeSeries = require('./TreeSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Point = require('./Point');
    var EffectHelper = require('../EffectHelper');
    var treemapLayout = require('../vans/TreeMapLayout').treemapLayout;
    var Scale = require('../utils/Scale');
    var Interpolator = require('../utils/Interpolator');
    var DomUtils = require('../dom/DomUtils');

    var TOPLABELGAP = 6;

    var ANIMATION_TIME = 800;
    var INIT_EASE = 'out-bounce';

    var CHANGE_TIME = 1000;

    var VANISH_TIME = 800;

    var CHOSEN_TIME = 100;

    var treeMap = TreeSeries.extend({

        nodes: [],

        root: null,

        zoomNow: null,

        sx: null,
        sy: null,

        zoom: null,

        _refresh: function () {
            this.sx = Scale.linear();
            this.sy = Scale.linear();
        },

        visitBefore: function (node) {
            this._setColor(node);
        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                node.chSum = chSum;
            }

            node.value = _value || node.chSum || 0;

            if (node.ancestor && !node.ancestor.visible) {
                node.value = 0;
            }
        },

        doLayout: function () {

            this.traverseData(this.root, null, this.visitAfter);

            var plotBounds = this.vanchart.bounds;

            this.sx.range([0, plotBounds.width]).domain([0, plotBounds.width]);
            this.sy.range([0, plotBounds.height]).domain([0, plotBounds.height]);

            var treeMap = treemapLayout()
                .value(function (d) { return Math.abs(d.value) })
                .size([plotBounds.width, plotBounds.height]);

            this.nodes = treeMap.nodes(this.root)
                .filter(function(d) { return !d.children && d.depth; })
                .map(function (d) {
                    d.value = d.chSum; // for negative value
                    d.visible = d.ancestor.visible;

                    if (d.visible) {
                        this._setVanishPos(d, plotBounds);
                    }

                    this.calculateLabelInfo(d);

                    this._calcLabelPos(d);

                    stash(d);

                    return d;
                }, this);

            function stash (d) {
                d._dx = d.dx;
                d._dy = d.dy;
                d._x = d.x;
                d._y = d.y;
            }
        },

        getDataToDraw: function () {
            return this.nodes;
        },

        _setVanishPos: function (d, plotBounds) {
            d.vanishPos = [
                Math.round((d.ancestor.x + d.ancestor.dx / 2) / plotBounds.width) * plotBounds.width,
                Math.round((d.ancestor.y + d.ancestor.dy / 2) / plotBounds.height) * plotBounds.height
            ];
        },

        _setColor: function (node) {
            if (node.depth === 1) {
                node.color = node.options.color || this.vanchart.getDefaultSeriesColor(node.name);
                node.mouseOverColor = node.options.mouseOverColor || ColorUtils.getHighLightColor(node.color);
                node.clickColor = node.options.clickColor || ColorUtils.getClickColor(node.color);
            }
            if (node.depth > 1 && !node.options.children) {
                if (node.options.color) {
                    node.color = node.options.color;
                } else {
                    node.color = node.ancestor.color;
                }

                if (node.options.mouseOverColor) {
                    node.mouseOverColor = node.options.mouseOverColor;
                } else {
                    if (node.options.color) {
                        node.mouseOverColor = ColorUtils.getHighLightColor(node.options.color);
                    } else {
                        node.mouseOverColor = node.ancestor.mouseOverColor;
                    }
                }

                if (node.options.clickColor) {
                    node.clickColor = node.options.clickColor;
                } else {
                    if (node.options.color) {
                        node.clickColor = ColorUtils.getClickColor(node.options.color);
                    } else {
                        node.clickColor = node.ancestor.clickColor;
                    }
                }
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
            node.borderColor = node.options.borderColor;
            node.borderOpacity = node.options.borderOpacity;
        },

        _calculateLabelPos: function () {

        },

        //
        _calcLabelPos: function (d) {
            var lbl = d.options.dataLabels;
            if (lbl && lbl.enabled) {

                switch (lbl.align) {
                    case Constants.CENTER:
                        lbl._align = Constants.CENTER;
                        d.labelPos = {
                            x: d.x + (d.dx - d.labelDim.width) / 2,
                            y: d.y + (d.dy - d.labelDim.height) / 2
                        };
                        break;
                    case Constants.TOP:
                    default:
                        lbl._align = Constants.LEFT;
                        d.labelPos = {
                            x: d.x + TOPLABELGAP,
                            y: d.y + TOPLABELGAP
                        };
                }

                var rectBound = {x: d.x, y: d.y, width: d.dx, height: d.dy};
                var dataBound = {
                    x: d.labelPos.x,
                    y: d.labelPos.y,
                    width: d.labelDim.width,
                    height: d.labelDim.height
                };
                if (!BaseUtils.containsRect(rectBound, dataBound)) {
                    d.labelPos = null;
                }
            }
        },

        /**
         * @override Series.calcMoreLabelPosition.
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.x + point.dx/2 + chartBounds.x, 
                startY = point.y + point.dy/2 + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d, d.x+d.dx/2, d.y+d.dy/2);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        _getFixedPos:function(datum){

            var plotBounds = this.vanchart.bounds;

            var x = plotBounds.x + datum.x + datum.dx;
            var y = plotBounds.y + datum.y;

            return [x, y];
        },

        zoomTo: function (d) {
            d = this.zoomNow === d.parent ? this.root : d.parent;
            var sx = this.sx.domain([d.x, d.x + d.dx]);
            var sy = this.sy.domain([d.y, d.y + d.dy]);

            var plotBounds = this.vanchart.bounds;
            var kx = plotBounds.width / d.dx, ky = plotBounds.height / d.dy;

            this.nodes.map(function (node) {
                node.dx = kx * node._dx;
                node.dy = ky * node._dy;
                node.x = sx(node._x);
                node.y = sy(node._y);
                this._calcLabelPos(node);
                node.clearPointEffect();
                node.graphic && node.graphic.interrupt();
            }, this);

            // this.render();
            this.vanchart.fire('animationStart');

            this.zoomNow = d;
        },

        getChartNodes: function () {
            return this.nodes;
        },
        
        getZoom: function () {
            return this.options.zoom;
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.group.append(this.vanchart.renderer.group());
            }
            return this.pathGroup;
        },

        // animation
        initialAnimation: function () {

            var series = this;
            var node = this._getPointGraphicGroup();
            var plotBounds = this.vanchart.bounds;
            var cx = plotBounds.width / 2;
            var cy = plotBounds.height / 2;
            node.animate({
                    duration: ANIMATION_TIME,
                    ease: INIT_EASE,
                    attrTween: {
                        transform: function () {
                            var i = Interpolator(0, 1);
                            return function (t) {
                                var inter = i(t);
                                return 'matrix(' +
                                    inter + ',' + 0 + ',' +
                                    0 + ',' + inter + ',' +
                                    (cx - inter * cx) + ',' + (cy - inter * cy) + ')';
                            };
                        }
                    }
                });
        },

        _pointExpandAttr: function (d) {
            return {
                'x': -d.dx/2,
                'y': -d.dy/2,
                'width': d.dx,
                'height': d.dy,
                'transform': "translate(" + (d.x + d.dx/2) + "," + (d.y + d.dy/2) + ")"
            }
        },

        _pointContractAttr: function (d) {
            return {
                'x': 0,
                'y': 0,
                'width': 0,
                'height': 0,
                'transform': "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")"
            }
        },

        getPointInitAttr:function(d){
            return this.initialAnimationMoving
                ? this._pointExpandAttr(d)
                : this._pointContractAttr(d)
        },

        getPointUpdateAnimationAttr: function (d) {
            var series = this;
            if (d.visible) {
                return {
                    ease: 'quad-in-out',
                    duration: CHANGE_TIME,
                    attr: this._pointExpandAttr(d)
                }
            } else {
                return series.getPointDropAnimationAttr(d)
            }
        },

        getPointInitAnimationAttr: function (d) {
            if (this.initialAnimationMoving) {
                return {};
            }
            return this.getPointUpdateAnimationAttr(d);
        },

        getPointDropAnimationAttr:function(d){
            return {
                ease: 'quad-in-out',
                duration: VANISH_TIME,
                attr: {
                    width: 0,
                    height: 0,
                    transform: "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")"
                }
            }
        },

        // event
        onPointMouseOver:function(point){
            point.series._onState.call(point, true);
        },

        onPointMouseOut:function(point){
            point.series._onState.call(point, false);
        },

        _onState:function(isChosen){
            var point = this, series = point.series;
            var style = {
                'fill': isChosen ? point.mouseOverColor : point.color,
                'border-width': point.options.borderWidth + (isChosen ? 1 : 0)
            };

            var attr = series._pointExpandAttr(point);
            if(isChosen){
                attr = {x:attr.x-1, y:attr.y-1, width:attr.width+2, height:attr.height+2}
            }

            DomUtils.toFront(point.graphic.node());

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:CHOSEN_TIME,
                    ease:'ease',
                    style:style,
                    attr:attr
                });

            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, 'ease');
        },

        onPointTap: function (point) {
            if (point.series.getZoom()) {
                point.series.zoomTo(point);
            }
        }

    });

    require('../ChartLibrary').register(Constants.TREEMAP_CHART, treeMap);
});
/**
 * Created by Mitisky on 16/10/10.
 * 所有的xy都是相对绘图区的左上角偏移0.03和0.05倍宽高的值
 */
define('chart/Funnel',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BezierEasing','../EffectHelper','../component/FormattedText','../utils/ColorUtils','../ChartLibrary'],function (require) {
    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var FormattedText = require('../component/FormattedText');
    var ColorUtils = require('../utils/ColorUtils');

    var WIDTH_GAP = 0.03;
    var HEIGHT_GAP = 0.05;
    var FUNNEL_CONNECTOR_GAP = 0.03;
    var CONNECTOR_LABEL_GAP = 0.05;
    var FUNNEL_LABEL_GAP = FUNNEL_CONNECTOR_GAP + CONNECTOR_LABEL_GAP;
    var LABEL_MAX_WIDTH = 0.4;

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var FUNNEL_SHOW_TIME = 400;//delay
    var FUNNEL_INIT_TIME = 400;
    var INIT_EASE = BezierEasing.css["ease-out-quart"];
    var FUNNEL_UPDATE_TIME = 500;
    var UPDATE_EASE = BezierEasing.css.swing;
    var FUNNEL_RE_SHOW_TIME = 500;
    var RE_SHOW_EASE = BezierEasing.css.swing;

    var CHOSEN_EASE = BezierEasing.css['ease'];
    var CHOSEN_TIME = 300;

    var Funnel = Series.extend({

        _getAxisTypes:function(){
            return [];
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point) {
            return point.name;
        },

        _calculatePercentage: function () {
            var validPoints = this.points.filter(function (point) {
                point._bottomPoint = null;//把最后一个点 点掉，倒数第二个的bottomPoint为null
                return !point.isNull && point.visible;});

            var pointCount = validPoints.length;

            var topPoint;

            validPoints
                .forEach(function (point, i) {
                    if(topPoint){
                        topPoint._bottomPoint = point;
                        point.percentage = Math.abs(point.value/(topPoint.value || 1));
                        point.arrivalRate = Math.abs(point.value/(validPoints[0].value || 1));
                    } else {
                        point.percentage = point.arrivalRate = 1;
                    }
                    point.delayTime = FUNNEL_SHOW_TIME * Math.sqrt(i/pointCount);

                    topPoint = point;
                })
        },

        //series dolayout的时候在计算label，因为计算label需要用到plotBounds
        calculateLabelInfo:function(){

        },

        _outSideSpecialLabel: function (point) {
            var content = point.labelContent;
            return content && (content.nameLabelContent || content.valueLabelContent);
        },

        doLayout:function(){

            var funnel = this;
            funnel.points
                .forEach(function (point) {
                    FormattedText.dataLabelGenerator(point);
                });

            this._calculatePosAndSize();

        },

        _calculateTotalValue: function (filterFun, valueKey) {
            var totalValue = 0;
            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    totalValue += Math.abs(point[valueKey]);
                });
            return totalValue;
        },

        _calculateSeriesMaxValue: function (filterFun, valueKey) {
            var seriesMaxValue = 0;
            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    seriesMaxValue = Math.max(seriesMaxValue, Math.abs(point[valueKey]));
                });
            return seriesMaxValue;
        },

        //标签的计算逻辑：
        //inside: 和点的位置大小信息一起计算出来
        //outSide:
        // 第一遍循环：计算所有标签占用的宽高。
        // 第二遍循环：计算点的posXY和宽高，同时利用高度得出牵引线是直的还是弯的。
        // 第三遍循环：根据所有标签占用的高和牵引线是否是直的计算出标签位置，并重置标签内容和宽度
        _calculatePosAndSize: function () {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds,
                filterFun = function (point) {return !point.isNull && point.visible;};

            var valueKey = funnel.getTargetKey();

            var width = plotBounds.width, height = plotBounds.height,
                totalWidth = width * (1 - 2 * WIDTH_GAP), totalHeight = height * (1 - 2 * HEIGHT_GAP);

            var labelUseSize = funnel._calculateTotalLabelSize();

            totalWidth -= (labelUseSize.useWidth > 0 ? labelUseSize.useWidth + plotBounds.width * FUNNEL_LABEL_GAP : 0);

            //使用弯的牵引线，默认是直线，有重叠才会用弯的
            funnel.useCurveConnectorLine = false;
            var topPoint;

            var validPoints = funnel.points.filter(filterFun);
            var pointCount = validPoints.length;

            if(pointCount < 1){
                return;
            }

            var firstPoint = validPoints[0], lastPoint = validPoints[pointCount - 1],
                firstLabelHeight = firstPoint.labelDim ? firstPoint.labelDim.height : 0,
                lastLabelHeight = lastPoint.labelDim ? lastPoint.labelDim.height : 0;

            if(funnel.options.useSameSlantAngle){
                var totalValue = funnel._calculateTotalValue(filterFun, valueKey);

                var firstHeight = Math.abs(firstPoint[valueKey]) * totalHeight / totalValue,
                    lastHeight = Math.abs(lastPoint[valueKey]) * totalHeight / totalValue;

                var posY = Math.max(0, firstLabelHeight - firstHeight)/2;
                
                totalHeight -= posY;
                totalHeight -= Math.max(0, lastLabelHeight - lastHeight)/2;

                validPoints
                    .forEach(function (point) {
                        point.posX = Math.round(posY * totalWidth / 2 / totalHeight);
                        point.width = Math.round(totalWidth - point.posX * 2);
                        point.posY = Math.round(posY);
                        point.height = Math.round(Math.abs(point[valueKey]) * totalHeight / totalValue);

                        posY += point.height;

                        funnel._calculateInsideLabelPos(point, topPoint);

                        topPoint = point;
                    })
            } else {
                var seriesMaxValue = funnel._calculateSeriesMaxValue(filterFun, valueKey);
                var unitHeight = totalHeight/pointCount;

                var startY = Math.max(0, firstLabelHeight - unitHeight)/2;

                totalHeight -= startY;
                totalHeight -= Math.max(0, lastLabelHeight - unitHeight)/2;

                validPoints
                    .forEach(function (point, i) {
                        point.width = Math.round(totalWidth * Math.abs(point[valueKey])/seriesMaxValue);
                        point.posX = Math.round((totalWidth - point.width)/2);
                        point.posY = Math.round(startY + i * unitHeight);
                        point.height = Math.round(unitHeight);

                        funnel._calculateInsideLabelPos(point, topPoint);

                        topPoint = point;
                    })
            }

            funnel._calculateOutSideLabelPos(filterFun, labelUseSize.useWidth, labelUseSize.useHeight);
        },

        _calculateInsideLabelPos: function (point, topPoint) {
            var dataLabels = point.options.dataLabels;
            if(dataLabels && dataLabels.enabled){
                if(dataLabels.align == Constants.INSIDE) {
                    point.labelPos = {
                        x: point.posX + point.width / 2 - point.labelDim.width / 2,
                        y: point.posY + point.height / 2 - point.labelDim.height / 2
                    };
                }else if(topPoint){//两个点的标签有重叠
                    this.useCurveConnectorLine = this.useCurveConnectorLine || point.height + topPoint.height < point.labelDim.height + topPoint.labelDim.height;
                }
            }
        },

        _calculateOutSideLabelPos: function (filterFun, labelUseWidth, labelUseHeight) {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;
            var gap2 = plotBounds.width * CONNECTOR_LABEL_GAP;
            var totalHeight = plotBounds.height * (1 - 2 * HEIGHT_GAP);

            var pointCount = Math.max(1, this.points.filter(filterFun).length -1);
            var label_label_gap = Math.max(0, (totalHeight - labelUseHeight)/pointCount);

            var startX = plotBounds.width * (1 - 2 * WIDTH_GAP) - labelUseWidth;
            var startY = 0;

            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    var dataLabels = point.options.dataLabels;

                    if(dataLabels && dataLabels.enabled && dataLabels.align == Constants.OUTSIDE && startY < totalHeight) {

                        var content = point.labelContent;

                        var labelDim = point.labelDim, labelHeight = labelDim.height;

                        var labelY = funnel.useCurveConnectorLine ? startY : point.posY + point.height / 2 - labelHeight / 2;

                        var bottomPoint = point._bottomPoint,
                            gapWidth = ((bottomPoint ? bottomPoint.width : 0) - point.width) / 4;

                        var endPos = {x: startX, y: labelY + labelHeight / 2},
                            midPos = {x: startX - gap2, y: labelY + labelHeight / 2},
                            startPos = {x: point.posX + point.width + gapWidth, y: point.posY + point.height / 2};

                        point.labelPos = {
                            x: startX,
                            y: labelY,

                            endPos: endPos,
                            midPos: midPos,
                            startPos: startPos
                        };
                        startY += (point.labelDim.height + label_label_gap);

                        if(funnel._outSideSpecialLabel(point)) {//外侧自定义就不用走下边了
                            var nameLabelContent = content.nameLabelContent, valueLabelContent = content.valueLabelContent;
                            //处理省略和对齐
                            var nameValueGap = labelDim.nameValueGap, valueLabelWidth = Math.min(labelUseWidth, funnel.maxValueLabelWidth);

                            if (nameLabelContent) {
                                var nameLabelDim = nameLabelContent.dim, nameLabelText = nameLabelContent.text;
                                var nameLabelWidth = labelUseWidth - nameValueGap - valueLabelWidth;
                                nameLabelText = funnel._omitLabel(nameLabelText, nameLabelWidth, nameLabelContent.style);

                                nameLabelContent.text = nameLabelText;
                                nameLabelContent.x = 0;
                                nameLabelContent.y = (labelHeight - nameLabelDim.height) / 2;
                            }

                            if (valueLabelContent) {
                                var valueLabelDim = valueLabelContent.dim, valueLabelText = valueLabelContent.text;
                                valueLabelText = funnel._omitLabel(valueLabelText, valueLabelWidth, valueLabelContent.style);

                                valueLabelContent.text = valueLabelText;
                                valueLabelContent.x = labelUseWidth - valueLabelWidth;
                                valueLabelContent.y = (labelHeight - valueLabelDim.height) / 2;
                            }
                        }
                    }
                })
        },

        _omitLabel: function (text, width, style) {

            var tmpDim = BaseUtils.getTextDimension(text, style, false);

            var hasClip = false;

            while(tmpDim.width > width && text.length){
                text = text.substr(0, Math.floor(text.length * 0.9));

                tmpDim = BaseUtils.getTextDimension(text + '...', style, false);

                hasClip = true;
            }

            if(hasClip && text){
                text += '...';
            }

            return text;
        },

        _calculateTotalLabelSize: function () {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;

            var useWidth = 0, useHeight = 0;

            funnel.points
                .filter(function (point) {
                    return !point.isNull && point.visible && point.options.dataLabels && point.options.dataLabels.enabled
                })
                .forEach(function (point) {
                    if(point.options.dataLabels.align == Constants.OUTSIDE){
                        if(+funnel.maxNameLabelWidth || +funnel.maxValueLabelWidth){//系列标签最大值、值标签最大值相加
                            useWidth = Math.max(useWidth, (funnel.maxNameLabelWidth || 0) + (funnel.maxValueLabelWidth || 0) + point.labelDim.nameValueGap)
                        } else {//外侧自定义标签
                            useWidth = Math.max(useWidth, point.labelDim.width);
                        }
                        useHeight += point.labelDim.height;
                    }
            });

            useWidth = Math.min(useWidth, plotBounds.width * LABEL_MAX_WIDTH);

            return {
                useWidth : useWidth,
                useHeight : useHeight
            };
        },

        //dolayout的时候已经算好了
        _calculateLabelPos:function() {

        },

        _getFixedPos:function(point){
            var translate = point.series._getTranslate();
            return [translate[0] + point.posX + point.width/2, translate[1] + point.posY + point.height/2];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var translate = point.series._getTranslate(); 
 
            var startX =point.posX +point.width/2, 
                startY = point.posY + point.height / 2; 
 
            return { 
                startX: translate[0] + startX, 
                startY: translate[1] + startY, 
                direction: "top" 
            }
        },

        getFillFilter:function(color, p){
            var series = p.series, vanchart = series.vanchart, options = vanchart.options;
            if(options.style == Constants.STYLE_GRADUAL && BaseUtils.isSupportSVG()){

                var renderer = vanchart.renderer;

                var attrs = {'x1':'0%', 'y1':'0%', 'x2':'100%', 'y2':'0%'};
                var stop1 = {'offset':'0%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.9)};
                var stop2 = {'offset':'100%', 'stop-color':color};

                if(p.colorGradient){
                    renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                }else{
                    p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                }

                return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
            }

            return color;
        },

        //选中状态长宽扩大2px
        _getPointPath: function (p, isChosen) {
            var bottomPoint = p._bottomPoint, diff = isChosen ? 1 : 0;

            var top_left = (-p.width/2 - diff) + ',' + (-p.height/2 - diff);
            var top_right = (p.width/2 + diff) + ',' + (-p.height/2 - diff);
            if(bottomPoint) {
                var bottom_right = (bottomPoint.width/2 + diff) + ',' + (p.height/2 + diff);
                var bottom_left = (-bottomPoint.width/2 - diff) + ',' + (p.height/2 + diff);
                return 'M' + top_left + 'L' + top_right + 'L' + bottom_right + 'L' + bottom_left + 'Z';
            } else {
                var bottom = '0,' + (p.height/2 + diff);
                return 'M' + top_left + 'L' + top_right + 'L' + bottom + 'L' + bottom + 'Z';
            }
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'fill':p.series.getFillFilter(p.mouseOverColor || p.color, p),
                'fill-opacity': p.opacity,
                'stroke-width': (p.options.borderWidth || 0) + CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : (p.borderOpacity || 0 + CHOSEN_STROKE_OPACITY)
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor || p.color,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        },

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d, d.posX+d.width/2, d.posY+d.height/2);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getPointInitAttr:function (d) {
            return {
                'transform':'translate(' + (d.posX + d.width/2) + ',' + (d.posY + d.height/2) +') scale(0.01)'
            }
        },

        _pointNormalAttr:function (d) {
            return {
                'd':d.series._getPointPath(d),
                'transform':'translate(' + (d.posX + d.width/2) + ',' + (d.posY + d.height/2) +') scale(1)'
            }
        },

        getPointInitAnimationAttr:function (d) {
            var series = d.series;
            return {
                delay:d.delayTime,
                ease:INIT_EASE,
                duration:FUNNEL_INIT_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        getPointReShowAnimationAttr:function (d) {
            var series = d.series;
            return {
                ease:RE_SHOW_EASE,
                duration:FUNNEL_RE_SHOW_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        getPointUpdateAnimationAttr:function(d){
            var series = d.series;
            return {
                ease:UPDATE_EASE,
                duration:FUNNEL_UPDATE_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({duration:CHOSEN_TIME, ease:CHOSEN_EASE, style:style, attr:{'d':series._getPointPath(point, isChosen)}});

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.INSIDE) {
                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            } else {
                series._leadLineState(point, 2, 0, isChosen, CHOSEN_TIME, CHOSEN_EASE);
                series._labelTransformState(point, 2, 0, isChosen, CHOSEN_TIME, CHOSEN_EASE);

                series._outSideSpecialLabel(point)
                    ? series._specialLabelColorState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE)
                    : series._outSideLabelColorState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            }
        },

        _getTranslate:function(){
            var plotBounds = this.vanchart.bounds;
            return[plotBounds.x + plotBounds.width * WIDTH_GAP, plotBounds.y + plotBounds.height * HEIGHT_GAP];
        },

        _updateDataLabels:function(){
            var series = this;
            series.getTextDataToDraw().forEach(function(point){

                series._outSideSpecialLabel(point) ? series._createOutSideTextGraphic(point)
                    : series._createTextGraphic(point);
            });
        },

        _createOutSideTextGraphic:function(point){
            var series = point.series, dataLabels = point.options.dataLabels;

            var hasText = function(d){return series.visible && !d.isNull && d.visible && d.labelPos && !isNaN(d.labelPos.x) && !isNaN(d.labelPos.y) && dataLabels && dataLabels.enabled};

            if(hasText(point)){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var labelContent = point.labelContent, useHtml = dataLabels.useHtml;

                var textLabelGroup = this._getPointTextLabelGroup();

                var text = renderer.vtext(useHtml).attr('transform', BaseUtils.makeTranslate(series._labelTrans(point))).style({'pointer-events': 'none'});

                var halfWidth = point.labelDim.width/2, halfHeight = point.labelDim.height/2;

                var createSpanGraphic = function (label) {
                    if(label){
                        var labelDim = label.dim, labelText = label.text, labelStyle = label.style;

                        return renderer.vtspan(useHtml)
                            .style({'width': dataLabels.labelWidth + 'px', height:dataLabels.labelHeight + 'px'})
                            .attr('y', label.y)
                            .attr('x', label.x)
                            .attr('dy', labelDim.height * .85 - halfHeight)
                            .attr('dx', -halfWidth)
                            .textContent(labelText).style(labelStyle)
                            .addTo(text);
                    }
                };

                text.nameSpan = createSpanGraphic(labelContent.nameLabelContent);
                text.valueSpan = createSpanGraphic(labelContent.valueLabelContent);

                point.textGraphic = textLabelGroup.append(text);

                if (point.labelPos.startPos) {//leadLine
                    point.leadLine = textLabelGroup.append(this._getLeadLine(point));
                }
            }
        },

        _specialLabelColorState:function (point, isChosen, duration, ease) {
            var labelContent = point.labelContent;

            function spanColorState(span, label) {
                if(label && span){
                    var style = label.style;

                    span.animate({
                        duration: duration,
                        ease: ease,
                        style: {'color':isChosen ? point.mouseOverColor : style.color}
                    });
                }

            }

            point.textGraphic && spanColorState(point.textGraphic.nameSpan, labelContent.nameLabelContent);
            point.textGraphic && spanColorState(point.textGraphic.valueSpan, labelContent.valueLabelContent);
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    require('../ChartLibrary').register(Constants.FUNNEL_CHART, Funnel);

    return Funnel;

});
/**
 * Created by Mitisky on 16/11/30.
 */
define('chart/WordCloud',['require','./Series','../Constants','../utils/BezierEasing','../EffectHelper','../utils/BaseUtils','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var BaseUtils = require('../utils/BaseUtils');

    var INIT_TIME = 400;
    var INIT_EASE = BezierEasing.css['ease-out-back'];
    var UPDATE_TIME = 600;
    var UPDATE_EASE = BezierEasing.css["ease-out-quart"];
    var DROP_TIME = 1000;
    var DROP_EASE = BezierEasing.css["ease-out-cubic"];
    var RE_SHOW_TIME = 1200;
    var RE_SHOW_EASE = BezierEasing.css["ease-out-cubic"];

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = BezierEasing.css["ease-out-quart"];


    var WordCloud = Series.extend({

        isNullValue: function (point) {
            var targetValue = point.options.value;
            return targetValue == '-' || BaseUtils.hasNotDefined(targetValue) || BaseUtils.hasNotDefined(point.name);
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point) {
            return point.name;
        },

        doLayout:function(){

        },

        //没有标签
        _calculateLabelPos:function() {

        },

        _getFixedPos:function(point, divDim){
            var word = point.word, dim = point.labelDim;
            var translate = point.series._getTranslate();
            var w = dim.width/2, h = dim.height/2, rotate = BaseUtils.toRadian(word.rotate);

            var ww = rotate === Math.PI/2 ? h : w * Math.cos(rotate) - h * Math.sin(rotate);
            var hh = w * Math.sin(rotate) + h * Math.cos(rotate);
            var dy = dim.height * .35 * Math.cos(rotate);
            var dx = dim.height * .35 * Math.sin(rotate);

            return BaseUtils.isSupportSVG()
                ? [translate[0] + word.x + ww + dx, translate[1] + word.y + hh - dy]
                : [translate[0] + word.x + dim.width, translate[1] + word.y + dim.height];
        },

        _getTranslate:function(){
            var plotBounds = this.vanchart.bounds;
            return[plotBounds.x + plotBounds.width / 2, plotBounds.y + plotBounds.height / 2];
        },

        effectAnimation:function (d) {
            var word = d.word,  series = d.series, period = series._getEffectTime(d);

            d.graphic
                .style('text-shadow','rgba(91,91,91,0.75) 0px 0px 0px')
                .effectTransition()
                .ease(BezierEasing.css["ease-out-quint"])
                .duration(0.5 * period)
                .style('font-size', (1.2 * word.size) + "px")
                .style('text-shadow','rgba(91,91,91,0.75) 3px 3px 5px')
                .transition()
                .ease(BezierEasing.css["ease-in-quint"])
                .duration(0.5 * period)
                .style('font-size',  word.size + "px")
                .style('text-shadow','rgba(91,91,91,0.75) 0px 0px 0px')
        },

        getDefaultEffectTime:function () {
            return 2000;
        },

        // _showLabels: function () {
        // },

        /**
         * @override Series.calcMoreLabelPosition.
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) {
            var translate = point.series._getTranslate();
            var isSupportSVG = BaseUtils.isSupportSVG();
            var word = point.word, textDim = point.labelDim;
            var direction = "top";

            var bestPoints = this._calcNiceMoreLabelPos(point, word.rotate);
            var bestPos = bestPoints.top;
            // 向上超出则使用下面的点
            if(bestPos.y - moreLabelDim.height < 0){
                bestPos = bestPoints.bottom;
                direction = "bottom";
            }

            // IE下不支持旋转，使用的DIV渲染，因此这里的位置要单独计算
            var ie8PosX = translate[0] + word.x + textDim.width / 2,
                ie8PosY = translate[1] + word.y;
            // IE8 下高度溢出，同样反向
            if(ie8PosY - moreLabelDim.height < 0){
                ie8PosY = translate[1] + word.y + textDim.height;
                direction = "bottom";
            }

            return {
                startX: isSupportSVG ? bestPos.x : ie8PosX,
                startY: isSupportSVG ? bestPos.y : ie8PosY,
                direction: direction
            }
        },

        /**
         * 现在的问题是，词云的刷新数据提示应该在词的上面，当超出的时候，则反向放在词的下面，
         * 而且要考虑到词的旋转角度问题，保证词在旋转一定角度之后，提示和词不重叠且在词的上面
         * 这里就涉及到一个最高点的计算问题，每一个词在画布中就是一个矩形，这里根据词的大小和角度及中心位置，算出词（矩形）的四个端点的坐标
         * 然后取一个topPos和bottomPos返回，优先使用topPos，如果使用topPos时提示超出，则使用bottomPos
         * 这里topPos并不一定指的是词的四个端点之一，比如词的rotate为0，那么y轴方向就有两个比较高的点，
         * 这时则取他们的中心点，当比较高的两点之间的y方向的差值超过一定界限（20px ?），这时才以最高的那个点作为返回的topPos
         * 对于bottomPos则以相同的逻辑计算
         * @private
         */
        _calcNiceMoreLabelPos: function (point, rotate){
            var translate = point.series._getTranslate();
            var word = point.word, textDim = point.labelDim, height = textDim.height * 0.86,  width = textDim.width;
            var wordX = word.x + translate[0], wordY = word.y  + translate[1];

            var PI = Math.PI, toRadin = function (deg){
                return deg * PI / 180;
            };

            var measure = 20;

            rotate = toRadin(rotate);

            // 旋转发生transform-origin为相对文字的(50%,100%)
            var _angle = Math.atan(height / width * 2);
            var _angles = [ 0, _angle, PI - _angle, PI ];

            var r1 = width / 2,  r2 = Math.sqrt(height * height + width * width / 4);

            var points = _angles.map(function (angle, index){
                var r = index % 3 ? r2 : r1;
                angle -= rotate;
                return {
                    x: Math.round(r * Math.cos(angle)),
                    y: Math.round(r * Math.sin(angle))
                };
            }).sort(function (a,b){
                return b.y - a.y
            });

            var centerPoint = function(p1, p2){
                return {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                }
            };
            var endPos = function (pos){
                return {
                    x: pos.x + wordX,
                    y: wordY - pos.y
                }
            };

            var topPos = (points[0].y - points[1].y > measure) ? points[0] : centerPoint(points[0], points[1]),
                bottomPos = (points[3].y - points[2].y < -measure) ? points[3] : centerPoint(points[3], points[2]);

            return {
                top: endPos(topPos),
                bottom: endPos(bottomPos)
            };
        },

        _getPointGraphicGroup:function(){
            return this.vanchart.group;
        },

        _createPointGraphic:function(point){
            var graphicKey = this.getPointGraphicKey(point), renderer = this.vanchart.renderer;
            point.graphic = renderer[graphicKey]();
            point.graphic.textContent(point.word.text);
            return point.graphic;
        },

        getPointGraphicKey:function(){
            return 'text';
        },

        getStyle:function(p){
            var word = p.word;
            return word ? {
                "font-size": word.size + "px",
                "font-family":word.fontFamily,
                'fill':p.color,
                'text-shadow':'',
                'stroke-width':0,
                'stroke-opacity':1,
                'fill-opacity':p.opacity,
                'filter':''
            } : {};
        },

        getHighLightStyle:function(p){
            var word = p.word, size = parseFloat(word.size)*1.15;

            return {
                "font-size": size + "px",
                'fill':p.mouseOverColor
            };
        },

        _onPointMouseOver:function(point){

            Series.prototype._onPointMouseOver.call(this, point);  // 超链鼠标悬浮变手

            var series = point.series, style = series.getHighLightStyle(point),
                vanchart = series.vanchart, renderer = vanchart.renderer;

            if(point.effectInterval) {
                clearInterval(point.effectInterval);
                point.graphic.interrupt();
            }

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            series.drawPointEffect(point);
        },

        getPointInitAttr:function (p) {
            var word = p.word;
            return word ? {
                'text-anchor': 'middle',
                'transform': "translate(" + [word.x, word.y] + ")rotate(" + word.rotate + ")"
            } : {};
        },

        getPointInitStyle:function () {
            return {
                'font-size':'0.1px',
                'opacity':1
            }
        },

        getPointReShowStyle:function () {
            return {
                'font-size':'0.1px',
                'opacity':0
            }
        },

        getPointInitAnimationAttr:function (d) {
            var word = d.word;

            return {
                delay:d.delayTime || 0,  // 这里的word如果不显示，给出的delayTime为undefined，导致transition不能触发end,animateCount因此不能归为0，也就无法执行series._animateEnd
                ease:INIT_EASE,
                duration:INIT_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity':1
                }
            }
        },

        getPointReShowAnimationAttr:function (d) {
            var word = d.word;

            return {
                ease:RE_SHOW_EASE,
                duration:RE_SHOW_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity':1
                }
            }
        },

        getPointUpdateAnimationAttr:function (d) {
            var word = d.word;

            return {
                ease:UPDATE_EASE,
                duration:UPDATE_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity': 1
                },
                attr:{
                    'transform': "translate(" + [word.x, word.y] + ")rotate(" + word.rotate + ")"
                }
            }
        },

        getPointDropAnimationAttr:function (d) {
            return {
                ease:DROP_EASE,
                duration:DROP_TIME,
                style:{
                    'opacity':0
                }
            }
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    require('../ChartLibrary').register(Constants.WORD_CLOUD_CHART, WordCloud);

    return WordCloud;
});
/**
 * Created by shine on 2017/1/10.
 */
define('chart/Structure',['require','./Series','./Point','../Constants','../utils/BezierEasing','../EffectHelper','../utils/BaseUtils','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var Point = require('./Point');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var BaseUtils = require('../utils/BaseUtils');

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = BezierEasing.custom["ease-out-back"];

    var Structure = Series.extend({

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point, parent, level) {
            parent = point.parent || parent; level = point.level || level || 0;
            return (parent ? parent.name : "") + point.name + level;
        },

        isNullValue:function(point){
            return false;
        },

        _dealData: function (data) {

            var series = this, vanchart = series.vanchart, ancestorData = data[0], ancestor = vanchart.ancestor;

            vanchart.nodes && vanchart.nodes.forEach(function (node) {
                node._events = null;
                node.graphic && node.graphic.remove();
                node.textGraphic && node.textGraphic.remove();
                node.textGraphic = node.graphic = null;
            });

            vanchart.edges && vanchart.edges.forEach(function (edge) {
                edge.linkGraphic && edge.linkGraphic.remove();
                edge.linkGraphic = null;
            });

            if(ancestorData){

                var nodes = [], edges = [], maxLevel = 0;

                function dealNodesAndEdges(parent, data, level, pointsMap) {
                    var key = series._getPointKey(data, parent, level);
                    var oldPoint = pointsMap[key];
                    var point;
                    if(oldPoint){
                        oldPoint._lastValue = oldPoint[series.getTargetKey()];
                        oldPoint.moreLabelG && oldPoint.moreLabelG.remove();
                        oldPoint.moreLabelG = null;

                        oldPoint.refresh(data);
                        point = oldPoint;

                        pointsMap[key] = null;
                    } else {
                        point = new Point(data, series);
                    }

                    point.level = level;
                    maxLevel = Math.max(level, maxLevel);
                    if(parent) {
                        point.parent = parent;
                        parent.children = parent.children || [];
                        if(BaseUtils.indexOf(parent.children, point) == -1) {
                            parent.children.push(point);
                        }
                    }

                    nodes.push(point);
                    if(parent) {
                        edges.push({source: parent, target: point});
                    }

                    if(data.children){
                        var pointsMap = {};

                        if(point.children){
                            point.children.forEach(function (child) {
                                pointsMap[series._getPointKey(child)] = child;
                            })
                        }

                        data.children.forEach(function (d) {
                            dealNodesAndEdges(point, d, level + 1, pointsMap);
                        });

                        for(var key in pointsMap){
                            pointsMap[key] && pointsMap[key].clearChild();
                        }
                    }

                    return point;
                }

                var map = {};
                if(ancestor) {
                    map[series._getPointKey(ancestor)] = ancestor;
                }
                ancestor = dealNodesAndEdges(null, ancestorData, 0, map);

                for(var key in map){
                    map[key] && map[key].remove();
                }

                vanchart.ancestor = ancestor;
                vanchart.maxLevel = maxLevel;
                vanchart.nodes = nodes;
                vanchart.edges = edges;

                series.points = nodes;
            }
        },


        doLayout:function(){
        },

        _calculateLabelPos:function() {
        },

        _getFixedPos:function(point, divDim){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds;
            var radius = (point.radius + 1)/1.414;
            return [plotBounds.x + point.posX + radius, plotBounds.y + point.posY + radius];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.posX + chartBounds.x, 
                startY = point.posY + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        getStyle:function(node){
            var options = node.options;
            return {
                'fill':node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke':node.borderColor || node.color,
                'stroke-opacity':node.borderOpacity,
                'stroke-width':options.borderWidth
            };
        },

        getHighLightStyle:function(node){
            var options = node.options;

            return {
                'fill':node.mouseOverColor || node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke-width':options.borderWidth,
                'stroke-opacity':node.borderOpacity,
                'stroke': node.borderColor || node.color
            }
        },

        getPressedStyle:function(node){
            var options = node.options;

            return {
                'fill':node.clickColor || node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke-width':options.borderWidth,
                'stroke-opacity':node.borderOpacity,
                'stroke':node.borderColor || node.color
            }
        },

        _onPointMouseOver:function(point){
            Series.prototype._onPointMouseOver.call(this, point);  // 超链鼠标悬浮变手
            
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var diff = isChosen ? 2 : 0, radius = point.radius, attr = {r:radius + diff};

            if(point.options.image){
                attr = {x:-radius-diff, y:-radius-diff, width:(radius+diff)*2, height:(radius+diff)*2};
            }
            point.graphic.nodeGraphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:CHOSEN_TIME,
                    ease:CHOSEN_EASE,
                    attr:attr,
                    style:style
                });

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.INSIDE){
                point.series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);

            } else {
                point.series._labelTransformState(point, 0, -2, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            }
        }
    });

    require('../ChartLibrary').register(Constants.STRUCTURE_CHART, Structure);

    return Structure;
});
/**
 * Created by eason on 16/8/16.
 */
define('chart/ForceBubble',['require','./Bubble','../Constants','../utils/BaseUtils','../EffectHelper','../ChartLibrary'],function(require){

    var Bubble = require('./Bubble');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var EffectHelper = require('../EffectHelper');

    var ForceBubble = Bubble.extend({

        _calculateBubblePosition:function(){

        },

        _getFixedPos:function(datum){
            var radius = datum.radius || 0;
            var plotBounds = this.vanchart.bounds;
            var x = plotBounds.x + datum.x + radius;
            var y = plotBounds.y + datum.y + radius;
            return [x, y];
        },
        
        _getAxisTypes:function(){
            return [];
        },
        
        getTargetKey:function(){
            return 'y';
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.x + chartBounds.x, 
                startY = point.y + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        isNullValue: function (point) {
            var options = point.options;

            return options.x == '-' || options.y == '-';
        },

        _getPointKey: function (point) {
            //point.options ? refreshOptions : init
            return '' + (point.options ? point.options.x : point.x);
        },

        effectAnimation:function (d) {
            EffectHelper.forceBubbleEffectAnimation(d, d);
        },

        getPointInitAttr:function(node){
            return {
                'r': node.radius,
                'transform': BaseUtils.makeTranslate({x:0, y:0})
            };
        },

        getPointInitAnimationAttr:function(point){
            return {
            }
        },
        getPointReShowAnimationAttr:function (point) {
            return{};
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                'r': point.radius,
                'transform': BaseUtils.makeTranslate({x:point.x, y:point.y})
            };
        },

        remove:function(){

            this.points.forEach(function(point){
                if(point.graphic){
                    point.graphic.remove();
                    point.graphic = null;
                }
            });

            this.textGraphicGroup && this.textGraphicGroup.remove();
            this.group && this.group.remove();
            this.textGraphicGroup = this._canvas = this.group = null;
        }

    });

    require('../ChartLibrary').register(Constants.FORCE_BUBBLE_CHART, ForceBubble);
    return ForceBubble;
});
/**
 * Created by eason on 16/5/9.
 */
define('chart/Map',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Series','../EffectHelper','../ChartLibrary','../ChartLibrary','../ChartLibrary'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Series = require('./Series');
    var EffectHelper = require('../EffectHelper');

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = 'ease';

    var Map = Series.extend({

        initialize:function(options, vanchart, index){

            Series.prototype.initialize.call(this, options, vanchart, index);

            this.on(this.getEvents(), this);
        },

        getTargetKey:function(){
            return 'value';
        },

        _getPointKey:function(point){
            return point.name;
        },

        effectAnimation:function (d) {
            var effectFun = this.type === Constants.POINT_MAP
                ? EffectHelper.pointMapEffectAnimation : EffectHelper.areaMapEffectAnimation;

            d.layers && d.layers.forEach(function(layer){
                effectFun(layer, d);
            });
        },

        getDefaultEffectTime:function () {
            return this.type == Constants.POINT_MAP ?
                EffectHelper.POINT_MAP_EFFECT_TIME :
                EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        _getFixedPos:function(point){
            var vanchart = point.series.vanchart, type = point.series.type;

            var latlng = point.getLatLng();

            if(!latlng){
                return;
            }

            var pos = vanchart.latLngToContainerPoint(latlng);

            if(type == Constants.AREA_MAP){
                var detX = 0, detY = 0;
                if(point.options.dataLabels && point.labelDim && point.labelPos){
                    detX = point.labelDim.width/2;
                    detY = point.labelDim.height/2;
                }
                return [pos.x + detX, pos.y + detY];
            }

            return [pos.x, pos.y];
        },
        
        getHighLightStyle:function (point) {
            return {
                'stroke':point.borderColor ,
                'fill':point.mouseOverColor,
                'fill-opacity': point.opacity,
                'stroke-width':point.options.borderWidth + 1,
                'stroke-opacity':point.borderOpacity,
                'filter':this._getShadowFilter()
            }
        },

        getStyle:function(point){
            var geo = point.series.vanchart.getCurrentGeo();

            return point.isNull ? geo.defaultAreaStyle() : Series.prototype.getStyle.call(this, point);
        },

        _getShadowFilter:function () {
            var series = this, vanchart = series.vanchart, renderer = vanchart.mapRenderer;
            vanchart.mapShadowFilter = vanchart.mapShadowFilter || renderer.createDropShadowFilter(0, 1, 0.5, 2);
            return 'url(#' + BaseUtils.stamp(vanchart.mapShadowFilter) + ')';
        },

        _onPointMouseOver:function(point){
            var style = this.getHighLightStyle(point);

            this._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var style = this.getStyle(point);

            this._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point._mapPointOnMouseState(isChosen, CHOSEN_TIME, CHOSEN_EASE, style);

            point.textLayers && point.textLayers.forEach(function(layer){
                series.type == Constants.POINT_MAP
                    ? layer._transformState(isChosen)
                    : layer._fontSizeState(isChosen, CHOSEN_TIME, CHOSEN_EASE);
            });
        }

    });

    require('../ChartLibrary').register(Constants.POINT_MAP, Map);
    require('../ChartLibrary').register(Constants.AREA_MAP, Map);
    require('../ChartLibrary').register(Constants.HEAT_MAP, Map);

    return Map;
});
/**
 * Created by Yuqian on 2016/12/23.
 */

define('chart/map/LineMapDataNormalizer',['require','../../utils/BaseUtils'],function (require) {

    var extend = require('../../utils/BaseUtils').extend;

    function normalSingle(p, geo) {
        var name = p.name || p;
        var features = geo.getFeaturesByName(name);
        if (features && features.length) {
            return features.map(function (f) {
                return {
                    name: name,
                    lnglat: f.geometry.coordinates
                }
            })
        }
    }

    function normalDatum(froms, tos, d, normalData) {
        if (!froms || !tos) {
            return;
        }
        var i = 0, f = froms[0] || froms;
        do {
            var j = 0, t = tos[0] || tos;

            do {
                var datum = {};
                extend(datum, d);
                datum.from = f;
                datum.to = t;
                normalData.push(datum)
            } while (t = tos[++j])

        } while (f = froms[++i])
    }
    /*
      1 ->
      from: "place",

      2 ->
      from: {
        name: "place"
      }
      (Get lnglats from geoJson with the same name. Return Points Array or null.)

      3 (correct) ->
      from: {
        name: "place",
        lnglat: [1,0]
      }

    */
    return function (data, geo) {
        geo._loadGeo(); // have to get json first
        var normalData = [];
        var i = -1, d;

        while (d = data[++i]) {
            var froms, tos;
            var isF = d.from && d.from.lnglat;
            var isT = d.to && d.to.lnglat;

            if (isF && isT) {
                normalData.push(d);

            } else {
                froms = isF ? d.from : normalSingle(d.from, geo);
                tos = isT ? d.to : normalSingle(d.to, geo);
                normalDatum(froms, tos, d, normalData)
            }
        }

        return normalData;
    }
});
/**
 * Created by Yuqian on 2016/12/14.
 */
define('chart/LineMap',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../ComponentLibrary','./Series','./map/LineMapDataNormalizer','../ChartLibrary'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var Series = require('./Series');
    var LineMapDataNormalizer = require('./map/LineMapDataNormalizer');

    var TOOLTIP_GAP = 6;

    var PI = Math.PI;

    var LineMap = Series.extend({

        doLayout: BaseUtils.emptyFn,

        _calculateLabelPos: BaseUtils.emptyFn,

        _loadData: function (data) {
            var geo = this.vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            return LineMapDataNormalizer(data, geo);
        },

        // here is obscure...
        // other charts use one canvas per series,
        // lineMap uses only one.
        // it's different...
        useCanvas: BaseUtils.trueFn,

        getTargetKey:function(){
            return 'value';
        },

        _getPointKey:function(point){
            point = point.options || point;
            return point.from.lnglat.join() + point.to.lnglat.join()
        },

        _getFixedPos:function(point, divDim){

            var arc = BaseUtils.computeArc(point.ax, point.ay, point.bx, point.by, point.curveness);

            var th = (arc[3] + arc[4]) / 2;
            th %= 2 * PI;
            var r = arc[2] + TOOLTIP_GAP;
            var x = r * Math.cos(th) + arc[0];
            var y = r * Math.sin(th) + arc[1];

            if (th <= PI / 2) {
                // original
            } else if (th <= PI) {
                x -= divDim.width;
            } else if (th <= 3 / 2 * PI) {
                x -= divDim.width;
                y -= divDim.height;
            } else {
                y -= divDim.height;
            }

            return [x, y];
        },

        remove: function () {
            Series.prototype.remove.call(this);

            this.points = [];
        },

        isSupportLegendHighlight: function () {
            // tmp
            return false
        }
    });

    require('../ChartLibrary').register(Constants.LINE_MAP, LineMap);

    return LineMap;
});
/**
 * Created by eason on 15/6/18.
 */
define('component/BaseAxis',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../ComponentLibrary','../utils/BoundsManager','../utils/Scale','./Base','../utils/BezierEasing'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var BoundsManager = require('../utils/BoundsManager');
    var Scale = require('../utils/Scale');


    var Base = require('./Base');

    var BezierEasing = require('../utils/BezierEasing');
    var TIME = 400;
    var EASE = BezierEasing.css.swing;
    
    var LABEL_LINE_GAP = 4;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };
    
    var TICK_LENGTH = 4;

    var TITLE_LABEL_GAP = 8;
    var TITLE_LABEL_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(TITLE_LABEL_GAP);
    };

    var TICK_COUNT = 5;
    var RADAR_TICK_COUNT = 4;
    var MIN_MAX_GAP = 100;

    var PADDING = 5;

    var MAIN_TICK = 'main';
    var MINOR_TICKS = 'minor';

    var ARROW_SIZE = 15;

    var BaseAxis = Base.extend({

        labelRotation: 0,

        _refresh:function(){
            this.series = [];

            //for category axis
            this.isRangePoints = true;

            this.piece = null;

            this.forecast = [0, 0]; // trendline period

            this._zoomDomain = this._dataDomain = this._domain = this._tickStart = this._step = 0;

            this.initScale();

            var options = this.options, titleOptions = options.title;
            BaseUtils.calculateFontSizeWithScale(options.labelStyle);
            BaseUtils.calculateFontSizeWithScale(titleOptions && titleOptions.style);
            options.tickPadding = isNaN(options.tickPadding) ? 6 : options.tickPadding;
            options.tickLength = options.enableTick ? (isNaN(options.tickLength) ? 4 : options.tickLength) : 0;
            options.minorTickLength = options.enableMinorTick ? (isNaN(options.minorTickLength) ? 2 : options.minorTickLength) : 0;
        },

        //计算坐标轴挤占绘图区的空间
        _calculateSize:function(tickData){

            var axisOption = this.options;

            this.tickLabelLength = this._getTickLabelLength(tickData);
            var axisTileLength = this.labelLength = this._getAxisTitleLength();
            axisTileLength += (axisTileLength > 0 ? TITLE_LABEL_GAP_FUN() : 0);

            var usedSize = this.tickLabelLength + axisTileLength;
            var isHorizontal = this.isHorizontal();
            var isInverted = this.vanchart.isInverted();

            if(isHorizontal){
                var max = isInverted ? axisOption.maxWidth : axisOption.maxHeight;
                usedSize = max ? Math.min(this._maxHeight(max), usedSize) : usedSize;
            }else{
                var max = isInverted ? axisOption.maxHeight : axisOption.maxWidth;
                usedSize = max ? Math.min(this._maxWidth(max), usedSize) : usedSize;
            }

            this._size = this.series.length === 0 ? 0 : Math.round(usedSize);
        },

        _recordAxisSize:function(){
            if(!this.isOnZero()){
                this.vanchart.axisSize[this.getPosition()] += this._size;
            }
        },

        calculateDomainFromData:function(dataDomain){
            if(!dataDomain){
                //确定是不是byPercent
                var series = this.series;
                this.byPercent = false;

                if(!this._isBaseAxis()) {
                    for (var i = 0, len = series.length; i < len && !this.byPercent; i++) {
                        this.byPercent = series[i].options.stackByPercent;
                    }
                }

                dataDomain = this._getDomainFromData();
            }
            // 为什么要在这里写：排序的时候doLayout不执行，就先放这里了
            if (this.indicator) {
                this._calculateCateDomainData();
            }

            this._dataDomain = dataDomain;

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);

            var zoomDomain = this._zoomDomain || (zoomTool && zoomTool.getZoomInitDomain(this));

            if(this._isBaseAxis() && zoomDomain){
                var min = parseFloat(zoomDomain[0]), max = parseFloat(zoomDomain[1]);
                if(!isNaN(min) && !isNaN(max)){
                    var t = min;
                    min = Math.min(min, max);
                    max = Math.max(t, max);
                }
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], isNaN(min) ? null : min, isNaN(max) ? null : max);
            }else{
                var axisOption = this.options;
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], axisOption.min, axisOption.max);
            }

            //日期轴计算默认格式
            this._calculateDateFormat && this._calculateDateFormat();
        },

        _calculateNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options;
            if(axisOption.log){
                return this._calculateLogNiceDomain(minValue, maxValue, fixedMin, fixedMax);
            }else if(this.byPercent){
                return this._calculatePercentValueDomain(minValue, maxValue, fixedMin, fixedMax);
            }else{
                return this._calculateValueNiceDomain(minValue, maxValue, fixedMin, fixedMax);
            }
        },

        calculateDomainFromZoom:function(){
            var zoomDomain = this._zoomDomain, cfg = this.options;
            if(this._isBaseAxis()){
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], zoomDomain[0], zoomDomain[1]);
            }else{
                var min = BaseUtils.hasDefined(cfg.min) ? Math.max(cfg.min, zoomDomain[0]) : zoomDomain[0];
                var max = BaseUtils.hasDefined(cfg.max) ? Math.min(cfg.max, zoomDomain[1]) : zoomDomain[1];
                if (min > max) {
                    return;
                }

                var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && BaseUtils.hasNotDefined(cfg.min);
                var baseValue = this.isLog() ? 1 : 0;
                min = fromZero ? Math.min(baseValue, min) : min;

                this._calculateNiceDomain(zoomDomain[0], zoomDomain[1], min, max);
            }
        },

        isCategory:function(){
            return this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT;
        },

        zoomRefresh:function(zoom){
            this._zoomDomain = zoom;

            this.calculateDomainFromZoom();
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos, isDateAxis = this.type == ComponentLibrary.DATE_AXIS_COMPONENT, det = isDateAxis ? 1000 : 1e-11;

            var plotBounds = this.vanchart.bounds;

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos.x, upPos.x) - plotBounds.x;
                endPos = Math.max(downPos.x, upPos.x) - plotBounds.x;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.width);
            }else{
                startPos = Math.min(downPos.y, upPos.y) - plotBounds.y;
                endPos = Math.max(downPos.y, upPos.y) - plotBounds.y;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.height);
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            if(isDateAxis){
                startValue = BaseUtils.date2int(startValue);
                endValue = BaseUtils.date2int(endValue);
            }

            if (Math.abs(startValue - endValue) < det) {
                return;
            }

            this.zoomRefresh([Math.min(startValue, endValue), Math.max(startValue, endValue)])
        },

        getAxisValue: function (value) {
            return value;
        },

        getTrendLineForecast: function (sery) {
            var trendLine = sery.options.trendLine;
            if (trendLine && trendLine.period && trendLine.period.length === 2) {
                var period = trendLine.period;
                this.forecast[0] = Math.min(0, period[0]);
                this.forecast[1] = Math.max(0, period[1]);
            }
        },

        _getStartAndEndTick:function(){
            return this._domain;
        },

        //即使自动旋转，也能保证这里clip出来的边界够用
        updateClipBounds: function (clipBounds) {

            if(this.series.length === 0){
                return;
            }

            var startSize, endSize, t_s, t_e;
            var isHorizontal = this.isHorizontal(), isReversed = this.isAxisReversed(), cfg = this.options;

            if(this.options.showLabel){
                var tick = this._getStartAndEndTick();
                var tick_0 = tick[0];
                var tick_1 = tick[1];
                if(this.isMultiCateAxis && this.isMultiCateAxis()){
                    tick_0 = BaseUtils.decodeCategoryArray(tick_0)[0];
                    tick_1 = BaseUtils.decodeCategoryArray(tick_1)[0];
                }
                var startDim = this._getTickDim(this._getTickContent(tick_0, cfg.formatter));
                var endDim =this._getTickDim(this._getTickContent(tick_1, cfg.formatter));

                if(isReversed){
                    t_s = endDim;
                    t_e = startDim;
                }else{
                    t_s = startDim;
                    t_e = endDim;
                }
                startSize = isHorizontal ? t_s.width : t_s.height;
                endSize = isHorizontal ? t_e.width : t_e.height;

                //标签与四周保证有个边距
                startSize = Math.round(startSize/2) + PADDING;
                endSize = Math.round(endSize/2) + PADDING;

                if(this.showArrow()){
                    endSize = Math.max(endSize, ARROW_SIZE);
                }

            }else{
                startSize = 0;
                endSize = this.showArrow() ? ARROW_SIZE : 0;
            }

            var plotBounds = this.vanchart.bounds;
            if (isHorizontal){

                var axisSize = this.vanchart.axisSize;
                var leftDis = plotBounds.x + axisSize.left + PADDING;
                var rightDis = axisSize.right + PADDING;

                if(this.isCategory() && !this.isRangePoints){
                    var domain = this._zoomDomain || this._dataDomain;
                    var rangeBand = (plotBounds.width - axisSize.left - axisSize.right)/domain.length;
                    leftDis += (Math.round(rangeBand/2));
                    rightDis += (Math.round(rangeBand/2));
                }

                if(this.options.labelRotation <= -15){
                    startSize = Math.round((startSize - PADDING) * 2);
                }else if(this.options.labelRotation >= 15){
                    endSize = Math.round((endSize - PADDING) * 2);
                }

                startSize = Math.max(startSize - leftDis, 0) + PADDING;
                endSize = Math.max(endSize - rightDis, 0) + PADDING + (this.showArrow() ? ARROW_SIZE : 0);

                clipBounds[Constants.LEFT] = Math.max(clipBounds[Constants.LEFT] || 0, startSize);
                clipBounds[Constants.RIGHT] = Math.max(clipBounds[Constants.RIGHT] || 0, endSize);
            }else{
                clipBounds[Constants.TOP] = Math.max(clipBounds[Constants.TOP] || 0, endSize);
                clipBounds[Constants.BOTTOM] = Math.max(clipBounds[Constants.BOTTOM] || 0, startSize);
            }
        },

        updateAxisSizeAndBounds:function(){
            this._setComponentBounds(this.getPosition(), this._size);
        },

        fixScaleAndTickData:function(){

            // 留着注释做参考:  使用rangeRound的话，zoom时invert算出的domain只能为整数，在坐标轴极值差 < 1的情况下会出问题
            // this.scale.domain(this._domain).rangeRound(this._getRange());
            this.scale.domain(this._domain).range(this._getRange());

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        dealOnZero:function(){

            var cfg = this.options;

            if(cfg.onZero){

                var axisIndex = cfg.onZero === true ? 0 : cfg.onZero;

                var relyOn = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ?
                                    ComponentLibrary.Y_AXIS_COMPONENT : ComponentLibrary.X_AXIS_COMPONENT;

                relyOn = this.vanchart.getComponent(relyOn).getAxis(axisIndex);

                var pos = relyOn.getZeroPos();

                var plotBounds = this.vanchart.bounds;

                var x, y, width, height;
                if(this.isHorizontal()){
                    x = plotBounds.x;
                    y = pos + plotBounds.y - (this.getPosition() == Constants.TOP ? this.bounds.height : 0);
                    width = plotBounds.width;
                    height = this.bounds.height;
                }else{
                    x = pos + plotBounds.x - (this.getPosition() == Constants.LEFT ? this.bounds.width : 0);
                    y = plotBounds.y;
                    width = this.bounds.width;
                    height = plotBounds.height;
                }

                this.bounds = {
                    x:x,
                    y:y,
                    width:width,
                    height:height
                };

            }
        },

        //坐标轴的标签占据的大小
        _getTickLabelLength:function(tickData){
            var axisOption = this.options;

            var tickLength = 0, maxLabelLength = 0, isHorizontal = this.isHorizontal();
            if (axisOption.showLabel) {
                tickLength = (isNaN(+axisOption.tickPadding) ? LABEL_LINE_GAP_FUN() : axisOption.tickPadding);
            }

            if(axisOption.enableTick){
                tickLength += (isNaN(+axisOption.tickLength) ? TICK_LENGTH : axisOption.tickLength);
            }

            if(tickData){
                tickData.forEach(function(t){
                    var labelDim = t.tickDim;
                    maxLabelLength = Math.max(maxLabelLength, isHorizontal ? labelDim.height : labelDim.width);
                });
            }else{
                // dim calc duplicated
                var ticks = this._getTickValues();
                for(var i = 0, len = ticks.length; i < len;  i++){
                    var testDim = this._getTickDim(this._getTickContent(ticks[i], axisOption.formatter));
                    maxLabelLength = Math.max(isHorizontal ? testDim.height : testDim.width, maxLabelLength);
                }
            }

            return tickLength + (axisOption.showLabel ? maxLabelLength: 0);
        },

        _getTickDim:function(tickContent){
            var axisOption = this.options, useHtml = axisOption.useHtml, rotation = axisOption.labelRotation || 0;
            var style = axisOption.labelStyle || {};
            return BaseUtils.getTextDimensionWithRotation(tickContent, style, useHtml, rotation);
        },

        //不考虑step和自动间隔
        _updateOriginTickData:function(){
            var labels = this._getTickValues(), axis = this;

            this._calculateLabelRotation(labels);
            this.tickData = [];
            
            for(var i = 0, len = labels.length; i < len; i++){
                var tickValue = labels[i], tickContent = tickValue;
                this.tickData.push(axis._calculateSingleTickData(tickValue, tickContent));
            }
        },

        /**
         * 计算标签旋转角度
         * @param  {[type]} labels [description]
         * @return {[type]}        [description]
         */
        _calculateLabelRotation: function (labels) {
            var option = this.options, formatter = option.formatter;

            if (!isNaN(option.labelRotation)) {
                this.labelRotation = option.labelRotation;
            } else if (option.autoRotate) {
                this.labelRotation = this.getLabelAutoRotation(labels, option, formatter);
            } else {
                this.labelRotation = 0;
            }
        },

        /**
         * 计算单个tickData
         * @return {[type]} [description]
         */
        _calculateSingleTickData: function (value, content, option){
            option = option || {};

            var axisOption = this.options;
            var formatter = axisOption.formatter, useHtml = axisOption.useHtml;

            var style = axisOption.labelStyle || {};
            var tbStyle = BaseUtils.extend(this._getVerticalTextStyle(), style);

            var tickContent = this._getTickContent(content, formatter);
            if (this.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT && tickContent) {
                tickContent = (tickContent + '').trim();
            }
            var rectDim, labelDim, tmpStyle = style;
            var labelRotation = this.labelRotation;

            if (Math.abs(labelRotation) === 90 && BaseUtils.hasChn(tickContent)) {
                labelRotation = 360; // as a log
                tmpStyle = tbStyle;
            }

            rectDim = BaseUtils.getTextDimension(tickContent, tmpStyle, useHtml);
            labelDim = BaseUtils.getTextDimRotated(rectDim, labelRotation);

            if(useHtml){
                labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
            }

            return QueryUtils.merge({
                tickValue:value,
                tickContent:tickContent,
                tickDim:labelDim,
                tickRectDim:rectDim,
                labelRotation: labelRotation
            }, option);
        },

        _isBaseAxis:function(){
            if(this.series.length){
                return this.componentType == this.series[0].getBaseAxisType();
            }
            return false;
        },

        getLabelAutoRotation: function () {
            return 0;
        },

        _getVerticalTextStyle: function (){
            var style = {
                'writingMode': 'tb-rl',
                'writing-mode': 'tb-rl'
            };
            if(!BaseUtils.hasTouch()){style['-webkit-writing-mode'] = 'vertical-rl'; }  // @BI-8541 安卓7.0以下版本使用vertical-rl会竖着排，但是文字是躺着的
            return style;
        },

        _getAxisTitleLength:function(){
            var title = this.options.title;

            if(!title || BaseUtils.isEmpty(title.text)){
                return 0;
            }

            var rectDim, dim;
            this.titleRotation = title.rotation;
            if (BaseUtils.hasChn(title.text) && Math.abs(title.rotation) === 90) {
                this.titleRotation = 360;
                title.style = BaseUtils.extend(this._getVerticalTextStyle(), title.style);
            }

            rectDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);

            dim = BaseUtils.getTextDimRotated(rectDim, this.titleRotation);

            this.titleRectDim = rectDim;
            this.titleDim = dim;

            return this.isHorizontal() ? dim.height : dim.width;
        },

        //坐标轴占据的空间
        getAxisTitleBounds:function(){

            var bounds = this.bounds;

            var tickLength = this.tickLabelLength + TITLE_LABEL_GAP_FUN();
            var labelLength = this.labelLength;

            var position = this.getPosition();

            var x = bounds.x;
            var y = bounds.y;
            var width = bounds.width;
            var height = bounds.height;

            switch (position){
                case Constants.LEFT:
                    x += width - tickLength - labelLength;  // 限制坐标轴尺寸时，标题与标签不应该重叠
                    width -= tickLength;
                    break;

                case Constants.BOTTOM:
                    y += tickLength;
                    height -= tickLength;
                    break;

                case Constants.RIGHT:
                    x += tickLength;
                    width -= tickLength;
                    break;

                case Constants.TOP:
                    y += height - tickLength - labelLength;  // 同Left时x计算
                    height -= tickLength;
                    break;
            }

            return {
                x:x,
                y:y,
                width: Math.max(width, 0),
                height: Math.max(height, 0)
            }
        },

        getTickLength:function(){
            var range = this.scale.range();
            return Math.abs(range[0] - range[1]) / Math.max(this.tickData.length, 1);
        },

        /**
         * **这个调整是有条件的，没有缩放，没有自定义的最大最小值**
         * 根据数据点的半径大小，重新调整坐标轴的dataDomain，保证可以全部显示，需要考虑的情况有：
         * 气泡图，散点图，折线图这一类有标记点的
         * 时间轴上的柱形图或者条形图
         * @returns {boolean}
         */
        adjustDomain4Radius: function () {
            if(this.type === ComponentLibrary.VALUE_AXIS_COMPONENT ||
                this.type === ComponentLibrary.DATE_AXIS_COMPONENT){

                var domain = this._domain, isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;
                var range = this._getRange();
                var minMax = this._dataDomain;

                var originLabelWidth = Math.max((domain[0] + '').length, (domain[1] + '').length);

                if(isDate){
                    domain = [BaseUtils.int2date(domain[0]), BaseUtils.int2date(domain[1])];
                }

                var scale = Scale.linear().domain(domain).range(range);

                var axis = this, isBaseAxis = this._isBaseAxis();

                var key = (this.componentType === ComponentLibrary.X_AXIS_COMPONENT) ? 'x' : 'y';

                var downBound = Number.MAX_VALUE, upBound = -Number.MAX_VALUE;

                this.series
                    .map(function(item){
                        if (!item.visible) {  return; }

                        var points = item.points,
                            seriesType = item.type;

                        // 获取数据点的扩展半径
                        var getPointRadius = function (point){
                            switch(seriesType) {
                                case Constants.BUBBLE_CHART:
                                case Constants.SCATTER_CHART:
                                    return BaseUtils.pick(point.radius, point.options.marker && point.options.marker.radius);
                                case Constants.COLUMN_CHART:
                                case Constants.BAR_CHART:
                                    // 柱形图和条形图，只需要考虑当前轴为BaseAxis

                                    return isBaseAxis ? (item._seriesWidth || item.getSeriesOffsetAndWidth().width) / 2 : 0;
                                case Constants.LINE_CHART:
                                case Constants.AREA_CHART:
                                    return point.options.marker && point.options.marker.radius || item.options.lineWidth;
                                default: return 0;
                            }
                        };

                        points.forEach(function (point){
                           var pos = scale(axis.getAxisValue(point[key], point));
                           if(point.visible && !point.isNull && !isNaN(pos)) {
                               var radius = getPointRadius(point);
                               downBound = Math.min(downBound, pos - radius);
                               upBound = Math.max(upBound, pos + radius);
                           }
                        });
                    });

                if (downBound === Number.MAX_VALUE || upBound === -Number.MAX_VALUE) {
                    return;
                }

                var b1 = scale.invert(downBound), b2 = scale.invert(upBound);

                if(isDate){
                    b1 = BaseUtils.date2int(b1);
                    b2 = BaseUtils.date2int(b2);
                }

                this.calculateDomainFromData([Math.min(Math.min(b1, b2), minMax[0]), Math.max(Math.max(b1, b2), minMax[1])]);

                var labelWidth = Math.max((this._domain[0] + '').length, (this._domain[1] + '').length);

                if (labelWidth > originLabelWidth) {
                    return true;
                }
            }
        },

        _getRange:function(){
            return this.componentType === ComponentLibrary.GAUGE_AXIS_COMPONENT ? this._getGaugeAxisRange() : this._getPlotRange();
        },

        /**
         * 限制最小刻度间隔
         * @returns {number}
         */
        limitTickInterval: function (){
            var domain = this._domain, maxValue = domain[1], minValue = domain[0];
            var axisRange = this._getRange();
            if(axisRange){
                var axisPixelSize = Math.abs(axisRange[0] - axisRange[1]),
                    minAllowedTickInterval = Math.floor((maxValue - minValue) / axisPixelSize * 5); // BI这边不能自定义次要刻度,那么主要刻度应该为最小次要刻度间隔的5倍
                return minAllowedTickInterval;
            }
        },

        /**
         * 现在的GaugeAxis的TickData计算是在Series.layout之前就需要定下来
         * 而关于值轴标签不溢出，则需要计算整个值轴的像素长度，而值轴的像素长度需要系列的半径才能确定，而系列的半径确定又在系列的layout里面计算
         * TODO 这里所用来计算的系列半径，只是一个大概的预估值
         * @returns {[number,null]}
         */
        _getGaugeAxisRange: function (){
            if(!this.series.length){return}
            var series = this.series[0], vanchart = this.vanchart, seriesLen = vanchart.series.length;
            var width = vanchart.width, height = vanchart.height;
            var gaugeStyle = series.options.style;

            var axisSize;
            switch(gaugeStyle){
                case Constants.POINTER_SEMI_GAUGE:
                    axisSize = Math.PI * Math.min(width, height) / (2 * seriesLen);
                    break;
                case Constants.THERMOMETER_GAUGE:
                    axisSize = this.options.thermometerLayout === Constants.HORIZONTAL_LAYOUT ? width : height;
                    break;
                default:
                    axisSize = Math.PI * (Math.min(width, height) / (2 * seriesLen)) * 5 / 3;  // 300 / 360 * 2 * PI * R
            }
            return [0, Math.floor(axisSize)];
        },

        _getPlotRange:function(){
            var plotBounds = this.vanchart.bounds;

            if(this.isHorizontal()){
                return this.isAxisReversed() ? [plotBounds.width, 0] : [0, plotBounds.width];
            }else{
                return this.isAxisReversed() ? [0, plotBounds.height] : [plotBounds.height, 0];
            }
        },

        _getPlotBands:function(){

            var plotBands = this.options.plotBands;
            var scale = this.scale;
            var isRangeBand = !!(scale.rangeBand && scale.rangeBand());

            if(typeof plotBands == 'string'){

                var color = plotBands;
                plotBands = [];

                var labels = this._getTickValuesWithEndValue();

                var endIndex = isRangeBand ? -1 : 0;

                for(var index = labels.length - 1; index > endIndex; index -= 2){
                    plotBands.push({
                        color:color,
                        from:isRangeBand ? labels[index] : labels[index - 1],
                        to:labels[index]
                    });
                }

            }else{

                plotBands = plotBands || [];

                var result = [];

                for(var i = 0, count = plotBands.length; i < count; i++){

                    var t_bands = plotBands[i];

                    if(BaseUtils.hasDefined(t_bands.from) && BaseUtils.hasDefined(t_bands.to)){
                        result.push(t_bands);
                    }

                }

                plotBands = result;
            }

            return plotBands;
        },

        _getTickValuesWithEndValue:function(){

            var result = this._getTickValues();

            var max = this._domain[1], isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;

            if(result.length){

                var maxInList = result[result.length - 1];

                if(isDate){
                    if(BaseUtils.date2int(maxInList) < max){
                        result.push(BaseUtils.int2date(max));
                    }
                }else{
                    if(maxInList < max){
                        result.push(max);
                    }
                }
            }

            return result;
        },

        //画的时候计算自定义标签间隔等
        getTickData:function(){
            return this.tickData;
        },

        getMinorTickData:function(){

            var minorTickData = [], cfg = this.options, interval = this._step;

            if(this.options.enableMinorTick && this.tickData.length){

                //分类轴
                if(this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT){
                    var minorTickLength = Math.round(this.getTickLength() / 5);
                    var endIndex = this.tickData.length;
                    endIndex = this.isRangePoints ? endIndex - 1 : endIndex;
                    for(var i = 0; i < endIndex; i++){
                        var startPos = this.tickData[i].tickPos;
                        for(var j = 1; j < 5; j++){
                            minorTickData.push(startPos + minorTickLength * j);
                        }
                    }
                }else{

                    var minorInterval = cfg.minorTickInterval ? cfg.minorTickInterval : interval / 5;

                    for(var i = 0, count = this.tickData.length; i < count - 1; i++){

                        var start = this.tickData[i].tickValue;

                        var end = this.tickData[i + 1].tickValue;

                        var isDate = (start instanceof Date && end instanceof Date);

                        start = isDate ? BaseUtils.date2int(start) : start;
                        end = isDate ? BaseUtils.date2int(end) : end;

                        for(var value = BaseUtils.accAdd(start,minorInterval); value < end; value = BaseUtils.accAdd(value, minorInterval)){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }

                    var endValue = this.tickData[this.tickData.length - 1].tickValue;
                    var maxValue = this.scale.domain()[1];

                    var isDate = (endValue instanceof Date) && (maxValue instanceof Date);
                    endValue = isDate ? BaseUtils.date2int(endValue) : endValue;
                    maxValue = isDate ? BaseUtils.date2int(maxValue) : maxValue;

                    if(endValue < maxValue){
                        for(var value = endValue + minorInterval; value <= maxValue; value += minorInterval){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }

                    var startValue = this.tickData[0].tickValue;
                    var minValue = this.scale.domain()[0];

                    isDate = (startValue instanceof Date) && (minValue instanceof Date);
                    startValue = isDate ? BaseUtils.date2int(startValue) : startValue;
                    minValue = isDate ? BaseUtils.date2int(minValue) : minValue;

                    if(startValue > minValue){
                        for(value = startValue - minorInterval; value >= minValue; value -= minorInterval){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }
                }
            }

            return minorTickData;
        },

        getMaxTickWidth:function(){
            var maxWidth = 0;

            this.tickData.forEach(function(data){
                maxWidth = Math.max(maxWidth, data.tickDim.width);
            });

            return maxWidth;
        },

        getTickHeight:function(){
            if(this.options.labelStyle && this.options.showLabel){
                return BaseUtils.getTextHeight(this.options.labelStyle);
            }
            return 0;
        },

        _calculateTickPosAndStep:function(){

            var axisOption = this.options, scale = this.scale, tickInterval = this.getTickLength();
            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;

            var tickData = this.getTickData();

            tickData.forEach(function(t){
                t.tickPos = scale(t.tickValue);
                t.tickLabelPos = t.tickPos + det;
            });

            if(!axisOption.showLabel){
                tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }else if(axisOption.step){
                var index = 0;
                tickData.forEach(function(t){
                    if(index++ % axisOption.step){
                        t.tickContent = '';
                    }
                });
            }else{
                var isHorizontal = this.isHorizontal(), testStep = 1, longestStep = 1;

                // label rotated [15-90) can as long as it can
                // otherwise check the dim
                var labelRotation = Math.abs(Math.abs(this.labelRotation) - (isHorizontal ? 0 : 90)),
                    isRotated = (labelRotation >= 15 && labelRotation !== 90),
                    labelRadian;
                labelRadian = BaseUtils.toRadian(labelRotation);
                var lastTickPos, lastH = -1, gap, l, h,
                    sin = Math.sin(labelRadian);

                tickData.forEach(function(t){
                    if (t.tickContent === '') {
                        return;
                    }

                    if (isRotated) {
                        h = t.tickRectDim.height;
                        gap = Math.abs(t.tickPos - lastTickPos);
                        l = (h + lastH) / 2;
                        if (l < gap * sin || lastH === -1) {
                            testStep = 1;
                            lastTickPos = t.tickPos;
                            lastH = h;
                        } else {
                            testStep++;
                            longestStep = Math.max(longestStep, testStep);
                        }

                    } else {

                        var testLength = isHorizontal ? t.tickDim.width : t.tickDim.height;

                        if(tickInterval){
                            longestStep = Math.max(longestStep, Math.ceil(testLength/tickInterval));
                        }

                    }
                });

                var index = 0;
                tickData.forEach(function(t){
                    if(index++ % longestStep){
                        t.tickContent = '';
                    }
                });
            }
        },

        _getAxisOriginPoint:function(){
            var axisBounds = this.bounds;
            var position = this.getPosition();
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = axisBounds.x;
                    y = axisBounds.y + axisBounds.height;
                    break;

                case Constants.BOTTOM:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;

                case Constants.LEFT:
                    x = axisBounds.x + axisBounds.width;
                    y = axisBounds.y;
                    break;

                case Constants.RIGHT:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        getPosition:function(){
            var defaultPosition = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'bottom' : 'left';
            var position = this.options.position || defaultPosition;

            if (this.vanchart.isInverted()){
                switch (position) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            } else {
                return position;
            }
        },

        isAxisReversed:function(){
            if (this.componentType === ComponentLibrary.X_AXIS_COMPONENT &&
                this.vanchart.isInverted()) {
                return !this.options.reversed;
            }
            return this.options.reversed;
        },

        isOnZero:function(){
            return this.options.onZero;
        },

        getLineWidth:function(){
            return this.options.lineWidth;
        },

        showArrow:function(){
            return this.options.showArrow;
        },

        getTitleAlign: function () {
            var title = this.options.title;
            if (!title) {
                return null;
            }

            var align = title.align || 'center';

            if (this.vanchart.isInverted()) {
                switch (align) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            }

            return align;
        },

        _calculateLogNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options, logBase = axisOption.log;

            var tickInterval = parseInt(BaseUtils.pick(axisOption.tickInterval, 1));

            minValue = minValue >= 1 ? 1 : minValue;
            minValue = minValue <= 0 ? 1 : minValue;

            minValue = BaseUtils.pick(fixedMin, minValue);
            maxValue = BaseUtils.pick(fixedMax, maxValue);

            minValue = Math.pow(logBase, Math.floor(BaseUtils.log(logBase, minValue)));
            maxValue = Math.pow(logBase, Math.ceil(BaseUtils.log(logBase, maxValue)));

            this._domain = [minValue, maxValue];
            this._tickStart = minValue;
            this._step = tickInterval;
        },

        _calculatePercentValueDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options, min = BaseUtils.pick(fixedMin, 0), max = BaseUtils.pick(fixedMax, 1);
            var interval = BaseUtils.pick(axisOption.tickInterval, 0.25);

            this._domain = [min, max];
            this._tickStart = min;
            this._step = interval;
        },

        //普通的值轴
        _calculateValueNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){

            var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && !this._isBaseAxis();

            var axisOption = this.options;

            if(fromZero){
                if(minValue > 0){
                    minValue = 0;
                }else if(maxValue < 0){
                    maxValue = 0;
                }
            }

            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : minValue;
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : maxValue;

            // if any exceeded min, adjust max to min + 100
            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var tickInterval = axisOption.tickInterval || this._linearTickInterval(minValue, maxValue);

            var domain = this._linearNiceDomain(minValue, maxValue, tickInterval);
            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : domain[0];
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : domain[1];

            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var start = domain[0];

            if(BaseUtils.hasDefined(fixedMin)){

                // ceil( (fixedMin - start) / tickInterval ) * tickInterval
                var diff = BaseUtils.accMul(
                    Math.ceil(
                        BaseUtils.accDiv(BaseUtils.accAdd(fixedMin, -start), tickInterval)
                    ),
                    tickInterval
                );

                start = BaseUtils.accAdd(start, diff);
            }


            this._domain = [minValue, maxValue];
            this._tickStart = start;

            var minAllowedTickInterval = this.limitTickInterval();
            this._step = minAllowedTickInterval ? Math.max(minAllowedTickInterval, tickInterval) : tickInterval;
        },

        _linearTickInterval:function(minValue, maxValue, m){

            m = m || this._getDefaultTickCount();
            var span = maxValue - minValue;
            var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
            var err = m / span * step;

            if (err <= .15) {
                step *= 10;
            } else if (err <= .35) {
                step *= 5;
            } else if (err <= .75) {
                step *= 2;
            }

            if (this.type === ComponentLibrary.DATE_AXIS_COMPONENT) {
                step = Math.max(step, 1000); // min date step = 1 second
            }

            return step;
        },

        _linearNiceDomain:function(minValue, maxValue, tickInterval){

            minValue = BaseUtils.accMul(Math.floor(minValue / tickInterval), tickInterval);

            maxValue = BaseUtils.accMul(Math.ceil(maxValue / tickInterval), tickInterval);

            return [minValue, maxValue];
        },

        _getDefaultTickCount:function(){
            return this.vanchart.options.chartType == Constants.RADAR_CHART ? RADAR_TICK_COUNT : TICK_COUNT;
        },

        getIndexByPosition: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var startX = scale(
                this.isAxisReversed() ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (this.isHorizontal()) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            switch (this.type) {
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    index = BaseUtils.date2int(scale.invert(x));
                    break;
                default:
                    index = scale.invert(x);
            }

            index = Math.round(index);
            return index;
        },

        _valueInDomain: function () {
            return true;
        },

        render:function(){

            this.lastScale = this.scale && this.scale.copy();

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = this.createComponentGroup();
                renderer.clip(this.clipAxisGroup = this.createComponentGroup(), vanchart.plotClip);
            }

            //clip的显示区域
            var b = this.bounds;
            var clipBounds = {x:b.x, y:b.y, width:b.width, height:b.height};

            if(this.isHorizontal()){
                clipBounds.x = 0; clipBounds.width = vanchart.width;
            }else{
                clipBounds.y = 0; clipBounds.height = vanchart.height;
            }

            if(!this.axisGroupClip){
                this.axisGroupClip = renderer.createClip(clipBounds);
                renderer.clip(this.axisGroup, this.axisGroupClip);
            }else{
                renderer.updateClip(this.axisGroupClip, clipBounds);
            }

            if(!this.axisLineGroup){
                this.axisLineGroup = renderer.group().addTo(vanchart.seriesGroup);
            }
			
			// 没有数据时，不绘制任何轴线
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this._drawPlotBands();

            this._drawGridLine();

            this._drawTickLine();

            this._drawTickLabel();

            this._drawPlotLines();

            this._drawAxisTitle();

            this._drawAxisLine();
        },

        isLog:function(){
            return this.options.log;
        },

        getZeroPos:function(){

            switch (this.type){
                case ComponentLibrary.VALUE_AXIS_COMPONENT:

                    return this.isLog() ? this.scale(1) : this.scale(0);

                case ComponentLibrary.DATE_AXIS_COMPONENT:

                    return this.scale(BaseUtils.int2date(0));

                case ComponentLibrary.CATEGORY_AXIS_COMPONENT:

                    return 0;
            }

        },

        _drawPlotBands:function(){
            var plotBands = this._getPlotBands(), scale = this.scale, isRangeBand = scale.rangeBand;
            var rangeBand = isRangeBand ? scale.rangeBand() : 0;

            var renderer = this.vanchart.renderer;
            var plotBounds = this.vanchart.bounds, axis = this, isHorizontal = axis.isHorizontal();

            var i, len, from, to, rect;
            var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

            if(!this.plotBandsGroup){
                this.plotBandsGroup = renderer.group().addTo(this.clipAxisGroup);
                this.plotBands = [];
            }

            this.plotBandsGroup.attr({'transform': BaseUtils.makeTranslate(plotBounds)});

            for(i = plotBands.length; i < this.plotBands.length; i++){
                this.plotBands[i] && this.plotBands[i].remove();
                this.plotBands[i] = null;
            }

            this.plotBands.length = plotBands.length;

            for(i = 0, len = plotBands.length; i < len; i++){
                var d = plotBands[i];

                var t_f = scale(d.from), t_t = scale(d.to);
                from = Math.min(t_f, t_t); to = Math.max(t_f + rangeBand, t_t + rangeBand);

                from = Math.max(isHorizontal ? x : y, from);
                to = Math.min(isHorizontal ? width : height, to);

                rect = isHorizontal ? {x:from, y:y, width:Math.max(to - from, 0), height:height}
                    :{x:x, y:from, width:width, height:Math.max(to - from, 0)};

                this.plotBands[i] = this.plotBands[i] || renderer.rect(rect).addTo(this.plotBandsGroup);

                this.plotBands[i].style({'fill':d.color}).animate({
                    'duration':TIME, 'ease':EASE, attr:rect
                });
            }
        },

        _drawAxisLine:function(){
            var cfg = this.options, lineWidth = cfg.lineWidth, lineColor = cfg.lineColor;
            var plotBounds = this.getPlotBounds(), axisOrigin = this._getAxisOriginPoint();
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var size = plotBounds.width, renderer = this.vanchart.renderer;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                size = plotBounds.height;
            }
            var det = BaseUtils.lineSubPixelOpt(0, lineWidth);
            if(!this.axisLine){
                this.axisLine = renderer.line().addTo(this.axisLineGroup);
            }
            var attrs = {};attrs[x1] = 0; attrs[x2] = size; attrs[y1] = attrs[y2] = det;
            attrs.transform = BaseUtils.makeTranslate(axisOrigin);
            this.axisLine.attr(attrs).style({stroke:lineColor, 'stroke-width': lineWidth});

            if(this.showArrow()){

                if(!this.arrowGroup){
                    this.arrowGroup = renderer.group().addTo(this.axisLineGroup);
                }

                var line = this.arrowGroup.line || renderer.line().addTo(this.arrowGroup);
                var path = this.arrowGroup.path || renderer.path().addTo(this.arrowGroup);
                this.arrowGroup.line = line; this.arrowGroup.path = path;

                if(this.isHorizontal()){
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y]));
                    line.attr({'x1':0, 'y1':det, 'x2':6, 'y2':det}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M2,-4 L10,0 L2,4 L6,0 L2,-4"}).style({'fill':lineColor});
                }else{
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate(axisOrigin));
                    line.attr({'x1':det, 'y1':0, 'x2':det, 'y2':-6}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M-4,-2 L0,-10 L4,-2 L0,-6 L-4,-2"}).style({'fill':lineColor});
                }
            }else{
                this.arrowGroup && this.arrowGroup.remove();
            }
        },

        _drawGridLine:function(){
            var cfg = this.options, plotBounds = this.getPlotBounds();
            var ticks = this.getTickData(), scale = this.scale, lastScale = this.lastScale || scale;
            var gridLineColor = cfg.gridLineColor, gridLineWidth = cfg.gridLineWidth;

            // phantomjs 1.9, 
            // svg 'stroke-width' has a default value 1
            // 0 is still 1 (→_→ maybe "value || 1" in apple's webkit...)
            if (gridLineWidth === 0) {
                gridLineColor = '';
            }

            var det = BaseUtils.lineSubPixelOpt(0, gridLineWidth), renderer = this.vanchart.renderer;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', lineSize = plotBounds.height;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';lineSize = plotBounds.width;
            }

            if(!this.gridLinesGroup){
                this.gridLinesGroup = renderer.group().addTo(this.clipAxisGroup);
                this.gridLines = [];
            }
            this.gridLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));

            var pos = this.getPosition(), isBottomOrTop = pos === Constants.TOP || pos === Constants.BOTTOM;
            // 当轴在上方或者下方时，需要在最右侧加一个边界线，在左方或者右方是，在最下方加
            var concatArray = this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? [{tickPos: isBottomOrTop ? plotBounds.width : plotBounds.height - 1}] : [];
            var selection = this._bindData(this.gridLines, ticks.concat(concatArray), function(d){return d.tickValue});

            var currentGridLines = [];
            for(var i = 0, len = selection.exit.length; i < len; i++){
                var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                var attr = {}; attr[x1] = pos; attr[x2] = pos;
                selection.exit[i].animate({
                    'duration':TIME, 'ease':EASE, 'attr':attr, 'style':{'opacity':0}
                }).remove();
            }

            for(var i = 0, len = selection.enter.length; i < len; i++){

                var d = selection.enter[i];
                var gridLine = renderer.line().style({'stroke':gridLineColor, 'stroke-width':gridLineWidth}).addTo(this.gridLinesGroup);
                var lastPos = lastScale(d.tickValue) + det;
                var pos = d.tickPos + det;
                lastPos = isNaN(lastPos) ? pos : lastPos;

                gridLine.attr(x1, lastPos).attr(x2, lastPos).attr(y1, 0).attr(y2, lineSize);

                var attr = {}; attr[x1] = pos, attr[x2] = pos, attr[y1] = 0, attr[y2] = lineSize;

                gridLine.animate({'attr':attr, 'duration':TIME, 'ease':EASE});

                gridLine.datum(d);
                currentGridLines.push(gridLine);
            }

            currentGridLines = currentGridLines.concat(selection.update);

            for(var i = 0, len = currentGridLines.length; i < len; i++){
                var gridLine = currentGridLines[i].style({'stroke':gridLineColor, 'stroke-width':gridLineWidth});
                var d = gridLine.datum(), pos = d.tickPos + det;
                var attr = {}; attr[x1] = pos, attr[x2] = pos, attr[y1] = 0, attr[y2] = lineSize;
                gridLine.animate({'attr':attr, 'duration':TIME, 'ease':EASE});
            }

            this.gridLines = currentGridLines;
        },

        //包括主要刻度线和次要刻度线,不加动画了
        _drawTickLine:function(){
            var renderer = this.vanchart.renderer, cfg = this.options;

            if(!this.tickLinesGroup){
                this.tickLinesGroup = renderer.group().addTo(this.axisGroup);
                this.tickLines = {};
                this.tickLines[MAIN_TICK] = [];
                this.tickLines[MINOR_TICKS] = [];
            }

            var tickLength = cfg.enableTick ? (cfg.tickLength || 0) : 0;
            var tickWidth = cfg.tickWidth || 1,tickColor = cfg.tickColor;
            var detMain = BaseUtils.lineSubPixelOpt(0, tickWidth);

            var minorTickLength = cfg.enableMinorTick ? (cfg.minorTickLength || 0) : 0;
            var minorTickColor = cfg.minorTickColor, minorTickWidth = cfg.minorTickWidth || 1;
            var detMinor = BaseUtils.lineSubPixelOpt(0, minorTickWidth);

            // 绘制主要间隔线
            this._drawMainTickLine({
                det:detMain,
                tickWidth:tickWidth,
                tickLength:tickLength,
                tickColor:tickColor
            });
            // 绘制次要间隔线
            this._drawMinorTickLine({
                det:detMinor,
                tickWidth:
                minorTickWidth,
                tickLength:minorTickLength,
                tickColor:minorTickColor
            });
        },

        /**
         * 绘制主要刻度线，多分类轴时重写该方法
         * @param  {[type]} option [description]
         * @return {[type]}        [description]
         */
        _drawMainTickLine: function (option) {
            var ticks = this.getTickData();
            this.tickLines[MAIN_TICK] = this._drawTickLineWithData(this.tickLines[MAIN_TICK], ticks, option);
        },

        /**
         * 绘制次要刻度线
         * @param  {[type]} option [description]
         * @return {[type]}        [description]
         */
        _drawMinorTickLine: function (option) {
            var minorTickData = this.getMinorTickData();
            this.tickLines[MINOR_TICKS] = this._drawTickLineWithData(this.tickLines[MINOR_TICKS], minorTickData,option );
        },

        /**
         * 根据给定的数据绘制标签间隔线
         * @param  {[type]} tickLines [存放tickLine的数组，方便以后更新tickLine]
         * @param  {[type]} tickData  [刻度线数据：包括文字内容，位置等]
         * @param  {[type]} options   [刻度线的样式等]
         * @return {[type]}           [description]
         */
        _drawTickLineWithData: function (tickLines, tickData, options) {
            var axisOrigin = this._getAxisOriginPoint(), orient = this.getPosition();
            var renderer = this.vanchart.renderer, axis = this;

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var selection = axis._bindData(tickLines, tickData, options.keyFunction);
            var currentTickLines = [], i, len;

            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                currentTickLines.push(renderer.line().datum(selection.enter[i]).addTo(axis.tickLinesGroup));
            }

            currentTickLines = currentTickLines.concat(selection.update);

            for(i = 0, len = currentTickLines.length; i < len; i++){
                var datum = currentTickLines[i].datum(), attrs  = {};

                var tickPos;

                if(BaseUtils.hasDefined(datum.tickPos)){
                    tickPos = datum.tickPos;
                }else{
                    tickPos = axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? datum : axis.scale(datum);
                }

                var detX = axisOrigin.x, detY = axisOrigin.y;
                if(!axis.isHorizontal()){
                    detX = axisOrigin.y; detY = axisOrigin.x;
                }

                // 多分类轴的时候，其主要刻度线的高度应该根据其categoryKey来计算
                var tickLength = typeof options.tickLengthFuc === "function" ? options.tickLengthFuc(datum) : options.tickLength;

                attrs[x1] = tickPos + options.det + detX; attrs[x2] = attrs[x1];
                attrs[y1] = detY;
                attrs[y2] = (sign * tickLength || 0) + detY;

                currentTickLines[i].attr(attrs).style({
                    'stroke':options.tickColor, 'stroke-width':options.tickWidth
                });
            }

            return currentTickLines;
        },

        _drawPlotLines:function(){
            var plotLines = this.options.plotLines || [], position = this.getPosition();
            var plotBounds = this.vanchart.bounds;
            var scale = this.scale, isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;
            var result = [], axis = this, renderer = this.vanchart.renderer;
            plotLines.forEach(function(d){
                if (BaseUtils.isEmpty(d.value)) {
                    return;
                }

                var originPos = scale(isDate ? BaseUtils.object2date(d.value) : d.value) + (scale.rangeBand ? scale.rangeBand()/2 : 0);
                var pos = BaseUtils.lineSubPixelOpt(originPos, d.width);
                var x1, x2, y1, y2;

                if (axis.isHorizontal()) {
                    if (originPos < 0 || originPos > plotBounds.width) { return }
                    x1 = x2 = pos; y1 = 0; y2 = plotBounds.height;
                } else {
                    if (originPos < 0 || originPos > plotBounds.height) { return }
                    x1 = 0; x2 = plotBounds.width; y1 = y2 = pos;
                }

                var textX, textY, text, style;
                if(d.label && d.label.text && d.label.style){
                    style = d.label.style; text = d.label.text;
                    var align = d.label.align;
                    var textDim = BaseUtils.getTextDimension(text, style, d.label.useHtml);
                    switch (align){
                        case Constants.TOP:
                            textX = x1 - textDim.width; textY = y1;
                            break;
                        case Constants.BOTTOM:
                            textX = x1 - textDim.width; textY = y2 - textDim.height;
                            break;
                        case Constants.LEFT:
                            textX = x1; textY = y1 - textDim.height - LABEL_LINE_GAP_FUN();
                            break;
                        case Constants.RIGHT:
                            textX = x2 - textDim.width; textY = y2 - textDim.height - LABEL_LINE_GAP_FUN();
                            break;
                    }
                }

                result.push({
                    color: d.color,
                    line:{x1:x1, y1:y1, x2:x2, y2:y2},
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],

                    text:text,
                    textDim:textDim,
                    style:style,
                    textX:textX,
                    textY:textY
                });
            });

            function _getPlotLineStyle(datum){
                return {'stroke':datum.color, 'stroke-width':datum.width, 'stroke-dasharray':datum.dataArray};
            }

            function _getLabelGraphic(datum){
                return renderer.text().textContent(datum.text).style(datum.style)
                    .attr({'x':datum.textX, 'y':datum.textY, 'text-anchor':'left', 'dy':datum.textDim.height * .85});
            }

            function _createLabelGraphic(datum, g){
                if(g._textG){
                    g._textG.remove();
                    g._textG = null;
                }
                if(datum.text && datum.textDim) {
                    g._textG = _getLabelGraphic(datum).addTo(g);
                }
            }

            if(!this.plotLinesGroup){
                this.plotLinesGroup = renderer.group().addTo(this.vanchart.backGroup);  // plotLines在clipSeriesGroup里面会盖在Series前面
                this.plotLines = [];
            }

            this.plotLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            var selection = this._bindData(this.plotLines, result), i, len;
            this.plotLines = [];

            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var datum = selection.enter[i], g = renderer.group();
                this.plotLines.push(g);

                g._lineG = g.append(renderer.line(datum.line).style(_getPlotLineStyle(datum)));
                _createLabelGraphic(datum, g);
                g.addTo(this.plotLinesGroup);
            }

            for(i = 0, len = selection.update.length; i < len; i++){
                var g = selection.update[i], datum = g.datum();

                g._lineG.attr(datum.line).style(_getPlotLineStyle(datum));

                _createLabelGraphic(datum, g);
                this.plotLines.push(g);
            }
        },

        _drawTickLabel:function(){
            this._drawSvgTickLabel();
        },

        /**
         * 使用SVG绘制轴标签：多分类轴下，需要重写这个方法
         * @return {[type]} [description]
         */
        _drawSvgTickLabel:function(){
            var vanchart = this.vanchart, renderer = vanchart.renderer;

            var ticks = this.getTickData().filter(function(tick){return tick.tickContent !== ''});

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = renderer.vgroup().add();
                this.axisGroup.append(this.tickLabelsGroup.renderG);
                this.tickLabels = [];
            }

            this.tickLabels = this._drawSvgTickLabelWithData(this.tickLabels, ticks);
        },

        /**
         * 绘制单行的svg标签
         * @param  {[type]} tickLabels [description]
         * @param  {[type]} ticks      [description]
         * @param  {[type]} level      [description]
         * @return {[type]}            [description]
         */
        _drawSvgTickLabelWithData: function (tickLabels, ticks, level) {
            var axis = this, vanchart = this.vanchart, renderer = vanchart.renderer;
            var startPos = level ? this._getLabelStartPos(level) : 0;

            var scale = this.scale, lastScale = this.lastScale || scale;
            var cfg = this.options, labelStyle = cfg.labelStyle,
                useHtml = cfg.useHtml;

            var selection = this._bindData(tickLabels, ticks, function (d) {return d.tickValue}), i, len;

            var currentTickLabels = [], para = {'duration':TIME, 'ease':EASE, 'style':{'opacity':0}};
            for(i = 0, len = selection.exit.length; i < len; i++){
                var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                selection.exit[i].animate(BaseUtils.extend({}, para, axis.isHorizontal() ? {'x': pos} : {'y' : pos})).remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var d = selection.enter[i];
                var transform = this._getLabelAttr(lastScale, d, startPos);

                var tickLabel = this.tickLabelsGroup.append(
                    renderer.vtext(useHtml)
                        .textContent(d.tickContent)
                        .style({'opacity':0})
                );
                var rotateStr = (d.labelRotation % 360) ?
                    tickLabel.vRotate(d.labelRotation, true/* delay */).rotateStr : '';
                transform.transform += rotateStr;
                tickLabel.attr(transform);
                tickLabel.datum(d);
                currentTickLabels.push(tickLabel);
            }

            currentTickLabels = currentTickLabels.concat(selection.update);

            for(i = 0, len = currentTickLabels.length; i < len; i++){
                var tickLabel = currentTickLabels[i], d = tickLabel.datum();
                tickLabel.textContent(d.tickContent).style(labelStyle);

                var transform = this._getLabelAttr(scale, d, startPos);

                var opacity = this._valueInDomain(d.tickValue) ? 1 : 0;

                if(this.useHtmlLabel()){
                    tickLabel.attr(transform).style({'opacity':opacity});
                    tickLabel.vRotate(d.labelRotation);
                }else{
                    var rotateStr = (d.labelRotation % 360) ?
                        tickLabel.vRotate(d.labelRotation, true/* delay */).rotateStr : '';
                    transform.transform += rotateStr;
                    tickLabel.animate({
                        'ease':EASE, 'duration':TIME, 'attr':transform, 'style':{'opacity':opacity}
                    });
                }
            }

            return currentTickLabels;
        },

        /**
         * 计算标签的位置属性,当为多分类轴是，需要传入startPos表示标签的位置偏移
         * @param  {[type]} scale    [description]
         * @param  {[type]} d        [description]
         * @param  {[type]} startPos [description]
         * @return {[type]}          [description]
         */
        _getLabelAttr:function(scale, d, startPos){
            var origin = this._getAxisOriginPoint();
            var det = scale.rangeBand ? scale.rangeBand()/2 * (d.length || 1) : 0;
            var tickLabelPos = scale(d.tickValue) + det;

            var cfg = this.options, isHorizontal = this.isHorizontal();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0, tickPadding = (cfg.tickPadding + tickLength) || 0;
            var labelRotation = d.labelRotation || 0, labelStyle = cfg.labelStyle, useHtml = cfg.useHtml;
            var position = this.getPosition(), sign = (position == Constants.TOP || position == Constants.LEFT) ? -1 : 1;

            var rectDim = d.tickRectDim, labelDim = d.tickDim;

            // 90 degree has no rotation
            // rotation represents in writing-mode;

            var textX = 0, textY = 0, dx = 0, dy = rectDim.height * 0.85, direction,
                rotationRadian = BaseUtils.toRadian(labelRotation), writingMode;

            if (labelRotation === 360) {
                dx = (useHtml || BaseUtils.isMS) ? 0 : rectDim.width * 0.85 / 2;
                dy = 0;
                writingMode = 'tb-rl';
            }

            if (isHorizontal) {

                direction = Math.abs(labelRotation % 90) < 15 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textY += sign * (labelDim.height - rectDim.height) / 2;
                textX += sign * direction * (labelDim.width - Math.abs(rectDim.height * Math.sin(rotationRadian))) / 2;

                if (position === Constants.TOP) {
                    textY -= rectDim.height;
                    textY -= startPos;
                } else {
                    textY += startPos;
                }

                textY += sign * tickPadding;

                textX += origin.x + tickLabelPos - rectDim.width / 2;
                textY += origin.y;

            } else {

                direction = Math.abs(labelRotation % 90) > 85 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textX += sign * (labelDim.width - rectDim.width) / 2;
                textY += sign * direction * (labelDim.height - rectDim.height * Math.cos(rotationRadian)) / 2;

                if (position === Constants.LEFT) {
                    textX -= rectDim.width;
                    textX  -= startPos;
                } else {
                    textX  += startPos;
                }

                textX += sign * tickPadding;

                textX += origin.x;
                textY += origin.y + tickLabelPos - rectDim.height / 2;
            }

            var px = useHtml ? 'px' : '';
            var transform = 'translate(' + textX + px + ' ' + textY + px + ')';

            var result = {
                transform : transform,
                dy: dy,
                dx: dx,
                'writingMode': writingMode,
                'writing-mode': writingMode
            };

            // phantomjs bug
            if (useHtml && writingMode && !BaseUtils.hasTouch()) {
                result['-webkit-writing-mode'] = 'vertical-rl';
            }

            return result;
        },

        _drawAxisTitle: function () {
            var cfg = this.options, title = cfg.title;
            if (!title || BaseUtils.isEmpty(title.text)) {
                this.titleGroup && this.titleGroup.remove();
                this.titleGroup = null;
                return;
            }
            var R = this.vanchart.renderer, axisGroup = this.axisGroup;
            var useHtml = title.useHtml, rotation = this.titleRotation, align = this.getTitleAlign(),
                text = title.text, style = title.style;

            var textDim = this.titleDim, rectDim = this.titleRectDim;
            var titleBounds = this.getAxisTitleBounds();

            if (!this.titleGroup) {
                this.titleGroup = R.vgroup().add();
                axisGroup.append(this.titleGroup.renderG);
            }

            this.titleGroup.attr({'transform': BaseUtils.makeTranslate(titleBounds)});
            var titleGroup = this.titleGroup;

            //标题每次刷新重新添加，原因：用中文的刷新没有中文的，中文应该没有rotate(deg,x,y)类似东西
            if (titleGroup.text) {
                titleGroup.text.remove();
            }
            titleGroup.text = titleGroup.append(R.vtext(useHtml));

            var x = 0, y = 0, dx = 0, dy = rectDim.height * 0.85;
            switch (align) {
                case Constants.TOP:
                    y = 0;
                    break;
                case Constants.BOTTOM:
                    y = titleBounds.height - textDim.height;
                    break;
                case Constants.LEFT:
                    x = 0;
                    break;
                case Constants.RIGHT:
                    x = titleBounds.width - textDim.width;
                    break;
                case Constants.CENTER:
                default:
                    if (this.isHorizontal()) {
                        x = (titleBounds.width - textDim.width)/2;
                    } else {
                        y = (titleBounds.height - textDim.height) / 2;
                    }
            }

            if (this.titleRotation === 360) {
                dx = useHtml ? 0 : (BaseUtils.isMS ? '0.2ex' : rectDim.width * 0.85 / 2);  // @CHART-769 IE下面竖直排版某些中文会往左边缩一点.
                dy = 0;
            } else {
                x += (textDim.width - rectDim.width) / 2;
                y += (textDim.height - rectDim.height) / 2;
            }

            titleGroup.text
                .textContent(text)
                .attr({
                    x: x,
                    y: y,
                    dy: dy,
                    dx: dx
                }).style(style);

            (rotation % 360) && titleGroup.text.vRotate(rotation);
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.clipAxisGroup && this.clipAxisGroup.remove();
            this.axisGroup = this.clipAxisGroup = null;

            this.axisLineGroup && this.axisLineGroup.remove();
            this.axisLineGroup = null;
            this.axisLine && this.axisLine.remove();
            this.axisLine = null;

            this.gridLinesGroup && this.gridLinesGroup.remove();
            this.gridLinesGroup = null;
            this.gridLines && this.gridLines.forEach(function (gridLine) {
                gridLine && gridLine.remove();
                gridLine = null;
            });
            this.gridLines = null;

            this.plotLinesGroup && this.plotLinesGroup.remove();
            this.plotLinesGroup = null;
            this.plotLines && this.plotLines.forEach(function (plotLine) {
                plotLine && plotLine.remove();
                plotLine = null;
            });
            this.plotLines = null;

            // remove vgroup
            this.tickLabelsGroup && this.tickLabelsGroup.remove();
            this.tickLabelsGroup = null;
            this.tickLabels = null;

            this.cateTickLabelsGroup && this.cateTickLabelsGroup.remove();
            this.cateTickLabelsGroup = null;
            this.cateTickLabels = null;
        }
    });

    return BaseAxis;
});
/**
 * Created by eason on 15/5/18.
 * 分类轴的定义
 */
define('component/CategoryAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/BezierEasing'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var BezierEasing = require('../utils/BezierEasing');

    var LABEL_LINE_GAP = 2.5;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };
    
    var CategoryAxis = BaseAxis.extend({

        type:ComponentLibrary.CATEGORY_AXIS_COMPONENT,

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = Scale.ordinal();
        },

        calculateDomainFromData:function(){
            this._dataDomain = this._getDomainFromData();

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);

            this._zoomDomain = this._zoomDomain || (zoomTool && zoomTool.getZoomDomain(this));

            this._domain = this._zoomDomain || this._dataDomain;
        },

        calculateDomainFromZoom:function(){
            this._domain = this._zoomDomain;
        },

        _getStartAndEndTick:function(){
            return [this._domain[0], this._domain[this._domain.length - 1]];
        },

        _getDomainFromData:function(){
            var axisOption = this.options, series = this.series, axis = this, stored = {};
            var categories = axisOption.categories || [];
            categories.forEach(function(category){
                stored[category] = true;
            });

            series.forEach(function(sery){

                this.getTrendLineForecast(sery);

                for(var i = 0, len = sery.points.length; i < len; i++){

                    var tickLabel = sery.points[i].getCategory();

                    if(!stored[tickLabel]){
                        stored[tickLabel] = true;
                        categories.push(tickLabel);
                    }
                }

                // 多分类轴下面积图isRangePoints也是false
                if (sery.type !== Constants.AREA_CHART || this.isMultiCateAxis()) {
                    axis.isRangePoints = false;
                }

            }, this);

            // 多分类轴下，需要将_dataDomain格式一下，保证相同父层级的分类在一起
            if(this.isMultiCateAxis() && categories.length){
                categories = this.resortDataDomain(categories);
            }

            return this.addTrendLineCategories(categories);
        },

        setCategories:function(categories){

            var lastDomain = this._dataDomain;

            this._dataDomain = this.addTrendLineCategories(categories);

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(this._isBaseAxis() && zoomTool && zoomTool.zoomToolEnabled()){

                zoomTool.updateRangeLeftAndRight(this, lastDomain, categories);

                var zoomDomain = zoomTool && zoomTool.getZoomDomain(this);

                this._zoomDomain = zoomDomain;

                this.calculateDomainFromZoom()
            }else{
                this._domain = this._dataDomain;
                this._zoomDomain = null;
            }

            this.fixScaleAndTickData();
        },

        addTrendLineCategories: function (categories) {
            if (this.forecast && (this.forecast[0] || this.forecast[1])) {
                var emptyL = 0;
                categories =
                    newArray(-this.forecast[0], function () { return Array(2 + emptyL++).join(' '); })
                        .concat(categories)
                        .concat(newArray(this.forecast[1], function () { return Array(2 + emptyL++).join(' '); }));

                function newArray(length, fillFun) {
                    return Array.apply(null, Array(length)).map(fillFun)
                }
            }

            return categories;
        },

        getOriginalCategories: function () {
            if (this.forecast && (this.forecast[0] || this.forecast[1])) {
                return this._dataDomain.slice(-this.forecast[0], this._dataDomain.length - this.forecast[1]);
            }
            return this._dataDomain;
        },

        //处理自动旋转的情况
        updateAxisSizeAndBounds:function(){

            this._updateOriginTickData();

            this._calculateSize(this.tickData);

            this._setComponentBounds(this.getPosition(), this._size);
        },

        _getTickValuesWithEndValue:function(){
            return this._getTickValues();
        },

        fixScaleAndTickData:function(){

            this.scale.domain(this._dataDomain);

            this.isRangePoints ? this.scale.rangePoints(this._getRange()) : this.scale.rangeBands(this._getRange());

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        _getRange:function(){
            var plotRange = this._getPlotRange();

            //没有缩放的时候直接返回
            if(this._dataDomain.length == this._domain.length){
                return plotRange;
            }

            var rangeBands, rangeLength = Math.abs(plotRange[1] - plotRange[0]);
            if (this.isRangePoints) {
                rangeBands = rangeLength / Math.max(this._domain.length - 1, 1);
            } else {
                rangeBands = rangeLength / this._domain.length
            }

            var startIndex = BaseUtils.indexOf(this._dataDomain, this._domain[0]);
            var endIndex = this._dataDomain.length - BaseUtils.indexOf(this._dataDomain, this._domain[this._domain.length - 1]) - 1;

            if(!(this.isAxisReversed() ^ this.isHorizontal())){
                var tmp = startIndex;
                startIndex = endIndex;
                endIndex = tmp;
            }

            var min = -startIndex * rangeBands, max = rangeLength + endIndex * rangeBands;

            if(this.isHorizontal()){
                return this.isAxisReversed() ? [max, min] : [min, max];
            }else{
                return this.isAxisReversed() ? [min, max] : [max, min];
            }
        },

        getLabelAutoRotation: function (labels, axisOption, formatter) {
            if (axisOption.autoRotate &&
                !axisOption.labelRotation) {
                var isInverted = this.vanchart.isInverted();
                var longLabel = labels.reduce(function (a, b) {
                    return BaseUtils.getTextDimension(a).width > BaseUtils.getTextDimension(b).width ? a : b;
                });
                var longContent = this._getTickContent(longLabel, formatter);
                var longDim = BaseUtils.getTextDimensionWithRotation(longContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);
                var gap = Math.max.apply(null, this._getPlotRange()) / this._domain.length - LABEL_LINE_GAP_FUN();

                var w, h;
                if (isInverted) {
                    w = longDim.height;
                    h = longDim.width;
                } else {
                    w = longDim.width;
                    h = longDim.height;
                }
                var l = Math.sqrt(w * w + h * h);

                if (h > gap) {
                    return -90;
                } else if (w > gap) {
                    var alpha = Math.acos(gap/l);
                    var beta = Math.atan(h/w);
                    var theta = alpha + beta;
                    return -BaseUtils.toDegree(theta);
                }
            }
        },

        getCategoryCount:function(){
            return this._dataDomain.length;
        },

        indexOfLabel:function(label){
            return BaseUtils.indexOf(this._dataDomain, label);
        },

        getTickLength:function(){

            var domain = this.scale.domain();

            var range = this.scale.rangeExtent();

            var cateLength = Math.abs(range[1] - range[0]);

            if(this.isRangePoints && domain.length <= 1){
                return cateLength;
            }

            return  this.isRangePoints ? cateLength / (domain.length - 1) : this.scale.rangeBand();
        },

        _getTickValues:function(){
            return this._domain;
        },

        getCategories:function(){
            return this._dataDomain;
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.bounds;

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos.x, upPos.x) - plotBounds.x;
                endPos = Math.max(downPos.x, upPos.x) - plotBounds.x;
            }else{
                startPos = Math.min(downPos.y, upPos.y) - plotBounds.y;
                endPos = Math.max(downPos.y, upPos.y) - plotBounds.y;
            }

            var domain = this.scale.domain();
            var range = this._getRange();

            var tmpScale = Scale.quantize().domain(range).range(domain);

            var start = BaseUtils.indexOf(this._dataDomain, tmpScale(startPos));
            var end = BaseUtils.indexOf(this._dataDomain, tmpScale(endPos));

            this.zoomRefresh(this._dataDomain.slice(Math.min(start, end), Math.max(start, end) + 1))
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByXYCoordinate(pos);
        },

        _getIndexByXYCoordinate: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var isHorizontal = this.isHorizontal();
            var isReversed = this.isAxisReversed() ^ !isHorizontal;

            var startX = scale(
                isReversed ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (isHorizontal) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = Math.abs(scale(scale.domain()[1]) - scale(scale.domain()[0]));
                index = isReversed ? categories.length - 1 - x / unitLength : x / unitLength;
            } else {
                index = 0;
            }

            if (this.isRangePoints) {
                index = Math.round(index);
            } else {
                index = isReversed ? Math.ceil(index) : Math.floor(index);
            }

            return index;
        },

        getPointsInCategory:function(containerPoint){
            var plotBounds = this.vanchart.bounds;
            var domain = this.scale.domain(), range = this._getRange();
            var tmpScale = Scale.quantize().domain(range).range(domain);
            var category = tmpScale(this.isHorizontal() ? containerPoint.x - plotBounds.x : containerPoint.y - plotBounds.y);
            return this.vanchart.getValidPointsPara(category);
        },

        drawHighlightBackground: function (sharedPoints) {
            var category = sharedPoints[0].getCategory();
            var highlightType = 'line';
            sharedPoints.map(function (point) {
                var series = point.series;
                if (series.type === Constants.BAR_CHART ||
                    series.type === Constants.COLUMN_CHART) {
                    highlightType = 'band';
                }
            });

            var plotBounds = this.getPlotBounds(), isHorizontal = this.isHorizontal();
            var scale = this.scale, rangeBand = scale.rangeBand ? scale.rangeBand() : 0;
            var from = scale(category), to = from + rangeBand, renderer = this.vanchart.renderer;

            var x = 'x', y = 'y', width = 'width', height = 'height', size = plotBounds.height;
            var x1 = 'x1', x2 = 'x2', y1 = 'y1', y2 = 'y2';
            if(!isHorizontal){
                x = 'y'; y = 'x'; width = 'height'; height = 'width'; size = plotBounds.width;
                x1 = 'y1'; x2 = 'y2'; y1 = 'x1'; y2 = 'x2';
            }

            switch (highlightType) {
                case 'band':
                    var bandAttr = {};bandAttr[x] = from;bandAttr[y] = 0;bandAttr[width] = Math.abs(from - to);bandAttr[height] = size;
                    if(!this.highlightBand){
                        this.highlightBand = renderer.rect().attr(bandAttr).style({
                            'fill': 'rgb(98,179,240)',
                            'fill-opacity':0.2
                        }).addTo(this.clipAxisGroup);
                    }
                    this.highlightBand
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .animate({
                            duration:250,
                            ease:BezierEasing.css['ease'],
                            attr:bandAttr
                        });

                    this.highlightLine && this.highlightLine.remove();
                    this.highlightLine = null;

                    break;
                case 'line':
                default:

                    if (rangeBand) {
                        from = (from + to) / 2;
                    }

                    var attr = {};attr[x1] = from;attr[y1] = 0;attr[x2] = from;attr[y2] = size;
                    if(!this.highlightLine){
                        this.highlightLine = renderer.line().attr(attr).style({
                            'stroke': 'rgb(140,140,140)',
                            'stroke-width':1
                        }).addTo(this.clipAxisGroup);
                    }

                    this.highlightLine
                        .attr('transform',BaseUtils.makeTranslate(plotBounds))
                        .animate({
                            duration:250,
                            ease:BezierEasing.css['ease'],
                            attr:attr
                        });

                    this.highlightBand && this.highlightBand.remove();
                    this.highlightBand = null;
            }
        },

        removeHighlightBackground:function(){
            this.highlightBand && this.highlightBand.remove();
            this.highlightLine && this.highlightLine.remove();

            this.highlightBand = null;
            this.highlightLine = null;
        },

        isMultiCateAxis: function (){
            return false;
        }
    });

    ComponentLibrary.register(ComponentLibrary.CATEGORY_AXIS_COMPONENT, CategoryAxis);
    return CategoryAxis;
});
/**
 * Created by eason on 15/5/18.
 * 值轴的定义
 */
define('component/ValueAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../utils/QueryUtils','../Constants','../ComponentLibrary','../utils/Scale'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');

    var ValueAxis = BaseAxis.extend({

        type:ComponentLibrary.VALUE_AXIS_COMPONENT,

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = this.options.log ? Scale.log().base(this.options.log) : Scale.linear();
        },

        getAxisValue: function (value, point) {
            return this.byPercent ? point.percentage : +value;
        },

        _valueInDomain: function (value) {
            var domain = this.scale.domain();
            return value >= Math.min(domain[0], domain[1]) && value <= Math.max(domain[0], domain[1]);
        },

        //从数据中计算最大最小值
        _getDomainFromData:function(){

            var minValue = Number.MAX_VALUE,maxValue = -minValue, emptyData = true;
            var series = this.series, dataMap = {};

            //check是否系列是全不可见的
            var visible = false;
            for(var i = 0, len = series.length; i < len && !visible; i++){
                visible = series[i].visible;
            }

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].visible || !visible){
                    this._getSeriesValue(dataMap, series[i]);
                    this.getTrendLineForecast(series[i]);
                }
            }

            var gap = 0; // for trend line period
            for(var key in dataMap){
                var data = dataMap[key];
                gap = data[1] - data[0] || 0;
                for(var j = 0, dataCount = data.length; j < dataCount; j++){
                    if(!isNaN(data[j]) && !(this.options.log && data[j] <= 0)){
                        minValue = Math.min(minValue, data[j]);
                        maxValue = Math.max(maxValue, data[j]);
                        emptyData = false;
                    }
                }
            }

            if (this._isBaseAxis() && gap && this.forecast) {
                minValue += gap * this.forecast[0];
                maxValue += gap * this.forecast[1];
            }

            if(emptyData){
                minValue = 0;
                maxValue = 100;
            }

            return [minValue, maxValue];
        },

        //获取系列的值，如果是堆积的话获取系列的和
        _getSeriesValue:function(dataMap, sery){

            var seriesName = sery.name || '';

            var key = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            if(BaseUtils.hasNotDefined(sery.stack) || this._isBaseAxis()){
                dataMap[seriesName] = dataMap[seriesName] || [];

                sery.points.forEach(function(point){
                    if(!point.isNull && point.visible) {
                        dataMap[seriesName].push(point.options[key]);
                    }
                });

            }else{
                var PK = sery.stack + sery.type + 'STACK_POSITIVE';
                var NK = sery.stack + sery.type + 'STACK_NEGATIVE';
                dataMap[PK] = dataMap[PK] || [];
                dataMap[NK] = dataMap[NK] || [];

                sery.points.forEach(function(point, i){
                    if(!point.isNull && point.visible){
                        var value = +point.options[key];
                        if(value > 0){
                            if(dataMap[PK][i] != null && dataMap[PK][i] != undefined){
                                dataMap[PK][i] += value;
                            }else{
                                dataMap[PK][i] = value;
                            }
                        }else{
                            if(dataMap[NK][i] != null && dataMap[NK][i] != undefined){
                                dataMap[NK][i] += value;
                            }else{
                                dataMap[NK][i] = value;
                            }
                        }
                    }

                });
            }
        },

        //考虑有正负值的时候的0值对齐的功能
        getStartPos:function(){
            return this.scale(this.getStartPosValue());
        },

        getStartPosValue:function(){

            var axisOption = this.options;

            return axisOption.log && axisOption.log !== 1 ? 1 : 0;
        },

        _getTickValues:function(){

            var valueList = [];

            if(this.options.log){
                var i = 0, tickValue;
                while((tickValue = this._tickStart * Math.pow(this.options.log, i)) <= this._domain[1]){
                    valueList.push(tickValue);
                    i += this._step;
                }
            }else {
                var start = this._tickStart;
                for(; start <= this._domain[1]; start = BaseUtils.accAdd(start, this._step)){
                    valueList.push(start);
                }
            }

            return valueList;
        }
    });

    ComponentLibrary.register(ComponentLibrary.VALUE_AXIS_COMPONENT, ValueAxis);
    return ValueAxis;
});
/**
 * Created by eason on 15/11/2.
 */
define('component/DateAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale'],function(require){

    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale')

    var SECOND = 1000;
    var MINUTE = SECOND * 60;
    var HOUR = MINUTE * 60;
    var DAY = HOUR * 24;
    var MONTH = DAY * 31;
    var YEAR = 12 * MONTH;

    var DateAxis = BaseAxis.extend({

        type:ComponentLibrary.DATE_AXIS_COMPONENT,

        getAxisValue: function (value) {
            return BaseUtils.object2date(value);
        },

        fixScaleAndTickData:function(){

            var domain = [BaseUtils.int2date(this._domain[0]), BaseUtils.int2date(this._domain[1])];

            this.scale.domain(domain).rangeRound(this._getRange());

            //domain确定以后，日期坐标轴要确定默认的日期格式
            this._calculateDateFormat();

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        _calculateDateFormat:function(){
            var tickInterval = this._step;

            var format = 'Dyyyy';

            if(tickInterval <= SECOND){
                format = 'Dss';
            }else if(tickInterval <= MINUTE){
                format = 'Dmm:ss';
            }else if(tickInterval <= HOUR){
                format = 'Dhh:mm';
            }else if(tickInterval <= DAY){
                format = 'Ddd-hh';
            }else if(tickInterval <= MONTH){
                format = 'DMM-dd';
            }else if(tickInterval <= YEAR){
                format = 'Dyyyy-MM';
            }

            this.dateFormat = format;
        },

        _getTickContent:function(tick, formatter){
            var format = this.dateFormat;
            //todo 为了兼容跟FR一样的格式，无奈之举
            function formatFunc(cv){
                return (window.FR && window.FR.contentFormat(cv, format)) || cv;
            };

            formatter = formatter || formatFunc;

            return BaseUtils.format(tick, formatter);
        },

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = Scale.linear();
        },

        _getStartAndEndTick:function(){
            return [BaseUtils.int2date(this._domain[0]), BaseUtils.int2date(this._domain[1])];
        },

        _getTickValues:function(){
            var result = [];
            var start = this._tickStart;
            for(; start <= this._domain[1]; start = BaseUtils.accAdd(start, this._step)){
                result.push(BaseUtils.int2date(start));
            }
            return result;
        },

        _valueInDomain: function (value) {
            var domain = this.scale.domain();
            return value >= Math.min(domain[0], domain[1]) && value <= Math.max(domain[0], domain[1]);
        },

        _getDomainFromData:function(){

            var minValue = Math.ceil(Number.MAX_VALUE);
            var maxValue = -minValue;

            var series = this.series;
            var hasData = false;

            var gap = 0;
            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var byAxis = sery[this.componentType];
                if(byAxis == this && sery.visible){
                    this.getTrendLineForecast(series[i]);
                    var data = sery.points;
                    if (data.length > 1) {
                        gap = this.getValueFromData(data[1]) - this.getValueFromData(data[0]) || 0;
                    }
                    for(var i = 0,len = data.length; i < len; i++){
                        var value = this.getValueFromData(data[i]);

                        if(value.getTime){
                            hasData = true;
                            value = BaseUtils.date2int(value);
                            minValue = Math.min(minValue, value);
                            maxValue = Math.max(maxValue, value);
                        }
                    }
                }
            }

            if (this._isBaseAxis() && gap && this.forecast) {
                minValue += gap * this.forecast[0];
                maxValue += gap * this.forecast[1];
            }

            if(!hasData){
                minValue = maxValue = (new Date()).getTime();
            }

            maxValue = minValue >= maxValue ? minValue + 1000 : maxValue;

            return [minValue, maxValue];
        },

        getValueFromData:function(datum){
            var valueIndex = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.object2date(value);
        }
    });

    ComponentLibrary.register(ComponentLibrary.DATE_AXIS_COMPONENT, DateAxis);
    return DateAxis;

});
/**
 * Created by Cmen on 2017/6/29.
 */

define('component/MultiCategoryAxis',['require','../utils/BaseUtils','./CategoryAxis','../Constants','../ComponentLibrary','../utils/BezierEasing'],function (require){
	var BaseUtils = require("../utils/BaseUtils");
    var CategoryAxis = require("./CategoryAxis");
    var Constants = require("../Constants");
    var ComponentLibrary = require("../ComponentLibrary");
    var BezierEasing = require("../utils/BezierEasing");

    var LAST_MAIN_TICK_LINE_KEY = "LAST_MAIN_TICK_LINE";

    var AXIS_GAP = 4,  // 多层级之间的间隔
        AXIS_GAP_FUN = function(){
            return BaseUtils.paddingConvertWithScale(AXIS_GAP);
        };

    var LABEL_LINE_GAP = 4;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };

    var TICK_LENGTH = 4;

    var MAIN_TICK = "main";

    var decodeArray = BaseUtils.decodeCategoryArray,
        encodeArray = BaseUtils.encodeCategoryArray;


	var MultiCategoryAxis = CategoryAxis.extend({

		/**
		 * 计算Axis.tickData，用于绘制tickLabel，传统的tickData为一维数组
		 * 在多分类轴下，axis.tickData为多维数组，第一维度表示的是分类轴的层级
		 * @return {[type]} [description]
		 */
		_updateOriginTickData: function (){
			var labelsArray = this._getTickValues();

			this._calculateLabelRotation(labelsArray[0]); // 标签旋转只考虑第一维

			this.tickData = [];

			for (var i = -1; ++i < labelsArray.length;) {
				var labels = labelsArray[i];
				this.tickData[i] = [];

				for(var j = -1; ++j < labels.length;) {
					var tickValue = labels[j].tickValue, tickContent = labels[j].content;

					this.tickData[i].push(
						this._calculateSingleTickData(tickValue, tickContent, { length: labels[j].length})  // length:改分类存在多少个最底层分类轴
					)
				}
			}

			this._updateTickLengthMap(); // 更新间隔线高度Map
		},

		/**
		 * 计算tickValues， 多分类轴下是个二维数组，第一维表示的层级，第二维表示层内的tick
		 * @return {[type]} [description]
		 */
		_getTickValues: function (){
			var axisArray = [];

			var domain = this._domain;

			domain.forEach(function (cateArrayStr) {
				axisArray.push(decodeArray(cateArrayStr));
			});

			var sortMap = {},sortArr = [];
			var pos = this.getPosition();

			var i, len = axisArray.length;

			var k1 = this.isAxisReversed() ? 1 : 0,
				k2 = (pos == Constants.LEFT || pos == Constants.RIGHT) ? 1 : 0;


			/**
			 * 轴逆序或者在轴在侧边的时候，需要倒过来计算tickValues
			 * 其他的情况则按0-len顺序计算
			 */
			var reverse = (k1 + k2) % 2;

			if(reverse) {
				for(i = len; --i >= 0;) {
					pushCateMap(axisArray[i]);
				}
			} else {
				for(i = -1; ++i < len;) {
					pushCateMap(axisArray[i]);
				}
			}

			function pushCateMap(categoryArray){
				var identifierArray = [];
				categoryArray.forEach(function (cate, index) {
					if(!sortArr[index]) { sortArr[index] = []; } // 分类轴有多少个层级，计算出的tickValues就有几个维度

					identifierArray.push(cate);
					var identifier = encodeArray(identifierArray);

					// 这边的做法是判断并更新那个层级中具体分类名的层级，出现次数
					if(sortMap[identifier]) {
						sortMap[identifier].length++;
					} else {
						sortMap[identifier] = {
							content: cate,
							level: index,
							length: 1, 
							tickValue: encodeArray(categoryArray)
						}
					}
				})
			}

			// 这边使用map来计算arr，不知道会不会出现顺序错乱的问题，如果低版本ie出现问题，得考虑换一种写法
			for (var identifier in sortMap) {
				var cateInfo = sortMap[identifier],
					index = cateInfo.level;

				sortArr[index].push({
					content: cateInfo.content,
					length: cateInfo.length,
					tickValue: cateInfo.tickValue
				});
			}

			// 顺序颠倒一下，绘制的时候方便一些
			return sortArr.map(function (lineTicks, index, array) {
				return array[array.length - index - 1];
			})
		},

		/**
		 * 计算多分类轴下标签占据的尺寸，Axis.doLayout时候计算裁剪时需要
		 * @return {[type]} [description]
		 */
		_getTickLabelLength: function (){
			var tickValues = this._getTickValues(), axisGap = AXIS_GAP_FUN();
			var option = this.options, axis = this;

			var totalHeight = 0, // 多层级占据总高度
				tickLengthArray = [], // 主要间隔线的长度数组
				labelStartPosArray = []; // 不同层级的标签起始位置（相对于最底层分类轴的偏移量）

			var defultTickLength = (isNaN(+option.tickLength) ? TICK_LENGTH : option.tickLength);

			if (option.showLabel) {
                totalHeight += (isNaN(+option.tickPadding) ? LABEL_LINE_GAP_FUN() : option.tickPadding);
            }

            if (option.enableTick) {
                totalHeight += defultTickLength;
            }

            var start_gap = totalHeight;

            var isHorizontal = this.isHorizontal();

            var ticksLen = tickValues.length;

			for(var i = -1; ++i < ticksLen;) {

				labelStartPosArray.push(totalHeight - start_gap);
				var lineHeight = 0, lineTicks = tickValues[i];

				lineTicks.forEach(function (tickInfo) {
					var textDim = axis._getTickDim(tickInfo.content, option.formatter);
					lineHeight = Math.max(lineHeight, (isHorizontal ? textDim.height : textDim.width));
				});

				totalHeight += lineHeight + (i === ticksLen - 1 ? 0 : axisGap);

				tickLengthArray.push(i === 0 ? defultTickLength : totalHeight);
			}

			this._tickLengthArray = tickLengthArray;
			this._tickLabelStartPosArray = labelStartPosArray;

			return option.showLabel ? totalHeight : 0;
		},

		/**
		 * 更新存储间隔线长度的Map
		 * @return {[type]} [description]
		 */
		_updateTickLengthMap: function (){
			var tickValues = this._getTickValues();
			var tickLengthArray = this._tickLengthArray, len = tickLengthArray.length;

			var calcMap = {};

			// 先计算
			for(var i = tickValues.length; --i >= 0;) {
				var lineTicks = tickValues[i];
				for(var j = -1; ++j < lineTicks.length;) {
					var tickValue = lineTicks[j].tickValue;
					if(!calcMap[tickValue]) {
						calcMap[tickValue] = tickLengthArray[i];
					}
				}
			}

			calcMap[LAST_MAIN_TICK_LINE_KEY] = tickLengthArray[len - 1];
			this._tickLengthMap = calcMap;
		},

		/**
		 * 根据传入的tickValue计算所在的间隔线的高度
		 * @param  {[type]} tickValue [description]
		 * @return {[type]}           [description]
		 */
		_getTickLength: function (tickValue) {
			return this._tickLengthMap[tickValue];
		},

		/**
		 * 绘制主要间隔线，多分类轴下次级间隔线绘制手法不变
		 * @param  {[type]} option [description]
		 * @return {[type]}        [description]
		 */
		_drawMainTickLine: function (option) {
			var ticks = this.getTickData(), axis = this;
			var plotBounds = this.getPlotBounds(), pos = this.getPosition();
			var isBottomOrTop = pos === Constants.BOTTOM || pos === Constants.TOP;
			ticks = ticks.concat([
					{
						tickPos: isBottomOrTop ? plotBounds.width : plotBounds.height - 1,
						tickValue: LAST_MAIN_TICK_LINE_KEY
					}
				]);  // 绘制结尾处的间隔线

			option.keyFunction = function (datum){ return datum.tickValue; };  // identifier，用于标识间隔线
            option.tickLengthFuc = function (datum) {    // 不同的层级对应的间隔线高度不一致，这里根据间隔线的key来计算
                return axis._getTickLength(datum.tickValue) || option.tickLength;
            };

            this.tickLines[MAIN_TICK] = this._drawTickLineWithData(this.tickLines[MAIN_TICK], ticks, option);
		},

		/**
		 * 获取坐标轴上点的scaleKey，在柱形图里面计算系列位置的时候会用到
		 * @param  {[type]} value [description]
		 * @param  {[type]} point [description]
		 * @return {[type]}       [description]
		 */
		getAxisValue: function (value, point) {
			return point.getCategory();
		},

		/**
		 * 很多计算都是使用最低一层分类轴上的tickData。
		 * 而多分类轴下tickData为二维数组，因此这里返回tickData[0]
		 * @return {[type]} [description]
		 */
		getTickData: function (){
			return this.tickData[0] || [];
		},

		/**
		 * 返回所有的层级的tickData
		 * @return {[type]} [description]
		 */
		getMultiTickData: function (){
			return this.tickData;
		},

        /**
         * 对dataDomain进行重新排序：
         * 主要为了解决多分类轴，新增数据点或者对于不规整数据诸如["A","B","C"], ["a","b","c"],["A","C","D"]应该整理成
         * ["A","B","C"],["A","C","D"], ["a","b","c"]的顺序--即具有相同父层级的应该在一起
         * @param categories
         */
        resortDataDomain: function (categories){
            var domainData = categories.map(function (cate){
                return decodeArray(cate);
            });

            var levels = domainData[0].map(function (){return [];});
            var i, j, data, dataStr, storageMap = {} ;

            // 先将传入的categories分层
            for(i = -1; ++i < levels.length;){
                for(j = -1; ++j < domainData.length;){
                    data = domainData[j].slice(0, i+1);
                    dataStr = encodeArray(data);
                    if(!storageMap[dataStr]){
                        storageMap[dataStr] = true;
                        var identifier = encodeArray(data);  // 诸如[""]这样的，生成的id应该是[""
                        levels[i].push(identifier.substr(0, identifier.length - 1));
                    }
                }
            }

            var levelsLen = levels.length;

            var lastLevel = levels[levelsLen - 1].map(function (str){
                return str;
            });

            // 以最后一层为基础，相对于倒数第二层，进行排序
            return sortLevel(levelsLen - 2, lastLevel).map(function (cate){
                return encodeArray(decodeArray(cate+"]"));
            });

            function sortLevel(index, lastLevel){
                // 第一层排序完成则直接返回lastLevel
                if(index < 0) {return lastLevel;}
                var newLevel = [];
                var curLevel = levels[index], curLevellen = curLevel.length;

                for(i = -1; ++i < curLevellen;){
                    var curStr = curLevel[i];
                    for(j = -1; ++j < lastLevel.length;){
                        var lastStr = lastLevel[j];
                        if(lastStr.indexOf(curStr) === 0){
                            newLevel.push(lastStr);
                        }
                    }
                }
                // 递归排序
                return sortLevel(index - 1, newLevel);
            }
        },

		/**
		 * 绘制svg标签，多分类轴下，应该根据标签的层级不同来分开绘制
		 * @return {[type]} [description]
		 */
		_drawSvgTickLabel: function (){
			var axis = this, renderer = this.vanchart.renderer;

			var multiTickData = this.getMultiTickData();

			if(!this.tickLabelsGroup){
                this.tickLabelsGroup = renderer.vgroup().add();
                this.axisGroup.append(this.tickLabelsGroup.renderG);
                this.tickLabels = multiTickData.map(function (){
                    return [];
                });
            }

            multiTickData.forEach(function (tickData, index) {
                axis.tickLabels[index] = axis._drawSvgTickLabelWithData(axis.tickLabels[index], tickData, index);
            })
		},

		/**
		 * 获取指定层级的标签相对于最底层分类轴的偏移值
		 * @param  {[type]} level [description]
		 * @return {[type]}       [description]
		 */
		_getLabelStartPos: function (level) {
			return this._tickLabelStartPosArray[level];
		},

		/**
		 * 判断是否为多分类轴
		 * @return {Boolean} [description]
		 */
		isMultiCateAxis: function(){
			return true;
		}

	});

	ComponentLibrary.register(ComponentLibrary.MULTI_CATEGORY_AXIS_COMPONENT, MultiCategoryAxis);
    return MultiCategoryAxis;
});
/**
 * Created by eason on 15/5/15.
 * 坐标轴组建的定义
 */
define('component/Axis',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','./CategoryAxis','./ValueAxis','./DateAxis','./MultiCategoryAxis'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var CategoryAxis = require('./CategoryAxis');
    var ValueAxis = require('./ValueAxis');
    var DateAxis = require('./DateAxis');
    var MultiCategoryAxis = require('./MultiCategoryAxis'); 
    
    var Axis = Base.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //最终生成的坐标轴数应该和新的option一样
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else{
                    var AxisClass;

                    var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                    if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                        AxisClass = ValueAxis;
                    } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                        AxisClass = CategoryAxis;
                    } else if (axisType == ComponentLibrary.DATE_AXIS_COMPONENT) {
                        AxisClass = DateAxis;
                    } else if(axisType === ComponentLibrary.MULTI_CATEGORY_AXIS_COMPONENT){ 
                        AxisClass = MultiCategoryAxis; 
                    } 

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }
            }
        },

        doLayout:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].calculateDomainFromData();
                this._axisList[i]._calculateSize();
                this._axisList[i]._recordAxisSize();
            }
        },

        reCalculateSize:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i]._calculateSize();
                this._axisList[i]._recordAxisSize();
            }
        },

        updateAxisClip:function(){
            var clipBounds = {};

            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].updateClipBounds(clipBounds);
            }

            this._recordForPlotBounds(Constants.LEFT, clipBounds[Constants.LEFT] || 0);
            this._recordForPlotBounds(Constants.RIGHT, clipBounds[Constants.RIGHT] || 0);
            this._recordForPlotBounds(Constants.TOP, clipBounds[Constants.TOP] || 0);
            this._recordForPlotBounds(Constants.BOTTOM, clipBounds[Constants.BOTTOM] || 0);
        },

        updateAxisSizeAndBounds:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].updateAxisSizeAndBounds();
            }
        },

        adjustDomain4Radius:function(){
            var adjusted = false;
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                adjusted = this._axisList[i].adjustDomain4Radius() || adjusted;
            }
            return adjusted
        },

        fixBoundsByPlot:function(){
            var plotBounds = this.vanchart.bounds;

            var map = {};

            for(var i = 0, axisCount = this._axisList.length; i < axisCount; i++){

                var axis = this._axisList[i], position = axis.getPosition();

                if(axis.isOnZero()){

                    if(isHorizontal){
                        axis.bounds.width = plotBounds.width;
                    }else{
                        axis.bounds.height = plotBounds.height;
                    }

                    //计算坐标轴的scale和tickData
                    axis.fixScaleAndTickData();

                }else{
                    map[position] = map[position] || [];
                    map[position].push(axis);
                }
            }

            for(var position in map){

                var axisList = map[position];
                var isHorizontal = position == Constants.TOP || position == Constants.BOTTOM;

                for(var i = 0, count = axisList.length; i < count; i++){

                    var axis = axisList[i], axisBounds = axis.bounds;

                    var baseBounds = (axisList[i - 1] && axisList[i - 1].bounds) || plotBounds;

                    if(isHorizontal){
                        var y = position == Constants.TOP ? baseBounds.y - axisBounds.height : baseBounds.y + baseBounds.height;
                        axis.bounds = BaseUtils.makeBounds(baseBounds.x, y, baseBounds.width, axisBounds.height);
                    }else{

                        var x = position == Constants.LEFT ? baseBounds.x - axisBounds.width : baseBounds.x + baseBounds.width;
                        axis.bounds = BaseUtils.makeBounds(x, baseBounds.y, axisBounds.width, baseBounds.height);
                    }

                    //计算坐标轴的scale和tickData
                    axis.fixScaleAndTickData();
                }
            }
        },


        getAxis:function(axisIndex){
            if (axisIndex >= this._axisList.length) {
                axisIndex = 0;
            }
            return this._axisList[axisIndex];
        },

        getAxisCount:function(){
            return this._axisList.length;
        },

        axisZoom:function(downPos, upPos){
            this._axisList.forEach(function(axis){
                axis.axisZoom(downPos, upPos);
            });
        },

        //处理0值对齐
        dealOnZero:function(){
            this._axisList.forEach(function(axis){
                axis.dealOnZero();
            });
        },

        render:function(){
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].render();
            }
        },

        /**
         * 移除Axis组件下所有细分的axis
         * @return {[type]} [description]
         */
        remove: function () {
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].remove();
            }
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.X_AXIS_COMPONENT, Axis);
    ComponentLibrary.register(ComponentLibrary.Y_AXIS_COMPONENT, Axis);

    return Axis;
});
/**
 * Created by eason on 15/5/15.
 * 仪表盘坐标轴属性的定义
 */
define('component/GaugeAxis',['require','../Constants','./Axis','../ComponentLibrary'],function(require){
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var ComponentLibrary = require('../ComponentLibrary');

    var GaugeAxis = Axis.extend({

        initAttributesWithSeries:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                var axis = this._axisList[i];
                axis.calculateDomainFromData();
                axis.scale.domain(axis._domain);
                axis._updateOriginTickData();

                if(!axis.options.showLabel){
                    axis.tickData.forEach(function(t){
                        t.tickContent = '';
                    });
                }
            }
        },

        doLayout:function(){

        },

        render:function(){

        }
    });

    ComponentLibrary.register(ComponentLibrary.GAUGE_AXIS_COMPONENT, GaugeAxis);

    return GaugeAxis;
});
/**
 * Created by eason on 16/8/1.
 */

define('component/LegendItem',['require','../dom/Evented','../Constants','../utils/BaseUtils','./LegendIconFactory','../ComponentLibrary'],function(require){

    var Evented = require('../dom/Evented');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var LegendIconFactory = require('./LegendIconFactory');
    var ComponentLibrary = require('../ComponentLibrary');

    // gap between legendIcon and legendText
    var GAP = 8;
    var GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(GAP);
    };

    var WORD_GAP = 0.2;

    var LegendItem = Evented.extend({

        initialize:function(legend, options){
            this.legendX = 0; this.legendY = 0;
            this.legend = legend;
            this.state = Constants.STATE_SHOW;
            this.refresh(options);
        },

        refresh:function(options){
            this.options = options;
            options.renderItem = this;
        },

        render:function(){
            var legend = this.legend, vanchart = legend.vanchart, renderer = vanchart.renderer;
            var textStyle = legend.options.style;

            if (!this.graphic) {
                this.graphic = legend.legendItemsGroup.append(renderer.group());
                if (!this.options.isTrendLine) {
                    this.graphic.style({'cursor': 'pointer'});
                }
            }

            vanchart.registerInteractiveTarget(this, this.graphic);

            var g = this.graphic, d = this.options;
            var markerColor = d.visible ? d.color : d.hiddenColor;
            var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
            var labelDim = BaseUtils.getTextDimension(d.itemName, textStyle, legend.options.useHtml);
            var itemHeight = Math.max(iconSize.height, labelDim.height);

            this.graphic.attr({'transform':BaseUtils.makeTranslate([this.legendX, Math.round(this.legendY + itemHeight/2)])});

            if(LegendIconFactory.hasIcon(d.legendIconType)){
                g.image && g.image.remove();
                g.image = null;

                g.path = g.path || renderer.path().addTo(g);
                g.path.attr('d', LegendIconFactory.getLegendIconPath(d.legendIconType))
                    .attr('transform', BaseUtils.makeTranslate([0, -iconSize.height/2]))
                    .style({
                        'fill':markerColor, 'fill-opacity': d.opacity
                    });
                if(d.series.type == Constants.BUBBLE_CHART){
                    g.path.style('stroke', markerColor).style('stroke-width',1);
                }
            }else{
                g.path && g.path.remove();
                g.path = null;
                
                g.image = g.image || renderer.image().addTo(g);
                g.image.attr({'x':0, 'y':-iconSize.height/2, 'width':12, 'height':12, 'preserveAspectRatio': 'none'})
                    .imageContent(d.legendIconType);
            }

            var svgOffset = !BaseUtils.isSupportSVG() ? {} : {'dy': '0.32em'};

            g.text && g.text.remove(); // @Cmen：监控刷新可能导致图例内容的变化，对于多行的图例文字，判断更新不如直接清除重绘
            g.text = null;

            g.text = g.append(renderer.vtext());
            g.text
                .style({
                    'cursor': this.options.isTrendLine ? 'default' : 'pointer',
                    'white-space':'nowrap'
                })
                .style({
                    fill:d.visible ? textStyle.color : d.hiddenColor
                });

            var y = 0;
            g.text.spans = this.labels.map(function (text) {
                g.text.append(
                    renderer.vtspan()
                        .attr('y', y)
                        .style('margin-top', '-0.7em') // only apply to div
                        .style(textStyle)
                        .attr(svgOffset)
                        .attr('x', iconSize.width + GAP_FUN())
                        .textContent(text)
                );

                y += (legend.textHeight * (1 + WORD_GAP));
            });
        },

        getEvents:function(){
            if (this.options.isTrendLine) {
                return {};
            }
            return {
                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut,

                'tap':this.onTap
            }
        },

        //for the onXXX functions, this points to the legendItem
        onMouseOver:function(){
            if(this.legend.options.hover){
                BaseUtils.getFormatterFunction(this.legend.options.hover)();
            } else {
                this.graphic && this.graphic.text && this.graphic.text.style({'fill': this.options.hoverColor});

                if (this.legend.options.highlight) {
                    this.legend.highlighted = true;
                    this.legend.vanchart.makeLegendHighlight(this.options.itemName);
                }
            }
           this.legend.fire('mouseover');
        },

        onMouseOut:function(ev){
            var item = this, legend = item.legend, d = item.options;
            var textColor = d.visible ? legend.options.style.color : d.hiddenColor;
            this.graphic && this.graphic.text && this.graphic.text.style({'fill': textColor});
            this.legend.fire('mouseout');
        },

        onTap:function(){
            if(this.legend.options.click){
                BaseUtils.getFormatterFunction(this.legend.options.click)();
                return;
            }

            var item = this, legend = item.legend;
            var name = this.options.bindName, vanchart = this.legend.vanchart, series = vanchart.series;
            var calculatedMap = {};

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                if(sery.isSeriesAccumulated()){
                    sery.points.map(function(point){
                        if(legend._itemBindName(point) == name){
                            point.visible = !point.visible;
                            item.state = point.visible ? Constants.STATE_TO_SHOW : Constants.STATE_TO_DROP;
                        }
                    });
                }else if (sery.name === name){
                    sery.visible = !sery.visible;
                    item.state = sery.visible ? Constants.STATE_TO_SHOW : Constants.STATE_TO_DROP;

                    sery._getAxisTypes().forEach(function(type){
                        var axis = sery[type];
                        // update value/date axis
                        if(axis && !axis._isBaseAxis() && !calculatedMap[BaseUtils.stamp(axis)]){
                            calculatedMap[BaseUtils.stamp(axis)] = true;
                            axis.calculateDomainFromData();
                            if (axis.componentType === ComponentLibrary.X_AXIS_COMPONENT ||
                                axis.componentType === ComponentLibrary.Y_AXIS_COMPONENT) {
                                axis.adjustDomain4Radius();
                            }else{
                                //radiusAxis等
                                axis.fixScaleAndTickData();
                            }
                        }
                    })
                }
            }

            this.options.visible = !this.options.visible;

            if (this.options.pairLegendOpt) {
                this.options.pairLegendOpt.visible = this.options.visible;
                this.options.pairLegendOpt.renderItem.render();
                this.options.pairLegendOpt.renderItem.onMouseOut();
            }

            vanchart.reRenderWholePlot();

            item.state = item.state == Constants.STATE_TO_SHOW ? Constants.STATE_SHOW : item.state;
            item.state = item.state == Constants.STATE_TO_DROP ? Constants.STATE_DROPPED : item.state;
        },

        remove: function () {
            this.graphic && this.graphic.remove();
            this.graphic = null;
        }
    });


    return LegendItem;
});
/**
 * Created by eason on 15/5/4.
 * 图例
 */
define('component/Legend',['require','./Base','../utils/BaseUtils','../Constants','./LegendIconFactory','./LegendItem','../dom/Evented','../utils/BezierEasing','../ComponentLibrary','../chart/gantt/Scrollbar','../dom/DomUtils'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var LegendItem = require('./LegendItem');
    var Evented = require('../dom/Evented');
    var BezierEasing = require('../utils/BezierEasing');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scrollbar = require('../chart/gantt/Scrollbar');
    var DomUtils = require('../dom/DomUtils');


    var PADDING = 4;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };
    
    // Gap between legendItem-icon and legendItem-text
    var GAP = 8;
    var GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(GAP);
    };

    var BUTTON_HEIGHT = 12;

    // Gap between legendItem & next legendItem when legend with horizontal layout
    var HORIZONTAL_GAP = 12;
    var HORIZONTAL_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(HORIZONTAL_GAP);
    };

    //文字换行 行间距为一行字高的0.2倍
    var WORD_GAP = 0.2;
    //vertical layout。 Gap between legendItem & next legendItem is 一行字高的0.6倍。
    var PARAGRAPH_GAP = 0.6;

    //横向布局，icon + icon_text_gap + text的最小长度
    var MIN_WIDTH = 96;
    var MIN_WIDTH_FUN = function () {
        return BaseUtils.paddingConvertWithScale(MIN_WIDTH);
    };

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var Legend = Base.extend({

        doLayout:function(){
            this.items = this.items || [];

            if(this.invisible()){
                this.remove();
                return ;
            }

            this.yPanEnabled = false;
            this.hasPages = false;

            this._updateLegendItems();
            this._layoutLegendItemBounds();
        },

        _updateLegendItems:function(){
            var series = this.vanchart.series, namedSeries = {}, namedTrendLine = {}, legend = this, vanchart = this.vanchart;
            var legendItemOptions = [], i, len;

            var opacityMap = {};

            // @Cmen-Chart-687
            // 饼图这一类图形，只有当条件属性设置系列透明度时，才对图例对应的透明度
            // 之前的问题是使用的第一个point的透明度来作为图例的透明度，理论上说是不正确的
            // 这里在生成legendItem之前，先遍历一边points，当具有相同bindName的point的opacity相同，才可以证明开启了系列透明
            for(i = -1; ++i < series.length;){
                var ser = series[i];
                if(ser.type === Constants.GAUGE_CHART){
                    continue; // 测量类图表不支持图例，故no need
                }
                if(ser.isSeriesAccumulated()){
                    ser.points.forEach(function(point){
                        var bindName = legend._itemBindName(point);
                        if(!opacityMap[bindName]){
                            opacityMap[bindName] = {
                                opacity: point.opacity || 1,
                                useSerOpacity : true
                            }
                        } else {
                            if(opacityMap[bindName].opacity != point.opacity){
                                opacityMap[bindName].useSerOpacity = false;
                            }
                        }
                    })
                }
            }

            for(i = 0, len = series.length; i < len; i++){
                var sery = series[i], chartType = sery.type;

                if(chartType == Constants.GAUGE_CHART){
                    continue;
                }

                if(sery.isSeriesAccumulated()){

                    var key = 'name';

                    // BI-7057
                    var ovk = chartType === Constants.PIE_CHART ? 'x' : 'name';
                    var orderMap = {};
                    sery.options.data.forEach(function(datum, i){
                        orderMap[datum[ovk]] = i;
                    });

                    var tmp = sery.points.slice().sort(function (a, b) {
                        return orderMap[a[ovk]] - orderMap[b[ovk]]
                    });

                    tmp.map(function (point) {
                        var bindName = legend._itemBindName(point);
                        if(!(namedSeries[bindName])){
                            var item = {
                                color:vanchart.getDefaultSeriesColor(bindName),
                                opacity: opacityMap[bindName].useSerOpacity ? opacityMap[bindName].opacity : 1,
                                bindName: bindName,
                                itemName: bindName,
                                visible:point.visible
                            };
                            legend._mergeCommonLegendAttr(sery, item);
                            namedSeries[bindName] = true;
                            legendItemOptions.push(item);
                        }
                    });

                }else{
                    if(!(namedSeries[sery.name])) {
                        var item = {color: sery.color, opacity: sery.opacity, bindName: sery.name, itemName: sery.name, visible: sery.visible};

                        legend._mergeCommonLegendAttr(sery, item);

                        namedSeries[sery.name] = item;

                        legendItemOptions.push(item);
                    }
                    if (sery.options.trendLine && !(namedTrendLine[sery.name])) {
                        var item = {isTrendLine: true, color: sery.options.trendLine.color, opacity: sery.opacity, bindName: sery.name, itemName: sery.options.trendLine.name, visible: sery.visible};

                        legend._mergeCommonLegendAttr(sery, item);
                        item.legendIconType = undefined;
                        // log both legends
                        namedSeries[sery.name].pairLegendOpt = item;
                        item.pairLegendOpt = namedSeries[sery.name];

                        namedTrendLine[sery.name] = item;

                        legendItemOptions.push(item);
                    }
                }
            }

            for(i = legendItemOptions.length, len = this.items.length; i < len; i++){
                this.items[i].remove();
                this.items[i] = null;
            }

            for(i = 0, len = legendItemOptions.length; i < len; i++){
                if(this.items[i]){
                    this.items[i].refresh(legendItemOptions[i]);
                }else{
                    this.items[i] = new LegendItem(legend, legendItemOptions[i]);
                }
            }

            this.items.length = legendItemOptions.length;
        },

        _mergeCommonLegendAttr:function(sery, item){
            var cfg = this.options;
            var hiddenColor = cfg.hiddenColor;
            var hoverColor = cfg.hoverColor || cfg.style.color;

            BaseUtils.extend(item, {
                series:sery,
                hiddenColor:hiddenColor,
                hoverColor:hoverColor,
                legendIconType:this._getLegendType(sery),
                lineIndex:0//记录下如果换行的行号
            });
        },

        _layoutLegendItemBounds:function(){

            //这边的padding是整个图例和别的组件的间隙
            var cfg = this.options, position = cfg.position || Constants.RIGHT;

            if (!this.items.length) {
                return
            }

            this.textHeight = BaseUtils.getTextHeight(cfg.style);//一行字高

            if(position == Constants.TOP || position == Constants.BOTTOM){

                this._layoutHorizontalLegendItemBounds(position);

            }else {
                //考虑不和工具栏&&标题重叠
                //更改:不考虑标题,因为标题已经裁剪过了，this.vanchart.bounds.y已经是考虑了标题的了
                var toolbarHeight = 0;
                if((position == Constants.RIGHT || position == Constants.RIGHT_TOP) && !this.isFloat){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    tools && tools.options.hidden != false && (toolbarHeight = 37 + PADDING_FUN() * 2);
                }

                this._layoutVerticalLegendItemBounds(position, toolbarHeight);
            }
        },

        _layoutVerticalLegendItemBounds:function(position, startY){

            var maxWidth = this._maxWidth(), style = this.options.style;

            var totalUsedWidth = 0, legendY = PADDING_FUN(), borderWidth = this.options.borderWidth || 0;

            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i], options = item.options;
                var iconDim = LegendIconFactory.getLegendIconSize(options.legendIconType);
                var textMaxWidth = maxWidth - GAP_FUN() - iconDim.width - 2 * PADDING_FUN();
                var textUsedWidth = this._getTextUsedWidth(options.itemName, style, textMaxWidth);
                totalUsedWidth = Math.max(textUsedWidth + GAP_FUN() + iconDim.width, totalUsedWidth);

                item.labels = BaseUtils.splitText(options.itemName, style, textMaxWidth, 0, false);
                item.legendX = PADDING_FUN() + borderWidth/2; item.legendY = legendY;

                legendY += (Math.max(this.textHeight * item.labels.length + this.textHeight * WORD_GAP * (item.labels.length - 1), iconDim.height) + PARAGRAPH_GAP * this.textHeight);
            }
            legendY -= PARAGRAPH_GAP * this.textHeight;//最后一行下面不用间距

            var legendSize = PADDING_FUN() * 2 + totalUsedWidth, needHeight = legendY + PADDING_FUN();

            var offeredHeight = this.vanchart.bounds.height - (this.isFloat ? 0 : PADDING_FUN() * 2);
            //但是要考虑标题高度小于37的时候，减去tools高度才是可用高度
            offeredHeight -= Math.max(0, startY - this.vanchart.bounds.y);

            //todo 这里有种期限的情况,比如256, 255,理论上算的话应该有翻页,但是因为太小了基本看不出来
            this.yPanEnabled = this.hasPages = (needHeight - PADDING_FUN()) > offeredHeight;

            if(this.hasPages){
                 this._calculatePagesTransMap(offeredHeight);

                legendSize = Math.max(legendSize, this._getPageButtonWidth(this.pageCount));

                this.maxYPan = this.translateMap[this.translateMap.length - 1];
            }

            // 非浮动下图例占用的实际宽度要再加上两倍间距
            var actualWidth = (legendSize > maxWidth ? maxWidth : legendSize) + (this.isFloat ? 0 : PADDING_FUN() * 2);

            this._setComponentBounds(position, actualWidth);

            var x = this.bounds.x + (this.isFloat ? 0 : PADDING_FUN());
            var y = this.bounds.y + (this.isFloat ? 0 : PADDING_FUN());
            var width = this.bounds.width - (this.isFloat ? 0 : PADDING_FUN() * 2);
            var height = this.bounds.height - (this.isFloat ? 0 : PADDING_FUN() * 2);
            //但是要考虑标题高度小于37的时候，减去tools高度才是可用高度
            height -= Math.max(0, startY - this.vanchart.bounds.y);

            var usedHeight = Math.min(needHeight, height);
            y = Math.max(startY, y);
            if(!this.isFloat && position == Constants.RIGHT_BOTTOM){
                //右下
                y = Math.round(this.bounds.y + this.bounds.height - usedHeight - PADDING_FUN());
            } else if (!this.isFloat && (position == Constants.RIGHT || position == Constants.LEFT)) {
                // 垂直居中
                y += Math.round((height - usedHeight) / 2);
            }

            this.bounds = {x:x, y:y, width:width, height:usedHeight};
        },

        _calculatePagesTransMap:function (offeredHeight) {
            offeredHeight -= (BUTTON_HEIGHT + PADDING_FUN());//可见部分不应该包括按钮的高度

            this.pageIndex = this.pageIndex || 0;

            this.translateMap = [0];//第几页到平移多少应该都是确定的

            var lastStartY = 0;
            for(var itemIndex = 0, itemCount = this.items.length; itemIndex < itemCount; itemIndex++){
                var startY = this.items[itemIndex].legendY;
                if(startY - lastStartY > offeredHeight){
                    lastStartY = startY - PARAGRAPH_GAP * this.textHeight;
                    this.translateMap.push(-startY);
                }
            }

            this.pageCount = this.translateMap.length;
            return offeredHeight;
        },

        _getPageButtonWidth:function(pageCount){
            var style = {'fontFamily':this.options.style.fontFamily || 'Verdana', 'fontSize':'14px'};
            var text = pageCount + '/' + pageCount;
            var textDim = BaseUtils.getTextDimension(text, style, false);
            return BUTTON_HEIGHT * 2 + textDim.width;
        },

        _getTextUsedWidth:function (text, style, maxWidth) {
            var dim = BaseUtils.getTextDimension(text, style, false);
            if(maxWidth && maxWidth < dim.width) {
                return maxWidth;
            }
            return dim.width;
        },

        _layoutHorizontalLegendItemBounds:function(position){
            var plotBounds = this.vanchart.bounds, style = this.options.style;
            //84*n+12(n-1) = offeredWidth。itemMaxWidth = icon + icon_text_gap + text + item_item_gap
            var offeredWidth = plotBounds.width - 4 * PADDING_FUN(),
                niceNum = Math.floor((offeredWidth + HORIZONTAL_GAP_FUN())/MIN_WIDTH_FUN());
                niceNum = Math.min(niceNum, this.items.length);

            var itemMaxWidth = Math.round((offeredWidth + HORIZONTAL_GAP_FUN())/niceNum);

            var legendY = PADDING_FUN();

            var currentLineMaxHeight = 0, hasWrap = false, multiLine = this.items.length > niceNum;
            for(var i = 0, len = this.items.length; i < len; i++) {
                var item = this.items[i], options = item.options;

                var iconSize = LegendIconFactory.getLegendIconSize(options.legendIconType);
                var textMaxWidth = itemMaxWidth - GAP_FUN() - iconSize.width - HORIZONTAL_GAP_FUN();
                item.labels = BaseUtils.splitText(options.itemName, style, textMaxWidth, 0, false);
                hasWrap = hasWrap || item.labels.length > 1;

                if (i % niceNum === 0) {//换行
                    legendY += currentLineMaxHeight;
                    currentLineMaxHeight = 0;
                }
                item.legendX = PADDING_FUN() + i % niceNum * itemMaxWidth;
                item.legendY = legendY;

                currentLineMaxHeight = Math.max(currentLineMaxHeight, (Math.max(this.textHeight * item.labels.length + this.textHeight * WORD_GAP * (item.labels.length - 1), iconSize.height) + PARAGRAPH_GAP * this.textHeight));
            }
            legendY += (currentLineMaxHeight - PARAGRAPH_GAP * this.textHeight);//最后一行下面不用间距

            var legendSize = Math.round(legendY) + PADDING_FUN();
            var maxHeight = this._maxHeight();

            this.yPanEnabled = maxHeight && (legendSize > maxHeight);
            this.maxYPan = -legendSize + maxHeight;//yPanEnabled = true时，这个才有用

            // 当计算组件占用的实际高度时，需要加上外间距值
            var actualHeight = (this.yPanEnabled ? maxHeight : legendSize) +  PADDING_FUN() * 2;

            this._setComponentBounds(position, actualHeight);

            var x = this.bounds.x + PADDING_FUN();
            var y = this.bounds.y + PADDING_FUN();
            var height = this.bounds.height - PADDING_FUN() * 2 + (this.options.borderWidth || 0) * 2;
            var width = this.bounds.width - PADDING_FUN() * 2 + (this.options.borderWidth || 0) * 2;

            var usedWidth = offeredWidth + PADDING_FUN() * 2;
            if(!hasWrap && !multiLine) {
                // 图例水平居中
                usedWidth = this._horizontalCenterLayout(style);
                x += (width - usedWidth) / 2;
            }

            this.bounds = {x:x, y:y, width:usedWidth, height:height};
        },

        // 图例水平居中用的宽度
        _horizontalCenterLayout:function (style) {
            var legendX = PADDING_FUN();
            for(var i = 0, len = this.items.length; i < len; i++) {
                var item = this.items[i], options = item.options;

                item.legendX = legendX;

                legendX += LegendIconFactory.getLegendIconSize(options.legendIconType).width;
                legendX += GAP_FUN();
                legendX += BaseUtils.getTextDimension(options.itemName, style, false).width;
                legendX += HORIZONTAL_GAP_FUN();
            }

           return legendX + PADDING_FUN()  - HORIZONTAL_GAP_FUN();
        },

        render:function(){

            if(this.invisible() || !this.items.length){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.legendGroup){
                this.legendGroup = this.createComponentGroup();
                this.backgroundGroup = renderer.group().addTo(this.legendGroup);
                this.clipGroup = renderer.group().addTo(this.legendGroup);
                this.legendItemsGroup = renderer.group().addTo(this.clipGroup);

                vanchart.registerInteractiveTarget(this, this.legendGroup);
            }

            this.legendGroup.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, BaseUtils.makeBounds(0,0,bounds.width, bounds.height));

            for(var i = 0, len = this.items.length; i < len; i++){
                this.items[i].render();
            }

            var clip = {x:0, y:0, width:bounds.width, height:bounds.height};
            if(this.hasPages){
                clip.height -= BUTTON_HEIGHT;
                this.pageButton = this.pageButton || new PageButton(legend);
                this.pageButton.refresh();
            }else if(this.pageButton){
                this.pageButton.remove();
                this.pageButton = null;
            }

            //clip的显示区域
            if(!this.verticalClip){
                this.verticalClip = renderer.createClip(clip);
                renderer.clip(this.clipGroup, this.verticalClip);
            }else{
                renderer.updateClip(this.verticalClip, clip);
            }

            legend._buildScrollbar();

            // 数据刷新的时候，重置图例的scrollTop和pageIndex
            if(vanchart._changeDataState){
                this.resetLegendScroll();
            }
        },

        _buildScrollbar: function () {
            var legend = this;
            legend.scrollbar && legend.scrollbar.remove();

            if(legend.yPanEnabled && legend.maxYPan) {
                legend.scrollbar = new Scrollbar({
                    scrollX: false,
                    scrollY: true,
                    view: legend,
                    group: legend.legendGroup,
                    width:legend.bounds.width,
                    height: legend.bounds.height,
                    innerHeight: legend.bounds.height - legend.maxYPan
                });
            }
        },

        getEvents:function(){
            return {
                'wheel':this.onWheel,
                'mouseout':this.mouseOut,
                'mouseover':this.mouseOver,

                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        mouseOut:function(){
            if(this.highlighted){
                this.vanchart.cancelLegendHighlight();
            }
        },

        mouseOver:function () {
        },

        onWheel: function (ev) {
            var e = ev.srcEvent;
            DomUtils.preventDefault(e);
            this.moveLegend(DomUtils.getWheelDelta(e));
        },

        onPanStart:function(ev){
            this.currentY = ev.containerPoint.y;
        },

        onPanMove:function(ev){

            var deltaY = ev.containerPoint.y - this.currentY;

            this.moveLegend(deltaY);

            this.currentY = ev.containerPoint.y;
        },

        onPanEnd:function(){
            this.vanchart.handler.panTarget = null;
        },

        moveLegend: function (deltaY) {
            var transY = 0;

            if(this.yPanEnabled){
                transY = deltaY + (this.legendItemsGroup.currentY || 0);
                transY = Math.max(this.maxYPan, Math.min(0, transY));
            }

            if(this.hasPages && this.pageButton){

                var pageIndex = this.translateMap.length - 1;
                for(var i = 0, len = this.translateMap.length - 1; i < len; i++){
                    var pre = this.translateMap[i], next = this.translateMap[i + 1];
                    if(pre >= transY && next < transY){
                        pageIndex = i;
                    }
                }

                if(this.pageIndex != pageIndex){
                    this.pageIndex = pageIndex;
                    this.pageButton.updatePage();
                }
            }

            this.legendItemsGroup.currentY = transY;
            this.legendItemsGroup.attr('transform', BaseUtils.makeTranslate([0,this.legendItemsGroup.currentY]));

            this.fire('innerChange', {x:0, y:transY});
        },

        /**
         * 图表刷新时，重置legend的滚轮位移和pageIndex
         */
        resetLegendScroll: function () {
            this.legendItemsGroup.currentY = 0;
            this.legendItemsGroup.attr('transform', 'translate(0,0)');

            if(this.hasPages && this.pageButton && this.pageIndex !== 0){
                this.pageIndex = 0;
                this.pageButton.updatePage();
            }
        },

        remove: function () {
            this.legendGroup && this.legendGroup.remove();
            this.verticalClip && this.verticalClip.remove && this.verticalClip.remove();
            this.legendGroup = this.verticalClip = null;
            this.items && (this.items.length = 0);
        },

        _itemBindName:function (point) {
            var sery = point.series;
            return sery.isSeriesAccumulated() ? point.name : sery.name;
        },

        reShowPoint:function (point) {
            var name = this._itemBindName(point);
            return this._stateName(name, Constants.STATE_TO_SHOW);
        },

        showSeries:function (series) {
            return this._stateName(series.name, Constants.STATE_SHOW);
        },

        toDropSeries:function (series) {
            return this._stateName(series.name, Constants.STATE_TO_DROP);
        },

        _stateName:function (name, state) {
            for(var i = 0, len = this.items.length; i < len;i++){
                var item = this.items[i];
                if(item.state == state && item.options.bindName == name){
                    return true;
                }
            }
            return false;
        }
    });

    var PageButton = Evented.extend({

        initialize:function(legend){
            this.legend = legend;
        },

        refresh:function(){
            var legend = this.legend, vanchart = legend.vanchart, renderer = vanchart.renderer, bounds = legend.bounds;
            var width = legend._getPageButtonWidth(legend.pageCount), height = bounds.height, y = height - BUTTON_HEIGHT;
            var startX = (bounds.width - width)/2;

            if(!this.pageGroup){
                this.pageGroup = renderer.group().addTo(legend.legendGroup);
                vanchart.registerInteractiveTarget(this, this.pageGroup);
                this.leftButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.rightButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.pageText = renderer.text().style({'fontFamily':legend.options.style.fontFamily || 'Verdana', 'fontSize':'14px'}).addTo(this.pageGroup);
            }

            var buttonWidth = width - BUTTON_HEIGHT;//实际现实的按钮的宽度
            var leftButtonTopX = startX + (width - buttonWidth) / 2;
            var rightButtonTopX = startX + (width + buttonWidth) / 2;
            var labelX = startX + width/2;

            this.pageGroup.attr('transform', BaseUtils.makeTranslate([0, y]));
            this.leftButton.attr('d', this._prePageButtonPath(leftButtonTopX));
            this.rightButton.attr('d', this._nextPageButtonPath(rightButtonTopX));
            this.pageText.attr({
                'x': labelX,
                'y': '-.14em',
                'dy': '.85em'
            }).attr("text-anchor", "middle");

            this.updatePage();
        },

        remove:function(){
            if(this.pageGroup){
                this.pageGroup.remove();
                this.pageGroup = null;
            }
        },

        updatePage:function(){
            
            var legend = this.legend, pageIndex = legend.pageIndex, pageCount = legend.pageCount;

            this.leftButton.style({'fill': pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR});

            this.rightButton.style({'fill':pageIndex < pageCount - 1 ? ENABLED_COLOR : DISABLED_COLOR});

            var text = pageIndex + 1 + '/' + pageCount;

            this.pageText.textContent(text);
            
            // for IE DIV text
            this.pageText.vMiddle();
        },

        _prePageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var leftBottomX = topX - edge / 2, leftBottomY = (edge / 2) * Math.sqrt(3);
            var rightBottomX = topX + edge / 2, rightBottomY = leftBottomY;
            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var topLeftX = topX - edge/2, topLeftY = topY;
            var topRightX = topX + edge/2, topRightY = topY;
            var bottomX = topX, bottomY = (edge / 2) * Math.sqrt(3);
            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        onTap:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement, legend = this.legend;

            if(this.leftButton.node() == src){
                if(legend.pageIndex <= 0){
                    return;
                }

                legend.pageIndex--;

            }else if(this.rightButton.node() == src){
                if(legend.pageIndex == legend.pageCount - 1){
                    return;
                }

                legend.pageIndex++;
            }

            var transY = legend.translateMap[legend.pageIndex];
            legend.legendItemsGroup.animate({
                duration:500,
                ease:BezierEasing.css.swing,
                attr:{'transform': 'translate(' + 0 + ',' + transY + ')'}
            });

            legend.legendItemsGroup.currentY = transY;
            legend.fire('innerChange', {x:0, y:transY});

            this.updatePage();
        },

        getEvents:function(){
            return {
                'tap':this.onTap
            }
        }

    });

    ComponentLibrary.register(ComponentLibrary.LEGEND_COMPONENT, Legend);
    return Legend;
});
/**
 * Created by eason on 15/10/12.
 */
define('component/Zoom',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/PathGenerator','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    //缩放控件默认的高度
    var HEIGHT = 30;
    var WIDTH = 10;

    // 缩放控件的最小高度和最大高度
    var HEIGHT_MIN = 10,
        HEIGHT_MAX = 25;

    var DIRECTION_NONE = 'none';
    var DIRECTION_LEFT_TO_RIGHT = 'left-to-right';
    var DIRECTION_RIGHT_TO_LEFT = 'right-to-left';

    var PADDING = 4;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var Zoom = Base.extend({

        _refresh:function(){
            this.rangeLeftTop = this.rangeRightBottom = null;
        },

        doLayout:function(){

            this.byAxisType = this.vanchart.chartType() == Constants.BAR_CHART ? 'yAxis' : 'xAxis';
            this.byAxis = this.vanchart[this.byAxisType]();

            if(this.zoomToolEnabled()){
                var dataSheet = this.vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
                var plotBounds = this.vanchart.bounds, isHorizontal = this.byAxis.isHorizontal(), padding = PADDING_FUN(); 

                var validHeight = isHorizontal ? plotBounds.height : plotBounds.width; 
 
                var calcZoomHeight = (validHeight - 2 * padding) / 23.3; 
                HEIGHT = calcZoomHeight < HEIGHT_MIN ? HEIGHT_MIN : (calcZoomHeight > HEIGHT_MAX ? HEIGHT_MAX : parseInt(calcZoomHeight)); 
                WIDTH  = Math.ceil(HEIGHT / 3); 
 
                this._setComponentBounds(isHorizontal ? Constants.BOTTOM : Constants.LEFT, HEIGHT + padding * 2); 

                // 在这里更新一下尺寸，方便下面计算位置时直接使用
                if(isHorizontal) { 
                    this.bounds.y += padding; 
                    this.bounds.height -= 2 * padding; 
                } else { 
                    this.bounds.x += padding; 
                    this.bounds.width -= 2 * padding; 
                } 
            }
        },

        fixBoundsByPlot:function(){

            if(!this.zoomToolEnabled()){
                return;
            }

            var positionAxis, axisCompo = this.vanchart.components[this.byAxisType];
            var axisCount = axisCompo.getAxisCount();
            for(var axisIndex = 0; axisIndex < axisCount; axisIndex++){
                var axis = axisCompo.getAxis(axisIndex), position = axis.getPosition();
                if(position== Constants.BOTTOM || position == Constants.LEFT){
                    positionAxis = axis;
                }
            }

            positionAxis = positionAxis || this.byAxis;

            var plotBounds = this.vanchart.bounds;

            if(positionAxis.isHorizontal()){
                this.bounds = BaseUtils.makeBounds(plotBounds.x, this.bounds.y, plotBounds.width, this.bounds.height); 
            }else{
                this.bounds = BaseUtils.makeBounds(this.bounds.x, plotBounds.y, this.bounds.width, plotBounds.height); 
            }
        },

        initToolDomain:function (axis) {
            var tool = this.options.zoomTool;

            tool.from = (BaseUtils.hasDefined(tool.from) && tool.from !== '') ? tool.from : null;
            tool.to = (BaseUtils.hasDefined(tool.to) && tool.to !== '') ? tool.to : null;
            if(axis.type === ComponentLibrary.DATE_AXIS_COMPONENT){
                tool.from = BaseUtils.date2int(BaseUtils.object2date(tool.from));
                tool.to = BaseUtils.date2int(BaseUtils.object2date(tool.to));
            }
            // 多分类轴的from和to格式化
            if(axis.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT && axis.isMultiCateAxis()){
                tool.from = BaseUtils.encodeCategoryArray(tool.from);
                tool.to = BaseUtils.encodeCategoryArray(tool.to);
            }
        },

        getZoomInitDomain: function (zoomAxis) {
            var axis = this.byAxis;
            if (this.zoomToolEnabled() && axis._isBaseAxis() && zoomAxis == axis) {
                var tool = this.options.zoomTool;

                this.initToolDomain(axis);

                return [tool.from, tool.to]
            }
        },

        getZoomDomain:function(zoomAxis){
            var axis = this.byAxis, dataDomain = zoomAxis.isCategory() ? axis._dataDomain : axis._domain;
            if(this.zoomToolEnabled() && axis._isBaseAxis() && zoomAxis == axis){
                var tool = this.options.zoomTool;

                this.initToolDomain(axis);

                var from = BaseUtils.pick(this.rangeLeftTop, tool.from, dataDomain[0]);

                var to = BaseUtils.pick(this.rangeRightBottom, tool.to, dataDomain[dataDomain.length - 1]);

                return this._getValidDomain(from, to, dataDomain, axis.isCategory());
            }
        },

        getMinAndMaxPos:function(){

            var domain = this.getZoomDomain(this.byAxis), scale = this.axisScale;

            if(!domain){//byAxis has no data
                return [0, this.vanchart.bounds.width];
            }

            var x1 = scale(domain[0]), x2 = scale(domain[domain.length - 1]);

            return [Math.min(x1, x2), (Math.max(x1, x2) + (scale.rangeBand ? scale.rangeBand() : 0))];
        },

        //只有分类轴排序以后会调用这个方法
        updateRangeLeftAndRight:function(cateAxis, lastDomain, currentDomain){

            var leftIndex = BaseUtils.indexOf(lastDomain, this.rangeLeftTop);
            var rightIndex = BaseUtils.indexOf(lastDomain, this.rangeRightBottom);

            var domain = currentDomain.slice(Math.min(leftIndex, rightIndex), Math.max(leftIndex, rightIndex) + 1);

            if(cateAxis.isAxisReversed() ^ cateAxis.isHorizontal()){
                this.rangeLeftTop = domain[0];
                this.rangeRightBottom = domain[domain.length - 1];
            }else{
                this.rangeLeftTop = domain[domain.length - 1];
                this.rangeRightBottom = domain[0];
            }

        },

        _getValidDomain:function(from, to, dataDomain, isCategory){
            var tmp;
            if(isCategory){
                var maxIndex = dataDomain.length - 1;
                var minIndex = 0;
                from = BaseUtils.indexOf(dataDomain, from);
                to = BaseUtils.indexOf(dataDomain, to);

                from = Math.min(Math.max(from, minIndex), maxIndex);
                to = Math.min(Math.max(to, minIndex), maxIndex);

                if(from > to){
                    tmp = to;
                    to = from;
                    from = tmp;
                }

                return dataDomain.slice(from, to + 1);

            }else{
                from = parseFloat(from);
                to = parseFloat(to);

                if(from > to){
                    tmp = to;
                    to = from;
                    from = tmp;
                }

                return [from, to];
            }
        },

        zoomToolEnabled:function(){
            var opt = this.options;
            return this.vanchart.series.length && opt && opt.zoomTool && opt.zoomTool.enabled && BaseUtils.isSupportSVG();
        },

        _getAxisScale:function(){
            var axis = this.byAxis, scale = axis.scale.copy();
            if (axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                scale.rangeBand ? scale.rangeBands(axis._getPlotRange()) : scale.range(axis._getPlotRange());
            } else {
                var domain = axis._dataDomain, zoomDomain = this.getZoomDomain(axis);

                var min = Math.min(domain[0], zoomDomain[0]);
                var max = Math.max(domain[1], zoomDomain[1]);

                if(axis.type == ComponentLibrary.DATE_AXIS_COMPONENT){
                    min = BaseUtils.int2date(min);
                    max = BaseUtils.int2date(max);
                }

                scale.domain([min, max]);
            }

            return scale;
        },

        render:function(){

            this.remove();

            if(this.zoomBarGroup || !this.zoomToolEnabled()){
                return;
            }

            this.axisScale = this._getAxisScale();

            var zoomBar = this, bounds = zoomBar.bounds, vanchart = zoomBar.vanchart, renderer = vanchart.renderer;
            var pos = this.getMinAndMaxPos(), isVertical = this.byAxis.isVertical();
            var minPos = pos[0], maxPos = pos[1];
            if(!this.zoomBarGroup){
                this.zoomBarGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate(bounds))
                    .style('cursor', isVertical ? 'ns-resize ' : 'ew-resize');

                vanchart.registerInteractiveTarget(this, this.zoomBarGroup);
            }

            this._createLines();

            this.leftTopRect = this._createSideRect(isVertical, minPos, true);

            this.rightBottomRect = this._createSideRect(isVertical, maxPos, false);

            this.centerRect = this._createCenterRect(isVertical, minPos, maxPos);

            this.leftTopButton = this._createButton(isVertical, minPos, true);

            this.rightBottomButton = this._createButton(isVertical, maxPos, false);

            var l_transX = this.leftTopButton.pos, r_transX = this.rightBottomButton.pos;

            this.rangeLeftTop = this._getValueByPosition(l_transX);

            this.rangeRightBottom = this._getValueByPosition(r_transX + WIDTH);
        },

        //缩放底边上的线
        _createLines:function(){
            if(this.byAxis.series.length === 0){
                return;
            }
            var axisScale = this.axisScale, byAxisType = this.byAxisType, vanchart = this.vanchart, renderer = vanchart.renderer, series = vanchart.series;
            var det = axisScale.rangeBand ? axisScale.rangeBand()/2 : 0, catePoints = vanchart.cateMap;
            var linePoints = [], min = Number.MAX_VALUE,  max = -Number.MAX_VALUE;
            var isHorizontal = this.byAxis.isHorizontal(), isDate = this.byAxis.type === ComponentLibrary.DATE_AXIS_COMPONENT;

            for(var key in catePoints){
                var points = catePoints[key];

                if(points[0].series[byAxisType]){
                    var value = 0;

                    //todo 是否要取绝对值
                    points.forEach(function(point){
                        value += point.getTargetValue();
                    });
                }

                if(!points[0].isNull){
                    linePoints.push({
                        'x':axisScale(isDate ? BaseUtils.object2date(key) : key) + det,'y':value
                    });
                }

                min = Math.min(min, value);
                max = Math.max(max, value);
            }

            var yRange = isHorizontal ? [HEIGHT, 0] : [0, HEIGHT];

            var yScale = Scale.linear().domain([min, max]).range(yRange);

            var lineSvg = PathGenerator.line().interpolate("linear")
                .x(function (d) {
                    return isHorizontal ? d.x : yScale(d.y);
                })
                .y(function (d) {
                    return isHorizontal ? yScale(d.y) : d.x;
                });

            linePoints.sort(function(pA, pB){
                return pA.x - pB.x;
            });

            this._line = this._line || renderer.path().style({fill:'none', stroke:'black', 'stroke-width':1});
            this._line.attr('d', lineSvg(linePoints)).addTo(this.zoomBarGroup);

            //保证折线不超过区域
            this._innerClip(this._line);
        },

        _createSideRect:function(isVertical, pos, isLeftTop){

            var renderer = this.vanchart.renderer;
            var x = 'x', y = 'y', width = 'width', height = 'height',size = this.bounds.width;
            if(isVertical){
                x = 'y'; y = 'x'; width = 'height'; height = 'width'; size = this.bounds.height;
            }

            var xPos, xWidth;
            if(isLeftTop){
                xPos = 0;
                xWidth = pos;
            }else{
                xPos = pos;
                xWidth = Math.abs(size - xPos);
            }

            return renderer.rect().attr(x, xPos).attr(y, 0)
                .attr(width, xWidth).attr(height, HEIGHT)
                .style({'fill':'rgba(220,221,221,0.4)'})
                .addTo(this.zoomBarGroup);
        },

        _createCenterRect:function(isVertical, startX, endX){
            var renderer = this.vanchart.renderer;

            var x = 'x', y = 'y', width = 'width', height = 'height';

            if(isVertical){
                x = 'y'; y = 'x'; width = 'height'; height = 'width';
            }

            return renderer.rect()
                .attr(x, startX + WIDTH).attr(y, 0)
                .attr(width, endX - startX - 2 * WIDTH).attr(height, HEIGHT)
                .style({
                    'fill':'rgba(255,255,255,0)',
                    'stroke':'#29ABE2',
                    'stroke-width':1
                }).addTo(this.zoomBarGroup);
        },

        /** 
         * 创建缩放控件按钮: 
         * 由于现在的控件高度是不固定的，因此要根据控件高度来计算buttonPath。 
         * 此外，内部的线的宽度和数量也要考虑到控件的大小而做出变化 
         * @param  {Boolean} isVertical 样式水平或者数值 
         * @param  {Number}  startPos   按钮起始位置 
         * @param  {Boolean} isLeftTop  是否为Left或Top按钮 
         * @return {Object}             按钮对象 
         */ 
        _createButton:function(isVertical, startPos, isLeftTop){

            startPos = isLeftTop ? startPos : startPos - WIDTH;
            var renderer = this.vanchart.renderer;
            var button = renderer.group().attr('transform', this._getButtonTranslate(isVertical, startPos));
            var lineStyle = {
                'fill': '#FFFFFF',
                'stroke': '#7ADAF4',
                'stroke-width': 2,
                'stroke-linecap': 'round',
                'stroke-linejoin': 'round',
                'stroke-miterlimit': 10
            };

            var buttonPath;
            if(isLeftTop){
                if(isVertical){
                    buttonPath = this.buttonPathGenerator(HEIGHT, WIDTH, WIDTH / 3, [0, 0, 1, 1]);
                }else{
                    buttonPath = this.buttonPathGenerator(WIDTH, HEIGHT, WIDTH / 3, [0, 1, 1, 0]);
                }
            }else{
                if(isVertical){
                    buttonPath = this.buttonPathGenerator(HEIGHT, WIDTH,  WIDTH / 3, [1, 1, 0, 0]); 
                }else{
                    buttonPath = this.buttonPathGenerator(WIDTH, HEIGHT, WIDTH / 3, [1, 0, 0, 1]);
                }
            }

            renderer.path().attr('d', buttonPath).style({'fill':'#29ABE2'}).addTo(button);

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', startY = Math.ceil(HEIGHT / 4), endY = HEIGHT - startY; 
            if(isVertical){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }
            
            var lineWidth = lineStyle['stroke-width'] = Math.floor(WIDTH / 5) || 1; 
            var needSecondLine = WIDTH >= 5; 
            
            var startX1 = needSecondLine ? (WIDTH - lineWidth * 2) / 3 : (WIDTH - lineWidth) / 2; 
            var startX2 = needSecondLine ? (WIDTH - lineWidth * 2) / 3 * 2 + lineWidth : 0;

            renderer.line().attr(x1, startX1).attr(y1, startY).attr(x2, startX1).attr(y2, endY) 
                .style(lineStyle).addTo(button); 
            if(needSecondLine){ 
                renderer.line().attr(x1, startX2).attr(y1, startY).attr(x2, startX2).attr(y2, endY) 
                    .style(lineStyle).addTo(button); 
            } 

            button.pos = startPos;

            button.addTo(this.zoomBarGroup);

            return button;
        },

        /** 
         * 按钮路径生成器:根据给定的参数，生成带有指定圆角的svg矩形路径。 
         * @param  {Number} width  [矩形宽度] 
         * @param  {Number} height [矩形高度] 
         * @param  {Number} r      [圆角大小] 
         * @param  {Array} arr     [角形状,1表示尖角,0表示圆角] 
         * @return {String}        [svg path string] 
         */ 
        buttonPathGenerator : function (width, height, r, arr){ 
            var endPoints = [[0, 0], [width, 0], [width, height], [0, height]], 
                curvePoints = [ 
                    [0, r], [r, 0], 
                    [width - r, 0], [width, r], 
                    [width, height - r],  [width - r, height], 
                    [r, height], [0, height - r], 
                    [0,r] 
                ]; 
 
            var path = 'M' + point(curvePoints[0]) + move(0) + move(1) + move(2) + move(3) + 'z'; 
 
            return path; 
 
            function point(arr){ 
                return arr.join(','); 
            } 
 
            function move(index){ 
                var p1 = endPoints[index], p2 = curvePoints[index * 2 + 1]; 
                var str = ''; 
                if(arr[index]){ 
                    str =  'L' + point(p1) + 'L' + point(p2); 
                } else { 
                    str = 'Q' + point(p1) + ',' + point(p2); 
                } 
                return str + 'L' + point(curvePoints[index * 2 + 2]) 
            } 
        }, 

        _findDraggingTarget:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement;

            var pos = this.byAxis.isHorizontal() ? (ev.containerPoint.x - this.bounds.x) : (ev.containerPoint.y - this.bounds.y), resizeable = this._resizeable();

            var target;
            while (src) {

                //by position
                var leftTopDet = this.leftTopButton.pos - pos;
                var rightBottomDet = pos - (this.rightBottomButton.pos + WIDTH);

                if(leftTopDet > 0 && leftTopDet < 10 && resizeable){
                    target = this.leftTopButton;
                }

                if(rightBottomDet > 0 && rightBottomDet < 10 && resizeable){
                    target = this.rightBottomButton;
                }

                if(target){
                    break;
                }

                //by dom
                if(src == this.leftTopButton.node() && resizeable){
                    target = this.leftTopButton;
                }else if(src == this.rightBottomButton.node() && resizeable){
                    target = this.rightBottomButton;
                }else if(src == this.centerRect.node() || src == this.zoomBarGroup.node()){
                    target = this.centerRect;
                }

                if (target){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        _panStart:function(ev, target){

            this.target = target || this._findDraggingTarget(ev);

            if(this.target){
                this.downPos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;
                this.initPos = this.target.pos;
                this.initTranslate = 0;
                this.vanchart._zooming = true;
            }

        },

        _panContainerMove:function(ev){

            if(this.target){

                var pos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;

                var direction = pos < this.downPos ? DIRECTION_LEFT_TO_RIGHT : DIRECTION_RIGHT_TO_LEFT;

                this._centerRectMove(this.downPos, this.downPos + this.downPos - pos);

                this._zoomRefresh(direction);
            }

        },

        _panMove:function(ev){

            var direction = DIRECTION_NONE, pos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;//如果是拖拽的话要保持显示的分类个数不变

            if(!this.target || this.downPos == pos){
                return;
            }


            switch (this.target){

                case this.leftTopButton:
                    this._leftButtonMove(this.downPos, this.initPos, pos);
                    break;

                case this.rightBottomButton:
                    this._rightButtonMove(this.downPos, this.initPos, pos);
                    break;

                case this.centerRect:
                    direction = this._centerRectMove(this.downPos, pos);
                    break;
            }

            this._zoomRefresh(direction);
        },

        _leftButtonMove:function(downPos, initPos, currentPos){
            var minTransPos = 0, maxTransPos = this.rightBottomButton.pos - WIDTH;
            var trans = initPos + currentPos - downPos;
            var isVertical = this.byAxis.isVertical();
            trans = Math.max(Math.min(trans, maxTransPos), minTransPos);
            this.leftTopButton.pos = trans;

            var width = 'width', x = 'x';
            if(isVertical){
                width = 'height'; x = 'y';
            }

            this.leftTopButton.attr('transform', this._getButtonTranslate(isVertical, trans));
            this.leftTopRect.attr(width, trans);
            this.centerRect.attr(x, trans + WIDTH).attr(width, maxTransPos - trans);
        },

        _rightButtonMove:function(downPos, initPos, currentPos){
            var size = this.bounds.width, x = 'x', width = 'width';
            var isVertical = this.byAxis.isVertical();
            if(isVertical){
                size = this.bounds.height; x = 'y'; width = 'height';
            }

            var maxTransPos = size - WIDTH, minTransPos = this.leftTopButton.pos + WIDTH;

            var trans = initPos + currentPos - downPos;

            trans = Math.max(Math.min(trans, maxTransPos), minTransPos);

            this.rightBottomButton.pos = trans;
            this.rightBottomButton.attr('transform', this._getButtonTranslate(isVertical, trans));

            this.rightBottomRect.attr(x, trans + WIDTH).attr(width, size - (trans + WIDTH));
            this.centerRect.attr(width, trans - minTransPos);
        },

        _centerRectMove:function(downPos, currentPos){

            var endPos = this.bounds.width, det = currentPos - downPos - this.initTranslate;
            var x = 'x', width = 'width';
            var isVertical = this.byAxis.isVertical();
            if(isVertical){
                endPos = this.bounds.height; x = 'y'; width = 'height';
            }

            this.initTranslate = currentPos - downPos;

            if(this.leftTopButton.pos + det >=0 && this.rightBottomButton.pos + WIDTH + det <= endPos){

                var l_trans = this.leftTopButton.pos + det;
                this.leftTopButton.pos = l_trans;
                this.leftTopButton.attr('transform', this._getButtonTranslate(isVertical, l_trans));
                this.leftTopRect.attr(width, l_trans);

                var r_trans = this.rightBottomButton.pos + det;
                this.rightBottomButton.pos = r_trans;
                this.rightBottomButton.attr('transform', this._getButtonTranslate(isVertical, r_trans));
                this.rightBottomRect.attr(x, r_trans + WIDTH).attr(width, endPos - (r_trans + WIDTH));

                this.centerRect.attr(x, l_trans + WIDTH);
            }

            return this.initTranslate > 0 ? DIRECTION_LEFT_TO_RIGHT : DIRECTION_RIGHT_TO_LEFT;
        },

        _getValueByPosition:function(x){
            var axis = this.byAxis, scale = this.axisScale;
            switch (axis.type) {
                case ComponentLibrary.CATEGORY_AXIS_COMPONENT:
                    var domain = scale.domain(), range = scale.range();
                    for(var i = 0, len = range.length - 1; i < len; i++){
                        if(x >= range[i] && x < range[i + 1]){
                            return domain[i];
                        }else if(x < range[i] && x >= range[i + 1]){
                            return domain[i + 1];
                        }
                    }
                    return range[0] > range[range.length - 1] ? domain[0] : domain[domain.length - 1];
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    return BaseUtils.date2int(this.axisScale.invert(x));
                default:
                    return this.axisScale.invert(x);
            }
        },

        _getButtonTranslate:function(isVertical, pos){
            var translate = isVertical ? [0, pos] :[pos, 0];

            return 'translate(' + translate +')';
        },

        _zoomRefresh:function(direction){

            var l_trans = this.leftTopButton.pos, r_trans = this.rightBottomButton.pos + WIDTH;

            var rangeLeftTop = this._getValueByPosition(l_trans);
            var rangeRightBottom = this._getValueByPosition(r_trans);

            var vanchart = this.vanchart, axis = this.byAxis, dataDomain = axis._dataDomain, indexOfCate = BaseUtils.indexOf;
            var dataSheet = vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);

            var domain;
            if(axis.isCategory()){

                if(direction == DIRECTION_NONE){

                    domain = this._getValidDomain(rangeLeftTop, rangeRightBottom, dataDomain, true);

                }else{

                    var cateCount = indexOfCate(dataDomain, this.rangeLeftTop) - indexOfCate(dataDomain, this.rangeRightBottom);
                    cateCount = Math.abs(cateCount) + 1;//在平移过程中需要显示的分类个数

                    if(direction == DIRECTION_LEFT_TO_RIGHT && rangeRightBottom != this.rangeRightBottom){

                        if(axis.isAxisReversed() ^ axis.isHorizontal()){
                            var endIndex = indexOfCate(dataDomain, rangeRightBottom);
                            var startIndex = endIndex - cateCount + 1;

                            rangeLeftTop = dataDomain[startIndex];
                            rangeRightBottom = dataDomain[endIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }else{
                            var startIndex = indexOfCate(dataDomain, rangeRightBottom);
                            var endIndex = startIndex + cateCount - 1;

                            rangeLeftTop = dataDomain[endIndex];
                            rangeRightBottom = dataDomain[startIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }

                    }else if(direction == DIRECTION_RIGHT_TO_LEFT && rangeLeftTop != this.rangeLeftTop){

                        if(axis.isAxisReversed() ^ axis.isHorizontal()){

                            var startIndex = indexOfCate(dataDomain, rangeLeftTop);

                            var endIndex = startIndex + cateCount - 1;

                            rangeLeftTop = dataDomain[startIndex];
                            rangeRightBottom = dataDomain[endIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }else{
                            var endIndex = indexOfCate(dataDomain, rangeLeftTop);
                            var startIndex = endIndex - cateCount + 1;

                            rangeLeftTop = dataDomain[endIndex];
                            rangeRightBottom = dataDomain[startIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }

                    }else{

                        //平移的时候考虑移动的方向
                        rangeLeftTop = this.rangeLeftTop;
                        rangeRightBottom = this.rangeRightBottom;
                    }
                }

                //中间滑块移动的时候，调整以后可能不需要更新
                if(this.rangeLeftTop != rangeLeftTop || this.rangeRightBottom != rangeRightBottom){

                    this.rangeLeftTop =  rangeLeftTop;
                    this.rangeRightBottom = rangeRightBottom;

                    axis.zoomRefresh(domain);
                    axis.fixScaleAndTickData();
                    axis.render();

                    if(dataSheet){
                        dataSheet.zoomRefresh();
                    }

                    vanchart.reRenderSeries();
                }

            }else{

                domain = this._getValidDomain(rangeLeftTop, rangeRightBottom, dataDomain, false);

                this.rangeLeftTop = rangeLeftTop;

                this.rangeRightBottom = rangeRightBottom;

                axis.zoomRefresh(domain);
                axis.fixScaleAndTickData();
                axis.render();
                vanchart.reRenderSeries();
            }
        },

        _panEnd:function(){
            this.target = null;
            this.vanchart._zooming = false;
        },

        _resizeable:function(){
            return this.options && this.options.zoomTool && this.options.zoomTool.resize;
        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove": BaseUtils.throttle(this._panMove, 16, this),  //60帧应该很流畅了
                "panend":this._panEnd
            }
        },

        remove: function () {
            this.zoomBarGroup && this.zoomBarGroup.remove();
            this.zoomBarGroup = null;
        }
    });
    
    require('../ComponentLibrary').register(ComponentLibrary.ZOOM_COMPONENT, Zoom);
    return Zoom;

});
/**
 * Created by eason on 15/8/24.
 */

define('component/ToolbarIcon',['require','./Base','../utils/BaseUtils','../Constants','../dom/Evented'],function(require){

    //icon的几种背景颜色
    function OPEN_NORMAL(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    function OPEN_HOVER() {
        return {'fill':'black', 'fill-opacity':0.1};
    }

    function CLOSED_NORMAL(){
        return {'fill':'black', 'fill-opacity':0};
    }

    function CLOSED_HOVER(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    var RECT_R = 2;
    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var GAP = ICON_SIZE + ICON_GAP;

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Evented = require('../dom/Evented');

    var ToolbarIcon = Evented.extend({

        initialize:function(iconType, toolbar, pos, visible){
            this.iconType = iconType; this.toolbar = toolbar;
            this.visible = visible; this.pos = pos; this.currentPos = {x:pos.x, y:pos.y};
        },

        render:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            if(!this.iconG){
                this.iconG = renderer.group().style({'cursor':'pointer'}).addTo(toolbar.toolbarGroup);
            }

            vanchart.registerInteractiveTarget(this, this.iconG);

            this.iconG.attr('transform', 'translate('+ icon.pos.x +','+ icon.pos.y +')').style({'display':this.visible ? '' : 'none'});

            this.iconG.rect = this.iconG.rect || renderer.rect().attr('width', ICON_SIZE).attr('height', ICON_SIZE)
                .attr('rx', RECT_R).attr('ry', RECT_R)
                .addTo(this.iconG);

            this.iconG.rect.style(toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());

            this.iconG.path = this.iconG.path || this._getIconPathGraphic(vanchart, renderer, icon);
        },

        _getIconPathGraphic: function (vanchart, renderer, icon) {
            switch (this.iconType){
                case Constants.REFRESH_ICON:
                    return renderer.path().attr('d', icon.getRefreshIconPath()).style({'fill':'#FF9933'}).addTo(this.iconG);
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        return renderer.path().attr('d', icon.getDecreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getIncreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }
                case Constants.EXPORT_ICON:
                    return renderer.path().attr('d', icon.getExportIconPath()).style({'fill':'#6666CC'}).addTo(this.iconG);
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.fullScreenFather){
                        return renderer.path().attr('d', icon.getMinIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getMaxIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }
                case Constants.MENU_ICON:
                    return renderer.path().attr('d', icon.getMenuIconPath()).style({'stroke-width':2, 'stroke':'#AAAAAA'}).addTo(this.iconG);
            }
        },

        refreshMove:function(left, right){

            var pos = this.pos, currentPos = this.currentPos;
            var leftPos = currentPos.x - left, rightPos = leftPos + right;

            this.iconG.animate({
                ease:'circle-out',
                duration:220,
                attr:{transform:'translate('+ leftPos +','+ pos.y +')'}
            }).transition({
                ease:'circle-in',
                duration:220,
                attr:{transform:'translate('+ rightPos +','+ pos.y +')'}
            });

            this.currentPos.x = rightPos;
        },

        refreshMoveWithoutAnimation:function(left, right){

            var rightPos = this.currentPos.x - left + right;

            this.iconG.attr('transform', 'translate('+ rightPos +','+ this.pos.y +')');

            this.currentPos.x = rightPos;
        },

        showIcon:function(){

            this.visible = true;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':''});
            }

        },

        hideIcon:function(){

            this.visible = false;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':'none'});
                //每次刷新之后，刷新按钮隐藏并且回到初始位置
                this.iconG.attr('transform', 'translate('+ this.pos.x +','+ this.pos.y +')');
                this.currentPos.x = this.pos.x;
            }
        },

        _iconAnimation:function(moveIndex, delay){

            var iconG = this.iconG, pos = this.pos, visible = this.visible;

            if(BaseUtils.isSupportSVG()){
                setTimeout(function(){
                    iconG.style({'display':visible ? '' : 'none'});

                    var moveDet = 4 * moveIndex, leftX = pos.x - moveDet;

                    iconG.animate([{
                        ease:'circle-out',
                        duration:100,
                        attr:{'transform':'translate('+ leftX +','+ pos.y +')'}
                    },{
                        ease:'circle-in',
                        duration:100,
                        attr:{'transform':'translate('+ pos.x +','+ pos.y +')'}
                    }]);

                    iconG.rect.style(visible ? CLOSED_NORMAL() : OPEN_NORMAL()).animate({
                        ease:'linear', duration:200, style:visible ? OPEN_NORMAL() : CLOSED_NORMAL()
                    });

                }, delay);

            }else{
                iconG.attr('transform', 'translate('+ pos.x +','+ pos.y +')').style({'display':visible ? '' : 'none'});

                iconG.rect.style(visible ? OPEN_NORMAL() : CLOSED_NORMAL())
            }
            this.currentPos.x = this.pos.x;
        },

        onMouseOver:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_HOVER() : OPEN_HOVER());

            var toolbar = this.toolbar, options = toolbar.options, vanchart = toolbar.vanchart;
            var tipMsg = '', icon = this;

            if(toolbar.needTooltip()){
                var content = options.tooltip.content;
                switch (icon.iconType) {
                    case Constants.REFRESH_ICON :
                        tipMsg = content['refresh'];
                        break;
                    case Constants.SORT :
                        tipMsg = content['sort'];
                        break;
                    case Constants.EXPORT_ICON:
                        tipMsg = content['toImage'];
                        break;
                    case Constants.FULL_SCREEN_ICON:
                        tipMsg = vanchart.vancharts.fullScreenFather ? content['fullScreenClose'] : content['fullScreenOpen'];
                        break;
                    case Constants.MENU_ICON:
                        tipMsg = toolbar.hidden ? content['menuOpen'] : content['menuClose'];
                        break;
                }
                // 有内容时才呈现
                tipMsg && vanchart.showToolbarTooltip(icon, tipMsg);
            }
        },

        onMouseOut:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());
            this.toolbar.vanchart.hideTooltip();  // 地图上面只能通过toolbar的mouseout移除
        },

        onTap:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            var dom = vanchart.getDivParentDom();
            vanchart.hideTooltip();  
            switch (icon.iconType){
                case Constants.REFRESH_ICON:
                    vanchart.clearAllEffects();
                    vanchart.refreshRestore();
                    icon.hideIcon();
                    break;
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        vanchart.orderType = Constants.DESCENDING;
                        icon.iconG.path.attr({'d':icon.getIncreaseIconPath()});
                    }else{
                        vanchart.orderType = Constants.ASCENDING;
                        icon.iconG.path.attr({'d':icon.getDecreaseIconPath()});
                    }
                    toolbar.refreshEnabled() && toolbar.refreshIcon.showIcon();
                    vanchart.orderData();
                    // vanchart.orderType = Constants.DISORDER;  todo 这样就只能点一次排序了
                    break;
                case Constants.EXPORT_ICON:
                    var exportIcon = this.toolbar.options.toImage;
                    exportIcon &&
                    exportIcon.imageUrl &&
                    BaseUtils.toPng(exportIcon.imageUrl);
                    break;
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.fullScreenFather){
                        vanchart.vancharts.hideLightBox(dom, vanchart.vancharts.fullScreenFather);
                    }else{
                        vanchart.vancharts.showLightBox(vanchart)
                    }
                    break;
                case Constants.MENU_ICON:
                    toolbar.showOrHide();
                    break;
            }
        },

        getEvents:function(){
            return {
                mouseover:this.onMouseOver,
                mouseout:this.onMouseOut,
                tap:this.onTap
            }
        },

        getMaxIconPath:function(){
            return 'M24,8v6.5L21.5,12l-3,3L17,13.5l3-3L17.5,8H24z M15,18.5l-3,3l2.5,2.5H8v-6.5l2.5,2.5l3-3L15,18.5z';
        },

        getMinIconPath:function(){
            return 'M15,17v6.5L12.5,21l-3,3L8,22.5l3-3L8.5,17H15z M24,9.5l-3,3l2.5,2.5H17V8.5l2.5,2.5l3-3L24,9.5z';
        },

        getIncreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,16h2v3h-2V16z M13,14h2v5h-2V14z M16,12h2v7h-2V12z M19,9h2v10h-2V9z';
        },

        getDecreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,9h2v10h-2V9z M13,12h2v7h-2V12z M16,15h2v4h-2V15z M19,16h2v3h-2V16z';
        },

        getExportIconPath:function(){
            return 'M22,8H8v16h16V10L22,8z M16,10h2v4h-2V10z M22,22H10V10h1v5h9v-5h1.171L22,10.829V22z';
        },

        getRefreshIconPath:function(){
            return 'M21.656,10.344C20.209,8.896,18.209,8,16,8c-3.43,0-6.354,2.158-7.492,5.19l1.873,0.703C11.234,11.619,13.428,10,16,10c1.657,0,3.156,0.672,4.243,1.757L18,14h6V8L21.656,10.344z M16,22c-1.657,0-3.156-0.671-4.243-1.757L14,18H8v6l2.344-2.344C11.791,23.104,13.791,24,16,24c3.43,0,6.354-2.158,7.492-5.19l-1.873-0.703C20.766,20.381,18.572,22,16,22z';
        },

        getMenuIconPath:function(){
            return 'M8,10L24,10 M8,15L24,15 M8,20L24,20';
        }

    });

    return ToolbarIcon;
});
/**
 * Created by eason on 15/7/27.
 * 工具栏组建
 */
define('component/ToolBar',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../Constants','./ToolbarIcon','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var ToolbarIcon = require('./ToolbarIcon');
    var ComponentLibrary = require('../ComponentLibrary');

    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var DEFAULT_GAP = 5;

    var NONSUPPORT_SORT = [Constants.GANTT_CHART, Constants.TREEMAP_CHART
        , Constants.WORD_CLOUD_CHART, Constants.FUNNEL_CHART, Constants.STRUCTURE_CHART
        , Constants.SCATTER_CHART, Constants.BUBBLE_CHART, Constants.FORCE_BUBBLE_CHART
        , Constants.AREA_MAP, Constants.POINT_MAP, Constants.LINE_MAP, Constants.HEAT_MAP
    ];

    var Toolbar = Base.extend({

        doLayout:function(){
            var options = this.options, hidden = options.hidden;

            // 在这里合并一下toolbar-tooltip-option
            options.tooltip = options.tooltip || {};
            QueryUtils.merge(options.tooltip, this.getDefaultToolbarTooltipOption());

            var keys = this.sortEnable() ? ['sort', 'toImage', 'fullScreen'] : ['toImage', 'fullScreen'];
            var icons = [Constants.REFRESH_ICON];
            keys.forEach(function(key){
                if(options[key] && options[key].enabled){
                    icons.push(key);
                }
            });

            hidden && icons.push(Constants.MENU_ICON);

            var GAP = ICON_SIZE + ICON_GAP;
            var size = icons.length * GAP + DEFAULT_GAP;

            //resize的时候translate下
            this.startX = this.vanchart.width - size;

            if(this.toolbarGroup){
                return;
            }

            this.toolbarIcons = []; this.hidden = hidden;

            for(var iconIndex = 0, len = icons.length; iconIndex < len; iconIndex++){
                var pos = {x:iconIndex * GAP, y:DEFAULT_GAP};
                var type = icons[iconIndex];
                var visible = !hidden;
                if(type == Constants.MENU_ICON){
                    this.menuIcon = new ToolbarIcon(type, this, pos, true);
                }else if(type == Constants.REFRESH_ICON){
                    this.refreshIcon = new ToolbarIcon(type, this, pos, false);
                }else{
                    this.toolbarIcons.push(new ToolbarIcon(type, this, pos, visible));
                }
            }

            this.isFloat = true;
        },

        sortEnable: function () {
            var sort = true;
            var options = this.vanchart.options, seriesData = options.series;
            var chartType;

            if(options.chartType){
                chartType = options.chartType;
            }

            seriesData && seriesData.forEach(function (sery) {
                if(sery.type) {
                    if (chartType && chartType != sery.type) {
                        sort = false;//组合图
                        return;
                    }
                    chartType = sery.type;
                }
            });

            return sort && NONSUPPORT_SORT.indexOf(chartType) == -1;
        },

        render:function(){
            var renderer = this.vanchart.renderer;

            if(this.toolbarGroup){
                this.toolbarGroup.attr('transform', BaseUtils.makeTranslate([this.startX, 0]));
                return;//工具栏只刷新一次
            }else{
                this.toolbarGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate([this.startX, 0]));
            }
            this.toolbarIcons.forEach(function(icon){
                icon.render();
            });

            this.menuIcon && this.menuIcon.render();
            this.refreshIcon && this.refreshIcon.render();
        },

        showOrHide:function(){
            this.hidden ? this.show() : this.hide();
            this.hidden = !this.hidden;
        },

        hide:function(){

            var toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length, delay = [];

            for(var i = 0; i < iconSize; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].hideIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }

        },

        show:function(){
            var delay = [0], toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize - 1; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].showIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);
            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }
        },

        showRefreshIconWhenZoom:function(){
            if(!this.refreshIcon.visible && this.refreshEnabled()){
                if(this.menuIcon){
                    if(this.hidden){
                        var iconSize = this.toolbarIcons.length;
                        var left = 4 * (iconSize + 1) ;
                        var right = 4 * (iconSize + 1) + 33 * iconSize;
                        this.refreshIcon.refreshMoveWithoutAnimation(left, right);
                        this.refreshIcon.showIcon();
                    }else{
                        this.refreshIcon.showIcon();
                    }
                }else{
                    this.refreshIcon.showIcon();
                }
            }
        },

        refreshEnabled:function(){
            return !(this.options.refresh && this.options.refresh.enabled === false);
        },

        getToolBarInitWidth: function () {
            if (!this.options.enabled) {
                return 0;
            }
            if (this.options.hidden) {
                return ICON_SIZE + DEFAULT_GAP;
            } else {
                return this.toolbarIcons.length * (ICON_SIZE + ICON_GAP) - ICON_GAP + DEFAULT_GAP;
            }
        },

        remove:function(){
            this.toolbarGroup && this.toolbarGroup.remove();
            this.toolbarGroup = null;
        },

        /**
         * 默认的toolbar-tooltip-option，用于和给出的options合并，保证能够正常显示工具栏提示
         * @return {Object} [description]
         */
        getDefaultToolbarTooltipOption:function () {
            // 默认是开启工具栏提示的，但是提示内容为空，由后台传入对应的提示文字
            return {
                "enabled": true,
                "content":{
                    "menuOpen": "",
                    "menuClose": "",
                    "sort": "",
                    "toImage": "",
                    "refresh": "",
                    "fullScreenOpen": "",
                    "fullScreenClose": ""
                },
                "style":{
                    "fontSize": "12pt",
                    "fontFamily": "Microsoft Yahei",
                    "color": "rgb(255,255,255)"
                },
                "borderRadius": 2,
                "borderWidth" : 0,
                "backgroundColor": "rgba(0,0,0,.3)",
                "padding": 5,
                "animation": true
            }
        },

        /**
         * 获取当前显示的toolbar的尺寸
         * @return {Object} 
         */
        getToolbarBounds: function () {
            var boundsWidth = this.menuIcon ? ICON_SIZE : 0,
                totalWidth = boundsWidth,
                otherIcons = [this.refreshIcon].concat(this.toolbarIcons);
            otherIcons.forEach(function(icon){
               if(icon.visible){
                   boundsWidth += ICON_SIZE + ICON_GAP;
               }
               totalWidth += ICON_SIZE + ICON_GAP;
            });


            var boundsX = this.startX + totalWidth - boundsWidth;
            return {
                x : boundsX,
                y : DEFAULT_GAP,
                width : boundsWidth,
                height : ICON_SIZE
            }
        },
        /**
         * 根据icon和提示框尺寸，计算提示框位置的top和left
         * @param  {Object} icon   工具提示对应的Icon
         * @param  {Object} divDim 工具提示框的尺寸
         * @return {Array}         计算后的提示框的left和top值
         */
        calcToolbarTipPos: function (icon, divDim) {
            var toolbarBounds = this.getToolbarBounds();
            var boundsEndX = toolbarBounds.x + toolbarBounds.width;
            var iconStartX = icon.currentPos.x + this.startX;

            var startY = toolbarBounds.y + toolbarBounds.height + ICON_GAP * 2;
            var startX = iconStartX + divDim.width > boundsEndX ? (iconStartX + ICON_SIZE - divDim.width)  : iconStartX;
            
            return [startX, startY];
        },

        needTooltip: function(){
            var options = this.options;
            return options && options.tooltip && options.tooltip.enabled;
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.TOOLBAR_COMPONENT, Toolbar);
    return Toolbar;
});
/**
 * Created by Mitisky on 16/3/21.
 */
define ('component/RangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var RangeLegend = Base.extend({

        doLayout: function () {

            if(this.invisible()){
                this.remove();
                return ;
            }

            var cfg = this.options;
            var position = cfg.position || Constants.RIGHT;
            var gap = PADDING_FUN() * (this.isFloat ? 2 : 4);//*4: 两边*内外边距

            if(position == Constants.TOP || position == Constants.BOTTOM){
                this._layoutHorizontal(position, gap);
            } else {
                this._layoutVertical(position, gap);
            }

            if(!this.isFloat) {
                var outGap = this.options.borderWidth + PADDING_FUN() * 2;
                this.bounds.x += outGap/2;
                this.bounds.y += outGap/2;
                this.bounds.width -= outGap;
                this.bounds.height -= outGap;

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled() && zoomComponent.bounds) {
                        this.bounds.y += zoomComponent.bounds.height || 0;
                    }
                }

                if(position == Constants.RIGHT_TOP){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    if(tools){
                        this.bounds.y = Math.max(37, this.bounds.y);
                    }
                }
            }
        },

        _layoutHorizontal: function (position, gap) {
            var dim = this.calculateHorizontalDim();

            var usedSize = dim.height + gap;

            usedSize = this.options.maxHeight ? Math.min(usedSize, this._maxHeight()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var width = dim.width + gap;
            if (!this.isFloat) {
                this.bounds.x += Math.max((this.bounds.width - width)/2, 0);
            }
            this.bounds.width = width;
        },

        _layoutVertical: function (position, gap) {
            var dim = this.calculateVerticalDim();

            var usedSize = dim.width + gap;

            usedSize = this.options.maxWidth ? Math.min(usedSize, this._maxWidth()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var height = dim.height + gap;
            if (!this.isFloat && (position == Constants.RIGHT || position == Constants.LEFT)) {
                this.bounds.y += Math.max((this.bounds.height - height)/2, 0);
            } else if(!this.isFloat && position == Constants.RIGHT_BOTTOM){
                this.bounds.y = Math.round(this.bounds.y + this.bounds.height - height);
            }
            this.bounds.height = height;
        },

        render:function(){
            if(this.invisible()){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.group){
                this.backgroundGroup = renderer.group().addTo(this.getComponentParentGroup());

                this.group = renderer.vgroup().add(this.getComponentParentGroup());

                this.legendGroup = this.group.append(renderer.vgroup());
            }

            var targetG;
            if (this.useHtmlLabel()) {
                targetG = this.legendGroup.divG.attr({
                                'pointer-events': 'auto'
                            })
            } else {
                targetG = this.legendGroup.renderG;
            }
            vanchart.registerInteractiveTarget(this, targetG);

            this._innerClip(this.group);
            this.group.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, bounds);

            this.renderBody(this.legendGroup, bounds);
        },

        getEvents:function(){
            return {
                'mouseout':this.mouseOut
            }
        },

        mouseOut:function(){
            if(this.highlighted){
                this.vanchart.cancelLegendHighlight();
            }
        },

        remove: function () {
            this.group && this.group.remove();
            this.backgroundGroup && this.backgroundGroup.remove();
            this.group = this._barBackground = this._bar = this._minButton = this._maxButton = this._minLabel = this._maxLabel = this.backgroundGroup = null;
            // 这里的items不能置为NULL，计算max和min的时候会用到
            // remove的时候，应该只把item上的graphic移除即可
            this.items && this.items.forEach(function (item){
                item.graphic = null;
            });
        }
    });

    return RangeLegend;
});

/**
 * Created by Mitisky on 16/8/10.
 */

define('component/IntervalRangeLegend',['require','../utils/BaseUtils','../Constants','../utils/ColorUtils','../dom/EventObject','./RangeLegend','../ComponentLibrary'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var EventObject = require('../dom/EventObject');
    var RangeLegend = require('./RangeLegend');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var WIDTH = 15;
    
    var BAR_TEXT_GAP = 4;
    var BAR_TEXT_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(BAR_TEXT_GAP);
    };
    
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;
    var ITEM_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(ITEM_GAP);
    };

    var IntervalRangeLegend = RangeLegend.extend({

        type:ComponentLibrary.INTERVAL_RANGE_LEGEND,

        initAttributesWithSeries: function () {
            var options = this.options, range = options.range || {};

            if(!BaseUtils.isArray(range)){//自动计算
                var splitNumber = range.splitNumber || 5;
                var color = range.color || this.vanchart.options.colors[0];
                var colors = this.vanchart.isHeatMap() ? ['rgb(0,0,255)','rgb(0,255,0)','rgb(255,255,0)','rgb(255,0,0)'] : ColorUtils.createColorsWithHsb(color, splitNumber);
                var minMax = this.vanchart.getChartMinMaxValue();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], splitNumber);
                var minValue = para[0];
                var gap = para[2];

                range = [];
                if(this.vanchart.isHeatMap()){
                    var sepPara = [0, 0.25, 0.55, 0.85, 1], valueRange = BaseUtils.accMul(gap, splitNumber);
                    for(var i = 1; i < 5; i++){
                        range.push({
                            from:BaseUtils.accAdd(minValue, BaseUtils.accMul(valueRange, sepPara[i - 1])),
                            to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(valueRange, sepPara[i])),
                            color:colors[i - 1]
                        });
                    }
                }else{
                    for(var i = 0; i < splitNumber; i++) {
                        range.push({
                            from:BaseUtils.accAdd(minValue, BaseUtils.accMul(gap, (splitNumber - i - 1))),
                            to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(gap, (splitNumber - i))),
                            color:colors[i]
                        });
                    }
                }
            }

            this.items = this.items || [];
            var realLen = range.length;
            var oldLen = this.items.length;

            for(var removeIndex = realLen; removeIndex < oldLen; removeIndex++){
                this.items[removeIndex].graphic && this.items[removeIndex].graphic.remove();
                this.items[removeIndex] = null;
            }

            var formatter = options.formatter;
            for(var index = 0; index < realLen; index++){
                var item = this.items[index] || new EventObject(this.getItemEvents());
                this.items[index] = item;

                var band = range[index];
                item.from = band.from;
                item.to = band.to;
                item.color = band.color;
                item.label = this._getIntervalLabelContent(band.from, band.to, formatter);
                item.visible = true;
                item.hiddenColor = options.hiddenColor;
                item.hoverColor = options.hoverColor;
                item.points = [];

                item.legend = this;
            }

            this.items.length = realLen;

            var self = this,series = this.vanchart.series;
            this.items.sort(function (itemA, itemB) {
                var itemAMin = Math.min(itemA.from, itemA.to);
                var itemBMin = Math.min(itemB.from, itemB.to);
                return self.isHorizontal() ? itemAMin - itemBMin : itemBMin - itemAMin;
            });

            for (var i = 0, len = series.length; i < len; i++) {
                var sery = series[i], valueKey = sery.getTargetKey();
                var pointS = sery.points;
                pointS.forEach(function (point) {

                    var size = point[valueKey];

                    var item = self._getPointItem(size);
                    if (item) {
                        item.points.push(point);

                        //缓存一下数据点属于的那个item
                        point._rangeItem = item;
                    }
                })
            }
        },

        _getMin:function(){

            var index = this.isHorizontal() ? 0 : this.items.length - 1;

            return this.items[index].from;
        },

        _getMax:function(){

            var index = this.isHorizontal() ? this.items.length - 1 : 0;

            return this.items[index].to;
        },

        _getGradient:function(){
            var config = {'0':'white'};
            var min = this._getMin(), max = this._getMax(), det = max - min;

            for(var i = this.items.length - 1; i >= 0; i--){
                var item = this.items[i];
                config[(item.to - min)/det] = item.color;
            }

            return config;
        },

        _getIntervalLabelContent:function(from, to, formatter){
            if(!formatter){
                return from + '-' + to;
            }

            return BaseUtils.format({'from':from,'to':to}, formatter);
        },

        _getPointItem:function(size){
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                var min = Math.min(item.from, item.to);
                var max = Math.max(item.from, item.to);

                if(size >= min && size <= max){
                    return item;
                }
            }
        },

        calculateHorizontalDim: function () {
            var len = this.items.length;
            var width = 0, height = 0;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.options.style, this.options.useHtml);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.options.style, this.options.useHtml);
                var gap = Math.max(0, d1.width - ITEM_WIDTH, d2.width - ITEM_WIDTH);
                width = len * ITEM_WIDTH + (len - 1) * ITEM_GAP_FUN() + gap;
                height = WIDTH + BAR_TEXT_GAP_FUN() * 2 + d1.height * 2
            }
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var len = this.items.length;
            var width = 0, gap = 0;
            var style = this.options.style, legend = this;
            this.items.forEach(function (item) {
                var labelDim = BaseUtils.getTextDimension(item.label, style, legend.options.useHtml);
                width = Math.max(width, labelDim.width);
                gap = Math.max(0, labelDim.height - ITEM_WIDTH)
            });
            return {
                width:width + WIDTH + BAR_TEXT_GAP_FUN(),
                height:len * ITEM_WIDTH + (len - 1) * ITEM_GAP_FUN() + gap
            }
        },

        getColorWithSize: function (size) {
            var item = this._getPointItem(size);
            return item && item.color;
        },

        renderBody: function (itemsGroup, bounds) {

            this.isHorizontal() ? this._renderHorizontalInterval(itemsGroup, bounds)
                : this._renderVerticalInterval(itemsGroup, bounds);
        },

        _renderHorizontalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items;

            var transX = (bounds.width - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP_FUN())/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([transX, PADDING_FUN()]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + PADDING_FUN();

            var labelStyle = this.options.style;
            var vanchart = this.vanchart, renderer = vanchart.renderer;

            var useHtml = this.useHtmlLabel();

            var startX = 0;
            var self = this;
            itemS.forEach(function (item, i) {

                item.graphic = item.graphic || itemsGroup.append(renderer.vgroup().style({'cursor': 'pointer'}));
                var g = item.graphic;
                vanchart.registerInteractiveTarget(item, useHtml ? g.divG : g.renderG);

                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle, self.options.useHtml);
                var height = labelDim.height;
                var iconY = height + BAR_TEXT_GAP_FUN();
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP_FUN();

                g.rect = g.rect || g.append(renderer.rect());
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', startX).attr('y', iconY)
                    .attr('width', ITEM_WIDTH).attr('height', WIDTH);

                var innerX = startX + ITEM_WIDTH/ 2 - labelDim.width / 2,
                    innerY = i%2 === 0 ? 0 : bottomY;

                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startX += (ITEM_WIDTH + ITEM_GAP_FUN());
            });
        },

        _renderVerticalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items, vanchart = this.vanchart;

            var transY = (bounds.height - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP_FUN())/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([PADDING_FUN(), transY]));

            this._absX = bounds.x + PADDING_FUN();
            this._absY = bounds.y + transY;

            var labelStyle = this.options.style;
            var renderer = this.vanchart.renderer;

            var useHtml = this.useHtmlLabel();

            var startY = 0;
            var self = this;
            itemS.forEach(function(item, i){

                item.graphic = item.graphic || itemsGroup.append(renderer.vgroup().style({'cursor': 'pointer'}));
                var g = item.graphic;
                vanchart.registerInteractiveTarget(item, useHtml ? g.divG : g.renderG);

                var labelDim = BaseUtils.getTextDimension(item.label, labelStyle, useHtml);

                g.rect = g.rect || g.append(renderer.rect());
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', 0).attr('y', startY)
                    .attr('width', WIDTH).attr('height', ITEM_WIDTH);

                var innerX = Math.round(WIDTH + BAR_TEXT_GAP_FUN()),
                    innerY = Math.round(startY + ITEM_WIDTH / 2 - labelDim.height / 2);
                
                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startY += (ITEM_WIDTH + ITEM_GAP_FUN());
            });
        },

        _renderItemLabel: function (item, g, innerX, innerY, labelDim, i) {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, options = legend.options;
            var labelContent = item.label, labelStyle = options.style, useHtml = this.useHtmlLabel();
            var textColor = item.visible ? labelStyle.color : item.hiddenColor;

            labelStyle = BaseUtils.extend({}, labelStyle);
            labelStyle.color = textColor;

            g.text = g.text || g.append(renderer.vtext(useHtml));
            g.text.textContent(labelContent)
                .attr('dy', '.88em')
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}))
                .style(labelStyle);
        },

        _getItemIconStyle: function (item) {
            return {
                'fill':item.visible ? item.color : item.hiddenColor,
                'fill-opacity':1,
                'stroke':'none'
            }
        },

        getItemEvents:function(){
            return {
                'mouseover':this.onItemMouseOver,
                'mousemove':this.onItemMouseMove,
                'mouseout':this.onItemMouseOut,

                'tap':this.onItemTap
            }
        },

        onItemMouseOver: function (e) {
            var item = this, legend = item.legend;
            var text = item.graphic && item.graphic.text;

            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(item.hoverColor));
            }else{
                text.style({'fill': item.hoverColor});
            }

            if(this.legend.options.highlight){
                this.legend.highlighted = true;
                this.legend.vanchart.makeLegendHighlight(item);
            }
        },

        onItemMouseMove: function (e) {

        },

        onItemMouseOut: function (e) {
            var item = this, legend = item.legend, options = legend.options;
            var text = item.graphic && item.graphic.text;

            var labelColor = options.style.color;
            var textColor = item.visible ? labelColor : item.hiddenColor;

            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(textColor));
            }else{
                text.style({'fill':textColor});
            }
        },

        onItemTap: function (e) {
            var item = this, legend = item.legend, options = legend.options, vanchart = legend.vanchart;
            var text = item.graphic && item.graphic.text;
            var rect = item.graphic && item.graphic.rect;

            item.visible = !item.visible;
            var labelColor = options.style.color;
            var iconColor = item.visible ? item.color : item.hiddenColor;
            var textColor = item.visible ? labelColor : item.hiddenColor;
            rect.style({'fill':iconColor});
            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(textColor));
            }else{
                text.style({'fill':textColor});
            }

            if(item.points && item.points.length > 0) {

                var hasMap = vanchart.vanChartType == 'vanChartMap';

                item.points.forEach(function (point) {
                    var isLineMap = point.series.type === Constants.LINE_MAP;
                    if (!hasMap || (hasMap && point.points && point.points[0] == point)
                       || isLineMap) {
                        point.visible = item.visible;
                        if (hasMap && !isLineMap) {
                            var points = point.points;
                            for (var i = 1, len = points.length; i < len; i++) {
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });

                vanchart.filterRender();
            }
        }

    });


    ComponentLibrary.register(ComponentLibrary.INTERVAL_RANGE_LEGEND, IntervalRangeLegend);

    return IntervalRangeLegend;

});


/**
 * Created by Mitisky on 16/8/10.
 */
define('component/GradientRangeLegend',['require','../utils/BaseUtils','../Constants','../utils/ColorUtils','./RangeLegend','../ComponentLibrary','../utils/Scale','../utils/Interpolator'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var RangeLegend = require('./RangeLegend');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var Interpolator = require('../utils/Interpolator');

    var MAX_INTERVAL_IN_LARGE = 10;
    var LARGE_RANGE = Array.apply(null, new Array(MAX_INTERVAL_IN_LARGE))
                    .map(function(d, i) {return i * 1 / MAX_INTERVAL_IN_LARGE});

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    
    var BAR_TEXT_GAP = 4;
    var BAR_TEXT_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(BAR_TEXT_GAP);
    };

    var TOP_BAR_PATH = 'M7.236,10H13c1.105,0,2-0.895,2-2V2c0-1.105-0.895-2-2-2L2.618,0C1.875,0,1.391,0.782,1.724,1.447l3.724,7.447C5.786,9.572,6.479,10,7.236,10z';
    var BOTTOM_BAR_PATH = 'M7.236,0L13,0c1.105,0,2,0.895,2,2v6c0,1.105-0.895,2-2,2H2.618c-0.743,0-1.227-0.782-0.894-1.447l3.724-7.447C5.786,0.428,6.479,0,7.236,0z';
    var LEFT_BAR_PATH = 'M0,7.236V13c0,1.105,0.895,2,2,2h6c1.105,0,2-0.895,2-2V2.618c0-0.743-0.782-1.227-1.447-0.894L1.106,5.447C0.428,5.786,0,6.479,0,7.236z';
    var RIGHT_BAR_PATH = 'M10,7.236V13c0,1.105-0.895,2-2,2H2c-1.105,0-2-0.895-2-2L0,2.618c0-0.743,0.782-1.227,1.447-0.894l7.447,3.724C9.572,5.786,10,6.479,10,7.236z';

    var GradientRangeLegend = RangeLegend.extend({

        type:ComponentLibrary.GradientRangeLegend,

        initAttributesWithSeries: function () {
            var options = this.options, range = options.range || {};
            this.valueAndColors = range.color || this._getDefaultValueAndColors();

            var minValue = range.min, maxValue = range.max;

            if(BaseUtils.hasNotDefined(minValue) && BaseUtils.hasNotDefined(maxValue)){//自动计算
                var minMax = this.vanchart.getChartMinMaxValue();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], Math.max(2, this.valueAndColors.length - 1));
                minValue = para[0];
                maxValue = para[1];
            }

            this.min = BaseUtils.pick(range.min, minValue);
            this.max = BaseUtils.pick(range.max, maxValue);

            this.minPos = 0;//左、下
            this.maxPos = HEIGHT;//右、上

            this.valueAndColors.sort(function(d1, d2){
                return d1[0] - d2[0];
            });
            var valueArray = [];
            var colorArray = [];
            for(var i = 0, len = this.valueAndColors.length; i < len; i ++ ){
                valueArray[i] = this.valueAndColors[i][0];
                colorArray[i] = this.valueAndColors[i][1];
            }

            var largeValueScale = Scale.quantize()
                .domain([this.min, this.max])
                .range(LARGE_RANGE);

            this.largeValueScale = function (datum){
                return this.min === this.max ? 0 : largeValueScale(datum);  // 最大最小一样的时候，直接返回0，不计算了，没有意义
            };

            this.valueScale = Scale.linear()
                .domain([this.min, this.max])
                .range([0, 1]);

            this.colorScale = Scale.linear()
                .domain(valueArray)
                .range(colorArray)
                .interpolate(Interpolator.interpolate)
                .interpolate(Interpolator.interpolate);
        },

        _getMin:function(){
            return this.min;
        },

        _getMax:function(){
            return this.max;
        },

        _getGradient:function(){
            var config = {};
            this.valueAndColors.forEach(function(v_c){
                config[v_c[0]] = v_c[1];
            });
            return config;
        },

        _getDefaultValueAndColors: function () {
            var colors = ColorUtils.createColorsWithHsb(this.vanchart.options.colors[0], 3);
            return [[0, colors[2]], [0.5, colors[1]], [1, colors[0]]];
        },

        calculateHorizontalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style, this.options.useHtml);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style, this.options.useHtml);
            var gap = Math.max(d1.width, d2.width, BAR_HEIGHT);
            var width = HEIGHT + gap * 2;
            var height = WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN() + d1.height;
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style, this.options.useHtml);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style, this.options.useHtml);
            var width = WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN() + Math.max(d1.width, d2.width);
            var gap = Math.max(d1.height/2, BAR_HEIGHT/2) * 2;
            var height = HEIGHT + gap * 2;
            return {
                width:width,
                height:height
            }
        },

        getColorWithSize: function (size, large) {
            if (size >= this.min && size <= this.max) {
                return this.colorScale(this[large ? 'largeValueScale' : 'valueScale'](size));
            } else {
                return null;
            }
        },

        _getGradientMinLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.min);
        },

        _getGradientMaxLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.max);
        },

        _getGradientLabelWithFormatter: function (value) {
            var formatter = this.options.formatter;
            if(!formatter){
                return value;
            }

            return BaseUtils.format(value, formatter);
        },

        _getGradientLabelContent: function (value) {
            return this._getGradientLabelWithFormatter(this._gradientScale(value));
        },

        _gradientScale: function (value) {
            var unit = BaseUtils.accDiv(BaseUtils.accAdd(this.max, -this.min), HEIGHT);
            value = BaseUtils.accMul(unit, this.isHorizontal() ? value : (HEIGHT - value));
            value = BaseUtils.accAdd(value, this.min);
            return value;
        },

        _getBarBackgroundStyle: function () {
            return {
                'fill':'#eaeaea',
                'stroke-width':0
            }
        },

        _getGradientFillColor:function(isHorizontal, renderer){

            var attrs = {
                'x1':'0%',
                'y1':isHorizontal ? '0%' : '100%',
                'x2':isHorizontal ? '100%' : '0%',
                'y2':'0%'
            };

            var stop = [];
            this.valueAndColors.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];

                stop.push({
                    'offset': value,
                    'stop-color':color
                })
            });

            if(this._bar.colorGradient){
                renderer.updateColorGradient(this._bar.colorGradient, attrs, stop);
            }else{
                this._bar.colorGradient = renderer.colorGradient(attrs, stop);
            }

            return "url(#" + BaseUtils.stamp(this._bar.colorGradient) +")";
        },

        _updateHorizontalGradientClipRect: function() {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':this.minPos,
                'y':0,
                'width':this.maxPos - this.minPos,
                'height':WIDTH
            };

            if(!this._bar.clipG){
                this._bar.clipG = renderer.createClip(attrs);
                renderer.clip(this._bar, this._bar.clipG);
            }else{
                renderer.updateClip(this._bar.clipG, attrs);
            }
        },

        _updateVerticalGradientClipRect: function () {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':0,
                'y':this.minPos,
                'width':WIDTH,
                'height':this.maxPos - this.minPos
            };

            if(!this._bar.clipG){
                this._bar.clipG = renderer.createClip(attrs);
                renderer.clip(this._bar, this._bar.clipG);
            }else{
                renderer.updateClip(this._bar.clipG, attrs);
            }
        },

        //vertical：下面的button对应：maxPos，minButton
        renderBody: function (barGroup, bounds) {

            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, plotBounds = vanchart.bounds;

            var isHorizontal = legend.isHorizontal();

            var transX = isHorizontal ? (bounds.width - HEIGHT)/2 : PADDING_FUN();
            var transY = isHorizontal ? PADDING_FUN() : (bounds.height - HEIGHT)/2;
            barGroup.attr('transform', BaseUtils.makeTranslate([transX, transY]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + transY;

            this._barBackground = this._barBackground || barGroup.append(renderer.rect());
            this._bar = this._bar || barGroup.append(renderer.rect());
            this._minButton = this._minButton || barGroup.append(renderer.path().style({'cursor': 'pointer'}));
            this._maxButton = this._maxButton || barGroup.append(renderer.path().style({'cursor': 'pointer'}));
            this._minLabel = this._minLabel || barGroup.append(renderer.vtext(this.useHtmlLabel()));
            this._maxLabel = this._maxLabel || barGroup.append(renderer.vtext(this.useHtmlLabel()));

            var rectAttr = {
                'rx': 2,
                'ry': 2,
                'x': 0,
                'y': 0,
                'width': isHorizontal ? HEIGHT : WIDTH,
                'height': isHorizontal ? WIDTH : HEIGHT
            };

            this._barBackground
                .style(this._getBarBackgroundStyle())
                .attr(rectAttr);

            this._bar
                .attr(rectAttr)
                .style({
                    'fill':this._getGradientFillColor(isHorizontal, renderer),
                    'stroke-width':0
                });

            //todo ie下特殊处理下filter
            if(!BaseUtils.isSupportSVG()){
                renderer._updateGradientFill(this._bar, this._bar.colorGradient);
            }

            this._minButton
                .attr('d', isHorizontal ? LEFT_BAR_PATH : TOP_BAR_PATH);

            this._maxButton
                .attr('d', isHorizontal ? RIGHT_BAR_PATH : BOTTOM_BAR_PATH);

            this._minLabel
                .attr('dy', '.85em')
                .style(this.options.style);

            this._maxLabel
                .attr('dy', '.85em')
                .style(this.options.style);

            this._updateMax();
            this._updateMin();
        },

        _updateMin: function () {
            this.isHorizontal() ? this._updateHorizontalMinBar()
                : this._updateVerticalMinBar();
        },

        _updateMax: function () {
            this.isHorizontal() ? this._updateHorizontalMaxBar()
                : this._updateVerticalMaxBar();
        },

        //下面的
        _updateVerticalMinBar: function() {

            this._minButton
                .attr('transform', 'translate('+ WIDTH  +','+ this.maxPos +')')
                .style({'fill':this.colorScale((HEIGHT - this.maxPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN()),
            innerY = Math.round(this.maxPos + BAR_HEIGHT / 2 - labelDim.height / 2);


            this._minLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateVerticalGradientClipRect();
        },

        //左边的
        _updateHorizontalMinBar: function() {
            var x = this.minPos - BAR_HEIGHT;

            this._minButton
                .attr('transform', 'translate('+ x  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.minPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(this.minPos - labelDim.width),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN());

            this._minLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateHorizontalGradientClipRect();
        },


        //上面的
        _updateVerticalMaxBar: function() {
            var y = this.minPos - BAR_HEIGHT;

            this._maxButton
                .attr('transform', 'translate('+ WIDTH  +','+ y +')')
                .style({'fill': this.colorScale((HEIGHT - this.minPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN()),
                innerY = Math.round(this.minPos - BAR_HEIGHT/2 - labelDim.height / 2);


            this._maxLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateVerticalGradientClipRect();
        },

        //右边的
        _updateHorizontalMaxBar: function() {
            this._maxButton
                .attr('transform', 'translate('+ this.maxPos  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.maxPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);

            var innerX = Math.round(this.maxPos),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN());

            this._maxLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateHorizontalGradientClipRect();
        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove":this._panMove,
                "panend":this._panEnd
            }
        },

        _panStart:function(ev){
            var position = this.options.position;

            this.currentX = ev.containerPoint.x;
            this.currentY = ev.containerPoint.y;
            this.eventTarget = position == Constants.TOP || position == Constants.BOTTOM ?
                this._findHorizontalTarget() : this._findVerticalTarget();
        },

        _findHorizontalTarget: function () {
            var gap = (this.maxPos - this.minPos)/5;
            if(this.currentX < this._absX + this.minPos + gap){
                return this._minButton;
            } else if(this.currentX > this._absX + this.maxPos - gap){
                return this._maxButton;
            }
        },

        _findVerticalTarget: function () {
            var gap = (this.maxPos - this.minPos)/5;
            if(this.currentY < this._absY + this.minPos + gap){
                return this._maxButton;
            } else if(this.currentY > this._absY + this.maxPos - gap){
                return this._minButton;
            }
        },

        _panMove: function (ev) {
            if(this.eventTarget == this._minButton){
                this._minButtonMove(this.currentX, this.currentY, ev.containerPoint.x, ev.containerPoint.y);

            } else if(this.eventTarget == this._maxButton){
                this._maxButtonMove(this.currentX, this.currentY, ev.containerPoint.x, ev.containerPoint.y);
            }
        },

        _minButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//left
                var temp = this.minPos;
                this.minPos += Math.round(currentX - oldX);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            } else {//bottom
                var temp = this.maxPos;
                this.maxPos += Math.round(currentY - oldY);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            }

            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMin();
                this.refreshPoints();
            }
        },

        _maxButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//right
                var temp = this.maxPos;
                this.maxPos += Math.round(currentX - oldX);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            } else {//top
                var temp = this.minPos;
                this.minPos += Math.round(currentY - oldY);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            }
            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMax();
                this.refreshPoints();
            }
        },

        _panEnd: function (ev) {
            this.eventTarget = null;
        },

        refreshPoints: function () {
            var minSize = this._gradientScale(this.minPos);
            var maxSize = this._gradientScale(this.maxPos);
            var vanChart = this.vanchart, series = vanChart.series;
            var change = false, hasMap = vanChart.vanChartType == 'vanChartMap';

            var points;
            for (var i = 0, len = series.length; i < len; i++) {
                var sery = series[i];

                sery.points.forEach(function (point) {

                    var isLineMap = point.series.type === Constants.LINE_MAP;

                    if (!hasMap || (hasMap && point.points && point.points[0] == point)
                        || isLineMap) {
                        var temp = point.visible;

                        var size = point.getTargetValue();

                        point.visible = (size >= minSize && size <= maxSize) || (size >= maxSize && size <= minSize);

                        change = change || temp != point.visible;

                        if (hasMap && !isLineMap) {
                            points = point.points;
                            for (var i = 1, len = points.length; i < len; i++) {
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });
            }

            if(change) {
                vanChart.filterRender();
            }
        }

    });

    ComponentLibrary.register(ComponentLibrary.GradientRangeLegend, GradientRangeLegend);

    return GradientRangeLegend;

});

define('component/Polar',['require','../Constants','../utils/BaseUtils','./Base','../ComponentLibrary'],function(require) {
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Base = require('./Base');
    var ComponentLibrary = require('../ComponentLibrary');

    var Polar = Base.extend({

        _refresh:function(){
            this.series = [];
        },

        _isBaseAxis:function(){
            return true;
        },

        doLayout: function () {
            var option = this.options;

            var radius = option.radius;
            var center = option.center;

            // keep origin radius (include null)
            // adjust radius by angleAxis later

            if (!center || center.length === 0) {
                var plotBounds = this.vanchart.bounds;
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            }

            this.setCenter(center);

            if(BaseUtils.hasDefined(radius)){
                this.setRadius(radius);
            }else{
                this.radius = null;
            }

            var plotOptions = this.vanchart.options.plotOptions;
            var shape = (plotOptions.radar && plotOptions.radar.shape) || plotOptions.shape;
            
            this.shape = shape || this.shape;
        },

        /**
         * set polar radius and update radiusAxis scale
         * @param {number|string} radius
         */
        setRadius: function (radius) {
            if (!radius) {
                return;
            }

            this.radius = this._getPercentValue(
                radius,
                Math.min(this.vanchart.width, this.vanchart.height) / 2
            );
        },

        /**
         * set polar center
         * @param {number[]|string[]} center
         */
        setCenter: function (center) {
            if (!center) {
                return;
            }

            this.center = [];

            this.center[0] = this._getPercentValue(center[0], this.vanchart.width);

            this.center[1] = this._getPercentValue(center[1], this.vanchart.height);
        },

        render: function () {
            var R = this.vanchart.renderer, radiusAxis = this.radiusAxis;
            var clipPath = {'d': radiusAxis._getRadiusGridPath(radiusAxis.scale.domain()[1])};
            if (!this.clip) {
                this.clip = R.createClip(clipPath, 'path');
            }else{
                R.updateClip(this.clip, clipPath);
            }

            this.radiusAxis.render();
            this.angleAxis.render();
        }
    });
    
    return Polar;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/AngleAxis',['require','./Base','./CategoryAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/PathGenerator'],function(require){
    var Base = require('./Base');
    var CategoryAxis = require('./CategoryAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    var PADDING_GAP = 8;
    
    var PADDING_GAP_FUN = function() {
        return BaseUtils.paddingConvertWithScale(PADDING_GAP);
    };

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var AngleAxis = CategoryAxis.extend({

        _refresh:function(options){
            this.series = [];

            this.piece = null;

            this.initScale();

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.angleAxis = this;
        },

        doLayout:function(){

            this.calculateDomainFromData();

            this.scale.domain(this._dataDomain).rangePoints([0, this._dataDomain.length - 1]);

            this.piece = (Math.PI * 2) / Math.max(this._dataDomain.length, 1);

            this._updateOriginTickData();

            this._updatePolarBounds();

            this._calculateTickData();
        },

        fixScaleAndTickData:function(){
            this.scale.domain(this._dataDomain).rangePoints([0, this._dataDomain.length - 1]);

            this._updateOriginTickData();

            this._calculateTickData();
        },

        _calculateTickData:function(){
            var radius = this.polar.radius, bounds;
            if (this.isBreakLabels) {
                bounds = this._getTestBoundsAndRadius().testBounds;
            }
            this.tickData.map(function (t) {
                this._getCateLabelBounds(radius, t, bounds);
            }, this);
        },

        _getTestBoundsAndRadius: function () {
            var plotBounds = this.vanchart.bounds;
            var center = this.polar.center;

            var tmpBounds = [
                // 0 top
                center[1] - plotBounds.y,
                // 1 right
                plotBounds.x + plotBounds.width - center[0],
                // 2 bottom
                plotBounds.y + plotBounds.height - center[1],
                // 3 left
                center[0] - plotBounds.x
            ];

            var radius = Math.min.apply(null, tmpBounds);
            radius -= PADDING_GAP_FUN();

            var testBounds = {
                x: - tmpBounds[3],
                y: - tmpBounds[0],
                width: plotBounds.width,
                height: plotBounds.height
            };

            return {
                testBounds: testBounds,
                radius: radius
            }
        },

        _updatePolarBounds: function () {

            if (this.polar.radius) {
                return;
            }

            // no radius setting, auto adjust
            var tmp = this._getTestBoundsAndRadius();
            var radius = tmp.radius;
            var testBounds = tmp.testBounds;

            if (this.options.showLabel) {
                if (!this._testRadius(radius, testBounds)) {
                    radius = this._findNiceRadius(testBounds);
                    this._testRadius(radius, testBounds);
                }
            }

            this.polar.setRadius(radius);
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByPolarCoordinate(pos);
        },

        _getIndexByPolarCoordinate: function (pos) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = pos[0]-center[0];
            var y = center[1]-pos[1];

            if ((x*x + y*y) > r*r) {
                return -1;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = 2 * Math.PI / categories.length;
                index = isReversed ? categories.length - 1 - arc / unitLength : arc / unitLength;
            } else {
                index = 0;
            }

            index = Math.round(index);

            index = index % categories.length;

            return index;
        },

        getAngleGridLineData: function () {

            var points = [];

            var angleAxis = this.polar.angleAxis;
            var categories = angleAxis.scale.domain();
            var self = this;

            categories.forEach(function(category){

                var radian = angleAxis.scale(category) * angleAxis.piece;

                var r = self.polar.radius;

                points.push(BaseUtils.getArcPoint(r, radian));

            });

            points = points.length ? points : [BaseUtils.getArcPoint(this.polar.radius, 0)];

            return points;
        },

        // clac the endPos of every gridLine.
        getCateAngleGridLineData : function (){   
            var points = this.getAngleGridLineData();   
            var category = this.polar.angleAxis.scale.domain();   
   
            return points.map(function (p, index) {   
                return {   
                    name : category[index],   
                    pos : p   
                }   
            })   
        },

        _testRadius:function(radius, testBounds){

            for(var i = 0, count = this.tickData.length; i < count; i++){

                var tick = this.tickData[i];
                var labelBounds = this._getCateLabelBounds(radius, tick);

                if(!BaseUtils.containsRect(testBounds, labelBounds)){
                    return false;
                }

            }
            return true;
        },

        _getCateLabelBounds:function(radius, cateTick, testBounds){

            var category = cateTick.tickValue;
            var dim = cateTick.tickRectDim;
            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var arcPoint = BaseUtils.getArcPoint(radius + PADDING_GAP_FUN(), index * this.piece);
            var pos;
            var cfg = this.options;

            var position = this._getPolarPosition(category);

            var originStyle = BaseUtils.extend({
                width: '',
                'white-space': '',
                'text-align': ''
            }, cfg.labelStyle);

            switch (position){

                case TOP:

                    pos = {
                        style: originStyle,
                        x:-dim.width/2,
                        y:-radius - dim.height * 0.65 - PADDING_GAP_FUN()
                    };

                    break;

                case RIGHT:

                    pos = {
                        style: originStyle,
                        x:arcPoint[0],
                        y:arcPoint[1] - dim.height/2
                    };

                    if (testBounds && this.isBreakLabels && (pos.x + dim.width) > (testBounds.x + testBounds.width)) {
                        var width = testBounds.x + testBounds.width - arcPoint[0];
                        var style = BaseUtils.extend({
                            width:width+'px',
                            'white-space': 'normal',
                            'text-align': 'left'
                        }, cfg.labelStyle);
                        dim = BaseUtils.getTextWrapDimension(cateTick.tickContent, style);
                        pos = {
                            style:style,
                            x:arcPoint[0],
                            y:arcPoint[1] - dim.height/2
                        };
                    }

                    break;

                case BOTTOM:

                    pos = {
                        style: originStyle,
                        x:-dim.width/2,
                        y:radius + PADDING_GAP_FUN()
                    };

                    break;

                case LEFT:

                    pos = {
                        style: originStyle,
                        x:arcPoint[0] - dim.width,
                        y:arcPoint[1] - dim.height/2
                    };

                    if (testBounds && this.isBreakLabels && pos.x < testBounds.x) {
                        var width = arcPoint[0] - testBounds.x;
                        var style = BaseUtils.extend({
                            width:width+'px',
                            'white-space': 'normal',
                            'text-align': 'right'
                        }, cfg.labelStyle);
                        dim = BaseUtils.getTextWrapDimension(cateTick.tickContent, style);
                        pos = {
                            style:style,
                            x:arcPoint[0] - dim.width,
                            y:arcPoint[1] - dim.height/2
                        };
                    }

                    break;
            }

            cateTick.tickPos = pos;
            return BaseUtils.makeBounds(pos, dim);
        },

        _getPolarPosition:function(category){

            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var midIndex = domain.length / 2;

            if(index === 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        _findNiceRadius:function(testBounds){

            var tmpBounds = [
                - testBounds.y,
                testBounds.width + testBounds.x,
                testBounds.height + testBounds.y,
                - testBounds.x
            ];

            var minBounds = Math.min.apply(null, tmpBounds);
            var minRadius = minBounds;

            var domain = this.scale.domain();
            var self = this;

            this.tickData.forEach(function(cateTick){
                if(cateTick.tickContent){

                    var category = cateTick.tickValue;
                    var tickDim = cateTick.tickDim;

                    var index = domain.indexOf(category);
                    var position = self._getPolarPosition(category);

                    var radius;
                    switch (position) {
                        case TOP:
                            radius = tmpBounds[0] - tickDim.height;
                            break;
                        case RIGHT:
                            radius = (tmpBounds[1] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        case BOTTOM:
                            radius = tmpBounds[2] - tickDim.height;
                            break;
                        case LEFT:
                            radius = (tmpBounds[3] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        default:
                    }

                    minRadius = Math.min(minRadius, radius);
                }
            });

            if (minRadius < minBounds * 2 / 3) {
                minRadius =  minBounds * 2 / 3;
                // this.breakLabels(this.tickData);
                if (!this.options.labelRotation && !this.options.useHtml) {
                    this.isBreakLabels = true; // break labels in render
                }
            }

            return minRadius - PADDING_GAP_FUN();
        },

        getPointsInCategory: function (containerPoint) {
            var center = this.polar.center;
            var r = this.polar.radius;

            var x = containerPoint.x - center[0];
            var y = center[1] - containerPoint.y;

            if ((x*x + y*y) > r*r) {
                return null;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var domain = this.scale.domain(), range = this.scale.rangeExtent();
            var tmpScale = Scale.quantize().domain(range).range(domain);
            var l = domain.length, index = Math.round(arc / ( 2 * Math.PI ) * l ) % l;
            var category = tmpScale(index);
            return this.vanchart.getValidPointsPara(category);
        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add(vanchart.backGroup);
            }

            // 没有数据时，不绘制任何轴线
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawAxisLine(this.axisGroup);

            this._drawGridLine(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawAxisLine:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this.polar.radiusAxis;

            var angleAxis = this;
            var lineWidth = angleAxis.options.lineWidth;
            var lineColor = angleAxis.options.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            if (!this.axisLine) {
                this.axisLine = axisGroup.append(R.path());
            }

            this.axisLine
                .attr({
                    d: radiusAxis._getRadiusGridPath(maxValue)
                })
                .style({
                    fill:'none',
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                });
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            // 'angle grid line' is like xAxis grid line
            // but now we name it radiusAxis axisLine in options
            // so
            var cfg = this.polar.radiusAxis.options;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var axisLineData = this.getAngleGridLineData();

            var selection = this._bindData(this.gridLines, axisLineData);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.line()).datum(d);
            });

            this.gridLines =
                enter.concat(selection.update).map(function (ele) {
                    var d = ele.datum();
                    return ele.style({'stroke':lineColor, 'stroke-width':lineWidth})
                            .attr({x1:0, y1:0, x2: d[0], y2: d[1]});
            });
        },

        _drawTickLabel:function(axisGroup){
            this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var angleAxis = this;
            var cfg = angleAxis.options;
            var isBreakLabels = this.isBreakLabels;

            var useHtml = cfg.useHtml || isBreakLabels;

            var ticks = angleAxis.tickData;

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
                this.tickLabels = [];
            }

            if (useHtml && this.tickLabels.length && this.tickLabels[0].type !== 'div') {
                this.tickLabels.map(function (d) {
                    d.remove();
                });
                this.tickLabels = [];
            }

            var tickLabelsGroup = this.tickLabelsGroup;

            var selection = this._bindData(this.tickLabels, ticks, function(d){return d.tickValue});

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                this.tickLabels = enter.concat(selection.update)
                    .filter(function (ele) {return ele.datum().tickPos;})
                    .map(function (ele) {
                        var d = ele.datum();

                        var tx = d.tickPos.x,
                            ty = d.tickPos.y;

                        var px = ele.type === 'div' ? 'px' : '';
                        var attr = {
                            transform: 'translate(' + tx + px + ' ' + ty + px + ')',
                            dy: '0.85em'
                        };

                        ele.textContent(d.tickContent)
                            .style(d.tickPos.style)
                            .attr(attr);

                        ele.vRotate(d.labelRotation);

                        return ele;
                    });

            }
        },

        drawHighlightBackground: function (sharedPoints) {
            var category = sharedPoints[0].category;
            var scale = this.scale, columnType = this.series[0] && this.series[0].options.columnType || false;
            var R = this.vanchart.renderer;

            var domain = scale.domain();

            var r = this.polar.radius;
            var radian = scale(category) / domain.length * 2 * Math.PI;

            if (columnType) {
                var halfSize = 1 / domain.length * 2 * Math.PI * 0.5;
                var startRadian = radian - halfSize;
                var endRadian = radian + halfSize;

                var arc = PathGenerator.arc()
                    .innerRadius(0)
                    .outerRadius(r)
                    .startAngle(startRadian)
                    .endAngle(endRadian);

                if (!this.highlightBand) {
                    this.highlightBand = this.axisGroup.append(R.path().style(
                        {
                            'fill': 'rgba(98,179,240,0.2)'
                        }
                    ));
                }

                this.highlightBand.attr('d', arc());
            } else {
                var point = BaseUtils.getArcPoint(r, radian);

                if (!this.highlightLine) {
                    this.highlightLine = this.axisGroup.append(R.line({
                        'stroke': 'rgb(140,140,140)',
                        'stroke-width': '1'
                    }));
                }

                this.highlightLine.attr('x2', point[0]).attr('y2', point[1]);
            }
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.axisGroup = null;
        }

    });

    return AngleAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/RadiusAxis',['require','./Base','./ValueAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/PathGenerator','../utils/Interpolator','../utils/Scale'],function(require){
    var Base = require('./Base');
    var ValueAxis = require('./ValueAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');
    var Scale = require('../utils/Scale');

    var VALUE_TICK_GAP = 2;
    var VALUE_TICK_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(VALUE_TICK_GAP);
    };

    var RadiusAxis = ValueAxis.extend({

        _refresh:function(options){
            this.series = [];

            this.initScale();

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.radiusAxis = this;
        },

        doLayout:function(){
            var series = this.series;
            this.indicator = series.length && series[0].options.indicator && series[0].options.indicator.enabled;  // bind indicator property

            this.calculateDomainFromData();

            this.scale.domain(this._domain).range([0, this.polar.radius]);

            // init categoryScale, used for calc scale value for points radius of every category 
            this._initCateScale(this._domain, [0, this.polar.radius]);  

            this._updateOriginTickData();
        },

        // bind radiusAxis.cateScale
        _initCateScale: function(d, r) {
            var scale = Scale.linear().domain(d).range(r)
            this._cateScale = scale;
        },

        // calc domain form data for every categroy
        // if the category is accumulated, calc sum use value of points on this category.  
        _calculateCateDomainData: function() {
            var radiusAxis = this, series = radiusAxis.series, vanchart = series.vanchart;
            var options = series.length && series[0].options, indicator = options.indicator;
            var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && !this._isBaseAxis();

            var minValue = Number.MAX_VALUE,maxValue = -minValue;
            var dataMap = {}, indicatorDataDomain; 
            this._cateDataDomain = [];
            // 先格式化出option中给出的数据值域
            if(indicator.data && indicator.data.length) {
                indicatorDataDomain = indicator.data.map(function (data) {
                    return {
                        name : data.name,
                        domain : [data.min, data.max]
                    }
                })
            }

            var visible = false;
            for(var i = 0, len = series.length; i < len && !visible; i++){
                visible = series[i].visible;
            }

            series.forEach(function (ser) {
                if(ser.visible || !visible) {
                    var isAccumulate = !(BaseUtils.hasNotDefined(ser.stack) || radiusAxis._isBaseAxis());

                    ser.points.forEach(function (point) {
                        var key = point.category, value = point.value;
                        if(!point.isNull && point.visible) {
                            if( isAccumulate ) {
                                dataMap[key] = dataMap[key] || [0, 0];
                                if(value >= 0) {
                                    dataMap[key][1] += value;
                                } else {
                                    dataMap[key][0] += value;
                                }
                            } else {
                                dataMap[key] = dataMap[key] || [minValue,maxValue];
                                dataMap[key][0] = Math.min(dataMap[key][0], value);
                                dataMap[key][1] = Math.max(dataMap[key][1], value);
                            }
                        }
                    })
                }
            });
            for(key in dataMap) {
                this._cateDataDomain.push({
                    useIndicator : false,
                    name : key,
                    domain : dataMap[key]
                })
            }
            // 从0开始的值轴，最小值不应该大于0
            var checkMaxAndMin  = function (arr) {
                if(fromZero) {
                    if(arr[0] > 0) { 
                        arr[0] = 0; 
                    }else if(arr[1] < 0){ 
                        arr[1] = 0; 
                    } 
                }
            }
            // 对于有自定义数据时，需要对数据进行校验
            // 只有对于那些指定分类且值域范围符合标准的才使用自定义的数据
            if (indicatorDataDomain) {
                indicatorDataDomain.forEach(function (cate) {
                    var name = cate.name, min = cate.domain[0], max = cate.domain[1];
                    // 最小值大于等于最大值的直接过滤
                    radiusAxis._cateDataDomain.forEach(function (_cate) {
                        // 未指定和多余的分类数据也同样过滤
                        if(name === _cate.name) {
                            // 都不存在时直接返回
                            if(min==null && max==null) { return; }
                            // 都存在且相等或最大值小于最小值是也返回
                            if(min!=null && max != null && min >= max){ return; }
                            var d_0 = _cate.domain[0],
                                d_1 = _cate.domain[1];

                            // 这里做一下归0判断，不然后面会很难做
                            var _min = min || (fromZero ? (d_0 > 0 ? 0 : d_0) : d_0),
                                _max = max || (fromZero ? (d_1 < 0 ? 0 : d_1) : d_1);

                            var hasMin = false, hasMax = false;
                            if(min) {
                                hasMin = true;
                            }
                            if(max){
                                hasMax = true;
                            }
                            // 有最小值没有最大值判断最大值是否小于最小值
                            if(hasMin && !hasMax) {
                                _max = _max <= _min ? _min + 100 : _max;
                            // 有最大值没有最小值判断最小值是否大于最大值
                            }else if(hasMax && !hasMin){
                                _min = _min > _max ? _max - 100 : _min;
                            }
                            _cate.useIndicator = true;
                            _cate.domain = [_min, _max];
                        }
                    })
                })
            }
            // 对于那些未能使用自定义数据的分类，需要判断将最小值置为0
            this._cateDataDomain.forEach(function (d){
                if(!d.useIndicator) {
                    checkMaxAndMin(d.domain)
                }
            })
            
            // As we get Max and Min of each category, next setp is to calc cateNiceDomain, cateStartTick, cateStep and cateTickData.
            this._calculateCateNiceDomain();
            this._updateCategoryTickData();
        },
        // clac nice domain for every category
        // and get each's tickStartValue,tickStep by the way.
        _calculateCateNiceDomain : function () {
            var radiusAxis = this, series = radiusAxis.series, vanchart = series.vanchart;


            this._cateTickStart = [];
            this._cateStep = [];
            this._cateDomain = [];

            var hasIndicator = false, defaultTickCount = this._getDefaultTickCount()
            // 第一步，依次计算每条值轴的最优值域和间隔
            // 对于自定义值域的分类轴，使用默认的tickCount进行计算
            this._cateDataDomain.forEach(function (data) {
                var name = data.name, _domain = data.domain, useIndicator = data.useIndicator;
                
                var step, domain, start;
                if (data.useIndicator) {
                    hasIndicator = true;
                    start = _domain[0],
                    domain = [_domain[0], _domain[1]];
                    step = parseFloat((_domain[1] - _domain[0]) / defaultTickCount);
                }else{
                    step = radiusAxis._linearTickInterval(_domain[0], _domain[1]),
                    domain = radiusAxis._linearNiceDomain(_domain[0], _domain[1], step);
                    start = domain[0];
                }

                radiusAxis._cateTickStart.push(start);
                
                radiusAxis._cateDomain.push({
                    useIndicator : useIndicator,
                    name : name, 
                    domain : domain 
                })

                radiusAxis._cateStep.push(step)
            });

            // 第二步，对数据再处理
            // 当有使用到自定义的最大最小值时，就全部使用默认的4行grinLine进行排版
            if(!hasIndicator) {
                var labelsLengthArr = this._getCateTickValues().map(function (d) {
                    return d.labels.length;
                })
                defaultTickCount = Math.max.apply(Math, labelsLengthArr);
            }
            
            this._cateDomain.forEach(function (d, i) {
                var min = d.domain[0], max = d.domain[1], useIndicator = d.useIndicator;
                // 自适应大小的轴重新计算step和max，确保上面的tickLabels不会出现小数
                if(!useIndicator) {
                    _step = Math.ceil((max - min) / defaultTickCount);
                    d.domain[1] = min + _step * defaultTickCount;
                    radiusAxis._cateStep[i] = _step;
                }
            })
        },

        // Update TickData for every radiusAxis
        _updateCategoryTickData: function() {
            var radiusAxis = this;
            var cateLabels = this._getCateTickValues();
            this.cateTickData = [];
  
            for(var i = 0, len = cateLabels.length; i < len; i++) {  
                var cateName = cateLabels[i].name,  
                    cateLabel = cateLabels[i].labels;  
                var cateTickData = [];  

                for(var j = 0, labelLen = cateLabel.length; j < labelLen; j++) {  
                    cateTickData.push(radiusAxis._labelInfoFormatter(cateLabel[j]));  
                }  
                radiusAxis.cateTickData.push({  
                    name : cateName,  
                    tickData : cateTickData  
                })  
            }  
        },
        // tickLabel info formatter, copy from BaseAxis._updateOriginTickData
        _labelInfoFormatter : function (tickValue) {
            var radiusAxis = this, axisOption = this.options;
            var formatter = axisOption.formatter, useHtml = axisOption.useHtml;

            var style = axisOption.labelStyle || {};
            var tbStyle = BaseUtils.extend({
                'writingMode': 'tb-rl',
                'writing-mode': 'tb-rl',
                '-webkit-writing-mode': 'vertical-rl'
            }, style);

            var tickContent = radiusAxis._getTickContent(tickValue, formatter);
            if (radiusAxis.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                tickContent = tickContent.trim();
            }
            var rectDim, labelDim, tmpStyle = style;
            var labelRotation = radiusAxis.labelRotation;

            if (Math.abs(labelRotation) === 90 && BaseUtils.hasChn(tickContent)) {
                labelRotation = 360; // as a log
                tmpStyle = tbStyle;
            }

            rectDim = BaseUtils.getTextDimension(tickContent, tmpStyle, useHtml);
            labelDim = BaseUtils.getTextDimRotated(rectDim, labelRotation);

            if(useHtml){
                labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
            }

            return {
                tickValue:tickValue,
                tickContent:tickContent,
                tickDim:labelDim,
                tickRectDim:rectDim,
                labelRotation: labelRotation
            }
        },
        // calc tickLabels info for ervery radiusAxis
        _getCateTickValues : function () {
            if(!this._cateDataDomain){  
                return [];  
            }  
            var cateValueList = [];  
            var radiusAxis = this;  
            this._cateDomain.forEach(function (d, i) {  
                var cateLabel = [];  
                var start = radiusAxis._cateTickStart[i],  
                    step = radiusAxis._cateStep[i];  
                var max = d.domain[1];
                for(; start <=max; start = BaseUtils.accAdd(start, step)){  
                    cateLabel.push(start);  
                }  
                cateValueList.push({  
                    name : d.name,  
                    labels : cateLabel   
                })  
            })  
            return cateValueList;  
        },

        fixScaleAndTickData:function(){
            this.scale.domain(this._domain).range([0, this.polar.radius]);

            this._updateOriginTickData();
        },


        getRadiusPlotBands:function(){

            var plotBands = this._getPlotBands();

            var result = [];

            var self = this;

            plotBands.forEach(function(d){
                result.push({
                    path: self._getRadiusPlotBandsPath(d.from, d.to),
                    color: d.color
                });
            });

            return result;
        },

        _getRadiusPlotBandsPath: function (from, to) {

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {
                return this._getRadiusGridPath(Math.min(from, to)) + this._getRadiusGridPath(Math.max(from, to), true)
            } else {
                var arc = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI);
                return arc.innerRadius(this.scale(Math.min(from, to)))
                    .outerRadius(this.scale(Math.max(from, to)))();
            }

        },

        getPlotLines:function(){

            var plotLines = this.options.plotLines || [];
            var self = this;

            var result = [];
            plotLines.forEach(function(d){

                var text, style, align;
                if(d.label && d.label.text && d.label.style){
                    text = d.label.text;
                    style = d.label.style;
                    align = d.label.align;
                }

                result.push({
                    color: d.color,
                    value: d.value,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],
                    text:text,
                    baseY:-self.scale(d.value),
                    textAnchor:align == Constants.LEFT ? 'end' : 'start',
                    style:style
                });
            });

            return result;
        },

        // radius grids are circles
        _getRadiusGridPath: function (value, reversed) {

            var data = this._getRadiusGridData(value, reversed);

            return this._getRadiusGridPathByData(data);
        },

        _getRadiusGridData: function (value, reversed, scale) {

            var radiusScale = scale || this.scale;
            var angleAxis = this.polar.angleAxis;

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {

                var points = [];

                var cateScale = angleAxis.scale;
                var categories = cateScale.domain();

                categories.forEach(function(category){

                    var radian = cateScale(category) * angleAxis.piece;

                    var r = radiusScale(value);

                    points.push(BaseUtils.getArcPoint(r, radian));

                });

                if (reversed) {
                    points.reverse();
                }

                return points;

            } else {
                return radiusScale(value);
            }
        },

        _getRadiusGridPathByData: function(data) {

            if(BaseUtils.isArray(data)){

                var path = "";

                if(data.length){
                    for(var i = 0, count = data.length; i < count; i++){

                        var mOrl = i ? 'L' : 'M';

                        path += (mOrl + BaseUtils.dealFloatPrecision(data[i][0]) + "," + BaseUtils.dealFloatPrecision(data[i][1]));
                    }

                    path += 'Z';
                }

                return path;

            }else{

                var arc = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                return arc.outerRadius(data)();
            }

        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add(vanchart.backGroup);
                renderer.clip(this.axisGroup.renderG, this.polar.clip);
            }

            // 没有数据时，不绘制任何轴线
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawPlotBands(this.axisGroup);

            this.indicator ? this._drawCateGridLine(this.axisGroup) : this._drawGridLine(this.axisGroup);

            this._drawPlotLines(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            var radiusAxis = this;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var selection = this._bindData(this.gridLines, ticks);

            selection.exit.map(function (ele) {
                var d = ele.datum();
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                var curPos = radiusAxis._getRadiusGridData(d.tickValue);

                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}}).remove();
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.path()).datum(d);
            });

            this.gridLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var curPos = radiusAxis._getRadiusGridData(d.tickValue);

                ele.style({
                    fill: 'none',
                    'stroke': gridLineColor,
                    'stroke-width': gridLineWidth,
                    'opacity': 1
                });

                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}});

                return ele;
            });

        },

        _drawCateGridLine: function(axisGroup) { 
            var R = this.vanchart.renderer; 
            var radiusAxis = this; 
            var lastScale = radiusAxis.lastScale || radiusAxis._cateScale; 
            var cfg = radiusAxis.options; 
            var ticks = radiusAxis.cateTickData[0].tickData; 
 
            var gridLineColor = cfg.gridLineColor; 
            var gridLineWidth = cfg.gridLineWidth; 
            
            var domain = radiusAxis._cateDomain[0].domain; 
 
 
            if(!this.gridLinesGroup){ 
                this.gridLinesGroup = axisGroup.append(R.group()); 
                this.gridLines = []; 
            } 
            var gridLinesGroup = this.gridLinesGroup; 
 
            var selection = this._bindData(this.gridLines, ticks); 
            selection.exit.map(function (ele) {
                var d = ele.datum();
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                var curPos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);

                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}}).remove();
            });

            var enter = selection.enter.map(function (d) { 
                return gridLinesGroup.append(R.path()).datum(d); 
            }); 
 
            this.gridLines = enter.concat(selection.update).map(function (ele) { 
                var d = ele.datum(); 

                lastScale.domain(domain); 
                var curPos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale); 
 
                ele.style({ 
                    fill: 'none', 
                    'stroke': gridLineColor, 
                    'stroke-width': gridLineWidth, 
                    'opacity': 1 
                }); 
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale); 
                ele.animate({'attrTween':{'d':function(){ 
                    var interpolate = Interpolate(prePos, curPos); 
 
                    return function (t) { 
                        return radiusAxis._getRadiusGridPathByData(interpolate(t)); 
                    }; 
                }}}); 
                return ele; 
            }); 
        }, 

        _drawPlotLines: function (axisGroup) {
            var R = this.vanchart.renderer;

            var plotLines = this.getPlotLines();

            if(!this.plotLinesGroup){
                this.plotLinesGroup = axisGroup.append(R.vgroup());
                this.plotLines = [];
            }
            var plotLinesGroup = this.plotLinesGroup;

            var selection = this._bindData(this.plotLines, plotLines);

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            var enter = selection.enter.map(function (d) {
                var path = plotLinesGroup.append(R.path().datum(d));
                if (d.text) {
                    path.text = plotLinesGroup.append(R.vtext());
                }
                return path;
            });

            this.plotLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var path = this._getRadiusGridPath(d.value);

                ele.style({
                    'fill': 'none',
                    'stroke': d.color,
                    'stroke-width': d.width,
                    'stroke-dasharray': d.dataArray
                }).animate({'attr':{'d':path}});

                ele.text && ele.text.textContent(d.text).style(d.style)
                    .attr({y: d.baseY});

                return ele;
            }, this);

        },

        _drawPlotBands: function (axisGroup) {
            var R = this.vanchart.renderer;

            var plotBands = this.getRadiusPlotBands();

            if(!this.plotBandsGroup){
                this.plotBandsGroup = axisGroup.append(R.group());
                this.plotBands = [];
            }
            var plotBandsGroup = this.plotBandsGroup;

            var selection = this._bindData(this.plotBands, plotBands);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return plotBandsGroup.append(R.path()).datum(d);
            });

            this.plotBands =
                enter.concat(selection.update).map(function (ele) {
                    var d = ele.datum();
                    ele.style('fill', d.color).animate({
                        'attr':{'d': d.path}
                    });
                    return ele;
            }, this);

        },

        _drawTickLabel:function(axisGroup){
            this.indicator ? this._drawCateSvgTickLabel(axisGroup) : this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            //最大值标签不显示
            var ticks = cfg.showLabel ? radiusAxis.getTickData().slice(0, -1) : [];

            var labelStyle = cfg.labelStyle;
            var useHtml = cfg.useHtml;

            var selection = this._bindData(this.tickLabels || [], ticks, function(d){return d.tickValue});
            this.tickLabels = [];

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
            }
            var tickLabelsGroup = this.tickLabelsGroup;

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                this.tickLabels = enter.concat(selection.update)
                    .map(function (ele) {
                        var d = ele.datum();

                        ele.textContent(d.tickContent).style(BaseUtils.clone(labelStyle));

                        var tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP_FUN(),
                            ty = -scale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                        var attr = {
                            transform: 'translate(' + tx + ' ' + ty + ')',
                            dy: '0.85em'
                        };

                        if (!useHtml) {

                            var rotateStr = (d.labelRotation % 360) ?
                                ele.vRotate(d.labelRotation).rotateStr : '';
                            attr.transform += rotateStr;

                            var _tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP_FUN(),
                                _ty = -lastScale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                            var lastAttr = {
                                transform: 'translate(' + _tx + ' ' + _ty + ')',
                                dy: '0.85em'
                            };
                            lastAttr.transform += rotateStr;

                            ele.attr(lastAttr).animate({'attr':attr});

                        } else {
                            ele.attr(attr);
                            ele.vRotate(d.labelRotation);
                        }
                        return ele;
                    });
            }
        },

        _drawCateSvgTickLabel : function (axisGroup) {  
            var R = this.vanchart.renderer;  
            var radiusAxis = this;  
            var lastScale = radiusAxis.lastScale || radiusAxis._cateScale;  
            var cfg = radiusAxis.options;  
            //最大值标签不显示  
            var ticks = radiusAxis.getTickData().slice(0, -1);  
  
            var labelStyle = cfg.labelStyle;  
            var useHtml = cfg.useHtml;  
  
            if(!this.cateTickLabelsGroup){  
                this.cateTickLabelsGroup = axisGroup.append(R.vgroup());  
                this.cateTickLabels = [];  
                this._cateDataDomain.forEach(function () {  
                    radiusAxis.cateTickLabels.push([]);  
                })  
            }  
            var tickLabelsGroup = this.cateTickLabelsGroup;  
  
            var cateSelection = [];  
  
            var getDir = function (x, y) {  
                var horizontal = x >= 0 ? 'RIGHT' : 'LEFT',  
                    vertical  = y >= 0 ? 'BOTTOM' : 'TOP';  
  
                return horizontal + '_' + vertical;  
            }  
  
            // label位置统一计算  
            var calcPostion = function (dir, x, y, rect_w, rect_h, dim_w, dim_h) {  
                  
                var gap = VALUE_TICK_GAP_FUN();  
                var _w = (rect_w + dim_w) / 2,  
                    _h = (rect_h + dim_h) / 2;  
                  
                switch(dir) {  
                    case 'LEFT_TOP' :  
                        _x = x + gap;  
                        _y = y + gap;  
                        break;  
                    case 'RIGHT_TOP' :  
                        _x = x - _w - gap;  
                        _y = y + gap;  
                        break;  
                    case 'RIGHT_BOTTOM' :  
                        _x = x + - _w - gap;  
                        _y = y - _h - gap;  
                        break;  
                    case 'LEFT_BOTTOM' :  
                        _x = x + gap;  
                        _y = y - _h - gap;  
                        break;  
                }  
                return {  
                    x : _x,  
                    y : _y  
                }  
            }  
            // 获取网格线的终点位置信息  
            var gridLineEndPosData = this.series[0].angleAxis.getCateAngleGridLineData();  
            var labelLenArr = this.cateTickData.map(function (tick) {
                return tick.tickData.length;
            })
            
            var lastDomain = lastScale.domain(),
                lastRange = lastScale.range();

            this.cateTickData.forEach(function (tick, i){  
                var cateName = tick.name, pos;  
                var selection = radiusAxis._bindData(radiusAxis.cateTickLabels[i], tick.tickData, function(d) { return d.tickValue });  

                gridLineEndPosData.forEach(function (d) {  
                    if(d.name == cateName) {  
                        pos = d.pos;  
                    }  
                })      
                selection.exit.map(function (d) {  
                    d.remove();  
                });  
  
                var x0 = pos[0], y0 = pos[1], dir = getDir(x0, y0);  
  
                if(cfg.showLabel){  
                    var _enter = selection.enter.map(function (d) {  
                        return tickLabelsGroup.append(R.vtext(useHtml).datum(d));  
                    });  
  
                    radiusAxis.cateTickLabels[i] = _enter.concat(selection.update)  
                        .map(function (ele, j, labels) {  
                            var d = ele.datum();  
                            ele.textContent(d.tickContent).style(labelStyle);  
                            
                            // 这里用scale感觉有点蠢
                            lastScale.domain(radiusAxis._cateDomain[i].domain)
                            lastScale.range([0,x0]);
                            var _x0 = lastScale(d.tickValue);
                            lastScale.range([0,y0]);
                            var _y0 = lastScale(d.tickValue);

                            var _pos = calcPostion(dir, _x0, _y0, d.tickRectDim.width, d.tickRectDim.height, d.tickDim.width, d.tickDim.height);  
                            var tx = _pos.x,  
                                ty = _pos.y;  
  
                            var attr = {  
                                transform: 'translate(' + tx + ' ' + ty + ')',  
                                dy: '0.85em'  
                            };  
  
                            if (!useHtml) {  
  
                                var rotateStr = (d.labelRotation % 360) ?  
                                    ele.vRotate(d.labelRotation).rotateStr : '';  
                                attr.transform += rotateStr;  
  
                                var _tx = tx,  
                                    _ty = ty;  
  
                                var lastAttr = {  
                                    transform: 'translate(' + _tx + ' ' + _ty + ')',  
                                    dy: '0.85em'  
                                };  
                                lastAttr.transform += rotateStr;  
  
                                ele.attr(lastAttr).animate({'attr':attr});  
  
                            } else {  
                                ele.attr(attr);  
                                ele.vRotate(d.labelRotation);  
                            }  
                            return ele;  
                        });  
                }  
            })  

            lastScale.range(lastRange).domain(lastDomain);
        }
    });

    return RadiusAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/PolarAxis',['require','./Base','../utils/BaseUtils','../Constants','./Axis','./Polar','./AngleAxis','./RadiusAxis','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var Polar = require('./Polar');
    var AngleAxis = require('./AngleAxis');
    var RadiusAxis = require('./RadiusAxis');
    var ComponentLibrary = require('../ComponentLibrary');

    var PolarAxis = Axis.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //最终生成的坐标轴数应该和新的option一样
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else {
                    var AxisClass;
                    if (this.componentType === ComponentLibrary.POLAR_COMPONENT) {
                        AxisClass = Polar;
                    } else {

                        var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                        if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                            AxisClass = RadiusAxis;
                        } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                            AxisClass = AngleAxis;
                        }
                    }

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }

            }
        },

        doLayout: function () {
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].doLayout();
            }
        },

        render:function(){
           this._axisList.map(function (axis) {
               if (axis.componentType === ComponentLibrary.POLAR_COMPONENT) {
                   axis.render();
               }
           });
        }

    });

    ComponentLibrary.register(ComponentLibrary.RADIUS_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.ANGLE_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.POLAR_COMPONENT, PolarAxis);

    return PolarAxis;
});
/**
 * Created by eason on 15/5/4.
 * 标题组建，包括图表标题和坐标轴标题
 */
define('component/Title',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;

    var PADDING_FUN = function() {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var Title = Base.extend({

        doLayout:function(){

            var cfg = this.options;

            if(!cfg.text){
                return;
            }

            var originBounds = this.vanchart.bounds;

            var remainWidth = originBounds.width;
            var remainHeight = originBounds.height;

            var textDim;

            // get maximal area
            if (this.isFloat) {

                remainWidth -= (this._floatX - originBounds.x);
                remainHeight -= (this._floatY - originBounds.y);

            } else {

                var toolbar = this.vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];
                this.initBarWidth = toolbar && toolbar.getToolBarInitWidth() || 0;
                remainWidth -= this.initBarWidth;

                if (cfg.align === 'center') {
                    remainWidth -= this.initBarWidth;
                }
            }

            // cut padding to place text
            remainWidth -= 2 * PADDING_FUN();
            remainHeight -= 2 * PADDING_FUN();

            // try to get minimal text width
            textDim = BaseUtils.getTextDimension(cfg.text, cfg.style, cfg.useHtml);

            // wrap text when too long
            if (textDim.width > remainWidth) {
                var newStyle = BaseUtils.clone(cfg.style);
                newStyle.width = Math.max(remainWidth, 0) + 'px';
                textDim = BaseUtils.getTextWrapDimension(cfg.text, newStyle, cfg.useHtml);
            } else {
                textDim.width += 0.5;
            }

            // title and text height are the same and should be minimal
            textDim.height = Math.min(this._maxHeight(), remainHeight, textDim.height);

            var doublePadding = 2 * PADDING_FUN();

            // 这里的height就是bounds.height，当使用限制的尺寸的时则使用限制的尺寸，否则以文字的尺寸+2*padding
            var height = Math.min(this._maxHeight(), remainHeight + doublePadding, textDim.height + doublePadding);

            // while widths are different
            // floating title width is text width
            // fixed title width remains plot width; cut toolbar is text width


            if (this.isFloat) {

                this.bounds = {
                    x: this._floatX,
                    y: this._floatY,
                    // contract floating title's background width
                    width: textDim.width + 2 * PADDING_FUN(),
                    height: height
                };

            } else {

                this._setComponentBounds(Constants.TOP, height === 0 ? 0 : (height+ 0.5 * PADDING_FUN()));
                this.bounds.height = height;
            }

            // 文字在内部整体居中
            var textTranslateY = (height - textDim.height) / 2;

            if (this.isFloat) {
                this.textBounds = {x:PADDING_FUN(), y: textTranslateY, width: textDim.width, height:textDim.height};
            } else {
                var x;
                switch (cfg.align) {
                    case 'right':
                        x = remainWidth - textDim.width;
                        break;
                    case 'center':
                        x = this.bounds.width / 2 - textDim.width / 2;
                        break;
                    case 'left':
                    default:
                        x = this.bounds.x + PADDING_FUN();
                }
                this.textBounds = {
                    x: x,
                    y: textTranslateY,
                    width: textDim.width,
                    height: textDim.height
                };
            }

            if (cfg.useHtml) {
                this.labels = [];
                this.labels.push({
                    text: cfg.text,
                    dim: textDim,
                    style: cfg.style
                });
            } else {
                var texts = BaseUtils.splitText(cfg.text, cfg.style, this.textBounds.width);
                this.labels = texts.map(function (text) {
                    return {
                        text: text,
                        dim: BaseUtils.getTextDimension(text, cfg.style, cfg.useHtml),
                        style: cfg.style
                    }
                });
            }
        },

        render: function () {

            if(!this.textBounds || this.textBounds.width < 0 || this.textBounds.height < 0){
                this.remove();
                return;
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.titleGroup){
                this.titleGroup = renderer.vgroup();

                //add进componentGroup中，toolbar不会被遮住
                this.titleGroup.renderG.addTo(this.isFloat ? vanchart.frontGroup : vanchart.backGroup);
                this.titleGroup.divG.add();

                this.titleGroup.divG.style('pointer-events', 'auto');
            }

            this.titleGroup.attr('transform', BaseUtils.makeTranslate([this.bounds.x, this.bounds.y]));

            this._innerClip(this.titleGroup);

            // use renderG to avoid style on div
            this.drawBackground(this.titleGroup.renderG);

            this.drawTitle(this.titleGroup);
        },

        drawBackground: function (titleGroup) {
            var cfg = this.options, bounds = this.bounds;
            if (cfg.backgroundColor) {
                this.vanchart._renderRectangleBackground(titleGroup, cfg, {x:0, y:0, width:bounds.width, height:bounds.height});
            }
        },

        drawTitle: function (titleGroup) {

            if (this.text) {
                this.text.remove();
                this.text = null;
            }

            var R = this.vanchart.renderer;

            var cfg = this.options;
            var textBounds = this.textBounds;
            var useHtml = cfg.useHtml;
            var align = cfg.align;

            var text = R.vtext(useHtml).attr({
                'transform': BaseUtils.makeTranslate([textBounds.x, textBounds.y]),
                'width': textBounds.width + 'px',
                'text-align': align,
                'white-space': 'normal'
            });

            this.text = text;

            var svgOffset = useHtml ? {} :
                BaseUtils.isMS ? {'dy': '1em'} :
                {'dominant-baseline': 'central', 'dy': textBounds.height/this.labels.length/2};

            var y = 0;
            this.labels.map(function (label) {
                var dx, labelDim = label.dim;
                switch (align) {
                    case Constants.LEFT:
                        dx = 0;
                        break;
                    case Constants.RIGHT:
                        dx = textBounds.width - labelDim.width;
                        break;
                    case Constants.CENTER:
                    default:
                        dx = (textBounds.width - labelDim.width)/2;
                }
                text.append(
                    R.vtspan(useHtml)
                        .attr({
                            'y': y,
                            'x': 0,
                            'dx': dx
                        })
                        .attr(svgOffset)
                        .textContent(label.text)
                        .style(label.style)
                        // .style('outline','1px solid #aaa')//
                );

                y += (labelDim.height);
            });

            titleGroup.append(text);
        },

        remove:function(){
            this.titleGroup && this.titleGroup.remove();
            this._clip && this._clip.remove && this._clip.remove();  // VmlRender下_clip没有remove方法，会报错
            this.titleGroup = this._clip = null;
        }
    });
    ComponentLibrary.register(ComponentLibrary.TITLE_COMPONENT, Title);

    return Title;
});
/**
 * Created by eason on 2017/2/9.
 */

define('utils/GeoUtils',['require','./Bounds'],function(require){

    var Bounds = require('./Bounds');

    var d3_geo_streamObjectType = {
        Feature: function(feature, pointsArray) {
            d3_geo_streamGeometry(feature.geometry, pointsArray);
        },
        FeatureCollection: function(object, pointsArray) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) { d3_geo_streamGeometry(features[i].geometry, pointsArray) }
        }
    };

    function d3_geo_streamGeometry(geometry, pointsArray) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, pointsArray);
        }
    }

    var d3_geo_streamGeometryType = {
        Point: function(object, pointsArray) {
            pointsArray.push(object.coordinates);
        },
        MultiPoint: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { object = coordinates[i]; pointsArray.push(object); }
        },
        LineString: function(object, pointsArray) {
            d3_geo_streamLine(object.coordinates, pointsArray);
        },
        MultiLineString: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { d3_geo_streamLine(coordinates[i], pointsArray) }
        },
        Polygon: function(object, pointsArray) {
            d3_geo_streamPolygon(object.coordinates, pointsArray);
        },
        MultiPolygon: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { d3_geo_streamPolygon(coordinates[i], pointsArray) }
        },
        GeometryCollection: function(object, pointsArray) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) { d3_geo_streamGeometry(geometries[i], pointsArray) }
        }
    };
    function d3_geo_streamLine(coordinates, pointsArray) {
        var i = -1, n = coordinates.length, coordinate;
        while (++i < n) { coordinate = coordinates[i]; pointsArray.push(coordinate) }
    }

    function d3_geo_streamPolygon(coordinates, pointsArray) {
        var i = -1, n = coordinates.length;
        while (++i < n) { d3_geo_streamLine(coordinates[i], pointsArray) }
    }

    function getAllPoints(object) {
        var allPoints = [];
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, allPoints);
        } else {
            d3_geo_streamGeometry(object, allPoints);
        }

        return allPoints;
    }

    function scaleGeo(geoJson, scale){
        var features = geoJson.features;
        for(var i = 0, len = features.length; i < len; i++){
            var center = features[i].properties.center;
            if(center){
                center[0] *= scale;
                center[1] *= scale;
            }
        }
        var points = getAllPoints(geoJson);
        for(var i = 0, len = points.length; i < len; i++){
            points[i][0] *= scale;
            points[i][1] *= scale;
        }
    }

    function bounds(geoJson){
        var bounds = new Bounds(getAllPoints(geoJson));
        return [[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]];
    }

    return {
        'getAllPoints':getAllPoints,
        'scaleGeo':scaleGeo,
        'bounds':bounds
    }

});
/**
 * Created by eason on 2017/2/6.
 */

define('chart/map/layer/ImageOverlay',['require','./../../../vector/Layer','../LatLngBounds','../../../utils/BaseUtils','../../../dom/DomUtils','../../../utils/Bounds'],function(require){

    var Layer = require('./../../../vector/Layer');
    var LatLngBounds = require('../LatLngBounds');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var Bounds = require('../../../utils/Bounds');

    var ImageOverlay = Layer.extend({

        // @section
        // @aka ImageOverlay options
        options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,

            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: '',

            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,

            // @option crossOrigin: Boolean = false
            // If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
            crossOrigin: false
        },

        initialize: function (url, bounds, options){ // (String, LatLngBounds, Object)
            this._url = url;
            this._bounds = LatLngBounds.create(bounds);
            BaseUtils.setOptions(this, options);
        },

        onAdd: function () {
            if (!this._image) {
                this._initImage();

                if (this.options.opacity < 1) {
                    this._updateOpacity();
                }
            }

            this.getPane().appendChild(this._image);
            this._reset();
        },

        onRemove: function () {
            DomUtils.remove(this._image);
            if (this.options.interactive) {
                this.removeInteractiveTarget(this._image);
            }
        },

        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function (opacity) {
            this.options.opacity = opacity;

            if (this._image) {
                this._updateOpacity();
            }
            return this;
        },

        setStyle: function (styleOpts) {
            if (styleOpts.opacity) {
                this.setOpacity(styleOpts.opacity);
            }
            return this;
        },

        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function () {
            if (this._map) {
                DomUtils.toFront(this._image);
            }
            return this;
        },

        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function () {
            if (this._map) {
                DomUtils.toBack(this._image);
            }
            return this;
        },

        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function (url) {
            this._url = url;

            if (this._image) {
                this._image.src = url;
            }
            return this;
        },

        setBounds: function (bounds) {
            this._bounds = bounds;

            if (this._map) {
                this._reset();
            }
            return this;
        },

        getEvents: function () {
            var events = {
                zoom: this._reset,
                viewreset: this._reset
            };

            if (this._zoomAnimated) {
                events.zoomanim = this._animateZoom;
            }

            return events;
        },

        getBounds: function () {
            return this._bounds;
        },

        _initImage: function () {
            var img = this._image = DomUtils.create('img',
                'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

            img.onselectstart = BaseUtils.falseFn;
            img.onmousemove = BaseUtils.falseFn;

            img.onload = BaseUtils.bind(this.fire, this, 'load');

            if (this.options.crossOrigin) {
                img.crossOrigin = '';
            }

            img.src = this._url;
            img.alt = this.options.alt;
        },

        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

            DomUtils.setTransform(this._image, offset, scale);
        },

        _reset: function () {
            var image = this._image,
                bounds = new Bounds(
                    this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                size = bounds.getSize();

            DomUtils.setPosition(image, bounds.min);

            image.style.width  = size.x + 'px';
            image.style.height = size.y + 'px';
        },

        _updateOpacity: function () {
            DomUtils.setOpacity(this._image, this.options.opacity);
        }

    });

    return ImageOverlay;
});
/**
 * Created by eason on 2017/1/20.
 */

define('chart/map/layer/GridLayer',['require','./../../../vector/Layer','../../../utils/BaseUtils','../../../dom/DomUtils','../../../dom/Browser','../../../utils/Point2D','../../../utils/Bounds','../LatLngBounds'],function(require){

    var Layer = require('./../../../vector/Layer');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var Browser = require('../../../dom/Browser');
    var Point = require('../../../utils/Point2D');
    var Bounds = require('../../../utils/Bounds');
    var LatLngBounds = require('../LatLngBounds');


    var GridLayer = Layer.extend({

        // @section
        // @aka GridLayer options
        options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,

            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,

            // @option updateWhenIdle: Boolean = depends
            // If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
            updateWhenIdle: Browser.mobile,

            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,

            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,

            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,

            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,

            // @option minZoom: Number = 0
            // The minimum zoom level that tiles will be loaded at. By default the entire map.
            minZoom: 0,

            // @option maxZoom: Number = undefined
            // The maximum zoom level that tiles will be loaded at.
            maxZoom: undefined,

            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around.
            noWrap: false,

            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: 'tilePane',

            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: '',

            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        onAdd: function () {
            this._initContainer();

            this._levels = {};
            this._tiles = {};

            this._resetView();
            this._update();
        },

        beforeAdd: function (map) {
            map._addZoomLimit(this);
        },

        onRemove: function (map) {
            this._removeAllTiles();
            DomUtils.remove(this._container);
            map._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = null;
        },

        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function () {
            if (this._map) {
                DomUtils.toFront(this._container);
                this._setAutoZIndex(Math.max);
            }
            return this;
        },

        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function () {
            if (this._map) {
                DomUtils.toBack(this._container);
                this._setAutoZIndex(Math.min);
            }
            return this;
        },

        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function () {
            return this._container;
        },

        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function (opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },

        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function (zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();

            return this;
        },

        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function () {
            return this._loading;
        },

        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function () {
            if (this._map) {
                this._removeAllTiles();
                this._update();
            }
            return this;
        },

        getEvents: function () {
            var events = {
                viewprereset: this._invalidateAll,
                viewreset: this._resetView,
                zoom: this._resetView,
                panend: this._onPanEnd,
                resize:this._onResize
            };

            if (!this.options.updateWhenIdle) {
                // update tiles on move, but not more often than once per given interval
                if (!this._onPanMove) {
                    this._onPanMove = BaseUtils.throttle(this._onPanEnd, this.options.updateInterval, this);
                }

                events.panmove = this._onPanMove;
            }

            if (this._zoomAnimated) {
                events.zoomanim = this._animateZoom;
            }

            return events;
        },

        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overriden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function () {
            return document.createElement('div');
        },

        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function () {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
        },

        _updateZIndex: function () {
            if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
                this._container.style.zIndex = this.options.zIndex;
            }
        },

        _setAutoZIndex: function (compare) {
            // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

            var layers = this.getPane().children,
                edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

            for (var i = 0, len = layers.length, zIndex; i < len; i++) {

                zIndex = layers[i].style.zIndex;

                if (layers[i] !== this._container && zIndex) {
                    edgeZIndex = compare(edgeZIndex, +zIndex);
                }
            }

            if (isFinite(edgeZIndex)) {
                this.options.zIndex = edgeZIndex + compare(-1, 1);
                this._updateZIndex();
            }
        },

        _updateOpacity: function () {
            if (!this._map) { return; }

            // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
            if (Browser.ielt9) { return; }

            DomUtils.setOpacity(this._container, this.options.opacity);

            var now = +new Date(),
                nextFrame = false,
                willPrune = false;

            for (var key in this._tiles) {
                var tile = this._tiles[key];
                if (!tile.current || !tile.loaded) { continue; }

                var fade = Math.min(1, (now - tile.loaded) / 200);

                DomUtils.setOpacity(tile.el, fade);
                if (fade < 1) {
                    nextFrame = true;
                } else {
                    if (tile.active) { willPrune = true; }
                    tile.active = true;
                }
            }

            if (willPrune && !this._noPrune) { this._pruneTiles(); }

            if (nextFrame) {
                BaseUtils.cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = BaseUtils.requestAnimFrame(this._updateOpacity, this);
            }
        },

        _initContainer: function () {
            if (this._container) { return; }

            this._container = DomUtils.create('div', 'leaflet-layer ' + (this.options.className || ''));
            this._updateZIndex();

            if (this.options.opacity < 1) {
                this._updateOpacity();
            }

            this.getPane().appendChild(this._container);
        },

        _updateLevels: function () {

            var zoom = this._tileZoom,
                maxZoom = this.options.maxZoom;

            if (zoom === undefined) { return undefined; }

            for (var z in this._levels) {
                if (this._levels[z].el.children.length || z === zoom) {
                    this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                } else {
                    DomUtils.remove(this._levels[z].el);
                    this._removeTilesAtZoom(z);
                    delete this._levels[z];
                }
            }

            var level = this._levels[zoom],
                map = this._map;

            if (!level) {
                level = this._levels[zoom] = {};

                level.el = DomUtils.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
                level.el.style.zIndex = maxZoom;

                level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                level.zoom = zoom;

                this._setZoomTransform(level, map.getCenter(), map.getZoom());

                // force the browser to consider the newly added element for transition
                BaseUtils.falseFn(level.el.offsetWidth);
            }

            this._level = level;

            return level;
        },

        _pruneTiles: function () {
            if (!this._map) {
                return;
            }

            var key, tile;

            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom ||
                zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }

            for (key in this._tiles) {
                tile = this._tiles[key];
                tile.retain = tile.current;
            }

            for (key in this._tiles) {
                tile = this._tiles[key];
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                        this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                    }
                }
            }

            for (key in this._tiles) {
                if (!this._tiles[key].retain) {
                    this._removeTile(key);
                }
            }
        },

        _removeTilesAtZoom: function (zoom) {
            for (var key in this._tiles) {
                if (this._tiles[key].coords.z !== zoom) {
                    continue;
                }
                this._removeTile(key);
            }
        },

        _removeAllTiles: function () {
            for (var key in this._tiles) {
                this._removeTile(key);
            }
        },

        _invalidateAll: function () {
            for (var z in this._levels) {
                DomUtils.remove(this._levels[z].el);
                delete this._levels[z];
            }
            this._removeAllTiles();

            this._tileZoom = null;
        },

        _retainParent: function (x, y, z, minZoom) {
            var x2 = Math.floor(x / 2),
                y2 = Math.floor(y / 2),
                z2 = z - 1,
                coords2 = new Point(+x2, +y2);
            coords2.z = +z2;

            var key = this._tileCoordsToKey(coords2),
                tile = this._tiles[key];

            if (tile && tile.active) {
                tile.retain = true;
                return true;

            } else if (tile && tile.loaded) {
                tile.retain = true;
            }

            if (z2 > minZoom) {
                return this._retainParent(x2, y2, z2, minZoom);
            }

            return false;
        },

        _retainChildren: function (x, y, z, maxZoom) {

            for (var i = 2 * x; i < 2 * x + 2; i++) {
                for (var j = 2 * y; j < 2 * y + 2; j++) {

                    var coords = new Point(i, j);
                    coords.z = z + 1;

                    var key = this._tileCoordsToKey(coords),
                        tile = this._tiles[key];

                    if (tile && tile.active) {
                        tile.retain = true;
                        continue;

                    } else if (tile && tile.loaded) {
                        tile.retain = true;
                    }

                    if (z + 1 < maxZoom) {
                        this._retainChildren(i, j, z + 1, maxZoom);
                    }
                }
            }
        },

        _resetView: function (e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },

        _animateZoom: function (e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
        },

        _setView: function (center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
                (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
                tileZoom = undefined;
            }

            var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

            if (!noUpdate || tileZoomChanged) {

                this._tileZoom = tileZoom;

                if (this._abortLoading) {
                    this._abortLoading();
                }

                this._updateLevels();
                this._resetGrid();

                if (tileZoom !== undefined) {
                    this._update(center);
                }

                if (!noPrune) {
                    this._pruneTiles();
                }

                // Flag to prevent _updateOpacity from pruning tiles during
                // a zoom anim or a pinch gesture
                this._noPrune = !!noPrune;
            }

            this._setZoomTransforms(center, zoom);
        },

        _setZoomTransforms: function (center, zoom) {
            for (var i in this._levels) {
                this._setZoomTransform(this._levels[i], center, zoom);
            }
        },

        _setZoomTransform: function (level, center, zoom) {
            var scale = this._map.getZoomScale(zoom, level.zoom),
                translate = level.origin.multiplyBy(scale)
                    .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

            if (Browser.any3d) {
                DomUtils.setTransform(level.el, translate, scale);
            } else {
                DomUtils.setPosition(level.el, translate);
            }
        },

        _resetGrid: function () {
            var map = this._map,
                crs = map.options.crs,
                tileSize = this._tileSize = this.getTileSize(),
                tileZoom = this._tileZoom;

            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
                this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }

            this._wrapX = crs.wrapLng && !this.options.noWrap && [
                    Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
                    Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
                ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
                    Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
                    Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
                ];
        },

        _onPanEnd: function () {
            if (!this._map || this._map._animatingZoom) { return; }
            this._update();
        },

        _onResize: function () {
            this._update();
        },

        _getTiledPixelBounds: function (center) {
            var map = this._map,
                mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
                scale = map.getZoomScale(mapZoom, this._tileZoom),
                pixelCenter = map.project(center, this._tileZoom).floor(),
                halfSize = map.getSize().divideBy(scale * 2);

            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },

        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function (center) {
            var map = this._map;
            if (!map) { return; }
            var zoom = map.getZoom();

            if (center === undefined) { center = map.getCenter(); }
            if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

            var pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                tileCenter = tileRange.getCenter(),
                queue = [],
                margin = this.options.keepBuffer,
                noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
                    tileRange.getTopRight().add([margin, -margin]));

            for (var key in this._tiles) {
                var c = this._tiles[key].coords;
                if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                    this._tiles[key].current = false;
                }
            }

            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

            // create a queue of coordinates to load tiles from
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
                for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                    var coords = new Point(i, j);
                    coords.z = this._tileZoom;

                    if (!this._isValidTile(coords)) { continue; }

                    var tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        queue.push(coords);
                    }
                }
            }

            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });

            if (queue.length !== 0) {
                // if it's the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles.
                    this.fire('loading');
                }

                // create DOM fragment to append tiles in one batch
                var fragment = document.createDocumentFragment();

                for (i = 0; i < queue.length; i++) {
                    this._addTile(queue[i], fragment);
                }

                this._level.el.appendChild(fragment);
            }
        },

        _isValidTile: function (coords) {
            var crs = this._map.options.crs;

            if (!crs.infinite) {
                // don't load tile if it's out of bounds and not wrapped
                var bounds = this._globalTileRange;
                if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
                    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
            }

            if (!this.options.bounds) { return true; }

            // don't load tile if it doesn't intersect the bounds in options
            var tileBounds = this._tileCoordsToBounds(coords);
            return LatLngBounds.create(this.options.bounds).overlaps(tileBounds);
        },

        _keyToBounds: function (key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },

        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function (coords) {

            var map = this._map,
                tileSize = this.getTileSize(),

                nwPoint = coords.scaleBy(tileSize),
                sePoint = nwPoint.add(tileSize),

                nw = map.unproject(nwPoint, coords.z),
                se = map.unproject(sePoint, coords.z);

            if (!this.options.noWrap) {
                nw = map.wrapLatLng(nw);
                se = map.wrapLatLng(se);
            }

            return new LatLngBounds(nw, se);
        },

        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function (coords) {
            return coords.x + ':' + coords.y + ':' + coords.z;
        },

        // converts tile cache key to coordinates
        _keyToTileCoords: function (key) {
            var k = key.split(':'),
                coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
        },

        _removeTile: function (key) {
            var tile = this._tiles[key];
            if (!tile) { return; }

            DomUtils.remove(tile.el);

            delete this._tiles[key];

            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire('tileunload', {
                tile: tile.el,
                coords: this._keyToTileCoords(key)
            });
        },

        _initTile: function (tile) {
            DomUtils.addClass(tile, 'leaflet-tile');

            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + 'px';
            tile.style.height = tileSize.y + 'px';

            tile.onselectstart = BaseUtils.falseFn;
            tile.onmousemove = BaseUtils.falseFn;

            // update opacity on tiles in IE7-8 because of filter inheritance problems
            if (Browser.ielt9 && this.options.opacity < 1) {
                DomUtils.setOpacity(tile, this.options.opacity);
            }

            // without this hack, tiles disappear after zoom on Chrome for Android
            // https://github.com/Leaflet/Leaflet/issues/2078
            if (Browser.android && !Browser.android23) {
                tile.style.WebkitBackfaceVisibility = 'hidden';
            }
        },

        _addTile: function (coords, container) {
            var tilePos = this._getTilePos(coords),
                key = this._tileCoordsToKey(coords);

            var tile = this.createTile(this._wrapCoords(coords), BaseUtils.bind(this._tileReady, this, coords));

            this._initTile(tile);

            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) {
                // mark tile as ready, but delay one frame for opacity animation to happen
                BaseUtils.requestAnimFrame(BaseUtils.bind(this._tileReady, this, coords, null, tile));
            }

            DomUtils.setPosition(tile, tilePos);

            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };

            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                tile: tile,
                coords: coords
            });
        },

        _tileReady: function (coords, err, tile) {
            if (!this._map) { return; }

            if (err) {
                // @event tileerror: TileErrorEvent
                // Fired when there is an error loading a tile.
                this.fire('tileerror', {
                    error: err,
                    tile: tile,
                    coords: coords
                });
            }

            var key = this._tileCoordsToKey(coords);

            tile = this._tiles[key];
            if (!tile) { return; }

            tile.loaded = +new Date();
            if (this._map._fadeAnimated) {
                DomUtils.setOpacity(tile.el, 0);
                BaseUtils.cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = BaseUtils.requestAnimFrame(this._updateOpacity, this);
            } else {
                tile.active = true;

                if(!this._map.options.toPhantom){
                    this._pruneTiles();
                }
            }

            if (!err) {
                DomUtils.addClass(tile.el, 'leaflet-tile-loaded');

                // @event tileload: TileEvent
                // Fired when a tile loads.
                this.fire('tileload', {
                    tile: tile.el,
                    coords: coords
                });
            }

            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');

                if(this._map.options.toPhantom){

                    window.console && console.log('done');

                }else{
                    if (Browser.ielt9 || !this._map._fadeAnimated) {
                        BaseUtils.requestAnimFrame(this._pruneTiles, this);
                    } else {
                        // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                        // to trigger a pruning.
                        setTimeout(BaseUtils.bind(this._pruneTiles, this), 250);
                    }
                }


            }
        },

        _getTilePos: function (coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },

        _wrapCoords: function (coords) {
            var newCoords = new Point(
                this._wrapX ? BaseUtils.wrapNum(coords.x, this._wrapX) : coords.x,
                this._wrapY ? BaseUtils.wrapNum(coords.y, this._wrapY) : coords.y);
            newCoords.z = coords.z;
            return newCoords;
        },

        _pxBoundsToTileRange: function (bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
                bounds.min.unscaleBy(tileSize).floor(),
                bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
        },

        _noTilesToLoad: function () {
            for (var key in this._tiles) {
                if (!this._tiles[key].loaded) { return false; }
            }
            return true;
        }
    });


    return GridLayer;
});
/**
 * Created by eason on 2017/1/20.
 */

define('chart/map/layer/TileLayer',['require','./GridLayer','../../../utils/BaseUtils','../../../dom/DomUtils','../CRS','../../../dom/Browser'],function(require){

    var GridLayer = require('./GridLayer');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var CRS = require('../CRS');
    var Browser = require('../../../dom/Browser');
    var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

    var TileLayer = GridLayer.extend({

        // @section
        // @aka TileLayer options
        options: {
            // @option minZoom: Number = 0
            // Minimum zoom number.
            minZoom: 0,

            // @option maxZoom: Number = 18
            // Maximum zoom number.
            maxZoom: 18,

            // @option maxNativeZoom: Number = null
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: null,

            // @option minNativeZoom: Number = null
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: null,

            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: 'abc',

            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: '',

            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,

            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,

            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,

            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,

            // @option crossOrigin: Boolean = false
            // If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
            crossOrigin: false
        },

        initialize: function (url, options) {

            this._url = url;

            options = BaseUtils.setOptions(this, options);

            // detecting retina displays, adjusting tileSize and zoom levels
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

                options.tileSize = Math.floor(options.tileSize / 2);

                if (!options.zoomReverse) {
                    options.zoomOffset++;
                    options.maxZoom--;
                } else {
                    options.zoomOffset--;
                    options.minZoom++;
                }

                options.minZoom = Math.max(0, options.minZoom);
            }

            if (typeof options.subdomains === 'string') {
                options.subdomains = options.subdomains.split('');
            }

            // for https://github.com/Leaflet/Leaflet/issues/137
            // if (!Browser.android) {
            //     this.on('tileunload', this._onTileRemove);
            // }
        },

        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        setUrl: function (url, noRedraw) {
            this._url = url;

            if (!noRedraw) {
                this.redraw();
            }
            return this;
        },

        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function (coords, done) {
            var tile = document.createElement('img');

            VanHammer.on(tile, 'load', BaseUtils.bind(this._tileOnLoad, this, done, tile));
            VanHammer.on(tile, 'error', BaseUtils.bind(this._tileOnError, this, done, tile));

            if (this.options.crossOrigin) {
                tile.crossOrigin = '';
            }

            /*
             Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
             http://www.w3.org/TR/WCAG20-TECHS/H67
             */
            tile.alt = '';

            /*
             Set role="presentation" to force screen readers to ignore this
             https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
             */
            tile.setAttribute('role', 'presentation');

            tile.src = this.getTileUrl(coords);

            return tile;
        },

        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function (coords) {
            var data = {
                r: Browser.retina ? '@2x' : '',
                s: this._getSubdomain(coords),
                x: coords.x,
                y: coords.y,
                z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
                var invertedY = this._globalTileRange.max.y - coords.y;
                if (this.options.tms) {
                    data['y'] = invertedY;
                }
                data['-y'] = invertedY;
            }

            return BaseUtils.template(this._url, BaseUtils.extend(data, this.options));
        },

        _tileOnLoad: function (done, tile) {
            // For https://github.com/Leaflet/Leaflet/issues/3332
            if (Browser.ielt9) {
                setTimeout(BaseUtils.bind(done, this, null, tile), 0);
            } else {
                done(null, tile);
            }
        },

        _tileOnError: function (done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl) {
                tile.src = errorUrl;
            }
            done(e, tile);
        },

        getTileSize: function () {
            var map = this._map,
                tileSize = GridLayer.prototype.getTileSize.call(this),
                zoom = this._tileZoom + this.options.zoomOffset,
                minNativeZoom = this.options.minNativeZoom,
                maxNativeZoom = this.options.maxNativeZoom;

            // decrease tile size when scaling below minNativeZoom
            if (minNativeZoom !== null && zoom < minNativeZoom) {
                return tileSize.divideBy(map.getZoomScale(minNativeZoom, zoom)).round();
            }

            // increase tile size when scaling above maxNativeZoom
            if (maxNativeZoom !== null && zoom > maxNativeZoom) {
                return tileSize.divideBy(map.getZoomScale(maxNativeZoom, zoom)).round();
            }

            return tileSize;
        },

        _onTileRemove: function (e) {
            e.tile.onload = null;
        },

        _getZoomForUrl: function () {
            var zoom = this._tileZoom,
                maxZoom = this.options.maxZoom,
                zoomReverse = this.options.zoomReverse,
                zoomOffset = this.options.zoomOffset,
                minNativeZoom = this.options.minNativeZoom,
                maxNativeZoom = this.options.maxNativeZoom;

            if (zoomReverse) {
                zoom = maxZoom - zoom;
            }

            zoom += zoomOffset;

            if (minNativeZoom !== null && zoom < minNativeZoom) {
                return minNativeZoom;
            }

            if (maxNativeZoom !== null && zoom > maxNativeZoom) {
                return maxNativeZoom;
            }

            return zoom;
        },

        _getSubdomain: function (tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },

        // stops loading all tiles in the background layer
        _abortLoading: function () {
            var i, tile;
            for (i in this._tiles) {
                if (this._tiles[i].coords.z !== this._tileZoom) {
                    tile = this._tiles[i].el;

                    tile.onload = BaseUtils.falseFn;
                    tile.onerror = BaseUtils.falseFn;

                    if (!tile.complete) {
                        tile.src = emptyImageUrl;
                        DomUtils.remove(tile);
                    }
                }
            }
        }
    });

    TileLayer.WMS = TileLayer.extend({

        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
            service: 'WMS',
            request: 'GetMap',

            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: '',

            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: '',

            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: 'image/jpeg',

            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,

            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: '1.1.1'
        },

        options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,

            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
        },

        initialize: function (url, options) {

            this._url = url;

            var wmsParams = BaseUtils.extend({}, this.defaultWmsParams);

            // all keys that are not TileLayer options go to WMS params
            for (var i in options) {
                if (!(i in this.options)) {
                    wmsParams[i] = options[i];
                }
            }

            options = BaseUtils.setOptions(this, options);

            wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && Browser.retina ? 2 : 1);

            this.wmsParams = wmsParams;
        },

        onAdd: function (map) {

            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);

            var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
            this.wmsParams[projectionKey] = this._crs.code;

            TileLayer.prototype.onAdd.call(this, map);
        },

        getTileUrl: function (coords) {

            var tileBounds = this._tileCoordsToBounds(coords),
                nw = this._crs.project(tileBounds.getNorthWest()),
                se = this._crs.project(tileBounds.getSouthEast()),

                bbox = (this._wmsVersion >= 1.3 && this._crs === CRS.EPSG4326 ?
                    [se.y, nw.x, nw.y, se.x] :
                    [nw.x, se.y, se.x, nw.y]).join(','),

                url = TileLayer.prototype.getTileUrl.call(this, coords);

            return url +
                BaseUtils.getParamString(this.wmsParams, url, this.options.uppercase) +
                (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
        },

        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function (params, noRedraw) {

            BaseUtils.extend(this.wmsParams, params);

            if (!noRedraw) {
                this.redraw();
            }

            return this;
        }
    });

    return TileLayer;

});
/**
 * Created by eason on 2017/2/6.
 */
define('chart/map/layer/Control',['require','../../../utils/Class','../../../utils/BaseUtils','../../../dom/DomUtils'],function(require){

    var Class = require('../../../utils/Class');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');

    var Control = Class.extend({

        options: {
            position: 'bottomleft'
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        getPosition: function () {
            return this.options.position;
        },

        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function (position) {
            var map = this._map;

            if (map) {
                map.removeControl(this);
            }

            this.options.position = position;

            if (map) {
                map.addControl(this);
            }

            return this;
        },

        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function () {
            return this._container;
        },

        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function (map) {
            this.remove();
            this._map = map;

            var container = this._container = this.onAdd(map),
                pos = this.getPosition(),
                corner = map._controlCorners[pos];

            DomUtils.addClass(container, 'leaflet-control');

            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }

            return this;
        },

        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function () {
            if (!this._map) {
                return this;
            }

            DomUtils.remove(this._container);

            if (this.onRemove) {
                this.onRemove(this._map);
            }

            this._map = null;

            return this;
        },

        _refocusOnMap: function (e) {
            // if map exists and event is not a keyboard event
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
                this._map.getContainer().focus();
            }
        }
    });

    Control.Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
            position: 'bottomright',

            // @option prefix: String = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: ''
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);

            this._attributions = {};
        },

        onAdd: function (map) {
            map.attributionControl = this;
            this._container = DomUtils.create('div', 'leaflet-control-attribution');

            this._update();

            return this._container;
        },

        // @method setPrefix(prefix: String): this
        // Sets the text before the attributions.
        setPrefix: function (prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },

        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
        addAttribution: function (text) {
            if (!text) { return this; }

            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;

            this._update();

            return this;
        },

        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function (text) {
            if (!text) { return this; }

            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }

            return this;
        },

        _update: function () {
            if (!this._map) { return; }

            var attribs = [];

            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }

            var prefixAndAttribs = [];

            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(', '));
            }

            this._container.innerHTML = prefixAndAttribs.join(' | ');
        }
    });

    Control.Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
            position: 'topleft',

            // @option zoomInText: String = '+'
            // The text set on the 'zoom in' button.
            zoomInText: '+',

            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: 'Zoom in',

            // @option zoomOutText: String = '-'
            // The text set on the 'zoom out' button.
            zoomOutText: '-',

            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: 'Zoom out'
        },

        onAdd: function (map) {
            var zoomName = 'leaflet-control-zoom',
                container = DomUtils.create('div', zoomName + ' leaflet-bar'),
                options = this.options;

            this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
                zoomName + '-in',  container, this._zoomIn);
            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
                zoomName + '-out', container, this._zoomOut);

            this._updateDisabled();
            map.on('zoomend zoomlevelschange', this._updateDisabled, this);

            container.style.position = 'absolute';
            container.style.left = options._topLeft.x + 'px';
            container.style.top = options._topLeft.y + 'px';
            container.style['z-index'] = 800;
            container.style['pointer-events'] = 'auto';

            return container;
        },

        onRemove: function (map) {
            map.off('zoomend zoomlevelschange', this._updateDisabled, this);
        },

        disable: function () {
            this._disabled = true;
            this._updateDisabled();
            return this;
        },

        enable: function () {
            this._disabled = false;
            this._updateDisabled();
            return this;
        },

        _zoomIn: function (e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
                this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
        },

        _zoomOut: function (e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
                this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
        },

        _createButton: function (html, title, className, container, fn) {
            var link = DomUtils.create('a', className, container);
            link.innerHTML = html;
            link.href = '#';
            link.title = title;

            /*
             * Will force screen readers like VoiceOver to read this as "Zoom in - button"
             */
            link.setAttribute('role', 'button');
            link.setAttribute('aria-label', title);

            VanHammer
                .on(link, 'mousedown dblclick', DomUtils.stopPropagation)
                .on(link, 'click', DomUtils.stop)
                .on(link, 'click', fn.bind(this))
                .on(link, 'click', this._refocusOnMap.bind(this));

            return link;
        },

        _updateDisabled: function () {
            var map = this._map,
                className = 'leaflet-disabled';

            DomUtils.removeClass(this._zoomInButton, className);
            DomUtils.removeClass(this._zoomOutButton, className);

            if (this._disabled || map._zoom === map.getMinZoom()) {
                DomUtils.addClass(this._zoomOutButton, className);
            }
            if (this._disabled || map._zoom === map.getMaxZoom()) {
                DomUtils.addClass(this._zoomInButton, className);
            }
        }
    });


    return Control;
});
/**
 * Created by eason on 2017/1/20.
 */
define('chart/map/layer/FeatureGroup',['require','./../../../vector/shape/LayerGroup','../LatLngBounds'],function(require){

    var LayerGroup = require('./../../../vector/shape/LayerGroup');
    var LatLngBounds = require('../LatLngBounds');

    var FeatureGroup = LayerGroup.extend({

        addLayer: function (layer) {
            if (this.hasLayer(layer)) {
                return this;
            }

            layer.addEventParent(this);

            LayerGroup.prototype.addLayer.call(this, layer);

            return this;
        },

        removeLayer: function (layer) {
            if (!this.hasLayer(layer)) {
                return this;
            }
            if (layer in this._layers) {
                layer = this._layers[layer];
            }

            layer.removeEventParent(this);

            LayerGroup.prototype.removeLayer.call(this, layer);

            return this;
        },

        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function (style) {
            return this.invoke('setStyle', style);
        },

        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function () {
            return this.invoke('bringToFront');
        },

        // @method bringToBack(): this
        // Brings the layer group to the top of all other layers
        bringToBack: function () {
            return this.invoke('bringToBack');
        },

        getBounds: function () {
            var bounds = new LatLngBounds();

            for (var id in this._layers) {
                var layer = this._layers[id];
                bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }

            return bounds;
        }
    });

    return FeatureGroup;
});
/**
 * Created by eason on 2017/2/8.
 */

define('utils/LineUtils',['require','./Point2D'],function(require){

    var Point = require('./Point2D');

    return {

        // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
        // Improves rendering performance dramatically by lessening the number of points to draw.

        // @function simplify(points: Point[], tolerance: Number): Point[]
        // Dramatically reduces the number of points in a polyline while retaining
        // its shape and returns a new array of simplified points, using the
        // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
        // Used for a huge performance boost when processing/displaying Leaflet polylines for
        // each zoom level and also reducing visual noise. tolerance affects the amount of
        // simplification (lesser value means higher quality but slower and with more points).
        // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
        simplify: function (points, tolerance) {
            if (!tolerance || !points.length) {
                return points.slice();
            }

            var sqTolerance = tolerance * tolerance;

            // stage 1: vertex reduction
            points = this._reducePoints(points, sqTolerance);

            // stage 2: Douglas-Peucker simplification
            points = this._simplifyDP(points, sqTolerance);

            return points;
        },

        // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
        // Returns the distance between point `p` and segment `p1` to `p2`.
        pointToSegmentDistance:  function (p, p1, p2) {
            return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
        },

        // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
        // Returns the closest point from a point `p` on a segment `p1` to `p2`.
        closestPointOnSegment: function (p, p1, p2) {
            return this._sqClosestPointOnSegment(p, p1, p2);
        },

        // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
        _simplifyDP: function (points, sqTolerance) {

            var len = points.length,
                ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                markers = new ArrayConstructor(len);

            markers[0] = markers[len - 1] = 1;

            this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

            var i,
                newPoints = [];

            for (i = 0; i < len; i++) {
                if (markers[i]) {
                    newPoints.push(points[i]);
                }
            }

            return newPoints;
        },

        _simplifyDPStep: function (points, markers, sqTolerance, first, last) {

            var maxSqDist = 0,
                index, i, sqDist;

            for (i = first + 1; i <= last - 1; i++) {
                sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist > sqTolerance) {
                markers[index] = 1;

                this._simplifyDPStep(points, markers, sqTolerance, first, index);
                this._simplifyDPStep(points, markers, sqTolerance, index, last);
            }
        },

        // reduce points that are too close to each other to a single point
        _reducePoints: function (points, sqTolerance) {
            var reducedPoints = [points[0]];

            for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                    reducedPoints.push(points[i]);
                    prev = i;
                }
            }
            if (prev < len - 1) {
                reducedPoints.push(points[len - 1]);
            }
            return reducedPoints;
        },


        // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
        // Clips the segment a to b by rectangular bounds with the
        // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
        // (modifying the segment points directly!). Used by Leaflet to only show polyline
        // points that are on the screen or near, increasing performance.
        clipSegment: function (a, b, bounds, useLastCode, round) {
            var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                codeB = this._getBitCode(b, bounds),

                codeOut, p, newCode;

            // save 2nd code to avoid calculating it on the next segment
            this._lastCode = codeB;

            while (true) {
                // if a,b is inside the clip window (trivial accept)
                if (!(codeA | codeB)) {
                    return [a, b];
                }

                // if a,b is outside the clip window (trivial reject)
                if (codeA & codeB) {
                    return false;
                }

                // other cases
                codeOut = codeA || codeB;
                p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
                newCode = this._getBitCode(p, bounds);

                if (codeOut === codeA) {
                    a = p;
                    codeA = newCode;
                } else {
                    b = p;
                    codeB = newCode;
                }
            }
        },

        _getEdgeIntersection: function (a, b, code, bounds, round) {
            var dx = b.x - a.x,
                dy = b.y - a.y,
                min = bounds.min,
                max = bounds.max,
                x, y;

            if (code & 8) { // top
                x = a.x + dx * (max.y - a.y) / dy;
                y = max.y;

            } else if (code & 4) { // bottom
                x = a.x + dx * (min.y - a.y) / dy;
                y = min.y;

            } else if (code & 2) { // right
                x = max.x;
                y = a.y + dy * (max.x - a.x) / dx;

            } else if (code & 1) { // left
                x = min.x;
                y = a.y + dy * (min.x - a.x) / dx;
            }

            return new Point(x, y, round);
        },

        _getBitCode: function (p, bounds) {
            var code = 0;

            if (p.x < bounds.min.x) { // left
                code |= 1;
            } else if (p.x > bounds.max.x) { // right
                code |= 2;
            }

            if (p.y < bounds.min.y) { // bottom
                code |= 4;
            } else if (p.y > bounds.max.y) { // top
                code |= 8;
            }

            return code;
        },

        // square distance (to avoid unnecessary Math.sqrt calls)
        _sqDist: function (p1, p2) {
            var dx = p2.x - p1.x,
                dy = p2.y - p1.y;
            return dx * dx + dy * dy;
        },

        // return closest point on segment or distance to that point
        _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
            var x = p1.x,
                y = p1.y,
                dx = p2.x - x,
                dy = p2.y - y,
                dot = dx * dx + dy * dy,
                t;

            if (dot > 0) {
                t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = p.x - x;
            dy = p.y - y;

            return sqDist ? dx * dx + dy * dy : new Point(x, y);
        },

        clipPolygon:function(points, bounds, round){

            var clippedPoints,
                edges = [1, 4, 2, 8],
                i, j, k,
                a, b,
                len, edge, p;

            for (i = 0, len = points.length; i < len; i++) {
                points[i]._code = this._getBitCode(points[i], bounds);
            }

            // for each edge (left, bottom, right, top)
            for (k = 0; k < 4; k++) {
                edge = edges[k];
                clippedPoints = [];

                for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                    a = points[i];
                    b = points[j];

                    // if a is inside the clip window
                    if (!(a._code & edge)) {
                        // if b is outside the clip window (a->b goes out of screen)
                        if (b._code & edge) {
                            p = this._getEdgeIntersection(b, a, edge, bounds, round);
                            p._code = this._getBitCode(p, bounds);
                            clippedPoints.push(p);
                        }
                        clippedPoints.push(a);

                        // else if b is inside the clip window (a->b enters the screen)
                    } else if (!(b._code & edge)) {
                        p = this._getEdgeIntersection(b, a, edge, bounds, round);
                        p._code = this._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                }
                points = clippedPoints;
            }

            return points;
        }
    };
});
/**
 * Created by eason on 2017/1/20.
 */
define('chart/map/layer/GeoJSON',['require','./FeatureGroup','../../../utils/BaseUtils','../../../utils/Point2D','../../../utils/Bounds','../LatLng','../LatLngBounds','../Marker','../../../vector/shape/Path','../../../utils/LineUtils'],function(require){

    var FeatureGroup = require('./FeatureGroup');
    var BaseUtils = require('../../../utils/BaseUtils');
    var Point = require('../../../utils/Point2D');
    var Bounds = require('../../../utils/Bounds');
    var LatLng = require('../LatLng');
    var LatLngBounds = require('../LatLngBounds');
    var Marker = require('../Marker');
    var Path = require('../../../vector/shape/Path');
    var LineUtils = require('../../../utils/LineUtils');

    var GeoJSON = FeatureGroup.extend({

        initialize: function (geojson, options) {
            BaseUtils.setOptions(this, options);

            this._layers = {};

            this._featureLayerMap = {};

            if (geojson) {
                this.addData(geojson);
            }
        },

        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function (geojson) {
            var features = BaseUtils.isArray(geojson) ? geojson : geojson.features,
                i, len, feature;

            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    // only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        this.addData(feature);
                    }
                }
                return this;
            }

            var options = this.options;

            if (options.filter && !options.filter(geojson)) { return this; }

            var layer = this.geometryToLayer(geojson, options);
            if (!layer) {
                return this;
            }

            layer.options = BaseUtils.extend({}, this.options);
            this._featureLayerMap[BaseUtils.stamp(geojson)] = layer;

            return this.addLayer(layer);
        },

        getLayerByFeature:function(geoJson){
            return this._featureLayerMap[BaseUtils.stamp(geoJson)];
        },

        geometryToLayer: function (geojson, options) {

            var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                coords = geometry ? geometry.coordinates : null,
                layers = [],
                coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
                latlng, latlngs, i, len;

            if (!coords && !geometry) {
                return null;
            }

            switch (geometry.type) {
                case 'Polygon':
                case 'MultiPolygon':
                    latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
                    return new Polygon(latlngs, options);

                case 'GeometryCollection':
                    for (i = 0, len = geometry.geometries.length; i < len; i++) {
                        var layer = this.geometryToLayer({
                            geometry: geometry.geometries[i],
                            type: 'Feature',
                            properties: geojson.properties
                        }, options);

                        if (layer) {
                            layers.push(layer);
                        }
                    }
                    return new FeatureGroup(layers);
            }
        },

        // @function coordsToLatLng(coords: Array): LatLng
        // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
        // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
        coordsToLatLng: function (coords) {
            return new LatLng(coords[1], coords[0], coords[2]);
        },

        // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
        // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
        // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
        // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
        coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
            var latlngs = [];

            for (var i = 0, len = coords.length, latlng; i < len; i++) {
                latlng = levelsDeep ?
                    this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
                    (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                latlngs.push(latlng);
            }

            return latlngs;
        },

        // @function latLngToCoords(latlng: LatLng): Array
        // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
        latLngToCoords: function (latlng) {
            return latlng.alt !== undefined ?
                [latlng.lng, latlng.lat, latlng.alt] :
                [latlng.lng, latlng.lat];
        },

        // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
        // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
        // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
        latLngsToCoords: function (latlngs, levelsDeep, closed) {
            var coords = [];

            for (var i = 0, len = latlngs.length; i < len; i++) {
                coords.push(levelsDeep ?
                    GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
                    GeoJSON.latLngToCoords(latlngs[i]));
            }

            if (!levelsDeep && closed) {
                coords.push(coords[0]);
            }

            return coords;
        },

        // @function asFeature(geojson: Object): Object
        // Normalize GeoJSON geometries/features into GeoJSON features.
        asFeature: function (geojson) {
            if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
                return geojson;
            }

            return {
                type: 'Feature',
                properties: {},
                geometry: geojson
            };
        }
    });

    var Polyline = Path.extend({

        initialize: function (latlngs, options) {
            BaseUtils.setOptions(this, options);
            this._setLatLngs(latlngs);
        },

        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function () {
            return this._latlngs;
        },

        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function (latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
        },

        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function () {
            return !this._latlngs.length;
        },

        closestLayerPoint: function (p) {
            var minDistance = Infinity,
                minPoint = null,
                closest = LineUtils._sqClosestPointOnSegment,
                p1, p2;

            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
                var points = this._parts[j];

                for (var i = 1, len = points.length; i < len; i++) {
                    p1 = points[i - 1];
                    p2 = points[i];

                    var sqDist = closest(p, p1, p2, true);

                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = closest(p, p1, p2);
                    }
                }
            }
            if (minPoint) {
                minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
        },

        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function () {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) {
                throw new Error('Must add layer to map before using getCenter()');
            }

            var i, halfDist, segDist, dist, p1, p2, ratio,
                points = this._rings[0],
                len = points.length;

            if (!len) { return null; }

            // polyline centroid algorithm; only uses the first ring if there are multiple

            for (i = 0, halfDist = 0; i < len - 1; i++) {
                halfDist += points[i].distanceTo(points[i + 1]) / 2;
            }

            // The line is so small in the current view that all points are on the same pixel.
            if (halfDist === 0) {
                return this._map.layerPointToLatLng(points[0]);
            }

            for (i = 0, dist = 0; i < len - 1; i++) {
                p1 = points[i];
                p2 = points[i + 1];
                segDist = p1.distanceTo(p2);
                dist += segDist;

                if (dist > halfDist) {
                    ratio = (dist - halfDist) / segDist;
                    return this._map.layerPointToLatLng([
                        p2.x - ratio * (p2.x - p1.x),
                        p2.y - ratio * (p2.y - p1.y)
                    ]);
                }
            }
        },

        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function () {
            return this._bounds;
        },

        // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function (latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = LatLng.create(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
        },

        _setLatLngs: function (latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
        },

        _defaultShape: function () {
            return Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },

        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function (latlngs) {
            var result = [],
                flat = Polyline._flat(latlngs);

            for (var i = 0, len = latlngs.length; i < len; i++) {
                if (flat) {
                    result[i] = LatLng.create(latlngs[i]);
                    this._bounds.extend(result[i]);
                } else {
                    result[i] = this._convertLatLngs(latlngs[i]);
                }
            }

            return result;
        },

        _project: function () {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);

            var w = this._clickTolerance(),
                p = new Point(w, w);

            if (this._bounds.isValid() && pxBounds.isValid()) {
                pxBounds.min._subtract(p);
                pxBounds.max._add(p);
                this._pxBounds = pxBounds;
            }
        },

        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function (latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng,
                len = latlngs.length,
                i, ring;

            if (flat) {
                ring = [];
                for (i = 0; i < len; i++) {
                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                    projectedBounds.extend(ring[i]);
                }
                result.push(ring);
            } else {
                for (i = 0; i < len; i++) {
                    this._projectLatlngs(latlngs[i], result, projectedBounds);
                }
            }
        },

        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function () {
            var bounds = this._renderer._bounds;

            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                return;
            }

            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }

            var parts = this._parts,
                i, j, k, len, len2, segment, points;

            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
                points = this._rings[i];

                for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                    segment = LineUtils.clipSegment(points[j], points[j + 1], bounds, j, true);

                    if (!segment) { continue; }

                    parts[k] = parts[k] || [];
                    parts[k].push(segment[0]);

                    // if segment goes out of screen, or it's the last one, it's the end of the line part
                    if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
                        parts[k].push(segment[1]);
                        k++;
                    }
                }
            }
        },

        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function () {
            var parts = this._parts,
                tolerance = this.options.smoothFactor;

            for (var i = 0, len = parts.length; i < len; i++) {
                parts[i] = LineUtils.simplify(parts[i], tolerance);
            }
        },

        _update: function () {
            if (!this._map) { return; }

            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
        },

        _updatePath:function(){
            this._updatePoly();
        },

        _updatePoly: function (closed) {
            this._path.attr('d', this.pointsToPath(this._parts, closed));
        },

        pointsToPath: function (rings, closed) {
            var str = '',
                i, j, len, len2, points, p;

            for (i = 0, len = rings.length; i < len; i++) {
                points = rings[i];

                for (j = 0, len2 = points.length; j < len2; j++) {
                    p = points[j];
                    str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
                }

                // closes the ring for polygons; "x" is VML syntax
                str += closed ? 'z' : '';
            }

            // SVG complains about empty path strings
            return str || 'M0 0';
        },

        _containsPoint:function(p, closed){
            var i, j, k, len, len2, part,
                w = this._clickTolerance();

            if (!this._pxBounds.contains(p)) { return false; }

            // hit detection for polylines
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];

                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    if (!closed && (j === 0)) { continue; }

                    if (LineUtils.pointToSegmentDistance(p, part[k], part[j]) <= w) {
                        return true;
                    }
                }
            }
            return false;
        }
    });

    Polyline._flat = function (latlngs) {
        // true if it's a flat array of latlngs; false if nested
        return !BaseUtils.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
    };

    var Polygon = Polyline.extend({

        isEmpty: function () {
            return !this._latlngs.length || !this._latlngs[0].length;
        },

        getCenter: function () {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) {
                throw new Error('Must add layer to map before using getCenter()');
            }

            var i, j, p1, p2, f, area, x, y, center,
                points = this._rings[0],
                len = points.length;

            if (!len) { return null; }

            // polygon centroid algorithm; only uses the first ring if there are multiple

            area = x = y = 0;

            for (i = 0, j = len - 1; i < len; j = i++) {
                p1 = points[i];
                p2 = points[j];

                f = p1.y * p2.x - p2.y * p1.x;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
                area += f * 3;
            }

            if (area === 0) {
                // Polygon is so small that all points are on same pixel.
                center = points[0];
            } else {
                center = [x / area, y / area];
            }
            return this._map.layerPointToLatLng(center);
        },

        _convertLatLngs: function (latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
                len = result.length;

            // remove last point if it equals first one
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
                result.pop();
            }
            return result;
        },

        _setLatLngs: function (latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (Polyline._flat(this._latlngs)) {
                this._latlngs = [this._latlngs];
            }
        },

        _defaultShape: function () {
            return Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },

        _clipPoints: function () {
            // polygons need a different clipping algorithm so we redefine that

            var bounds = this._renderer._bounds,
                w = this.options['stroke-width'],
                p = new Point(w, w);

            // increase clip padding by stroke width to avoid stroke on clip edges
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                return;
            }

            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }

            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
                clipped = LineUtils.clipPolygon(this._rings[i], bounds, true);
                if (clipped.length) {
                    this._parts.push(clipped);
                }
            }
        },

        _updatePath:function(){
            this._updatePoly(true);
        },

        _containsPoint:function(p){
            var inside = false,
                part, p1, p2, i, j, k, len, len2;

            if (!this._pxBounds.contains(p)) { return false; }

            // ray casting algorithm for detecting if point is in polygon
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];

                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    p1 = part[j];
                    p2 = part[k];

                    if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                        inside = !inside;
                    }
                }
            }

            // also check if it's on polygon stroke
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
    });

    return GeoJSON;
});
/**
 * Created by eason on 2017/3/17.
 */

define('utils/getJson',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }

    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }

    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = BaseUtils.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) { request = new XDomainRequest(); }
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                result = response.call(xhr, request);
                callback(result);
            }
        }

        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) { return headers[name]; }
            if (value == null) { delete headers[name];} else { headers[name] = value + ""; }
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) { return mimeType; }
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) { return responseType; }
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(BaseUtils.toArray(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") { callback = data; data = null; }
            request.open(method, url, false);
            if (mimeType != null && !("accept" in headers)) { headers["accept"] = mimeType + ",*/*"; }
            if (request.setRequestHeader) { for (var name in headers) { request.setRequestHeader(name, headers[name]); } }
            if (mimeType != null && request.overrideMimeType) { request.overrideMimeType(mimeType); }
            if (responseType != null) { request.responseType = responseType; }
            if (callback != null) {
                xhr.on("error", callback).on("load", function (request) {
                    callback(null, request);
                });
            }
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        BaseUtils.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }

    function d3_json(request) {
        return JSON['parse'](request.responseText);
    }

    return function(url, callback){
        return d3_xhr(url, "application/json", d3_json, callback)
    };

});
/**
 * Created by eason on 16/5/23.
 * 地理坐标系的定义
 */

define('component/Geo',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../utils/GeoUtils','../Constants','../ComponentLibrary','../chart/map/layer/ImageOverlay','../chart/map/layer/TileLayer','../chart/map/layer/Control','../chart/map/layer/GeoJSON','../utils/getJson','../chart/map/CRS','../chart/map/LatLngBounds'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var GeoUtils = require('../utils/GeoUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var _loadedLayerMap = {};//避免创建重复的tileLayer
    var ImageOverlay = require('../chart/map/layer/ImageOverlay');
    var TileLayer = require('../chart/map/layer/TileLayer');
    var Control = require('../chart/map/layer/Control');
    var GeoJSON = require('../chart/map/layer/GeoJSON');
    var getJson = require('../utils/getJson');
    var CRS = require('../chart/map/CRS');
    var LatLngBounds = require('../chart/map/LatLngBounds');

    var POINT  = 'Point';
    var LINE_STRING = 'LineString';
    var MULTI_LINE_STRING = 'MultiLineString';

    function get(resource){
        var mapData;
        if(resource && typeof resource === 'object'){
            mapData = resource;
        }else{
            if(window.FR && window.FR.ajax){
                FR.ajax({
                    type: 'GET',
                    url: resource,
                    dataType: 'json',
                    async: false,
                    success: function (result) {
                        mapData = result;
                    }
                });
            } else {
                getJson(resource, function (result) {
                    mapData = result;
                });
            }
        }
        return mapData;
    }

    var Geo = Base.extend({

        _refresh:function(){
            this._loaded = false;

            var vanchartsID = BaseUtils.stamp(this.vanchart);
            _loadedLayerMap[vanchartsID] = _loadedLayerMap[vanchartsID] || {};
        },

        doLayout:function(){

            this._loadGeo();

            var map = this.vanchart, options = this.options;
            var level;
            if(BaseUtils.hasDefined(options.zoomListener)){
                level = options.zoomListener;
            }else if(BaseUtils.hasDefined(options.zoomLevel)){
                level = options.zoomLevel;
            }

            var center = options.viewCenter ? [options.viewCenter[1], options.viewCenter[0]] : null;

            var isValidLevel = !isNaN(+level);

            if (isValidLevel && center) { // has level, has center
                map.setView(center, level);
            } else {
                var _fitBounds = this._getFitBounds();

                if (isValidLevel) { // has level, no center
                    // get center
                    map.fitBounds(_fitBounds, {animate:false});
                    // than set level
                    center = map.getCenter();
                    map.setView(center, level);
                } else { // no level, ?center
                    map.fitBounds(_fitBounds);
                }
                // force refresh background in case of blank
                if (center = map.getCenter()) {
                    map.panTo(center, {animate:false});
                }
            }

            this._topLeft = {x:0, y:map.bounds.y};
        },

        render:function(){

            var options = this.options, json = this.jsonData, vanchartsID = BaseUtils.stamp(this.vanchart);

            var url = options.tileLayer || this.vanchart.options.geo.tileLayer;
            var attribution = options.attribution || this.vanchart.options.geo.attribution || '';

            var wmsUrl = options.wmsUrl || this.vanchart.options.geo.wmsUrl;
            var wmsLayer = options.wmsLayer || this.vanchart.options.geo.wmsLayer;

            var lastLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;
            this._imageBackgroundLayer = this._tileLayer = this._wmsLayer = null;

            if(this._isImageMap() && (options.imageUrl || json.imageString)){

                var imageUrl = options.imageUrl || ("data:image/"+json.imageSuffix+";base64," + json.imageString);

                var bounds = [[0,0], [json.imageHeight * this.scale, json.imageWidth * this.scale]];

                this._imageBackgroundLayer = new ImageOverlay(imageUrl, bounds).addTo(this.vanchart);

            }else if(url){

                this._attribution = _loadedLayerMap[vanchartsID][attribution] || new Control.Attribution().addAttribution(attribution);
                _loadedLayerMap[vanchartsID][attribution] = this._attribution;

                this._tileLayer = _loadedLayerMap[vanchartsID][url] || new TileLayer(url);
                _loadedLayerMap[vanchartsID][url] = this._tileLayer;

                _loadedLayerMap[vanchartsID][url].addTo(this.vanchart);
                _loadedLayerMap[vanchartsID][attribution].addTo(this.vanchart);

            }else if(wmsUrl){

                this._wmsLayer = _loadedLayerMap[vanchartsID][wmsUrl] || new TileLayer.WMS(wmsUrl, {layers: wmsLayer.join(',')});
                _loadedLayerMap[vanchartsID][wmsUrl] = this._wmsLayer;

                _loadedLayerMap[vanchartsID][wmsUrl].addTo(this.vanchart);
            }

            this.renderAreaFeatures();

            if(options.control){
                options._topLeft = this._topLeft;
                this._zoomControl = this._zoomControl || new Control.Zoom(options).addTo(this.vanchart);  // @CHART-990
            }

            //updateLayer
            var currentLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;
            if(lastLayer && lastLayer != currentLayer){
                this.vanchart.removeLayer(lastLayer);
            }
        },

        needsNullArea:function(){
            var vanchart = this.vanchart;
            return vanchart.isAreaMap() || vanchart.isHeatMap() || vanchart.seriesOfType(Constants.AREA_MAP).length;
        },

        renderAreaFeatures:function(){
            if(this.needsNullArea()){
                var options =  this.defaultAreaStyle();
                this.geoJsonLayer = this.geoJsonLayer || new GeoJSON(this.jsonData, options);
                this.geoJsonLayer.addTo(this.vanchart);
            }
        },

        getLayerByFeature:function(feature){
            return this.geoJsonLayer.getLayerByFeature(feature);
        },

        defaultAreaStyle:function(){
            var plotOptions = this.vanchart.options.plotOptions;
            var queryList = [plotOptions[Constants.AREA_MAP], plotOptions];
            return {
                'fill':BaseUtils.pick(QueryUtils.queryList(queryList, 'nullColor'), '#cccccc'),
                'fill-opacity':BaseUtils.pick(QueryUtils.queryList(queryList, 'opacity'), 0.75) ,
                'stroke-width':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderWidth'), 1),
                'stroke':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderColor'), '#ffffff'),
                'stroke-opacity':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderOpacity'), 1)
            };
        },

        geoName:function(){
            return this.options.name;
        },

        _loadGeo:function(){

            if(this._loaded || (this._dataUrl == this.options.data)){

                this._loaded = true;

                this._checkCRS();

                return;
            }

            this._loaded = true;
            this._dataUrl = this.options.data;
            this.geoJsonLayer && this.geoJsonLayer.remove();
            this.geoJsonLayer = null;//新的data进来才置空

            var options = this.options, geo = this, vanchart = this.vanchart;

            geo._validPointName = {}, geo._validAreaName = {}, geo._extendedLineFeature = [];

            if (options.data) {
                geo.jsonData = get(options.data);
            } else {
                geo.jsonData = {};
            }

            var features = geo.jsonData && geo.jsonData.features || [];
            for(var i = 0, len = features.length; i < len; i++){
                var feature = features[i];
                var geometry = feature.geometry;
                if(geometry.type == POINT){//点地图
                    geo._validPointName[feature.properties.name] = geo._validPointName[feature.properties.name] || [];
                    geo._validPointName[feature.properties.name].push(feature);
                }else if(geometry.type == LINE_STRING || geometry.type == MULTI_LINE_STRING){
                    geo._extendedLineFeature.push(feature);
                }else{//区域地图
                    geo._validAreaName[feature.properties.name] = geo._validAreaName[feature.properties.name] || [];
                    geo._validAreaName[feature.properties.name].push(feature);
                }
            }

            this.scale = 1;
            if(this._isImageMap()){
                var chartWidth = vanchart.width, chartHeight = vanchart.height;

                var wR = chartWidth / geo.jsonData.imageWidth, wH = chartHeight / geo.jsonData.imageHeight;

                this.scale = Math.min(wR, wH);

                GeoUtils.scaleGeo(geo.jsonData, geo.scale);
            }

            this._checkCRS();
        },

        getDataPointLngLat: function (point, feature) {

            if(!feature || point.options.lnglat){
                return point.options.lnglat;
            }

            var lnglat = point.series && point.series.type == Constants.AREA_MAP ? feature.properties.center : feature.geometry.coordinates;
            if(!lnglat){
                if(this._isImageMap()){
                    var lngMin = this.jsonData.imageWidth,lngMax = 0;
                    var latMin = this.jsonData.imageHeight, latMax = 0;
                    var points = GeoUtils.getAllPoints(feature);
                    points.forEach(function (point) {

                        if(isNaN(point[0]) || isNaN(point[1])){
                            return;
                        }

                        lngMin = Math.min(lngMin, point[0]);
                        lngMax = Math.max(lngMax, point[0]);

                        latMin = Math.min(latMin, point[1]);
                        latMax = Math.max(latMax, point[1]);
                    });
                    lnglat = [(lngMax + lngMin)/2, (latMax + latMin)/2];
                }else{
                    var bounds = GeoUtils.bounds(feature);
                    var lng = (bounds[0][0] + bounds[1][0])/2;
                    var lat = (bounds[0][1] + bounds[1][1])/2;
                    lnglat = [lng, lat];
                }
            }
            return lnglat;
        },

        getZoomListener:function(){
            return this.options.zoomListener || this.options.zoomLevel;
        },

        getFeaturesByName:function(name, type){
            this._loadGeo();

            if(!this._validAreaName || !this._validPointName){
                return;//data为空
            }

            return type == Constants.AREA_MAP ? this._validAreaName[name] : this._validPointName[name];
        },

        _isImageMap:function(){
            return this.jsonData && this.jsonData.imageWidth;
        },

        _checkCRS:function () {
            this.vanchart.options.crs = this._isImageMap() ? CRS.Simple : CRS.EPSG3857;
        },

        //这个fitbounds既需要考虑json文件,还要考虑点地图的时候的在数据里写死了经纬度
        _getFitBounds:function(){
            //先统计数据里写死的经纬度信息,已写死的经纬度信息为准
            var byJson = true, geo = this;
            var lngMin = 180, lngMax = -180, latMin = 90, latMax = -90;

            if(this._isImageMap()){
                lngMin = this.jsonData.imageWidth * this.scale; lngMax = 0;
                latMin = this.jsonData.imageHeight * this.scale; latMax = 0;
            }else{
                var series = this.vanchart.series;
                for(var i = 0, len = series.length; i < len; i++){
                    if(series[i].visible && series[i].type != Constants.AREA_MAP){
                        if (series[i].type === Constants.LINE_MAP) {
                            series[i].points.forEach(function (item) {
                                getLngLatMinMax(item.options.from);
                                getLngLatMinMax(item.options.to);
                            });
                        } else {
                            series[i].points.forEach(getLngLatMinMax);
                        }
                    }
                }

                if(byJson && this.jsonData && this.jsonData.features.length){
                    var fitBounds = GeoUtils.bounds(this.jsonData);
                    var southWest = fitBounds[0];
                    var northEast = fitBounds[1];
                    return [[southWest[1], southWest[0]], [northEast[1], northEast[0]]];
                }
            }

            function getLngLatMinMax(point){
                // lineMap:
                // from.lnglat, from.name;
                // others:
                // p.options.lnglat, p.name
                //
                // lineMap from,to get lnglat in Normalizer.
                //
                var lnglat = point.lnglat || point.options.lnglat;
                if(!lnglat){
                    var features = geo.getFeaturesByName(point.name, point.series.type);
                    lnglat = geo.getDataPointLngLat(point, features && features[0]);
                }

                if(lnglat){
                    //只有写死在数据里的经纬度才能按照经纬度来定位
                    byJson = false;

                    lngMin = Math.min(lngMin, lnglat[0]);
                    lngMax = Math.max(lngMax, lnglat[0]);

                    latMin = Math.min(latMin, lnglat[1]);
                    latMax = Math.max(latMax, lnglat[1]);
                }
            }

            return [[Math.min(latMin, latMax), Math.min(lngMin, lngMax)],[Math.max(latMax, latMin), Math.max(lngMax, lngMin)]];
        },

        remove:function(){
            this.geoJsonLayer && this.geoJsonLayer.remove();//不能置空

            if(this.geoJsonLayer){
                var defaultOptions = this.geoJsonLayer.options;
                // 这边remove的时候，将所有的layer的option重置为默认.否则下次addTo(vanchart)，使用的样式就不对了
                this.geoJsonLayer.eachLayer(function (layer){
                    layer.options = BaseUtils.extend({}, defaultOptions);
                }, this);
            }

            this._imageBackgroundLayer && this.vanchart.removeLayer(this._imageBackgroundLayer);
            this._attribution && this._attribution.remove();
            this._tileLayer && this._tileLayer.remove();
            this._wmsLayer && this._wmsLayer.remove();

            this._imageBackgroundLayer = this._attribution = this._tileLayer = this._wmsLayer;
        },

        resize:function(){
            if(!this._isImageMap()){
                return;
            }

            var options = this.options, json = this.jsonData, lastScale = this.scale;

            var vanchart = this.vanchart, chartWidth = vanchart.width, chartHeight = vanchart.height;

            var wR = chartWidth / json.imageWidth, wH = chartHeight / json.imageHeight;

            this.scale = Math.min(wR, wH);

            GeoUtils.scaleGeo(json, this.scale / lastScale);

            if(this._imageBackgroundLayer){
                var bounds = [[0,0], [json.imageHeight * this.scale, json.imageWidth * this.scale]];
                this._imageBackgroundLayer.setBounds(LatLngBounds.create(bounds));
            }

            if(this.geoJsonLayer){
                this.geoJsonLayer.remove();
                this.geoJsonLayer = null;
                vanchart.validPoints.forEach(function(point){
                    if(point.series.type == Constants.AREA_MAP){
                        point.layers = null;
                    }
                });
            }
        }
    });

    ComponentLibrary.register(ComponentLibrary.GEO_COMPONENT, Geo);
    return Geo;
});
/**
 * Created by eason on 16/5/17.
 */
define('component/DrillTools',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var FIRST_LEFT_PADDING = 0.417;
    var LEFT_PADDING = 0.583;
    var RIGHT_PADDING = 0.25;
    var ARROW_SIZE = 0.333;
    var TOP_PADDING = 0.1665;

    var PADDING = 8; 
    var PADDING_FUN = function () { 
        return BaseUtils.paddingConvertWithScale(PADDING) 
    }; 

    var DrillTools = Base.extend({

        _refresh:function(){
            this.iconData = [];
        },

        doLayout:function(){
            BaseUtils.calculateFontSizeWithScale(this.options && this.options.style);
            var dim = BaseUtils.getTextDimension('test', this.options.style);
            this._setComponentBounds(Constants.TOP, dim.height * (TOP_PADDING * 2 + 1));
        },

        getBookMarkPath:function(d){

            var style = this.options.style, index = d.layerIndex;
            var dim = BaseUtils.getTextDimension(d.geo.geoName(), style);

            var rectWidth = (index === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            rectWidth = dim.height * rectWidth + dim.width;
            var arrowWidth = dim.height * ARROW_SIZE;
            var rectHeight = (1 + TOP_PADDING * 2) * dim.height;

            var ltop = [0,0], rtop = [rectWidth, 0], cp = [rectWidth + arrowWidth, rectHeight/2];
            var rbottom = [rectWidth, rectHeight], lbottom = [0, rectHeight];

            return 'M' + ltop + 'L' + rtop + 'L' + cp + 'L' + rbottom + 'L' + lbottom + 'Z';
        },

        isCurrent:function(d){
            var currentD = this.iconData[this.iconData.length - 1];
            return  currentD.series == d.series;
        },

        textColor:function(d){
            return this.isCurrent(d) ? this.options.currentColor : this.options.style.color;
        },

        mouseOverColor:function(d){
            var mouseOverColor;
            if(!(mouseOverColor = this.options.mouseOverColor)){
                var textColor = this.textColor(d);
                var rgba = ColorUtils.getRGBAColorArray(textColor);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var rgb = ColorUtils.hsb2rgb(hsb[0], hsb[1]/2, (hsb[2] + 1)/2);
                mouseOverColor = ColorUtils.toColor(rgb, 'rgb');
            }
            return mouseOverColor;
        },

        leftPadding:function(d){
            return d.layerIndex === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING;
        },

        calculateExitAnimation:function(exitData){
            var time = 600;
            var i = 0, len = exitData.length;
            for(; i < len; i++){
                exitData[i].time = time;
                time = Math.max(time - 100, 0);
            }

            var delay = 0;
            for(i = len - 1; i >= 0; i--){
                if(exitData[i].time){
                    exitData[i].delay = delay;
                    delay += 200;
                }else{
                    exitData[i].delay = 0;
                }
            }
        },

        getMarkPos:function(d){
            var x = 0;
            for(var i = 0; i < d.layerIndex; i++){
                x += this.getBookMarkLength(this.iconData[i], i);
            }
            return x;
        },

        getMarkAnimationStartPos:function(d){
            var index = d.layerIndex;
            return index === 0 ? 0 : (this.getMarkPos(this.iconData[index - 1]) - this.getBookMarkLength(d, index));
        },

        getBookMarkLength:function(data, index){
            var textHeight = BaseUtils.getTextDimension(data.geo.geoName(), this.options.style).height;
            var length = BaseUtils.getTextDimension(data.geo.geoName(), this.options.style).width;
            var padding = (index === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            return length + padding * textHeight;
        },

        render:function(){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer;
            var clipBounds = {'x':0, 'y':0, 'width':this.bounds.width, 'height':this.bounds.height + PADDING_FUN()};
            if(!this.dToolsGroup){
                this.dToolsGroup = this.createComponentGroup();
                this.clip = renderer.createClip(clipBounds);
                this.shadow = renderer.createDropShadowFilter(0, 0, 0.15, 1);
                renderer.clip(this.dToolsGroup, this.clip);
                this.drillItems = [];
                vanchart.registerInteractiveTarget(this, this.dToolsGroup);
            }

            this.iconData = this.vanchart.layerMap;
            this.dToolsGroup.attr('transform', BaseUtils.makeTranslate([this.bounds.x, this.bounds.y + PADDING_FUN()]));
            renderer.updateClip(this.clip, clipBounds);

            for(var i = this.iconData.length - 1; i >= 0; i--) {
                var d = this.iconData[i];

                if(!this.drillItems[i]){
                    d.aniStart = this.getMarkAnimationStartPos(d);
                    d.aniEnd = this.getMarkPos(d);
                    this.drillItems[i] = this._createItem(d);
                }else{
                    var item = this.drillItems[i];
                    item.datum(d); 
                    item.path.attr({'d':dTools.getBookMarkPath(d)});
                    item.text
                        .style(BaseUtils.extend({},this.options.style))  
                        .attr(dTools._getTextAttr(d))
                        .style({'fill':this.textColor(d)})
                        .textContent(d.geo.geoName());
                }
            }

            var exitItems = this.drillItems.splice(this.iconData.length, this.drillItems.length);

            this.calculateExitAnimation(exitItems);
            for(var i = 0, len = exitItems.length; i < len; i++){
                var d = exitItems[i];
                d.animate({
                    duration:d.time,
                    delay:d.delay,
                    ease:'quad-in',
                    attr:{
                        transform:BaseUtils.makeTranslate([d.datum().aniStart, 0]),
                        opacity:0
                    }
                }).remove();
            }

            this.drillItems.length = this.iconData.length;
        },

        _createItem:function(d){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer;
            var cfg = this.options;

            var item = renderer.group().style({'cursor': 'pointer'}).datum(d);
            item.path = renderer.path({'d':dTools.getBookMarkPath(d)})
                .style({
                    'fill':cfg.backgroundColor,
                    "filter":'url(#'+ BaseUtils.stamp(this.shadow) +')'
                })
                .addTo(item);

            item.text = renderer.text()
                .attr(dTools._getTextAttr(d))
                .style(cfg.style).style({'fill':this.textColor(d)}).textContent(d.geo.geoName()).addTo(item);

            item.attr('transform', BaseUtils.makeTranslate([d.aniStart, 0])).addTo(this.dToolsGroup)
                .animate({
                    duration:500,
                    ease:'cubic-out',
                    attr:{transform:BaseUtils.makeTranslate([d.aniEnd, 0])}
                });

            BaseUtils.toBack(item.node());
            return item;
        },

        _findDrillTarget:function(ev){

            var event = ev.srcEvent, src = event.target || event.srcElement;

            var target;
            while (src) {

                for(var i = this.drillItems.length - 1; i >= 0; i--){
                    if(this.drillItems[i].node() == src){
                        target = this.drillItems[i];
                    }
                }

                if (target || src == this.dToolsGroup.node()){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        onTap:function(ev){
            var target = this._findDrillTarget(ev);
            var index = this.drillItems.indexOf(target);
            var iconData = this.vanchart.layerMap[index];
            if(target && iconData){
                var iconData = target.datum();
                if(this.options.click && iconData.drillUpDataPoint){
                    var click = BaseUtils.getFormatterFunction(this.options.click);
                    click(iconData.drillUpDataPoint, ev.srcEvent);
                }

                this.vanchart.drillUp(iconData);
            }
        },

        onMouseOver:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.mouseOverColor(target.datum())});
            }
        },

        onMouseOut:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.textColor(target.datum())});
            }
        },

        getEvents:function(){
            return {
                "tap":this.onTap,

                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut
            }
        },

        remove:function(){
            this.dToolsGroup && this.dToolsGroup.remove();
            this.dToolsGroup = null;
            this.iconData = this.drillItems = [];
        },

        _getTextAttr: function(d){
            var cfg = this.options, textHeight = BaseUtils.getTextDimension(d.geo.geoName(), cfg.style).height;

            return {
                'x':this.leftPadding(d) * textHeight,
                'y':(TOP_PADDING) * textHeight,
                'dy': "0.85em"
            }
        }
    });

    ComponentLibrary.register(ComponentLibrary.DRILL_TOOLS, DrillTools);
    return DrillTools;
});
/**
 * Created by eason on 15/5/4.
 * 数据表
 */
define('component/DataSheet',['require','./Base','../utils/BaseUtils','../Constants','./LegendIconFactory','../ComponentLibrary','../utils/BezierEasing','../utils/QueryUtils'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var ComponentLibrary = require('../ComponentLibrary');
    var BezierEasing = require('../utils/BezierEasing');
    var QueryUtils = require('../utils/QueryUtils');
    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var PADDING_GAP = 4;
    var PADDING_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING_GAP);
    };

    var ICON_GAP = 2;
    var ICON_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(ICON_GAP);
    };

    var MAX_ICON_SIZE = 18;

    var STYLE = { color : "#666666", fontSize: "14px", fontFamily:"Verdana"};

    var DataSheet = Base.extend({

        /**
         *数据表的对象要先于坐标轴存在，但是大小需要最后确定
         */
        doLayout:function(){
            this._recordForPlotBounds(Constants.LEFT, Math.round(this.getSeriesNameLength()));
        },

        reCalculateSize:function(){
            this.doLayout();
        },

        updateAxisSizeAndBounds:function(){
            this.maxCateLineHeight = this.maxSeriesLineHeight = null;

            this._setComponentBounds(Constants.BOTTOM, this._calculateLineHeight());
        },

        //只有重新布局的时候才会重新计算每行的高度
        // 计算每一行的高度，和整个数据表占的总高度
        _calculateLineHeight:function(){
            this.calculateShowText();

            //开始计算高度
            var cateStyle = this._categoryStyle(), valueHeight = 0;
            var seriesLineHeight = Math.ceil(BaseUtils.getTextHeight(this._seriesStyle()));  // 计算字体大小时候取整,防止绘制表格线时出现很细小的间距

            var borderWidth = this.options.borderWidth;

            this.maxCateLineHeight = PADDING_GAP_FUN() * (this.maxCateLine + 1) + this.maxCateLine * Math.ceil(BaseUtils.getTextHeight(cateStyle)) + borderWidth * 2;

            this.maxSeriesLineHeight = [];
            // 计算每个系列文字的高度，然后个对应的正文行高比较，得出最大值即是当前行的行高
            for(var sIndex = 0, sCount = this.seriesNames.length; sIndex < sCount; sIndex++){

                var s_count = this.maxSeriesLine[sIndex];
                var s_height = s_count * seriesLineHeight + (s_count + 1) * PADDING_GAP_FUN() + borderWidth * 2;

                this.maxSeriesLineHeight[sIndex] = Math.max(s_height, this.maxValueLineHeight[sIndex]);

                valueHeight += this.maxSeriesLineHeight[sIndex];
            }

            this.sheetHeight = Math.ceil(this.maxCateLineHeight + valueHeight) + borderWidth * 2;

            return this.sheetHeight;
        },

        /**
         * 计算需要显示的文字：分类和正文，及其对应的尺寸
         * @return {[type]} [description]
         */
        calculateShowText:function(){
            this.maxCateLine = 0;
            this.maxValueLineHeight = [];

            this.showTextMap = this.showTextMap || {};

            var axis = this.vanchart.xAxis(), categories = axis._dataDomain, showCategories = axis._domain;
            var cateStyle = this._categoryStyle(), cateHeight = BaseUtils.getTextHeight(cateStyle) + PADDING_GAP_FUN();
            var unitLength = this.vanchart.bounds.width / showCategories.length;

            var self = this;

            var borderWidth = this.options.borderWidth;

            categories.forEach(function(category){
                var sCateName = BaseUtils.splitText(category, cateStyle, unitLength - 2 * borderWidth, PADDING_GAP_FUN());
                if(self.maxCateLineHeight){
                    var endIndex = Math.min(parseInt(self.maxCateLineHeight / cateHeight, 10), sCateName.length);
                    sCateName = sCateName.slice(0, endIndex);
                }

                if(BaseUtils.indexOf(showCategories, category) != -1){
                    self.maxCateLine = Math.max(self.maxCateLine, sCateName.length);
                }

                self.showTextMap[category] = self.showTextMap[category] || {};
                self.showTextMap[category].categoryArray = sCateName;
            });

            var series = this.vanchart.series;

            series.forEach(function (sery, index){
                var points = sery.points, dataSheetCfg;
                for(var dIndex = 0, len = points.length; dIndex < len; dIndex++){
                    var point = points[dIndex], value = point.options[sery.getTargetKey()], category = point.category;

                    //获取当前点的dataSheet信息,并且和DataSheet.options合并一下，保证里面的属性是全的
                    dataSheetCfg = point.options.dataSheet || {};
                    dataSheetCfg = QueryUtils.merge(dataSheetCfg, self.options);
                    var pointFormat = dataSheetCfg.formatter;
                    var pointStyle = self._valueStyle(dataSheetCfg.style);
                    var pointBorderWidth = dataSheetCfg.borderWidth;

                    //单独计算每个点的字体行高
                    var valueHeight = Math.ceil(BaseUtils.getTextHeight(pointStyle)) + PADDING_GAP_FUN();

                    var f_value = point.isNull ? '-' : self._getTickContent(value, pointFormat);
                    var sValue = BaseUtils.splitText(f_value, pointStyle, unitLength - 2 * borderWidth, PADDING_GAP_FUN());

                    if(self.maxSeriesLineHeight && self.maxSeriesLineHeight[index]){
                        var endIndex = Math.min(parseInt(self.maxSeriesLineHeight[index] / valueHeight, 10), sValue.length);
                        sValue = sValue.slice(0, endIndex);
                    }

                    self.showTextMap[category].value = self.showTextMap[category].value || [];
                    self.showTextMap[category].value[index] = self.showTextMap[category].value[index] || {};
                    self.showTextMap[category].value[index].valueArray = sValue;

                    //将dataSheet存起来，方便draw的时候使用
                    self.showTextMap[category].value[index].dataSheet = dataSheetCfg;

                    // 对于组合图一类，即使分类移除，其下方的点，也是应该用于计算系列高度的
                    var curLineHeight = sValue.length * valueHeight + PADDING_GAP_FUN() + pointBorderWidth * 2;
                    self.maxValueLineHeight[index] = Math.max(self.maxValueLineHeight[index]||0, curLineHeight);
                }
            });

            // 数据补位
            for(var j = -1; ++j < categories.length;) {
                var cate = categories[j], showCate = self.showTextMap[cate];
                for(var i = -1; ++i < series.length;) {
                    if(!showCate.value[i]){
                        showCate.value[i] = {
                            "dataSheet": this.options,
                            "valueArray" : ['-']
                        }
                    }
                }
            }
        },

        fixBoundsByPlot:function() {
            var plotBounds = this.vanchart.bounds;

            var xAxisComponent = this.vanchart.getComponent(ComponentLibrary.X_AXIS_COMPONENT);
            var posY = plotBounds.y + plotBounds.height + this.options.borderWidth / 2;
            if(xAxisComponent && xAxisComponent._axisList.length){
                xAxisComponent._axisList.forEach(function(axis){
                    if(axis.getPosition() == Constants.BOTTOM){
                        posY = Math.max(posY, axis.bounds.y + axis.bounds.height);
                    }
                })
            }

            this.bounds = {
                x: plotBounds.x - this.maxSeriesWidth,
                y: posY,
                width: this.maxSeriesWidth + plotBounds.width,
                height: this.sheetHeight
            };
        },
        //最长的系列名
        getSeriesNameLength:function(){

            this.seriesNames = [];
            this.maxSeriesLine = [];
            this.seriesIconType = [];

            var borderWidth = this.options.borderWidth;

            var  dataSheet = this, vanchart = dataSheet.vanchart, series = vanchart.series;

            var style = this._seriesStyle();

            var limitedWidth = vanchart.getChartBounds().width / 4 - (MAX_ICON_SIZE + ICON_GAP_FUN() * 2) - borderWidth * 2;

            var maxWidth = 0;

            var iconSize = 0;

            series.forEach(function (sery) {
                var width = BaseUtils.getTextDimension(sery.name, style, false).width + PADDING_GAP_FUN() * 2;

                if(width > limitedWidth){

                    var s_names = BaseUtils.splitText(sery.name, style, limitedWidth, PADDING_GAP_FUN());

                    dataSheet.maxSeriesLine.push(s_names.length);

                    dataSheet.seriesNames.push(s_names);

                    maxWidth = limitedWidth;
                }else{
                    dataSheet.maxSeriesLine.push(1);

                    dataSheet.seriesNames.push([sery.name]);

                    maxWidth = Math.max(width + borderWidth * 2, maxWidth);
                }

                var iconType = dataSheet._getLegendType(sery);

                dataSheet.seriesIconType.push(iconType);

                iconSize = Math.max(iconSize, LegendIconFactory.getLegendIconSize(iconType).width);
            });

            this.maxSeriesWidth = Math.ceil(maxWidth + ICON_GAP_FUN() * 2 + iconSize);

            return  this.maxSeriesWidth + PADDING_GAP_FUN();
        },

        _categoryStyle:function(){
            var cateAxis = this.vanchart.xAxis();
            var style = cateAxis ? cateAxis.options.labelStyle : STYLE;
            return BaseUtils.calculateFontSizeWithScale(style);
        },

        _seriesStyle:function(){
            var legend = this.vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            var style = legend ? legend.options.style : STYLE;
            return BaseUtils.calculateFontSizeWithScale(style);
        },

        _valueStyle:function(style){
            return BaseUtils.calculateFontSizeWithScale(style || this.options.style);
        },

        getTextPadding:function(){
            return PADDING_GAP_FUN();
        },

        render:function(){

            this.remove();

            if(!this.vanchart.series.length){
                return;
            }

            this.calculateShowText();

            var vanchart = this.vanchart, bounds = this.bounds, renderer = vanchart.renderer;

            var clipBounds = {x:this.maxSeriesWidth, y:0, width:bounds.width - this.maxSeriesWidth, height:bounds.height};
            this.animationClip = renderer.createClip(clipBounds);
            this.dataSheetGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate(this.bounds));
            this.borderGroup    = renderer.group().addTo(this.dataSheetGroup);
            this.animationGroup = renderer.group().addTo(this.dataSheetGroup);
            renderer.clip(this.animationGroup, this.animationClip);
            renderer.clip(this.borderGroup, this.animationClip);

            this._drawBaseTable();

            this._drawTableContent();
        },

        /**
         * 绘制表格外边框
         * @return {[type]} [description]
         */
        _drawBaseTable:function(){

            var cfg = this.options, seriesWidth = this.maxSeriesWidth, categoryHeight = this.maxCateLineHeight;

            var vanchart = this.vanchart, renderer = vanchart.renderer, group = this.dataSheetGroup;

            var borderWidth = cfg.borderWidth;

            var endX = this.bounds.width, endY = this.bounds.height - borderWidth;

            var styles = {'fill':'none', 'stroke':cfg.borderColor, 'stroke-width':cfg.borderWidth};

            var baseTableBorderPath = 'M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight + "L" + seriesWidth + "," + categoryHeight + "Z";

            renderer.path().attr('d', baseTableBorderPath)
                .style(styles).addTo(group);

            this._drawSeries();
        },

        /**
         * 绘制表格内容：绘制分类文字+绘制表格主体列表文字
         * @return {[type]} [description]
         */
        _drawTableContent:function(){

            var vanchart = this.vanchart, axis = vanchart.xAxis();

            var domain = axis._domain, dataDomain = axis._dataDomain, rangeLength = this.getPlotBounds().width;

            var unitLength = rangeLength / domain.length;

            var startX = - BaseUtils.indexOf(dataDomain, domain[0]) * unitLength + this.maxSeriesWidth;

            for(var i = 0, len = dataDomain.length; i < len; i++){
                var text = this.showTextMap[dataDomain[i]];
                // 之前考虑轴逆序的时候，位置不对，所以改用scale，结果在缩放拖拽的时候，算出来的位置还是不对
                // 因此这里还是改用unitLength*i的方式，只不过逆序的时候，倒过来计算
                var x = startX + unitLength * (axis.isAxisReversed() ? (len - 1 -i) : i);

                this._drawCategory(text, x, unitLength);

                this._drawValues(text, x, unitLength);

            }
        },

        /**
         * 缩放控件改变缩放后刷新
         * @return {[type]} [description]
         */
        zoomRefresh:function(){

            this.calculateShowText();

            this._drawTableContent();
        },

        /**
         * 绘制分类：文字+边框
         * @param  {[type]} text       [description]
         * @param  {[type]} x          [description]
         * @param  {[type]} unitLength [description]
         * @return {[type]}            [description]
         */
        _drawCategory:function(text, x, unitLength){

            var categoryArray = text.categoryArray, renderer = this.vanchart.renderer;

            text._category = text._category || [];

            var categoryStyle = this._categoryStyle(), categoryLineHeight = BaseUtils.getTextHeight(categoryStyle), textPadding = this.getTextPadding();

            var option = this.options;

            var startY = this._getStartY(categoryArray, categoryStyle, this.maxCateLineHeight);

            var textX, textY;

            var borderWidth = option.borderWidth,
                borderX = x + borderWidth / 2,
                borderY = borderWidth;

            for(var i = 0; i < categoryArray.length; i++){
                textX = x + unitLength/2;
                textY = startY + (categoryLineHeight + textPadding) * i + categoryLineHeight/2 + borderWidth / 2;
                text._category[i] = text._category[i] || renderer.text().attr({'text-anchor':'middle', 'dy':'.32em', 'x': textX, 'y': textY})
                        .style('margin-top', '-0.53em').style(categoryStyle).addTo(this.animationGroup);

                text._category[i].textContent(categoryArray[i]).animate({
                    'attr':{'x':textX, 'y':textY},'duration':TIME, 'ease':EASE
                });

                text._category[i].textContent(categoryArray[i]).vMiddle();
            }

            var borderAttr = {
                "width": unitLength - borderWidth,
                "height": this.maxCateLineHeight - borderWidth,
                "transform": "translate(" + borderX + "," + borderY + ")"
            }

            text.border = text.border || this._drawTableElementBorder(this.borderGroup);
            text.border.attr(borderAttr);

            for(var i = categoryArray.length; i < text._category.length; i ++){
                text._category[i].remove();
            }

            text._category.length = categoryArray.length;

        },

        /**
         * 绘制表格正文：文字+边框
         * @param  {[type]} text       [description]
         * @param  {[type]} x          [description]
         * @param  {[type]} unitLength [description]
         * @return {[type]}            [description]
         */
        _drawValues:function(text, x, unitLength){
            var renderer = this.vanchart.renderer, valueStyle = this._valueStyle();
            var textPadding = this.getTextPadding();
            var startY = this.maxCateLineHeight;

            if(!text.value){
                text.value = [];
                for(var i = 0, len = this.vanchart.series.length; i < len; i++){
                    text.value.push({
                        valueArray:['']
                    });
                }
            }

            var textX, textY;
            for(var seriesIndex = 0;seriesIndex < text.value.length; seriesIndex++){

                var value = text.value[seriesIndex], valueHeight = this.maxSeriesLineHeight[seriesIndex];

                var valueArray = value.valueArray;

                value._value = value._value || [];

                var pointStyle = value.dataSheet.style;
                var valueLineHeight = BaseUtils.getTextHeight(pointStyle);

                var firstY = startY + this._getStartY(valueArray, pointStyle, valueHeight);

                var valueOption = value.dataSheet,
                    borderWidth = valueOption.borderWidth,
                    defaultBorderWidth = this.options.borderWidth;

                for(var i = 0; i < valueArray.length; i++){
                    textX = x + unitLength/2;
                    textY = firstY + (valueLineHeight + textPadding) * i + valueLineHeight/2 +  defaultBorderWidth / 2;

                    value._value[i] = value._value[i] || renderer.text().attr({'text-anchor':'middle', 'dy':'.32em', 'x': textX, 'y': textY})
                            .style('margin-top', '-0.53em').style(pointStyle).addTo(this.animationGroup);

                    value._value[i].textContent(valueArray[i]).animate({
                        'duration':TIME, 'ease':EASE, 'attr':{'x':textX, 'y':textY}
                    });

                    value._value[i].textContent(valueArray[i]).vMiddle();

                }

                value.border = value.border || this._drawTableElementBorder(this.borderGroup);
                
                var borderStyle =  {
                    "fill": "none",
                    "stroke-width": borderWidth,
                    "stroke": valueOption.borderColor
                };

                var borderAttr = {
                    "width": unitLength - borderWidth,
                    "height": valueHeight - borderWidth,
                    "transform": "translate(" + (x + borderWidth / 2) + "," + (startY + (borderWidth + defaultBorderWidth) / 2) + ")"
                }
                
                value.border.style(borderStyle).attr(borderAttr);

                for(var i = valueArray.length; i < value._value.length; i ++){
                    value._value[i].remove();
                }

                value._value.length = valueArray.length;

                startY += valueHeight;
            }
        },

        /**
         * 绘制系列：文字+边框
         * @return {[type]} [description]
         */
        _drawSeries:function(){
            var renderer = this.vanchart.renderer, seriesG = renderer.group().addTo(this.dataSheetGroup);
            var seriesNames = this.seriesNames, seriesWidth = this.maxSeriesWidth, categoryHeight = this.maxCateLineHeight;

            var option = this.options,
                borderWidth = option.borderWidth;

            var startX = 16 + borderWidth, startY = categoryHeight;
            var seriesStyle = this._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.getTextPadding();
            var series = this.vanchart.series;

            var textMiddleX = (seriesWidth + startX) / 2;

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.maxSeriesLineHeight[index];
                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.85 + borderWidth /2 ;

                for(var i = 0; i < singleName.length; i++){
                    renderer.text()
                        .attr('x', textMiddleX)
                        .attr('text-anchor', 'middle')
                        .attr('y', firstY + (seriesLineHeight + textPadding) * i)
                        .textContent(singleName[i]).style(seriesStyle)
                        .style('margin-top', '-1em') // ie
                        .addTo(seriesG)
                        .vMiddle();
                }

                var seriesBorder = this._drawTableElementBorder(seriesG);
                seriesBorder.attr({
                    "width": seriesWidth - borderWidth,
                    "height": seriesHeight - borderWidth,
                    "transform": "translate(" + (borderWidth) + "," + (startY + borderWidth) + ")"
                })

                //画前面的色块
                var iconType = this.seriesIconType[index];
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                var iconX = PADDING_GAP_FUN() + this.options.borderWidth * 1.5,
                    iconY =  (seriesHeight - iconHeight) / 2 + startY + borderWidth / 2 ;

                if(LegendIconFactory.hasIcon(iconType)){
                    renderer.path().addTo(seriesG)
                        .attr('d', LegendIconFactory.getLegendIconPath(iconType))
                        .attr('transform', 'translate('+iconX+',' + iconY + ')')
                        .style({'fill': series[index].color});
                }else{
                    renderer.image(
                        {
                            'preserveAspectRatio':'none',
                            'x':iconX ,'y': iconY,
                            'width': 12, 'height': 12
                        })
                        .imageContent(iconType).addTo(seriesG)
                }

                startY += seriesHeight;
            }
        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        /**
         * 绘制表格元素对应的边框
         * @param  {[type]} group [所属的group：必填]
         * @param  {[type]} style [所拥有的样式：非必填]
         * @return {[type]}       [description]
         */
        _drawTableElementBorder: function(group, attr, style){
            var renderer = this.vanchart.renderer;

            var border = renderer.rect().addTo(group);

            border.style(style || this._getTableElementBorderStyle());

            return border;
        },

        /**
         * 获取默认的表格元素的边框样式
         * @return {[type]} [description]
         */
        _getTableElementBorderStyle: function(){
            var option = this.options;

            return {
                "stroke": option.borderColor,
                "stroke-width": option.borderWidth,
                "fill": "none"
            }
        },

        remove:function(){
            this.dataSheetGroup && this.dataSheetGroup.remove();
            this.dataSheetGroup = null;
            this.showTextMap = null;
        }
    });

    ComponentLibrary.register(ComponentLibrary.DATA_SHEET_COMPONENT, DataSheet);
    return DataSheet;
});
/**
 * Created by Yuqian on 2016/10/14.
 */
define('component/TrendLine',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../vans/VanChart','../utils/PathGenerator'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var VanChart = require('../vans/VanChart');
    var PathGenerator = require('../utils/PathGenerator');

    function isInvert(location) {
        return location === Constants.LEFT || location === Constants.RIGHT;
    }

    function leastSquares (asXsues, asYsues){
        var reduceSumFunc = function(prev, cur) { return prev + cur; };

        var xBar = asXsues.reduce(reduceSumFunc) * 1.0 / asXsues.length;
        var yBar = asYsues.reduce(reduceSumFunc) * 1.0 / asYsues.length;

        var ssXX = asXsues.map(function(d) { return Math.pow(d - xBar, 2); })
            .reduce(reduceSumFunc);

        var ssYY = asYsues.map(function(d) { return Math.pow(d - yBar, 2); })
            .reduce(reduceSumFunc);

        var ssXY = asXsues.map(function(d, i) { return (d - xBar) * (asYsues[i] - yBar); })
            .reduce(reduceSumFunc);

        var slope = ssXY / ssXX;
        var intercept = yBar - (xBar * slope);

        return [slope, intercept];
    }

    VanChart.include({

        trendLines: [],

        calcTrendLines:function(){
            var trendLines = [], vanchart = this, series = vanchart.series;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i], trendLine = sery.options.trendLine;
                //堆积的系列用趋势线没意义吧
                if(!trendLine || !sery.visible){
                    continue;
                }

                var func;
                switch (trendLine.type) {
                    case Constants.LINEAR:
                        func = vanchart.linear;
                        break;
                    case Constants.LOGARITHMIC:
                        func = vanchart.logarithmic;
                        break;
                    case Constants.POLYNOMIAL:
                        func = vanchart.polynomial;
                        break;
                    default:
                    case Constants.EXPONENTIAL:
                        func = vanchart.exponential;
                }

                var XY = sery.getTrendLineXYValues(sery);
                if (XY[0].length <= 1) {
                    continue;
                }
                var isInverted = isInvert(XY[2]);
                var asXs, asYs;

                if (isInverted) {
                    asYs = XY[0];
                    asXs = XY[1];
                } else {
                    asXs = XY[0];
                    asYs = XY[1];
                }

                var data = func(asXs, asYs, this.extendXs(asXs, trendLine.period));

                var lineGen = PathGenerator.line().interpolate('cardinal');
                if (isInverted) {
                    // normal: [x, y]; inverted: [y, x]
                    lineGen.x(function (d) {return d[1];}).y(function (d) {return d[0];});
                }

                var line = {
                    d: lineGen(data),
                    trendLine: trendLine
                };

                trendLines.push(line);
            }

            this.trendLines = trendLines;
        },

        extendXs: function (asXs, period) {
            if (period && period.length === 2 && asXs.length > 1) {
                var gap = asXs[1] - asXs[0];

                return newArray(-period[0], function (t, i) { return asXs[0] - (i + 1) * gap; })
                    .reverse()
                    .concat(asXs)
                    .concat(
                        newArray(period[1], function (t, i) { return asXs[asXs.length - 1] + (i + 1) * gap; })
                    );
            }
            return asXs;

            function newArray(length, fillFun) {
                return Array.apply(null, Array(length)).map(fillFun)
            }
        },

        linear: function (asXs, asYs, extXs) {
            var x1,x2,y1,y2;

            var coeff = leastSquares(asXs, asYs);
            x1 = extXs[0];
            y1 = coeff[0] * x1 + coeff[1];
            x2 = extXs[extXs.length - 1];
            y2 = coeff[0] * x2 + coeff[1];

            return [[x1, y1], [x2, y2]];
        },

        logarithmic: function (asXs, asYs, extXs) {

            var newXs = [], newYs = [];

            // get min X in extendXs
            var minX = Math.min.apply(null, extXs);

            asXs
                .map(function (val, i) {
                    if (minX <= 0) {
                        // offset to positive
                        val += (-minX) + 1;
                    }
                    newXs.push(Math.log(val));
                    newYs.push(asYs[i]);
                });

            var coeff = leastSquares(newXs, newYs);

            return extXs
                .map(function (val) {
                    var x = val; // x is the true position
                    if (minX <= 0) {
                        val += (-minX) + 1; // value offset is equation's value
                    }
                    return [x, coeff[0] * Math.log(val) + coeff[1]];
                })
        },

        exponential: function (asXs, asYs, extXs) {

            var newXs = [], newYs = [];

            var minY = Math.min.apply(null, asYs);

            asXs
                .map(function (val, i) {
                    if (minY <= 0) {
                        // offset to positive
                        asYs[i] += (-minY) + 1;
                    }
                    newXs.push(val);
                    newYs.push(Math.log(asYs[i]));
                });

            var coeff = leastSquares(newXs, newYs);

            var tmp = coeff[0];
            coeff[0] = Math.exp(coeff[1]);
            coeff[1] = tmp;

            return extXs
                .map(function (val) {
                    var y = coeff[0] * Math.exp(val * coeff[1]);
                    if (minY <= 0) {
                        y -= (-minY) + 1;
                    }
                    return [val, y];
                });
        },

        polynomial: function (asXs, asYs, extXs) {
            var M = Math.min(asXs.length - 1, 6);
            M++;
            var t;
            var b = [];
            var A = [];
            for (var i = 0; i < M; i++) {
                b[i] = [];
                A[i] = [];
            }
            var B = [];
            var y = [];
            var coeff = [];

            var i, j, k, l;
            for (i = 0; i < M; i++) {
                for (j = 0; j < asXs.length; j++) {
                    t = 1;
                    for (l = 0; l < i; l++) {
                        t = t * asXs[j];
                    }
                    b[i][j] = t;
                }
            }

            for (i = 0; i < M; i++) {
                for (k = 0; k < M; k++) {
                    t = 0;
                    for (j = 0; j < asXs.length; j++) {
                        t += b[i][j] * b[k][j];
                    }
                    A[i][k] = t;
                }
            }
            for (i = 0; i < M; i++) {
                t = 0;
                for (j = 0; j < asXs.length; j++) {
                    t += asYs[j] * b[i][j];
                }
                B[i] = t;
            }

            for (i = 1; i < M; i++) {
                A[i][0] = A[i][0] / A[0][0];
            }
            for (i = 1; i < M; i++) {
                for (j = i; j < M; j++) {
                    var tmp1 = 0;
                    for (k = 0; k < i; k++) {
                        tmp1 += A[k][j] * A[i][k];
                    }
                    A[i][j] = A[i][j] - tmp1;
                    if (j + 1 != M) {
                        var tmp2 = 0;
                        for (k = 0; k < i; k++) {
                            tmp2 += A[k][i] * A[j + 1][k];
                        }
                        A[j + 1][i] = (A[j + 1][i] - tmp2) / A[i][i];
                    }

                }
            }
            y[0] = B[0];
            for (i = 1; i < M; i++) {
                t = 0;
                for (j = 0; j < i; j++) {
                    t += A[i][j] * y[j];
                }
                y[i] = B[i] - t;
            }

            coeff[M - 1] = y[M - 1] / A[M - 1][M - 1];
            for (i = M - 2; i >= 0; i--) {
                t = 0;
                for (j = i + 1; j < M; j++) {
                    t += A[i][j] * coeff[j];
                }
                coeff[i] = (y[i] - t) / A[i][i];
            }

            return extXs
                .map(function (val) {
                    return [
                        val,
                        coeff.reduce(function (prev, curr, i) {
                            return prev + curr * Math.pow(val, i);
                        }, 0)
                    ]
                });
        },

        _renderTrendLine:function(){
            this.calcTrendLines();
            var trendLineOptions = this.trendLines, plotBounds = this.bounds, renderer = this.renderer;

            if(!this.trendLineGroup){
                // don't render it if empty
                if (!(this.trendLines && this.trendLines.length)) {
                    return
                }
                this.trendLineGroup = this.seriesGroup.append(renderer.group());
                renderer.clip(this.trendLineGroup, this.plotClip);
            }
            this.trendLineGroup.trendLines = this.trendLineGroup.trendLines || [];
            var trendLines = this.trendLineGroup.trendLines;

            for(var i = 0, len = trendLineOptions.length; i < len; i++){
                var options = trendLineOptions[i], attrs = {'d': options.d},
                    style = {'fill': 'none', 'stroke':options.trendLine.color, 'stroke-width':options.trendLine.width, 'stroke-dasharray':Constants.DASH_TYPE[options.trendLine.dashStyle]};
                if(trendLines[i]){
                    trendLines[i].attr(attrs).style(style);
                }else{
                    trendLines[i] = renderer.path(attrs).style(style).addTo(this.trendLineGroup);
                }
                trendLines[i].attr('transform', BaseUtils.makeTranslate(plotBounds));
            }

            for(var i = trendLineOptions.length; i < trendLines.length; i++){
                trendLines[i].remove(); trendLines[i] = null;
            }

            trendLines.length = trendLineOptions.length;
            return this.trendLineGroup;
        }
    })
});
/**
 * Created by Cmen on 2017/6/20.
 */
define('component/MoreLabel',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Base','../ComponentLibrary','../utils/BezierEasing','../dom/DomUtils','../vector/SvgRenderer','../vector/VmlRenderer','../utils/ColorUtils'],function(require) {
    var Constants = require("../Constants");
    var BaseUtils = require("../utils/BaseUtils");
    var QueryUtils = require("../utils/QueryUtils");
    var Base = require("./Base");
    var ComponentLibrary = require("../ComponentLibrary");
    var BezierEasing = require("../utils/BezierEasing");
    var DomUtils = require("../dom/DomUtils");
    var SvgRenderer = require("../vector/SvgRenderer");
    var VmlRenderer = require("../vector/VmlRenderer");
    var ColorUtils = require("../utils/ColorUtils");

    var DEFAULT_PADDING = 6,
        DEFAULT_GAP = 5;

    // 边框和内容的显示和隐藏的deley
    var MORELABEL_BORDER_INIT_TIME = 250,
        MORELABEL_CONTENT_INIT_TIME = 350,
        MORELABEL_CONTENT_REMOVE_TIME = 350,
        MORELABEL_BORDER_REMOVE_TIME = 250;

    var MORELABEL_BORDER_INIT_EASE = BezierEasing.css["ease"], // 边框init
        MORELABEL_BORDER_EXIT_EASE = BezierEasing.css["ease"], // 边框exit
        MORELABEL_CONTENT_INIT_EASE = BezierEasing.css["ease"], // 内容Init
        MORELABEL_CONTENT_EXIT_EASE = BezierEasing.css["ease"]; // 内容exit

    var MORELABEL_TOTAL_TIME = MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + MORELABEL_CONTENT_REMOVE_TIME + MORELABEL_BORDER_REMOVE_TIME;

    // 默认的提示边框的相关信息
    var DEFAULT_TRIANGLE_SIZE = 5,
        DEFAULT_BORDER_RADIUS = 8;

    // 系列，值，变化值，变化百分比，分类，百分比，x, y, 层级，指标，转换率，变化转换率
    var identifiers = [
        'changedValue', // 变化值
        'changedPercent', // 变化百分比
        'changedArrivalRate', // 变化转换率
        'changedWordRate', // 变化词频
        'value', // 值
        'percent', // 百分比
        'name', // 词名
        'wordRate', // 词频
        'arrivalRate', // 转换率
        'x', // x
        'y', // y
        'series', // 系列
        'category', // 分类
        'size'
    ];

    var contentType = {
        'changedValue': 'changedValue',
        'changedPercent': 'changedValue',
        'changedArrivalRate': 'changedValue',
        'changedWordRate': 'changedValue',
        'value': 'value',
        'size': 'value',
        'percentage': 'value',
        'x': 'value',
        'y': 'value',
        'arrivalRate': 'value',
        'wordRate': 'value',
        'seriesName': 'series',
        'category': 'series',
        'name': 'series'
    }

    var identifierMap = {};

    identifiers.forEach(function(identifier) {
        var key = "{" + identifier.toUpperCase() + "}";
        identifierMap[key] = [identifier, identifier + "Format"];
    });


    identifierMap['{SERIES}'] = ['seriesName', 'seriesFormat'];
    identifierMap['{PERCENT}'] = ['percentage', 'percentFormat'];
    identifierMap['{X}'] = ['x', 'XFormat'];
    identifierMap['{Y}'] = ['y', 'YFormat'];

    var MoreLabel = Base.extend({
        /**
         * 初始化执行方法，@override Base.initialize
         * @param options  moreLabel相关的配置项
         * @param componentType  组件类型
         * @param vanchart    vanchart图表对象
         */
        initialize: function(options, componentType, vanchart) {
            this.componentType = componentType;
            this.vanchart = vanchart;
            this.refresh(options);

            this.hasAniamtion = vanchart.renderer.isAnimation;
            // 用于保存点和点相关的内容
            this.pointsContentArray = [];
            this.contentArray = [];
            // 用于保存moreLabelG和divLabelG，图表刷新的时候会同意删除并重置数组
            this.svgMoreLabels = [];
            this.divMoreLabels = [];
        },

        /**
         * 合并给出的配置和默认的配置
         * @param options
         * @private
         */
        _refresh: function(options) {
            QueryUtils.merge(options, this.getDefaultMoreLabelOptions());

            // 持续时间为0则moreLabel不可用
            if(options.duration == 0){
                options.enabled = false;
            }
        },

        /**
         * Dom相关初始化，构建svg容器和div容器，用于后期存放提示框和内容
         * @param dom
         */
        doLayout: function(dom) {
            if (!this._dom) {
                dom = dom || this.vanchart.getDivParentDom();

                this._dom = DomUtils.create("div", "moreLabelWrapper", dom);
                this._dom.style.cssText = "width:100%;height:100%;top:0;left:0;position:absolute;pointer-events:none;";

                this.renderer = BaseUtils.isSupportSVG() ? new SvgRenderer(this._dom, this.vanchart) : new VmlRenderer(this._dom, this.vanchart);
                this.renderer.onAdd();
            }
        },

        /**
         * 移除所有的MoreLabel：
         */
        removeAllMoreLabels: function() {
            if (this.svgMoreLabels.length === 0 && this.divMoreLabels.length === 0) {
                return;
            }

            this.svgMoreLabels.forEach(function(moreLabel) {
                moreLabel.remove();
            });
            this.divMoreLabels.forEach(function(moreLabel) {
                moreLabel.remove();
            });

            this.svgMoreLabels = [];
            this.divMoreLabels = [];
        },

        /**
         * 所谓的移除组件，一般指的是把组件所在的group移除
         * 但是MoreLabel还有tooltip比较特殊，是独立于绘图区的，因此这里只是清除现有的moreLabel提示框
         * 而不是把MoreLabel组件实例移除
         * @return {[type]} [description]
         */
        remove: function (){
            this.removeAllMoreLabels();
        },

        /**
         * 根据给出的point，显示moreLabel, like Tooltip.showWithPoint.
         * @param point  发生值变化的point
         * @param startX moreLabel的缩放起始位置X(非必填，如果没传的话，则会调用seires.calcMoreLabelPosition计算)
         * @param startY moreLabel的缩放起始位置X(同startX)
         */
        showWithPoint: function(point, startX, startY) {
            if (this.pointsContentArray.length === 0) {
                return;
            }

            var series = point.series, vanchart = series.vanchart;
            // 先布局
            this.layoutContent();
            var moreLabelDim = {
                width: this.moreLabelWidth,
                height: this.moreLabelHeight
            };

            var position;
            if (BaseUtils.hasDefined(startX) && BaseUtils.hasDefined(startY)) {
                position = {
                    startX: startX,
                    startY: startY,
                    direction: "top"
                }
            } else {
                position = series.calcMoreLabelPosition(point, moreLabelDim);
            }

            position = this._calculateBeyondBounds(position)

            this._show(position);
        },

        /**
         * 计算当前的摆放位置和朝向，会不会导致moreLabel超出绘图区:
         * 这边的处理逻辑是，当前方向上如果溢出，那么就使用当前方向的反方向绘制，其余方向超出则不管了。
         * @param position
         */
        _calculateBeyondBounds: function(position) {
            position.direction = position.direction || "top";

            var domWidth = BaseUtils.getDomWidth(this._dom),
                domHeight = BaseUtils.getDomHeight(this._dom);

            var dir = position.direction,
                startX = position.startX,
                startY = position.startY,
                moreLabelHeight = this.moreLabelHeight,
                moreLabelWidth = this.moreLabelWidth;

            switch (dir) {
                case "top":
                    if (startY - moreLabelHeight - DEFAULT_TRIANGLE_SIZE < 0) {
                        dir = "bottom";
                    }
                    break;
                case "bottom":
                    if (startY + moreLabelHeight + DEFAULT_TRIANGLE_SIZE > domHeight) {
                        dir = "top";
                    }
                    break;
                case "left":
                    if (startX - moreLabelWidth - DEFAULT_TRIANGLE_SIZE < 0) {
                        dir = "right";
                    }
                    break;
                case "right":
                    if (startX + moreLabelWidth + DEFAULT_TRIANGLE_SIZE > domWidth) {
                        dir = "left";
                    }
                    break;
            }

            position.direction = dir;
            return position;
        },

        /**
         * 渲染MoreLabel
         * @param position moreLabel的位置和朝向
         */
        _show: function(position) {
            var moreLabel = this,
                option = this.options,
                renderer = this.renderer;

            var svgContainer = renderer._container,
                divContainer = renderer._divContainer;

            var useHtml = BaseUtils.isSupportSVG() ? option.useHtml : true;
            var direction = position.direction || "top";

            var moreLabelG, moreLabelDivG;

            if(this.vanchart.isMap()){
                position = this._considerMapPane(position);
            }

            var translateInfo = this.calculateTranslate(position);

            moreLabelG = renderer.group().addTo(svgContainer);
            this.svgMoreLabels.push(moreLabelG);
            moreLabelG.attr({
                "transform": "translate(" + translateInfo[0] + "," + translateInfo[1] + ")"
            });

            this.renderSvgBorder(moreLabelG, renderer, direction);
            if (useHtml) {
                moreLabelDivG = renderer.div().addTo(divContainer);
                moreLabelDivG.style({
                    "left": translateInfo[0] + "px",
                    "top": translateInfo[1] + "px"
                });
                this.divMoreLabels.push(moreLabelDivG);
                this.renderHtmlContent(moreLabelDivG, renderer);
            } else {
                this.renderSvgContent(moreLabelG, renderer);
            }

            var removeMoreLabelDelay = MORELABEL_TOTAL_TIME + this.getMoreLabelDuration();

            // 定时清除moreLabel
            this.vanchart.setTimeout('moreLabel_remove_timer', function() {
                moreLabel.removeAllMoreLabels();
            }, removeMoreLabelDelay);

            this.resetContentArray();
        },

        /**
         * 边框Path生成器
         * @param width 边框宽度
         * @param height 边框高度
         * @param triangleDirection 三角所在方向
         * @param borderWidth 边框宽度
         * @param borderRadius 圆角大小
         * @param triangleSize 三角大小
         * @returns {string} 计算得到的path
         */
        borderPathGenerator: function(width, height, triangleDirection, borderWidth, borderRadius, triangleSize) {
            width += borderWidth;
            height += borderWidth;
            var r = borderRadius;
            // 圆角，不能大于最小宽高的一半（去掉凸出三角后的宽高）
            var isVertical = triangleDirection === "top" || triangleDirection === "bottom";
            var maxBorderRadius = Math.min((width - (isVertical ? triangleSize * 2 : 0)), (height - (isVertical ? 0 : triangleSize * 2))) / 2;
            if(r > maxBorderRadius) {
                r = maxBorderRadius;
            }

            var endPoints = [
                    [0, 0],
                    [width, 0],
                    [width, height],
                    [0, height]
                ],
                curvePoints = [
                    [0, r],
                    [r, 0],
                    [width - r, 0],
                    [width, r],
                    [width, height - r],
                    [width - r, height],
                    [r, height],
                    [0, height - r],
                    [0, r]
                ];

            var direction = ['top', 'right', 'bottom', 'left'];
            // 依次连接4个点和四条边
            var path = 'M' + points(curvePoints[0]) + angle(0) + line(0) + angle(1) + line(1) + angle(2) + line(2) + angle(3) + line(3);

            return path;

            function points(arr) {
                return arr.join(',');
            }
            // 画圆角
            function angle(index) {
                var p1 = endPoints[index],
                    p2 = curvePoints[index * 2 + 1];
                return 'Q' + points(p1) + ',' + points(p2);
            }
            // 画边框，对于有三角的那个边，要特殊对待
            function line(index) {
                var p1 = curvePoints[index * 2 + 1],
                    p2 = curvePoints[index * 2 + 2]

                if (direction[index] === triangleDirection) { // 存在三角的那条边框
                    var centerPoints = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];

                    var centerX = centerPoints[0],
                        centerY = centerPoints[1];

                    var x1, x2, y1, y2;

                    switch (index) {
                        case 0:
                            x1 = -1;
                            y1 = 0;
                            x2 = 0;
                            y2 = -1;
                            break;
                        case 1:
                            x1 = 0;
                            y1 = -1;
                            x2 = 1;
                            y2 = 0;
                            break;
                        case 2:
                            x1 = 1;
                            y1 = 0;
                            x2 = 0;
                            y2 = 1;
                            break;
                        case 3:
                            x1 = 0;
                            y1 = 1;
                            x2 = -1;
                            y2 = 0;
                            break;
                    }

                    var m1 = [centerX + x1 * triangleSize, centerY + y1 * triangleSize];
                    var m2 = [centerX + x2 * triangleSize, centerY + y2 * triangleSize];
                    var m3 = [centerX - x1 * triangleSize, centerY - y1 * triangleSize];

                    return 'L' + points(m1) + 'L' + points(m2) + 'L' + points(m3) + 'L' + points(p2);
                }
                return 'L' + points(p2);
            }
        },

        /**
         * 渲染moreLabel边框
         * @param moreLabelG 边框所属group
         * @param renderer
         * @param direction moreLabel朝向
         */
        renderSvgBorder: function(moreLabelG, renderer, direction) {
            var position = {
                'top': 'bottom',
                'bottom': 'top',
                'right': 'left',
                'left': 'right'
            };

            var option = this.options,
                borderWidth = option.borderWidth,
                width = this.moreLabelWidth,
                height = this.moreLabelHeight,
                triangleDirection = position[direction],
                borderRadius = option.borderRadius || DEFAULT_BORDER_RADIUS;

            var path = this.borderPathGenerator(width, height, triangleDirection, borderWidth, borderRadius, DEFAULT_TRIANGLE_SIZE);
            var duration = this.getMoreLabelDuration();

            var moreLabelBorder = renderer.path().addTo(moreLabelG);
            var borderShadow = this._createMoreLabelShadow(renderer);

            var transformOrigin = this.getSvgTransformOrigin(width, height,direction);
            // 由于IE和fireFox下不支持SVG-transform-origin属性，因此这里采用translate(a,b) scale(c) translate(-a, -b)的方式实现单方向缩放
            var setScaleWithOrigin = function (scale, origin){
                var leftTranslate = "translate("+origin[0]+","+origin[1]+")",
                rightTranslate = "translate("+ (-origin[0])+","+(-origin[1])+")";
                var translateScale = leftTranslate +" scale(" + scale + ") " + rightTranslate;

                // IE8及以下就不要用这种位移加缩放来模拟SVG-transform-origin了:
                // 第一，IE8下面没有动画
                // 第二，VMLRender还会直接把translate转成top和left。。。
                return BaseUtils.isSupportSVG() ? translateScale : 'scale('+ scale +')';
            };


            var fillColor = typeof option.backgroundColor === 'string' ?
                    (option.backgroundColor || "rgba(0,0,0,0)") :
                    this._createGradientBackground(renderer, option.backgroundColor);

            moreLabelBorder
                .attr({
                    "d": path,
                    "transform": setScaleWithOrigin(1, transformOrigin),
                    "filter": option.shadow ? borderShadow : "none"
                })
                .style({
                    'fill': fillColor,
                    'stroke': option.borderColor,
                    'stroke-width': option.borderWidth
                });

            // 😔还要考虑没开启动画的情况，如果用户强制关闭动画的话
            // transition就会把两个动画合在一起，这样一开一合就不显示了😔😔😔😔😔😔
            // 那么这边就先分开吧，没动画的时候，直接更新属性和样式，有动画再使用transition去执行动画
            this.hasAniamtion && moreLabelBorder
                .attr("transform", setScaleWithOrigin(0, transformOrigin))
                .transition()
                .ease(MORELABEL_BORDER_INIT_EASE)
                .duration(MORELABEL_BORDER_INIT_TIME)
                .attr('transform', setScaleWithOrigin(1, transformOrigin))
                .transition()
                .ease(MORELABEL_BORDER_EXIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration + MORELABEL_CONTENT_REMOVE_TIME)
                .duration(MORELABEL_BORDER_REMOVE_TIME)
                .attr('transform', setScaleWithOrigin(0, transformOrigin));
        },

        /**
         * 边框阴影
         * @param renderer
         * @returns {string}
         * @private
         */
        _createMoreLabelShadow: function (renderer) {
            this.borderShadow = this.borderShadow || renderer.createDropShadowFilter(0,0,4, 2);
            return 'url(#' + BaseUtils.stamp(this.borderShadow) + ')'
        },

        /**
         * 创建渐变色背景
         * @private
         */
        _createGradientBackground: function (renderer, color) {
            var toPercent = function (n){ return n * 100 + '%';}
            var x1 = toPercent(color.x1),
                x2 = toPercent(color.x2),
                y1 = toPercent(color.y1),
                y2 = toPercent(color.y2);

            var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
            var stop1 = {'offset':'0%', 'stop-color': ColorUtils.colorToHex(color.startColor)};
            var stop2 = {'offset':'100%', 'stop-color':  ColorUtils.colorToHex(color.endColor)};

            this.backgourndColorGradient = this.backgourndColorGradient || renderer.colorGradient(attrs, [stop1, stop2]);

            return "url(#" + BaseUtils.stamp(this.backgourndColorGradient) +")";
        },

        /**
         * 计算SVG下进行Scale缩放时的原点：主要针对IE，fireFox和其他不支持transform-origin使用的黑科技
         * @param width
         * @param height
         * @param direction
         */
        getSvgTransformOrigin: function (width, height, direction) {
            var centerX = width / 2,
                centerY = height / 2;

            var originPosition;

            switch(direction) {
                case "top":
                    originPosition = [centerX, height];
                    break;
                case "bottom":
                    originPosition = [centerX, 0];
                    break;
                case "right":
                    originPosition = [0, centerY];
                    break;
                case "left":
                    originPosition = [width, centerY];
                    break;
            }
            return originPosition;
        },

        /**
         * 使用SVG渲染内容
         * @param moreLabelG 所属group
         * @param renderer
         */
        renderSvgContent: function(moreLabelG, renderer) {
            var contentArray = this.contentArray;
            var svgOffset = !BaseUtils.isSupportSVG() ? {} : {
                'dy': '0.32em'
            };
            var option = this.options;

            var duration = this.getMoreLabelDuration();

            var textGroup = renderer.group().addTo(moreLabelG);

            contentArray.forEach(function(content) {
                var textG = renderer.group()
                    .attr({
                        'transform': BaseUtils.makeTranslate([content.x + option.borderWidth, option.borderWidth + content.y + content.height / 2])
                    })
                    .addTo(textGroup);

                var text = renderer.text().attr(svgOffset).addTo(textG);
                content.data.forEach(function(c) {
                    renderer.tspan().style(c.style).textContent(c.content).addTo(text);
                })
            });

            this.hasAniamtion && textGroup
                .attr('fill-opacity', 0)
                .transition()
                .ease(MORELABEL_CONTENT_INIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME)
                .duration(MORELABEL_CONTENT_INIT_TIME)
                .attr('fill-opacity', 1)
                .transition()
                .ease(MORELABEL_CONTENT_EXIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration)
                .duration(MORELABEL_CONTENT_REMOVE_TIME)
                .attr('fill-opacity', 0);
        },

        /**
         * 使用HTML渲染内容
         * @param divG 所属div
         * @param renderer
         */
        renderHtmlContent: function(divG, renderer) {
            var contentArray = this.contentArray;
            var duration = this.getMoreLabelDuration();

            contentArray.forEach(function(content) {
                var lineHeight = content.height;
                var lineDiv = renderer.div()
                                .style({
                                    "top": content.y + 'px',
                                    "left": content.x + 'px'
                                })
                                .addTo(divG);

                var translateX = 0;
                content.data.forEach(function(d) {
                    var dim = d.dim;
                    var style = BaseUtils.clone(d.style);
                    style.display = 'inline-block';
                    style['lineHeight'] = parseFloat(style.fontSize) * 1.33 + 'px';
                    style['top'] = lineHeight - dim.height + 'px';
                    style['left'] = translateX + 'px';

                    renderer.div()
                        .style(style)
                        .textContent(d.content)
                        .addTo(lineDiv);

                    translateX += dim.width;
                });
            });

            this.hasAniamtion && divG
                .style("opacity", 0)
                .transition()
                .style({
                    "opacity": 1
                })
                .delay(MORELABEL_BORDER_INIT_TIME)
                .duration(MORELABEL_CONTENT_INIT_TIME)
                .ease(MORELABEL_CONTENT_INIT_EASE)
                .transition()
                .style({
                    "opacity": 0
                })
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration)
                .duration(MORELABEL_CONTENT_REMOVE_TIME)
                .ease(MORELABEL_CONTENT_EXIT_EASE)
        },

        /**
         * 收集值变化的点，并存入moreLabel.pointsContentArray
         * @param point
         * @returns {*}
         */
        collectPoint: function(point) {
            var option = this.options,
                formatter = option.formatter;

            // 现在的MoreLabel的画布大小等于vanchart.dom的大小，理论上只要不超出这块区域都是可以显示MoreLabel的
            // 但是正是由于MoreLabel脱离图表区，这就导致了超出图表区的点发生值变化时，可以显示MoreLabel，理论上不应该显示，
            // 因此这里加一个判断，如果点已经超出绘图区，则默认该点不可用
            var series = point.series, vanchart = series.vanchart, plotBounds = vanchart.bounds;
            var isOutChartBounds = function (x, y){
                return x < plotBounds.x || x > plotBounds.x + plotBounds.width || y < plotBounds.y || y > plotBounds.y + plotBounds.height;
            };

            // 对于直接传位置的点，应该不存在点移除的问题，比如地图
            if(series.calcMoreLabelPosition){
                var pointPos = series.calcMoreLabelPosition(point, {width: 0, height: 0})
                if(isOutChartBounds(pointPos.startX, pointPos.startY)){
                    return;
                }
            }

            // 自定义值变化提示内容,直接当作系列处理，不走calculateContent的逻辑了
            if (typeof formatter !== 'object') {
                try {
                    var content =  BaseUtils.getFormatterFunction(formatter).call(point);
                    if(content){
                        this.pointsContentArray.push({
                            point: point,
                            seriesMap:[
                                {
                                    type: "series",
                                    content: content
                                }
                            ],
                            changedValueMap: [],
                            valueMap: [],
                            categoryMap: []
                        });
                    }
                    return;
                } catch (e) {
                    return;
                }
            }
            // 这种啥都没有的不计算
            if (formatter.identifier === "") {
                return;
            }

            this.calculateContent(formatter, point);
        },

        /**
         * 获取MoreLabel持续时间
         * @return {[type]} [description]
         */
        getMoreLabelDuration: function (){
            var duration = this.options.duration;
            return BaseUtils.hasDefined(duration) ? duration * 1000 : 3000;
        },

        /**
         * 根据内容进行排版
         */
        layoutContent: function() {
            var self = this;

            // 布局根据展示的点的数目(一个点和多个点)分开考虑
            if (this.pointsContentArray.length === 1) {
                this.onePointMoreLabelLayout(this.pointsContentArray[0]);
            } else {
                this.pointsContentArray.forEach(function(pointContentObj, index, arr) {
                    // 这边很多个点的时候，诸如分类一些共有的信息还得单独另开一行，因此在最后一行布局的时候，加一个lastPoint的判断
                    if (index === arr.length - 1) {
                        self.morePointsMoreLabelLayout(pointContentObj, true);
                    } else {
                        self.morePointsMoreLabelLayout(pointContentObj);
                    }

                })
            }

            // 内容排版完成后，计算每一行的尺寸和偏移
            this.calculateContentDim();
        },

        /**
         * 计算MoreLabel的偏移，用于后期摆放MoreLabel
         * @param position
         * @returns {[*,*]}
         */
        calculateTranslate: function(position) {
            var translateX = 0,
                translateY = 0,
                moreLabelPosX = position.startX,
                moreLabelPosY = position.startY;

            var moreLabelWidth = this.moreLabelWidth,
                moreLabelHeight = this.moreLabelHeight;

            switch (position.direction) {
                case 'top':
                    translateX = moreLabelPosX - moreLabelWidth / 2;
                    translateY = moreLabelPosY - moreLabelHeight - DEFAULT_TRIANGLE_SIZE;
                    break;
                case 'bottom':
                    translateX = moreLabelPosX - moreLabelWidth / 2;
                    translateY = moreLabelPosY + DEFAULT_TRIANGLE_SIZE;
                    break;
                case 'right':
                    translateX = moreLabelPosX + DEFAULT_TRIANGLE_SIZE;
                    translateY = moreLabelPosY - moreLabelHeight / 2;
                    break;
                case 'left':
                    translateX = moreLabelPosX - moreLabelWidth - DEFAULT_TRIANGLE_SIZE;
                    translateY = moreLabelPosY - moreLabelHeight / 2;
                    break;
            }

            return [translateX, translateY];
        },

        /**
         * 一个框一个点的布局方式
         * @param pointContentObj
         */
        onePointMoreLabelLayout: function(pointContentObj) {
            var self = this;

            var point = pointContentObj.point, series = point.series, chartType = series.type;
            var vanchart = series.vanchart;

            var Style = this._getContentStyle(),
                plusStyle = Style.plus,
                minusStyle = Style.minus,
                numericalStyle = Style.numerical,
                textStyle = Style.text,
                delimiterStyle = Style.delimiter;

            var changedStyle = point.changedValue > 0 ? plusStyle : minusStyle;

            var changedValueMap = pointContentObj.changedValueMap,
                valueMap = pointContentObj.valueMap,
                seriesMap = pointContentObj.seriesMap,
                categoryMap = pointContentObj.categoryMap;

            // 单点布局的时候，系列和分类放在一行，因此这里把系列和分类合并，分类在前
            seriesMap = categoryMap.concat(seriesMap);


            var changedCount = changedValueMap.length,
                valueCount = valueMap.length,
                seriesCount = seriesMap.length;

            // 普通的气泡图和散点图需要特殊排版，气泡地图和散点地图则按找默认排版
            if (!vanchart.isMap() && (chartType === Constants.BUBBLE_CHART || chartType === Constants.SCATTER_CHART)) {
                bubbleContentLayoutFuc();
            } else {
                defaultContentLayoutFuc();
            }

            // 气泡图提示内容布局
            function bubbleContentLayoutFuc() {
                var xContent, yContent, valueContent;

                valueMap.forEach(function(value) {
                    var type = value.type,
                        content = value.content;

                    if (type === 'x') {
                        xContent = content + ''; // 防止为0的时候判断为false
                    } else if (type === 'y') {
                        yContent = content + '';
                    } else if (type === 'size' || type === 'value') {
                        valueContent = content;
                    }
                });

                var lineOne = [],
                    lineTwo = [];

                // 加入变化值
                changedCount && pushContent(lineOne, changedValueMap[0].content, changedStyle);

                // 加入分隔符
                ((changedCount === 1 && valueCount) || changedCount === 2) && pushContent(lineOne, "/", delimiterStyle);

                // 加入变化百分比
                (changedCount === 2) && pushContent(lineOne, changedValueMap[1].content, changedStyle);

                // 重新组合值内容
                var newValueContent = '';
                if (valueCount) {
                    newValueContent += valueContent;
                }

                // 加入坐标内容
                if (xContent && yContent) {
                    newValueContent += '  (' + xContent + ',' + yContent + ')';
                } else if (xContent || yContent) {
                    newValueContent += '  (' + (xContent || yContent) + ')';
                }
                // 加入值内容
                newValueContent && pushContent(lineOne, newValueContent, textStyle);

                pushLine(lineOne);

                seriesCount && lineTwo.push(lineContentFuc(seriesMap, " ", textStyle));
                pushLine(lineTwo);
            }

            /**
             * 默认的布局方式：最多三行：第一行变化值和变化百分比，第二行值和百分比，第三行系列名和分类名
             * 当变化类和值类的内容数目小于等于2个的时候，就需要把变化类和值类放在一行，中间加一个黑色的/
             */
            function defaultContentLayoutFuc() {
                var lineOne = [],
                    lineTwo = [],
                    lineThree = [];
                // 变化类内容和值内容分两行显示
                if (changedCount + valueCount > 2) {
                    lineOne.push(lineContentFuc(changedValueMap, '/', changedStyle));
                    lineTwo.push(lineContentFuc(valueMap, '/', numericalStyle))
                }
                // 变化类内容和值内容一行显示，中间加一个分隔符
                else {
                    changedCount && lineOne.push(lineContentFuc(changedValueMap, '/', changedStyle));
                    if (changedCount === 1 && valueCount === 1) {
                        lineOne.push({
                            content: '/',
                            style: delimiterStyle
                        });
                    }
                    valueCount && lineOne.push(lineContentFuc(valueMap, '/', numericalStyle))
                }

                seriesCount && lineThree.push(lineContentFuc(seriesMap, ' ', textStyle));

                lineOne.length && self.contentArray.push({
                    data: lineOne
                });

                lineTwo.length && self.contentArray.push({
                    data: lineTwo
                });

                lineThree.length && self.contentArray.push({
                    data: lineThree
                });
            }

            /**
             * 把每一行的内容数组存入contentArray.
             * @param line
             */
            function pushLine(line) {
                line.length && self.contentArray.push({
                    data: line
                });
            }

            function pushContent(line, content, style) {
                line.push({
                    content: content,
                    style: style
                })
            }
            /**
             * 单行内容生成
             */
            function lineContentFuc(contentMap, separator, style) {
                var content, len = contentMap.length;
                if (len === 1) {
                    content = contentMap[0].content;
                } else if (len === 2) {
                    content = contentMap[0].content + separator + contentMap[1].content;
                }
                if (content) {
                    return {
                        content: content,
                        style: style
                    }
                }
            }
        },

        /**
         * 一个框多个点的布局方式
         * @param pointContentObj 点内容对象
         * @param lastPoint 是否为最后一个点(最后一个点的时候，需要再加一行用于存放共有的分类名)
         */
        morePointsMoreLabelLayout: function(pointContentObj, lastPoint) {
            var self = this;

            var point = pointContentObj.point, series = point.series, chartType = series.type;

            var Style = this._getContentStyle();

            var plusStyle = Style.plus,
                minusStyle = Style.minus,
                numericalStyle = Style.numerical,
                textStyle = Style.text,
                delimiterStyle = Style.delimiter;

            var changedStyle = point.changedValue > 0 ? plusStyle : minusStyle;

            var changedValueMap = pointContentObj.changedValueMap,
                valueMap = pointContentObj.valueMap,
                seriesMap = pointContentObj.seriesMap,
                categoryMap = pointContentObj.categoryMap;

            var cateContent = this._isPointOrAreaMap(chartType) ? point.name : point.category;

            var changedCount = changedValueMap.length,
                valueCount = valueMap.length,
                seriesCount = seriesMap.length,
                categoryCount = categoryMap.length;

            var lineData = [];

            var changedContent = createContent(changedValueMap);
            var valueContent = createContent(valueMap, true);
            var seriesContent = createContent(seriesMap, true);

            // 加入变化值
            changedCount && pushContent(lineData, changedContent, changedStyle);
            // 加入分隔符
            if (changedCount === 1 && (valueCount || seriesCount)) {
                pushContent(lineData, "/", delimiterStyle)
            }
            // 加入值
            valueCount && pushContent(lineData, valueContent, numericalStyle)
                // 加入系列
            seriesCount && pushContent(lineData, seriesContent, textStyle)
                // 把整行加入到contentArray
            lineData.length && self.contentArray.push({
                data: lineData
            });
            // 最后一个点且选中了分类的时候还需要另开一行用来放分类
            if (lastPoint && categoryCount && cateContent) {
                self.contentArray.push({
                    data: [{
                        content: cateContent,
                        style: textStyle
                    }]
                })
            }

            function createContent(contentMap, space) {
                var content = space ? "  " : "";
                switch(contentMap.length) {
                    case 2 :
                        content += contentMap[0].content + '/' + contentMap[1].content;
                        break;
                    case 1 :
                        content += contentMap[0].content;
                        break;
                }
                return content;
            }

            function pushContent(line, content, style) {
                line.push({
                    content: content,
                    style: style
                })
            }
        },

        /**
         * 统一获取内容的样式，分为值变化样式, 文字样式，数字样式，分隔符样式
         * 当存在自定义样式的时候，则统一使用自定义样式。
         */
        _getContentStyle: function() {
            // TODO 本来每次获取样式都要计算，于是重写了一下，直接把样式绑定在this上，这样只有第一次的时候会计算一下样式
            // 这样做，后期如果有样式修改的话，就比较麻烦了，想了想，好像也没有可能会在自动刷新的过程中改变样式
            // 性能问题虽然现在不重要，但是也需要考虑，不然后期整理起来就繁琐了，因此能不重复计算的就不重复计算
            if(this.moreLabelStyle) {
                return this.moreLabelStyle;
            }

            var style = this.options.style,
                customStyle = style.custom;

            // 自定义的样式或者默认的样式，都需要考虑Scale缩放的问题
            if(customStyle) {
                customStyle = BaseUtils.calculateFontSizeWithScale(customStyle);
            }

            ['plus', 'minus', 'numerical', 'text'].forEach(function (name) {
                style[name] = BaseUtils.calculateFontSizeWithScale(style[name]);
            })

            var plusStyle = customStyle ? customStyle : style.plus,
                minusStyle = customStyle ? customStyle : style.minus,
                numericalStyle = customStyle ? customStyle : style.numerical,
                textStyle = customStyle ? customStyle : style.text,
                delimiterStyle = customStyle ? customStyle : {
                    "fontSize": style.plus.fontSize,
                    "fontFamily": style.plus.fontFamily,
                    "color": "#1515151"
                };

            this.moreLabelStyle = {
                plus: plusStyle,
                minus: minusStyle,
                numerical: numericalStyle,
                text: textStyle,
                delimiter: delimiterStyle
            }

            return this.moreLabelStyle;
        },

        /**
         * 计算需要显示的内容和样式
         * @param formatter
         * @param point
         */
        calculateContent: function(formatter, point) {
            var series = point.series,
                chartType = series.type;

            var changedValueMap = [],
                valueMap        = [],
                seriesMap       = [],
                categoryMap     = [];

            var moreLabel = this;

            var sortContent = function (type, content) {
                if(!content){ return; }  // 内容为空不显示
                var contentObj = {
                    type: type,
                    content: content
                };

                switch(contentType[type]) {
                    case 'changedValue':
                        changedValueMap.push(contentObj);
                        break;
                    case 'value':
                        valueMap.push(contentObj);
                        break;
                    case 'series':
                        if((moreLabel._isPointOrAreaMap(chartType) && type === 'name') || type === 'category') {
                            categoryMap.push(contentObj)
                        } else {
                            seriesMap.push(contentObj);
                        }
                        break;
                }
            };

            formatter.identifier.substring(1).split("$").forEach(function(id) {
                var type = identifierMap[id][0],
                    formatKey = identifierMap[id][1];

                var content;

                // 矩形树图的层级名需要特殊计算
                if (chartType === Constants.TREEMAP_CHART && type === 'name') {
                    content = treeMapNameContentFuc(point);
                } else {
                    content = BaseUtils.format(point[type == 'size' ? 'value' : type], formatter[formatKey]);
                }
                // FR.format会移除字符串中的+,因此这里格式化之后再判断加上+
                if(type === 'changedValue' && content > 0) {
                    content = '+' + content;
                }

                sortContent(type, content);

            });

            this.pointsContentArray.push({
                point: point,
                changedValueMap: changedValueMap,
                valueMap: valueMap,
                seriesMap: seriesMap,
                categoryMap: categoryMap
            });

            // 矩形树图层级名生成
            function treeMapNameContentFuc(point) {
                var p, d = point,
                    points = [point.name];
                while ((p = d.parent) && p.depth) {
                    d = p;
                    points.unshift(p.name);
                }

                return points.join(' / ');
            }
        },

        _isPointOrAreaMap: function (chartType){
            return chartType === Constants.AREA_MAP || chartType === Constants.POINT_MAP;
        },

        /**
         * 重置内容数组，showWithPoint中调用，表示一个moreLabel制作已经完成。
         */
        resetContentArray: function() {
            this.pointsContentArray = [];
            this.contentArray = [];
        },

        /**
         * 根据内容数组计算数据提示框的尺寸
         * @param contentArray
         */
        calculateContentDim: function() {
            var gap = DEFAULT_GAP,
                padding = DEFAULT_PADDING;
            var maxWidth = 0,
                maxHeight = padding;

            var useHtml = this.options.useHtml;

            this.contentArray.forEach(function(line) {
                var lineWidth = 0,
                    lineHeight = 0;

                line.data.forEach(function(content) {
                    var dim = BaseUtils.getTextDimension(content.content, content.style, useHtml);
                    content.dim = dim;
                    lineWidth += dim.width;
                    lineHeight = Math.max(dim.height || 0, lineHeight);
                });

                line.x = padding;
                line.y = maxHeight;
                line.width = lineWidth;
                line.height = lineHeight;

                maxWidth = Math.max(lineWidth, maxWidth);
                maxHeight += lineHeight + gap;
            });

            this.moreLabelWidth = maxWidth + 2 * padding;
            this.moreLabelHeight = maxHeight - gap + padding;
        },

        /**
         * do nothing
         */
        render: function() {

        },

        /**
         * 默认的moreLabel.options
         */
        getDefaultMoreLabelOptions: function() {
            return {
                "style": {
                    "plus": {
                        "color": "#FF4848",
                        "fontSize": "22px",
                        "fontFamily": "Akrobat,Helvetica"
                    },
                    "minus": {
                        "color": "#1CBE91",
                        "fontSize": "22px",
                        "fontFamily": "Akrobat,Helvetica"
                    },
                    "numerical": {
                        "color": "#151515",
                        "fontSize": "12px",
                        "fontFamily": "Helvetica,Akrobat"
                    },
                    "text": {
                        "color": "#151515",
                        "fontSize": "12px",
                        "fontFamily": "Microsoft YaHei, PingFang SC"
                    }
                },
                "duration": 3000,
                "borderWidth": 1,
                "borderColor": "#000",
                "shadow": false,
                "useHtml": false
            }
        },

        /**
         * 地图这边的paneMove后，点的pixel位置并没有变
         * 但由于leaflet自身发生了translate，所以点的位置更新了。
         * 因此这边再绘制地图的自动提示时，需要考虑地图自身的translate
         * @param position 之前的数据变化提示的起始位置
         * @returns {*}  兼容地图位置偏移后的数据变化提示起始位置
         * @private
         */
        _considerMapPane: function (position) {
            var mapTranslateInfo = this.vanchart._getMapPanePos();
            position.startX += mapTranslateInfo.x;
            position.startY += mapTranslateInfo.y;

            return position;
        }
    });

    ComponentLibrary.register(ComponentLibrary.MORELABEL_COMPONENT, MoreLabel);
    return MoreLabel;
});
/**
 * Created by eason on 16/2/5.
 */

define('FullChartTypes',['require','./VanCharts','./Carousel','./chart/Bar','./chart/Pie','./chart/Line','./chart/LineRadar','./chart/ColumnRadar','./chart/Bubble','./chart/Scatter','./chart/PointerGauge','./chart/SlotGauge','./chart/RingGauge','./chart/ThermometerGauge','./chart/MultiPie','./chart/TreeMap','./chart/Funnel','./chart/WordCloud','./chart/Structure','./chart/ForceBubble','./chart/Map','./chart/LineMap','./chart/gantt/Gantt','./component/Tooltip','./component/Axis','./component/GaugeAxis','./component/Legend','./component/Zoom','./component/ToolBar','./component/IntervalRangeLegend','./component/GradientRangeLegend','./component/Polar','./component/PolarAxis','./component/Title','./component/Geo','./component/DrillTools','./component/DataSheet','./component/TrendLine','./component/MoreLabel'],function(require){

    require('./VanCharts');
    require('./Carousel');

    //chart types
    require('./chart/Bar');
    require('./chart/Pie');
    require('./chart/Line');
    require('./chart/LineRadar');
    require('./chart/ColumnRadar');
    require('./chart/Bubble');
    require('./chart/Scatter');

    require('./chart/PointerGauge');
    require('./chart/SlotGauge');
    require('./chart/RingGauge');
    require('./chart/ThermometerGauge');


    //@Jeffrey
    require('./chart/MultiPie');
    require('./chart/TreeMap');

    require('./chart/Funnel');
    require('./chart/WordCloud');
    require('./chart/Structure');

    require('./chart/ForceBubble');

    require('./chart/Map');
    require('./chart/LineMap');

    require('./chart/gantt/Gantt');

    //components
    require('./component/Tooltip');
    require('./component/Axis');
    require('./component/GaugeAxis');
    require('./component/Legend');
    require('./component/Zoom');
    require('./component/ToolBar');
    require('./component/IntervalRangeLegend');
    require('./component/GradientRangeLegend');
    require('./component/Polar');
    require('./component/PolarAxis');
    require('./component/Title');
    require('./component/Geo');
    require('./component/DrillTools');
    require('./component/DataSheet');
    require('./component/TrendLine');

    require('./component/MoreLabel'); 
});
/**
 * Created by eason on 15/12/25.
 */

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
var VanCharts = require('VanCharts');

require('./Carousel');

//chart types
require('./chart/Bar');
require('./chart/Pie');
require('./chart/Line');
require('./chart/LineRadar');
require('./chart/ColumnRadar');

require('./chart/TreeMap');
require('./chart/Bubble');
require('./chart/ForceBubble');
require('./chart/Scatter');
require('./chart/MultiPie');

require('./chart/PointerGauge');
require('./chart/SlotGauge');
require('./chart/RingGauge');
require('./chart/ThermometerGauge');

require('./chart/Map');
require('./chart/Funnel');
require('./chart/WordCloud');
require('./chart/LineMap');
require('./chart/Structure');

//components
require('./component/Tooltip');
require('./component/Axis');
require('./component/GaugeAxis');
require('./component/Legend');
require('./component/Zoom');
require('./component/ToolBar');
require('./component/IntervalRangeLegend');
require('./component/GradientRangeLegend');
require('./component/Polar');
require('./component/PolarAxis');
require('./component/Title');
require('./component/Geo');
require('./component/DrillTools');
require('./component/DataSheet');
require('./component/TrendLine');

require('./component/MoreLabel');
return VanCharts;
}));