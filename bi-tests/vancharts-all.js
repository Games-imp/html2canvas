(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.VanCharts = factory();
    }
}(this, function () {/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

// Copyright 2006 Google Inc. 
// 
// Licensed under the Apache License, Version 2.0 (the "License"); 
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, 
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License.


// Known Issues: 
// 
// * Patterns are not implemented. 
// * Radial gradient are not implemented. The VML version of these look very 
//   different from the canvas one. 
// * Clipping paths are not implemented. 
// * Coordsize. The width and height attribute have higher priority than the 
//   width and height style values which isn't correct. 
// * Painting mode isn't implemented. 
// * Canvas width/height should is using content-box by default. IE in 
//   Quirks mode will draw the canvas using border-box. Either change your 
//   doctype to HTML5 
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype) 
//   or use Box Sizing Behavior from WebFX 
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html) 
// * Non uniform scaling does not correctly scale strokes. 
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation 
if (!document.createElement('vancanvas').getContext) {

    (function() {

        // alias some functions to make (compiled) code shorter
        var m = Math;
        var mr = m.round;
        var ms = m.sin;
        var mc = m.cos;
        var abs = m.abs;
        var sqrt = m.sqrt;

        // this is used for sub pixel precision
        var Z = 10;
        var Z2 = Z / 2;

        /**
         * This funtion is assigned to the <canvas> elements as element.getContext().
         * @this {HTMLElement}
         * @return {CanvasRenderingContext2D_}
         */
        function getContext() {
            return this.context_ ||
                (this.context_ = new CanvasRenderingContext2D_(this));
        }

        var slice = Array.prototype.slice;

        /**
         * Binds a function to an object. The returned function will always use the
         * passed in {@code obj} as {@code this}.
         *
         * Example:
         *
         *   g = bind(f, obj, a, b)
         *   g(c, d) // will do f.call(obj, a, b, c, d)
         *
         * @param {Function} f The function to bind the object to
         * @param {Object} obj The object that should act as this when the function
         *     is called
         * @param {*} var_args Rest arguments that will be used as the initial
         *     arguments when the function is called
         * @return {Function} A new function that has bound this
         */
        function bind(f, obj, var_args) {
            var a = slice.call(arguments, 2);
            return function() {
                return f.apply(obj, a.concat(slice.call(arguments)));
            };
        }

        var G_vmlCanvasManager_ = {
            init: function(opt_doc) {
                if (/MSIE/.test(navigator.userAgent) && !window.opera) {
                    var doc = opt_doc || document;
                    // Create a dummy element so that IE will allow canvas elements to be
                    // recognized.
                    doc.createElement('vancanvas');
                    doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
                }
            },

            init_: function(doc) {

                if(!doc.namespaces){
                    return;
                }

                // create xmlns
                if (!doc.namespaces['g_vml_']) {
                    doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',
                        '#default#VML');

                }
                if (!doc.namespaces['g_o_']) {
                    doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',
                        '#default#VML');
                }

                // Setup default CSS.  Only add one style sheet per document
                if (!doc.styleSheets['ex_canvas_']) {
                    var ss = doc.createStyleSheet();
                    ss.owningElement.id = 'ex_canvas_';
                    ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
                        // default size is 300x150 in Gecko and Opera
                        'text-align:left;width:300px;height:150px}' +
                        'g_vml_\\:*{behavior:url(#default#VML)}' +
                        'g_o_\\:*{behavior:url(#default#VML)}';

                }

                // find all canvas elements
                var els = doc.getElementsByTagName('vancanvas');
                for (var i = 0; i < els.length; i++) {
                    this.initElement(els[i]);
                }
            },

            /**
             * Public initializes a canvas element so that it can be used as canvas
             * element from now on. This is called automatically before the page is
             * loaded but if you are creating elements using createElement you need to
             * make sure this is called on the element.
             * @param {HTMLElement} el The canvas element to initialize.
             * @return {HTMLElement} the element that was created.
             */
            initElement: function(el) {
                if (!el.getContext) {

                    el.getContext = getContext;

                    // Remove fallback content. There is no way to hide text nodes so we
                    // just remove all childNodes. We could hide all elements and remove
                    // text nodes but who really cares about the fallback content.
                    el.innerHTML = '';

                    // do not use inline function because that will leak memory
                    el.attachEvent('onpropertychange', onPropertyChange);
                    el.attachEvent('onresize', onResize);

                    var attrs = el.attributes;
                    if (attrs.width && attrs.width.specified) {
                        // TODO: use runtimeStyle and coordsize
                        // el.getContext().setWidth_(attrs.width.nodeValue);
                        el.style.width = attrs.width.nodeValue + 'px';
                    } else {
                        el.width = el.clientWidth;
                    }
                    if (attrs.height && attrs.height.specified) {
                        // TODO: use runtimeStyle and coordsize
                        // el.getContext().setHeight_(attrs.height.nodeValue);
                        el.style.height = attrs.height.nodeValue + 'px';
                    } else {
                        el.height = el.clientHeight;
                    }
                    //el.getContext().setCoordsize_()
                }
                return el;
            }
        };

        function onPropertyChange(e) {
            var el = e.srcElement;

            switch (e.propertyName) {
                case 'width':
                    el.style.width = el.attributes.width.nodeValue + 'px';
                    el.getContext().clearRect();
                    break;
                case 'height':
                    el.style.height = el.attributes.height.nodeValue + 'px';
                    el.getContext().clearRect();
                    break;
            }
        }

        function onResize(e) {
            var el = e.srcElement;
            if (el.firstChild) {
                el.firstChild.style.width =  el.clientWidth + 'px';
                el.firstChild.style.height = el.clientHeight + 'px';
            }
        }

        G_vmlCanvasManager_.init();

        // precompute "00" to "FF"
        var dec2hex = [];
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++) {
                dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
            }
        }

        function createMatrixIdentity() {
            return [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ];
        }

        function matrixMultiply(m1, m2) {
            var result = createMatrixIdentity();

            for (var x = 0; x < 3; x++) {
                for (var y = 0; y < 3; y++) {
                    var sum = 0;

                    for (var z = 0; z < 3; z++) {
                        sum += m1[x][z] * m2[z][y];
                    }

                    result[x][y] = sum;
                }
            }
            return result;
        }

        function copyState(o1, o2) {
            o2.fillStyle     = o1.fillStyle;
            o2.lineCap       = o1.lineCap;
            o2.lineJoin      = o1.lineJoin;
            o2.lineWidth     = o1.lineWidth;
            o2.miterLimit    = o1.miterLimit;
            o2.shadowBlur    = o1.shadowBlur;
            o2.shadowColor   = o1.shadowColor;
            o2.shadowOffsetX = o1.shadowOffsetX;
            o2.shadowOffsetY = o1.shadowOffsetY;
            o2.strokeStyle   = o1.strokeStyle;
            o2.globalAlpha   = o1.globalAlpha;
            o2.arcScaleX_    = o1.arcScaleX_;
            o2.arcScaleY_    = o1.arcScaleY_;
            o2.lineScale_    = o1.lineScale_;
        }

        function processStyle(styleString) {
            var str, alpha = 1;

            styleString = String(styleString);
            if (styleString.substring(0, 3) == 'rgb') {
                var start = styleString.indexOf('(', 3);
                var end = styleString.indexOf(')', start + 1);
                var guts = styleString.substring(start + 1, end).split(',');

                str = '#';
                for (var i = 0; i < 3; i++) {
                    str += dec2hex[Number(guts[i])];
                }

                if (guts.length === 4 && styleString.substr(3, 1) === 'a') {
                    alpha = guts[3];
                }
            } else {
                str = styleString;
            }

            return {color: str, alpha: alpha};
        }

        function processLineCap(lineCap) {
            switch (lineCap) {
                case 'butt':
                    return 'flat';
                case 'round':
                    return 'round';
                case 'square':
                default:
                    return 'square';
            }
        }

        /**
         * This class implements CanvasRenderingContext2D interface as described by
         * the WHATWG.
         * @param {HTMLElement} surfaceElement The element that the 2D context should
         * be associated with
         */
        function CanvasRenderingContext2D_(surfaceElement) {
            this.m_ = createMatrixIdentity();

            this.mStack_ = [];
            this.aStack_ = [];
            this.currentPath_ = [];

            // Canvas context properties
            this.strokeStyle = '#000';
            this.fillStyle = '#000';
            this.font = '12px sans-serif';

            this.lineWidth = 1;
            this.lineJoin = 'miter';
            this.lineCap = 'butt';
            this.miterLimit = Z * 1;
            this.globalAlpha = 1;
            this.canvas = surfaceElement;

            var el = surfaceElement.ownerDocument.createElement('div');
            el.style.width =  surfaceElement.clientWidth + 'px';
            el.style.height = surfaceElement.clientHeight + 'px';
            // el.style.overflow = 'hidden';
            el.style.position = 'absolute';
            surfaceElement.appendChild(el);

            this.element_ = el;
            this.arcScaleX_ = 1;
            this.arcScaleY_ = 1;
            this.lineScale_ = 1;
        }

        var contextPrototype = CanvasRenderingContext2D_.prototype;
        contextPrototype.clearRect = function() {
            this.element_.innerHTML = '';
        };

        contextPrototype.beginPath = function() {
            // TODO: Branch current matrix so that save/restore has no effect
            //       as per safari docs.
            this.currentPath_ = [];
        };

        contextPrototype.moveTo = function(aX, aY) {
            var p = this.getCoords_(aX, aY);
            this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
            this.currentX_ = p.x;
            this.currentY_ = p.y;
        };

        contextPrototype.lineTo = function(aX, aY) {
            var p = this.getCoords_(aX, aY);
            this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

            this.currentX_ = p.x;
            this.currentY_ = p.y;
        };

        contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                                  aCP2x, aCP2y,
                                                  aX, aY) {
            var p = this.getCoords_(aX, aY);
            var cp1 = this.getCoords_(aCP1x, aCP1y);
            var cp2 = this.getCoords_(aCP2x, aCP2y);
            bezierCurveTo(this, cp1, cp2, p);
        };

        // Helper function that takes the already fixed cordinates.
        function bezierCurveTo(self, cp1, cp2, p) {
            self.currentPath_.push({
                type: 'bezierCurveTo',
                cp1x: cp1.x,
                cp1y: cp1.y,
                cp2x: cp2.x,
                cp2y: cp2.y,
                x: p.x,
                y: p.y
            });
            self.currentX_ = p.x;
            self.currentY_ = p.y;
        }

        contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
            // the following is lifted almost directly from
            // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

            var cp = this.getCoords_(aCPx, aCPy);
            var p = this.getCoords_(aX, aY);

            var cp1 = {
                x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
                y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
            };
            var cp2 = {
                x: cp1.x + (p.x - this.currentX_) / 3.0,
                y: cp1.y + (p.y - this.currentY_) / 3.0
            };

            bezierCurveTo(this, cp1, cp2, p);
        };

        contextPrototype.arc = function(aX, aY, aRadius,
                                        aStartAngle, aEndAngle, aClockwise) {
            aRadius *= Z;
            var arcType = aClockwise ? 'at' : 'wa';

            var xStart = aX + mc(aStartAngle) * aRadius - Z2;
            var yStart = aY + ms(aStartAngle) * aRadius - Z2;

            var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
            var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

            // IE won't render arches drawn counter clockwise if xStart == xEnd.
            if (xStart == xEnd && !aClockwise) {
                xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                                 // that can be represented in binary
            }

            var p = this.getCoords_(aX, aY);
            var pStart = this.getCoords_(xStart, yStart);
            var pEnd = this.getCoords_(xEnd, yEnd);

            this.currentPath_.push({type: arcType,
                x: p.x,
                y: p.y,
                radius: aRadius,
                xStart: pStart.x,
                yStart: pStart.y,
                xEnd: pEnd.x,
                yEnd: pEnd.y});

        };

        contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
        };

        contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
            var oldPath = this.currentPath_;
            this.beginPath();

            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
            this.stroke();

            this.currentPath_ = oldPath;
        };

        contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
            var oldPath = this.currentPath_;
            this.beginPath();

            this.moveTo(aX, aY);
            this.lineTo(aX + aWidth, aY);
            this.lineTo(aX + aWidth, aY + aHeight);
            this.lineTo(aX, aY + aHeight);
            this.closePath();
            this.fill();

            this.currentPath_ = oldPath;
        };

        contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
            var gradient = new CanvasGradient_('gradient');
            gradient.x0_ = aX0;
            gradient.y0_ = aY0;
            gradient.x1_ = aX1;
            gradient.y1_ = aY1;
            return gradient;
        };

        contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                         aX1, aY1, aR1) {
            var gradient = new CanvasGradient_('gradientradial');
            gradient.x0_ = aX0;
            gradient.y0_ = aY0;
            gradient.r0_ = aR0;
            gradient.x1_ = aX1;
            gradient.y1_ = aY1;
            gradient.r1_ = aR1;
            return gradient;
        };

        contextPrototype.drawImage = function(image, var_args) {
            if (image.getContext) {
                this.element_.innerHTML += image.getContext("2d").element_.innerHTML;
            }
            var dx, dy, dw, dh, sx, sy, sw, sh;

            // to find the original width we overide the width and height
            var oldRuntimeWidth = image.runtimeStyle.width;
            var oldRuntimeHeight = image.runtimeStyle.height;
            image.runtimeStyle.width = 'auto';
            image.runtimeStyle.height = 'auto';

            // get the original size
            var w = image.width;
            var h = image.height;

            // and remove overides
            image.runtimeStyle.width = oldRuntimeWidth;
            image.runtimeStyle.height = oldRuntimeHeight;

            if (arguments.length === 3) {
                dx = arguments[1];
                dy = arguments[2];
                sx = sy = 0;
                sw = dw = w;
                sh = dh = h;
            } else if (arguments.length === 5) {
                dx = arguments[1];
                dy = arguments[2];
                dw = arguments[3];
                dh = arguments[4];
                sx = sy = 0;
                sw = w;
                sh = h;
            } else if (arguments.length === 9) {
                sx = arguments[1];
                sy = arguments[2];
                sw = arguments[3];
                sh = arguments[4];
                dx = arguments[5];
                dy = arguments[6];
                dw = arguments[7];
                dh = arguments[8];
            } else {
                throw Error('Invalid number of arguments');
            }

            var d = this.getCoords_(dx, dy);

            var w2 = sw / 2;
            var h2 = sh / 2;

            var vmlStr = [];

            var W = 10;
            var H = 10;

            // For some reason that I've now forgotten, using divs didn't work
            vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

            // If filters are necessary (rotation exists), create them
            // filters are bog-slow, so only create them if abbsolutely necessary
            // The following check doesn't account for skews (which don't exist
            // in the canvas spec (yet) anyway.

            if (this.m_[0][0] !== 1 || this.m_[0][1]) {
                var filter = [];

                // Note the 12/21 reversal
                filter.push('M11=', this.m_[0][0], ',',
                    'M12=', this.m_[1][0], ',',
                    'M21=', this.m_[0][1], ',',
                    'M22=', this.m_[1][1], ',',
                    'Dx=', mr(d.x / Z), ',',
                    'Dy=', mr(d.y / Z), '');

                // Bounding box calculation (need to minimize displayed area so that
                // filters don't waste time on unused pixels.
                var max = d;
                var c2 = this.getCoords_(dx + dw, dy);
                var c3 = this.getCoords_(dx, dy + dh);
                var c4 = this.getCoords_(dx + dw, dy + dh);

                max.x = m.max(max.x, c2.x, c3.x, c4.x);
                max.y = m.max(max.y, c2.y, c3.y, c4.y);

                vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                    'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                    filter.join(''), ", sizingmethod='clip');")
            } else {
                vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
            }

            vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px;"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

            this.element_.insertAdjacentHTML('BeforeEnd',
                vmlStr.join(''));
        };

        contextPrototype.stroke = function(aFill) {
            var lineStr = [];
            var lineOpen = false;
            var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
            var color = a.color;
            var opacity = a.alpha * this.globalAlpha;

            var W = 10;
            var H = 10;

            lineStr.push('<g_vml_:shape',
                ' filled="', !!aFill, '"',
                ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                ' coordorigin="0 0" coordsize="', Z * W, ' ', Z * H, '"',
                ' stroked="', !aFill, '"',
                ' path="');

            var newSeq = false;
            var min = {x: null, y: null};
            var max = {x: null, y: null};

            for (var i = 0; i < this.currentPath_.length; i++) {
                var p = this.currentPath_[i];
                var c;

                switch (p.type) {
                    case 'moveTo':
                        c = p;
                        lineStr.push(' m ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'lineTo':
                        lineStr.push(' l ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'close':
                        lineStr.push(' x ');
                        p = null;
                        break;
                    case 'bezierCurveTo':
                        lineStr.push(' c ',
                            mr(p.cp1x), ',', mr(p.cp1y), ',',
                            mr(p.cp2x), ',', mr(p.cp2y), ',',
                            mr(p.x), ',', mr(p.y));
                        break;
                    case 'at':
                    case 'wa':
                        lineStr.push(' ', p.type, ' ',
                            mr(p.x - this.arcScaleX_ * p.radius), ',',
                            mr(p.y - this.arcScaleY_ * p.radius), ' ',
                            mr(p.x + this.arcScaleX_ * p.radius), ',',
                            mr(p.y + this.arcScaleY_ * p.radius), ' ',
                            mr(p.xStart), ',', mr(p.yStart), ' ',
                            mr(p.xEnd), ',', mr(p.yEnd));
                        break;
                }


                // TODO: Following is broken for curves due to
                //       move to proper paths.

                // Figure out dimensions so we can do gradient fills
                // properly
                if (p) {
                    if (min.x == null || p.x < min.x) {
                        min.x = p.x;
                    }
                    if (max.x == null || p.x > max.x) {
                        max.x = p.x;
                    }
                    if (min.y == null || p.y < min.y) {
                        min.y = p.y;
                    }
                    if (max.y == null || p.y > max.y) {
                        max.y = p.y;
                    }
                }
            }
            lineStr.push(' ">');

            if (!aFill) {
                var lineWidth = this.lineScale_ * this.lineWidth;

                // VML cannot correctly render a line if the width is less than 1px.
                // In that case, we dilute the color to make the line look thinner.
                if (lineWidth < 1) {
                    opacity *= lineWidth;
                }

                lineStr.push(
                    '<g_vml_:stroke',
                    ' opacity="', opacity, '"',
                    ' joinstyle="', this.lineJoin, '"',
                    ' miterlimit="', this.miterLimit, '"',
                    ' endcap="', processLineCap(this.lineCap), '"',
                    ' weight="', lineWidth, 'px"',
                    ' color="', color, '" />'
                );
            } else if (this.fillStyle && typeof this.fillStyle == 'object') {
                var fillStyle = this.fillStyle;
                var angle = 0;
                var focus = {x: 0, y: 0};

                // additional offset
                var shift = 0;
                // scale factor for offset
                var expansion = 1;

                if (fillStyle.type_ == 'gradient') {
                    var x0 = fillStyle.x0_ / this.arcScaleX_;
                    var y0 = fillStyle.y0_ / this.arcScaleY_;
                    var x1 = fillStyle.x1_ / this.arcScaleX_;
                    var y1 = fillStyle.y1_ / this.arcScaleY_;
                    var p0 = this.getCoords_(x0, y0);
                    var p1 = this.getCoords_(x1, y1);
                    var dx = p1.x - p0.x;
                    var dy = p1.y - p0.y;
                    angle = Math.atan2(dx, dy) * 180 / Math.PI;

                    // The angle should be a non-negative number.
                    if (angle < 0) {
                        angle += 360;
                    }

                    // Very small angles produce an unexpected result because they are
                    // converted to a scientific notation string.
                    if (angle < 1e-6) {
                        angle = 0;
                    }
                } else {
                    var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
                    var width  = max.x - min.x;
                    var height = max.y - min.y;
                    focus = {
                        x: (p0.x - min.x) / width,
                        y: (p0.y - min.y) / height
                    };

                    width  /= this.arcScaleX_ * Z;
                    height /= this.arcScaleY_ * Z;
                    var dimension = m.max(width, height);
                    shift = 2 * fillStyle.r0_ / dimension;
                    expansion = 2 * fillStyle.r1_ / dimension - shift;
                }

                // We need to sort the color stops in ascending order by offset,
                // otherwise IE won't interpret it correctly.
                var stops = fillStyle.colors_;
                stops.sort(function(cs1, cs2) {
                    return cs1.offset - cs2.offset;
                });

                var length = stops.length;
                var color1 = stops[0].color;
                var color2 = stops[length - 1].color;
                var opacity1 = stops[0].alpha * this.globalAlpha;
                var opacity2 = stops[length - 1].alpha * this.globalAlpha;

                var colors = [];
                for (var i = 0; i < length; i++) {
                    var stop = stops[i];
                    colors.push(stop.offset * expansion + shift + ' ' + stop.color);
                }

                // When colors attribute is used, the meanings of opacity and o:opacity2
                // are reversed.
                lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                    ' method="none" focus="100%"',
                    ' color="', color1, '"',
                    ' color2="', color2, '"',
                    ' colors="', colors.join(','), '"',
                    ' opacity="', opacity2, '"',
                    ' g_o_:opacity2="', opacity1, '"',
                    ' angle="', angle, '"',
                    ' focusposition="', focus.x, ',', focus.y, '" />');
            } else {
                lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                    '" />');
            }

            lineStr.push('</g_vml_:shape>');

            this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
        };

        contextPrototype.fill = function() {
            this.stroke(true);
        }

        contextPrototype.closePath = function() {
            this.currentPath_.push({type: 'close'});
        };

        /**
         * @private
         */
        contextPrototype.getCoords_ = function(aX, aY) {
            var m = this.m_;
            return {
                x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
            }
        };

        contextPrototype.save = function() {
            var o = {};
            copyState(this, o);
            this.aStack_.push(o);
            this.mStack_.push(this.m_);
            this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
        };

        contextPrototype.restore = function() {
            copyState(this.aStack_.pop(), this);
            this.m_ = this.mStack_.pop();
        };

        function matrixIsFinite(m) {
            for (var j = 0; j < 3; j++) {
                for (var k = 0; k < 2; k++) {
                    if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
                        return false;
                    }
                }
            }
            return true;
        }

        function setM(ctx, m, updateLineScale) {
            if (!matrixIsFinite(m)) {
                return;
            }
            ctx.m_ = m;

            if (updateLineScale) {
                // Get the line scale.
                // Determinant of this.m_ means how much the area is enlarged by the
                // transformation. So its square root can be used as a scale factor
                // for width.
                var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                ctx.lineScale_ = sqrt(abs(det));
            }
        }

        contextPrototype.translate = function(aX, aY) {
            var m1 = [
                [1,  0,  0],
                [0,  1,  0],
                [aX, aY, 1]
            ];

            setM(this, matrixMultiply(m1, this.m_), false);
        };

        contextPrototype.rotate = function(aRot) {
            var c = mc(aRot);
            var s = ms(aRot);

            var m1 = [
                [c,  s, 0],
                [-s, c, 0],
                [0,  0, 1]
            ];

            setM(this, matrixMultiply(m1, this.m_), false);
        };

        contextPrototype.scale = function(aX, aY) {
            this.arcScaleX_ *= aX;
            this.arcScaleY_ *= aY;
            var m1 = [
                [aX, 0,  0],
                [0,  aY, 0],
                [0,  0,  1]
            ];

            setM(this, matrixMultiply(m1, this.m_), true);
        };

        contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
            var m1 = [
                [m11, m12, 0],
                [m21, m22, 0],
                [dx,  dy,  1]
            ];

            setM(this, matrixMultiply(m1, this.m_), true);
        };

        contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
            var m = [
                [m11, m12, 0],
                [m21, m22, 0],
                [dx,  dy,  1]
            ];

            setM(this, m, true);
        };

        /******** STUBS ********/
        contextPrototype.clip = function() {
            // TODO: Implement
        };

        contextPrototype.arcTo = function() {
            // TODO: Implement
        };

        contextPrototype.createPattern = function() {
            return new CanvasPattern_;
        };

        contextPrototype.measureText = function(textToDraw) {
            var hiddenSpan = document.createElement('span');
            hiddenSpan.style.font = this.font;
            hiddenSpan.innerHTML = textToDraw;
            var bodyNode = document.getElementsByTagName("body")[0];
            bodyNode.appendChild(hiddenSpan);
            var width = hiddenSpan.offsetWidth;
            bodyNode.removeChild(hiddenSpan);
            return {"width" : width + 1};
        }

        contextPrototype.fillText = function(textToDraw, x, y) {
            var vmlStr = [];
            var textHeightStr = this.font.split("px")[0].replace(/(^\s+)|(\s+$)/g, "");
            var textHeight = /^\d+$/.test(textHeightStr) ? parseInt(textHeightStr) : 0;
            vmlStr.push('<g_vml_:shape style="font:' + this.font + ';',
                ' color:' + this.fillStyle + ';',
                ' position:absolute;',
                ' left:' + x + 'px;',
                ' top:' + (y - textHeight) + 'px;',
                ' width:' + this.measureText(textToDraw).width + 'px;',
                ' height:' + textHeight + 'px;"',
                ' ><g_vml_:textbox inset="0,0,0,0">' + textToDraw,
                ' </g_vml_:textbox>',
                '</g_vml_:shape>');

            this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
        }

        // Gradient / Pattern Stubs
        function CanvasGradient_(aType) {
            this.type_ = aType;
            this.x0_ = 0;
            this.y0_ = 0;
            this.r0_ = 0;
            this.x1_ = 0;
            this.y1_ = 0;
            this.r1_ = 0;
            this.colors_ = [];
        }

        CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
            aColor = processStyle(aColor);
            this.colors_.push({offset: aOffset,
                color: aColor.color,
                alpha: aColor.alpha});
        };

        function CanvasPattern_() {}

        // set up externs
        VanCanvasManager = G_vmlCanvasManager_;
        CanvasRenderingContext2D = CanvasRenderingContext2D_;
        CanvasGradient = CanvasGradient_;
        CanvasPattern = CanvasPattern_;

    })();

} // if ;
define("excanvas", function(){});

/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var MOUSE_UP_DOWN = 'mousedown mouseup pointerdown pointerup MSPointerDown MSPointerUp';

    var _preventDefault = function (e) {

        if(e.type && MOUSE_UP_DOWN.indexOf(e.type) != -1){
            //biprevent
            return;
        }


        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
        return this;
    };

    var ie8 = !(window.SVGSVGElement);

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function() {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            if(target.addEventListener){
                // IE9addEventListenerwheelmousewheel
                // IE9-IE11"onwheel" in targetfalse,BUG,Edge:https://connect.microsoft.com/IE/Feedback/Details/768199
                target.addEventListener(type, handler, false);  
            }else if(target.attachEvent){
                if(type == 'wheel'){
                    type = 'mousewheel';
                }
                target.attachEvent('on' + type, handler);

            }
        });

        return this;
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            if(target.removeEventListener){
                target.removeEventListener(type, handler, false);
            }else if(target.detachEvent){

                if(type == 'wheel'){
                    type = 'mousewheel';
                }

                target.detachEvent('on' + type, handler);
            }
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property.charAt(0).toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return (doc.defaultView || doc.parentWindow || window);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover wheel';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    //ie8bug,documentmouseup
    if(ie8){
        MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover mouseup wheel';
        MOUSE_WINDOW_EVENTS = 'mousemove';
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var data = {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            };

            var eventType = MOUSE_INPUT_MAP[ev.type];

            var isLeftButton = ie8 ? ev.button === 1 : ev.button === 0;

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && isLeftButton) {
                this.pressed = true;
            }


            if (eventType & INPUT_MOVE && (ie8 ? !this.pressed : (ev.which !== 1))) {
                eventType = INPUT_END;
            }

            // mouse must be down
            if (!this.pressed) {

                var eventType = ev.type;
                if(eventType.indexOf('wheel') != -1){
                    eventType = 'wheel';
                }
                var handlers = this.manager.handlers[eventType]
                    && this.manager.handlers[eventType].slice();

                if(handlers && handlers.length){
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                }
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, data);
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

// in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var _MOUSE_EVENTS = 'mousemove mouseout mouseover wheel';
    var POINTER_ELEMENT_EVENTS = 'pointerdown wheel';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel mousemove mouseout mouseover';

// IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown mousemove mouseout mouseover wheel';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }


    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            var data = {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            };

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                
                var _evType = ev.type;
                _evType = _evType.indexOf("wheel") >= 0 ? "wheel" : _evType;  // @chart-1112 IEmousewheelwheel
                
                if(_MOUSE_EVENTS.indexOf(_evType) != -1){
                    var handlers = this.manager.handlers[_evType]
                        && this.manager.handlers[_evType].slice();

                    if(handlers && handlers.length){
                        var i = 0;
                        while (i < handlers.length) {
                            handlers[i](data);
                            i++;
                        }
                    }
                }

                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, data);

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */

    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);

        this.primaryTouch = null;
        this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }

            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {x: touch.clientX, y: touch.clientY};
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                // #touchActionAndriod
                this._shouldChangeTouchAction = value === TOUCH_ACTION_MANIPULATION
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * by Jeffrey
         * #touchActionAndriod
         */
        setTouchActionNone: function () {
            if (this._shouldChangeTouchAction) {
                // set to none
                // enable the pan event
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = TOUCH_ACTION_NONE;
            }
        },
        recoverTouchAction: function () {
            if (this._shouldChangeTouchAction) {
                // recover to origin
                // enable scroll
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = TOUCH_ACTION_MANIPULATION;
            }
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            var hammerHandler = this.manager.options._handler;

            var _prevent = hammerHandler && (hammerHandler.preventDefault(input) && !hammerHandler.vanchart.isForceBubble());

            if(_prevent || this.manager.session.prevented){
                _preventDefault(srcEvent);
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {

                return;
            }

            // if (hasNone ||
            //     (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            //     (hasPanX && direction & DIRECTION_VERTICAL)) {
            //     return this.preventSrc(srcEvent);
            // }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            _preventDefault(srcEvent);
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning

        //TOUCH_ACTION_NONE
        //
        // 2017-04-27 Jeffrey:
        // manipulationblinkpan
        // pan none_
        //  setTouchActionNone / recoverTouchAction
        // #touchActionAndriod
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_MANIPULATION;
            // return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            //
            var _handler = this.manager.options._handler;
            var _pressed = _handler && _handler.preventDefault(input);

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;

            return _pressed && hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.offsetDirection &&
                input.distance > this.options.threshold &&
                input.maxPointers == this.options.pointers &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.7';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ['rotate']],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            if (events === undefined) {
                return;
            }
            if (handler === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            if (events === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                _preventDefault(data.srcEvent);
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
    freeGlobal[exportName] = Hammer;

    if (typeof define === 'function' && define.amd) {
        define('hammer',[],function() {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

})(window, document, 'VanHammer');

/**
 * Created by eason on 15/6/30.
 * some of the following methods are borrowed from zrender
 */

//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('utils/ColorUtils',[],function(){
    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    var _cache = {};
    var _emptyDefault = [0, 0, 0, 1];

    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    // 
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * 
     * @param color 
     */
    function getRGBAColorArray(color){
        if (_nameColors[color]) {
            color = _nameColors[color];
        }

        if (_cache[color]) {
            return _cache[color].slice();
        }

        color = trim(color);

        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }

        var r = color.match(colorRegExp);

        // 2017.05.05 Jeffrey
        // to avoid "Cannot read property '2' of null" exception
        // default is black [0,0,0,1]
        // if anywhere's color is strangely black,
        // comment here, then you can trace the bug
        if (!r) {
            _cache[color] = _emptyDefault;
            return _emptyDefault.slice();
        }

        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );
        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }


        //rgba
        if(data.length === 3){
            data.push(1);
        }

        _cache[color] = data.slice();

        return data;
    }

    function toColor(data, format){
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(', ') + ')';
            }

            return format + '(' + data.slice(0, 3).join(', ') + ')';
        }
    }

    function getHighLightColor(color){
        var rgba = getRGBAColorArray(color);
        var tmp = [];
        for(var i = 0; i < 3; i++){
            var x = rgba[i];
            if(x <= 128){
                tmp.push(adjust(x-(255-x)*(255-2*x)/(2*x), [0,255]));
            }else{
                tmp.push(adjust(x+x*(2*x-255)/(2*(255-x)), [0,255]));
            }
        }

        var result = [];
        for(i = 0; i < 3; i++){
            result.push(Math.round(0.65 * rgba[i] + 0.35 * tmp[i]));
        }

        return toColor(result, 'rgb');
    }

    function getColorWithDivider(color, divider){
        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 3; i++){
            rgba[i] = parseInt(rgba[i] / divider, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function getClickColor(color){

        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 2; i++){
            rgba[i] = parseInt(rgba[i] * 0.95, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function mixColorWithAlpha(color, alpha){
        var rgba = getRGBAColorArray(color);
        rgba[3] = alpha;
        return toColor(rgba, 'rgba');
    }

    function mixColorWithHSB(color, detH, detS, detB){
        var rgba = getRGBAColorArray(color);

        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        hsb[0] += detH;
        hsb[1] += detS;
        hsb[2] += detB;

        var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);

        return toColor(rgb, 'rgb');
    }

    function hsb2rgb(hue, saturation, brightness){

        saturation = Math.min(1, Math.max(0, saturation));

        brightness = Math.min(1, Math.max(0, brightness));

        var r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = brightness * 255.0 + 0.5;
        } else {
            var h = (hue - Math.floor(hue)) * 6.0;
            var f = h - Math.floor(h);
            var p = brightness * (1.0 - saturation);
            var q = brightness * (1.0 - saturation * f);
            var t = brightness * (1.0 - (saturation * (1.0 - f)));
            switch (Math.floor(h)) {
                case 0:
                    r = brightness * 255.0 + 0.5;
                    g = t * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 1:
                    r = q * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 2:
                    r = p * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = t * 255.0 + 0.5;
                    break;
                case 3:
                    r = p * 255.0 + 0.5;
                    g = q * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 4:
                    r = t * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 5:
                    r = brightness * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = q * 255.0 + 0.5;
                    break;
            }
        }
        var rgb = [];
        rgb.push(Math.floor(r));
        rgb.push(Math.floor(g));
        rgb.push(Math.floor(b));
        return rgb;
    }

    function createColorsWithHsb(color, count){

        color = color || 'blue';
        count = count || 1;

        var rgba = getRGBAColorArray(color);
        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        var result = [], h = hsb[0], s = hsb[1], b = hsb[2];

        for(var i = 0; i < count; i++){
            var tmpS = s * (1 - i / count);
            var tmpB = b + i * (1 - b) / count;
            result.push(toColor(hsb2rgb(h, tmpS, tmpB)));
        }

        return result;
    }

    function rgb2hsb(r, g, b){

        var hue, saturation, brightness;

        var hsbvals = [3];
        var cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        var cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }

        brightness = cmax / 255.0;
        if (cmax !== 0) {
            saturation = (cmax - cmin) / cmax;
        }else{
            saturation = 0;
        }


        if (saturation === 0) {
            hue = 0;
        }else{
            var redc = (cmax - r) / (cmax - cmin);
            var greenc = (cmax - g) / (cmax - cmin);
            var bluec = (cmax - b) / (cmax - cmin);
            if (r == cmax) {
                hue = bluec - greenc;
            }
            else if (g == cmax) {
                hue = 2.0 + redc - bluec;
            }
            else {
                hue = 4.0 + greenc - redc;
            }
            hue = hue / 6.0;
            if (hue < 0) {
                hue = hue + 1.0;
            }
        }

        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    function getColorOpacity(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1)) ?
            getRGBAColorArray(color)[3] :
            1;
    }

    //a
    function getColorOpacityWithoutDefault(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1))
                                                    ? getColorOpacity(color) : undefined;

    }

    function colorToHex(color){
        return colorToHexAlpha(color).hex;
    }

    function colorToHexAlpha(color){
        var rgb = toColor(getRGBAColorArray(color), 'rgba');

        var rRgba = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/,
            r, g, b, a,
            rsa = rgb.replace(/\s+/g, "").match(rRgba);

        r = (+rsa[1]).toString(16);
        r = r.length === 1 ? "0" + r : r;
        g = (+rsa[2]).toString(16);
        g = g.length === 1 ? "0" + g : g;
        b = (+rsa[3]).toString(16);
        b = b.length === 1 ? "0" + b : b;
        a = +(rsa[5] ? rsa[5] : 1);

        return {hex: "#" + r + g + b, alpha: a};
    }

    /**
     * 
     * @param color colorrgbgdbared#ffffff
     * @param alpha 
     */
    function getStandardColorAndOpacity(color, alpha) {

        if(color == null){
            return {hex:color, alpha:alpha};
        }

        if(alpha == null) {
            alpha = 1;
        }

        alpha = adjust(parseFloat(alpha), [ 0, 1 ]);

        var hexAlpha = colorToHexAlpha(color);

        if(hexAlpha.alpha != null) {
            alpha *= hexAlpha.alpha;
        }

        return {hex:hexAlpha.hex, alpha: alpha};
    }

    function hasColorName(name){
        return _nameColors[name];
    }

    var ColorUtils = {
        hasColorName:hasColorName,
        toColor:toColor,
        hsb2rgb:hsb2rgb,
        rgb2hsb:rgb2hsb,
        createColorsWithHsb:createColorsWithHsb,
        getRGBAColorArray:getRGBAColorArray,
        mixColorWithHSB:mixColorWithHSB,
        getHighLightColor:getHighLightColor,
        getColorWithDivider:getColorWithDivider,
        mixColorWithAlpha:mixColorWithAlpha,
        getColorOpacity:getColorOpacity,
        getColorOpacityWithoutDefault:getColorOpacityWithoutDefault,
        colorToHex:colorToHex,
        colorToHexAlpha:colorToHexAlpha,
        getClickColor:getClickColor,
        getStandardColorAndOpacity:getStandardColorAndOpacity
    };

    window.ColorUtils = ColorUtils;

    return ColorUtils;
});
/**
 * Created by eason on 15/5/4.
 */
define('Constants',[],function(){
    return {

        BLANK_VALUE_PERCENTAGE:'\xa0\xa0',

        INSTANCES_KEY:'vancharts_index_',

        SELECT_ANIMATION:'select',

        CHART_HIDE: 'vancharts-chart-hide',
        EXPORT_HIDE: 'vancharts-export-hide',

        //
        GEO:'geographic_co_sys',
        PLANE:'plane_co_sys',

        // switch style
        BUTTON: 'button',
        CAROUSEL: 'carousel',

        //
        BAR_CHART:'bar',//
        COLUMN_CHART:'column',//
        LINE_CHART:'line',//
        AREA_CHART:'area',//
        PIE_CHART:'pie',//
        MULTIPIE_CHART:'multiPie',//
        TREEMAP_CHART:'treeMap',//
        SCATTER_CHART:'scatter',//
        BUBBLE_CHART:'bubble',//
        FORCE_BUBBLE_CHART:'forceBubble',//
        GANTT_CHART: 'gantt',// 

        GAUGE_CHART:'gauge',//
        POINTER_GAUGE:'pointer',//
        POINTER_SEMI_GAUGE:'pointer_semi',
        SLOT_GAUGE:'slot',//
        THERMOMETER_GAUGE:'thermometer',//
        RING_GAUGE:'ring',//

        RADAR_CHART:'radar',//
        COLUMN_RADAR:'columnRadar',
        LINE_RADAR:'lineRadar',

        POINT_MAP:'pointMap',
        AREA_MAP:'areaMap',
        HEAT_MAP:'heatMap',
        LINE_MAP:'lineMap',

        FUNNEL_CHART:'funnel',//
        WORD_CLOUD_CHART:'wordCloud',//
        STRUCTURE_CHART:'structure',//

        MULTI_CHARTS: 'multiCharts', // 

        VANCHART:'vanchart',

        //icon
        FULL_SCREEN_ICON : 'fullScreen',
        EXPORT_ICON : 'toImage',
        SORT : 'sort',
        MENU_ICON : 'vancharts-icon-menu',
        REFRESH_ICON : 'vancharts-icon-refresh',

        AXIS_GROUP:'vanchart-axis-group',

        //
        BOTTOM:'bottom',
        TOP:'top',
        LEFT:'left',
        RIGHT:'right',
        RIGHT_TOP:'right-top',
        RIGHT_BOTTOM:'right-bottom',

        //
        LEFT_TO_RIGHT:'left-to-right',
        RIGHT_TO_LEFT:'right-to-right',
        BOTTOM_TO_TOP:'bottom-to-top',
        TOP_TO_BOTTOM:'top-to-botttom',

        //
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //
        CIRCLE:'circle',
        SQUARE:'square',
        DIAMOND:'diamond',
        TRIANGLE:'triangle',
        STAR:'star',
        LOCATION: 'location',

        CIRCLE_HOLLOW:'circle_hollow',
        SQUARE_HOLLOW:'square_hollow',
        DIAMOND_HOLLOW:'diamond_hollow',
        TRIANGLE_HOLLOW:'triangle_hollow',

        //
        NORMAL_ICON:'normal-legend-icon',//
        PIE_ICON:'pie-legend-icon',
        DONUT_ICON:'donut-legend-icon',
        BUBBLE_ICON:'bubble-legend-icon',
        SCATTER_ICON:'scatter-legend-icon',
        TREEMAP_ICON:'treeMap-legend-icon',

        //
        DASH_TYPE:{
            Solid:'none', // 0,0 bug IE9; 0 bug phantom;
            Dash:'8,6'
        },

        //
        SAME_ARC : 'sameArc',//
        DIFFERENT_ARC : 'differentArc',//

        //
        OUTSIDE : 'outside',
        INSIDE : 'inside',
        CENTER:'center',

        //
        STYLE_GRADUAL:'gradual', //

        //
        HORIZONTAL_LAYOUT:'horizontal',
        VERTICAL_LAYOUT:'vertical',

        //
        POLYGON_RADAR:'polygon',
        CIRCLE_RADAR:'circle',

        //size
        SIZE_BY_AREA:'area',
        SIZE_BY_WIDTH:'width',

        GRADUAL_LIGHTER: 'lighter',
        GRADUAL_DARKER: 'darker',

        //
        STATE_TO_DROP:'to-drop',
        STATE_DROPPED:'dropped',
        STATE_TO_SHOW:'to-show',
        STATE_SHOW:'show',

        // trend line
        EXPONENTIAL: 'exponential',
        LINEAR: 'linear',
        LOGARITHMIC: 'logarithmic',
        POLYNOMIAL: 'polynomial'

    }

});
/**
 * Created by eason on 2017/2/15.
 */
define('utils/vMap',['require'],function(require){

    var d3_map_proto = "__proto__", d3_map_zero = "\x00";

    function vMap(object, f) {
        this._ = Object.create(null);

        if(object){
            var map = this;
            if (object instanceof vMap) {
                object.forEach(function(key, value) {
                    map.set(key, value);
                });
            } else if (Array.isArray(object)) {
                var i = -1, n = object.length, o;
                if (arguments.length === 1) {
                    while (++i < n) {
                        map.set(i, object[i]);
                    }
                } else {
                    while (++i < n) {
                        map.set(f.call(object, o = object[i], i), o);
                    }
                }
            } else {
                for (var key in object) {
                    map.set(key, object[key]);
                }
            }
        }
    }

    vMap.prototype = {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for (var key in this._) {
                values.push(this._[key]);
            }
            return values;
        },
        entries: function() {
            var entries = [];
            for (var key in this._) {
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            }
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) {
                f.call(this, d3_map_unescape(key), this._[key]);
            }
        }
    };

    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._) {
            keys.push(d3_map_unescape(key));
        }
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._){
            ++size;
        }
        return size;
    }
    function d3_map_empty() {
        for (var key in this._) {
            return false;
        }
        return true;
    }

    return vMap;

});
/**
 * Created by eason on 15/5/4.
 * 
 */
define('utils/BaseUtils',['require','./ColorUtils','../Constants','./vMap'],function(require){

    var ColorUtils = require('./ColorUtils');
    var Constants = require('../Constants');
    var vMap = require('./vMap');
    var templateRe = /\{ *([\w_\-]+) *\}/g;

    var DIV_CONTAINER, SVG_CONTAINER, CANVAS_CTX;

    var lastID = 0;

    var DOUBLE_PI = 2 * Math.PI;

    var decimalPlacesRegExp = /(?:\d+)(?:\.(\d+))?(?:[eE]-(\d+))?/; // ["0.111e-7", "111", "7"]
    var decimalRegExp = /\.|[eE]-\d+/g; // (1.1e-7 + '').match(/\.|e-\d+/ig) -> [".", "e-7"]

    //optionskey
    var skipKeys = {'minSize':true, 'maxSize':true, 'name':true};

    var SCALE = 1;

    var styleToCss = {
        color:'fill',
        font:'font',
        fontFamily:'font-family',
        fontSize:'font-size',
        fontStretch:'font-stretch',
        fontStyle:'font-style',
        fontVariant:'font-variant',
        fontWeight:'font-weight',
        letterSpacing:'letter-spacing',
        lineHeight:'line-height',
        quotes:'quotes',
        textAlign:'text-align',
        textDecoration:'text-decoration',
        textIndent:'text-indent',
        textShadow:'text-shadow',
        textTransform:'text-transform',
        whiteSpace:'white-space',
        wordSpacing:'word-spacing',
        padding:'padding'
    };

    function initConst() {

        if (utils.isMS != null) {
            return;
        }

        // MS includes IE and Edge
        utils.isMS = navigator.appName === 'Microsoft Internet Explorer' ||
            (navigator.appVersion.indexOf('Trident') > -1) ||
            (navigator.appName === "Netscape" && navigator.appVersion.indexOf('Edge') > -1);

        utils.transPrefix = "-webkit-transform" in document.body.style ? "-webkit-"
            : "-moz-transform" in document.body.style ? "-moz-"
            : "-ms-transform" in document.body.style ? "-ms-"
            : "";

        DIV_CONTAINER = document.createElement("div");
        document.body.appendChild(DIV_CONTAINER);

        if(isSupportSVG()){
            var c = document.createElement("canvas");
            // document.body.appendChild(c);
            CANVAS_CTX = c.getContext('2d');

            SVG_CONTAINER = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            document.body.appendChild(SVG_CONTAINER);
            var node = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            SVG_CONTAINER.appendChild(node);
            SVG_CONTAINER._textNode = node;
            SVG_CONTAINER.style.visibility = "hidden";
        }
    }

    /**
     * 
     * @param scale
     * @returns {boolean} scaletrue
     */
    function initPaddingScale(scale) {
        if(scale && scale === SCALE){
            return false;
        }
        SCALE = scale || 1;
        return true;
    }

    /**
     * picknullundefined
     * @returns {*}
     */
    function pick(){
        var arg, length = arguments.length;
        for (var i = 0; i < length; i++) {
            arg = arguments[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
        return null;
    }

    /**
     * 
     * @param value 
     * @returns {boolean} 
     */
    function isArray(value){
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /**
     * length
     * @param sequence 
     */
    function toArray(sequence){
        return Array.prototype.slice.call(sequence);
    }

    function setTextStyle(textS, style){
        style = cssNormalization(style);
        for(var attr in style){
            textS.style(attr, style[attr]);
        }
    }

    /**
     * get text dimension by html, svg or canvas
     * @param {string} text
     * @param {object} style
     * @param {boolean} useHtml
     */
    function getTextDimension(text, style, useHtml) {
        if (text == null) {
            return {width: 0, height: 0};
        }

        if (useHtml) {
            return _getHtmlTextDim(text, style);
        }

        if (!isSupportSVG()) {
            return _getHtmlTextDim(text, style, false);
        }

        var fontSizePxNum = convertREMtoPX(style.fontSize);
        // only svg can display <12px
        // IE11 cannot use 'rem' in canvas
        if (!style['writing-mode'] && fontSizePxNum >= 12) {
            return {
                width: _getCanvasTextWidth(text, fontSizePxNum + 'px', style),
                height: getTextHeight(style)
            }
        }

        return _getSvgTextDim(text, style);
    }

    function getTextWrapDimension(text, style, useHTML){

        var newStyle = extend({
            'white-space': 'normal',
            'whiteSpace': 'normal',
            'word-wrap': 'break-word',
            'wordWrap': 'break-word'
        }, style);

        return _getHtmlTextDim(text, newStyle, useHTML);
    }

    function _getHtmlTextDim(text, style, useHtml){
        DIV_CONTAINER.style.cssText = '';

        DIV_CONTAINER.style.visibility = "hidden";
        DIV_CONTAINER.style.whiteSpace = "nowrap";
        DIV_CONTAINER.style.position = 'absolute';
        DIV_CONTAINER.style.display = '';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                DIV_CONTAINER.style[property] = style[property];
            }
        }

        if (useHtml === false) {
            DIV_CONTAINER.textContent ?
                (DIV_CONTAINER.textContent = text) :
                (DIV_CONTAINER.innerText = text);
        } else {
            DIV_CONTAINER.innerHTML = text;
        }

        var width = DIV_CONTAINER.offsetWidth || 0;
        var height = DIV_CONTAINER.offsetHeight || 0;
        var size = {width:width, height:height};

        DIV_CONTAINER.style.display = 'none';
        return size;
    }

    function _getSvgTextDim(text, style) {

        SVG_CONTAINER.style.display = "";

        var node = SVG_CONTAINER._textNode;
        node.textContent = text;

        node.style.cssText = '';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                node.style[property] = style[property];
            }
        }

        var box = node.getBBox();
        var size = {width: box.width, height:box.height};

        SVG_CONTAINER.style.display = "none";
        return size;
    }

    function _getCanvasTextWidth(text, fontSize, style) {
        if(!CANVAS_CTX){
            return 0;
        }

        var fontStyle = style['fontStyle'] || '';
        var fontWeight = style['fontWeight'] || '';
        var fontFamily = style['fontFamily'] || '';

        var det = fontStyle === 'italic' ? 5 : 0;

        CANVAS_CTX.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;
        return CANVAS_CTX.measureText(text).width + det || 0;
    }

    function setDomBackground(dom, opt){

        var cssText = [];
        if (opt.backgroundColor) {
            if(typeof opt.backgroundColor == 'string'){
                if(isSupportSVG()){
                    cssText.push('background-Color:' + opt.backgroundColor);
                }else{
                    var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                    cssText.push('background-Color:' + hexAlpha.hex);
                    cssText.push('filter:alpha(opacity=' + hexAlpha.alpha * 100 + ')')
                }
            }else if(typeof opt.backgroundColor == 'object'){

                var color = opt.backgroundColor;
                var startColor = ColorUtils.colorToHex(color.startColor);
                var endColor = ColorUtils.colorToHex(color.endColor);

                var start = 'left';

                var startPos = 'left top';
                var endPos = 'right top';
                var type = 1;

                if(color.x1 == color.x2){
                    start = 'top';

                    startPos = 'left top';
                    endPos = 'left bottom';

                    type = 0;
                }

                cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
            }
        }

        if(opt.backgroundImage){
            cssText.push('background-image:url(' + opt.backgroundImage + ')');
            cssText.push('background-size:100% 100%');
        }

        if (opt.borderWidth != null) {
            cssText.push('border-style:solid');
            cssText.push('border-width:' + opt.borderWidth + 'px');
        }

        if (opt.borderColor != null) {
            cssText.push('border-color:' + opt.borderColor);
        }

        if (opt.borderRadius != null) {
            cssText.push(
                'border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-moz-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-webkit-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-o-border-radius:' + opt.borderRadius + 'px'
            );
        }

        if(opt.shadow){
            cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
        }

        dom.style.cssText += cssText.join(';') + ';';
    }

    function getTextHeight(style) {
        var fontSize = style.fontSize || '0.75rem';
        return convertREMtoPX(fontSize);
    }

    function stamp(obj){
        obj._vanchart_id = obj._vanchart_id || ('vancharts' + ++lastID);
        return obj._vanchart_id;
    }

    //properties mix in
    function extend(dest) {
        var i, j, len, src;

        for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
                dest[i] = src[i];
            }
        }

        return dest;
    }

    function domRotate(div, rotation){

        var cssText = [];
        cssText.push('transform:rotate(' + rotation + 'deg)');
        cssText.push('-ms-transform:rotate(' + rotation + 'deg)');
        cssText.push('-webkit-transform:rotate(' + rotation + 'deg)');
        cssText.push('-moz-transform:rotate(' + rotation + 'deg)');
        cssText.push('-o-transform:rotate(' + rotation + 'deg)');

        var costheta = Math.cos(toRadian(rotation));
        var sintheta = Math.sin(toRadian(rotation));

        //ie9filterms-transform
        if(!isSupportSVG()){
            var filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                ', sizingMethod=\'auto expand\')'].join('') : 'none';
            cssText.push('filter:' + filter);
        }

        div.style.cssText += (cssText.join(';') + ';');
    }

    //breakWord == false:-
    function splitText(text, style, offeredSize, padding, breakWord){

        if(!text){
            return [];
        }

        text += '';

        padding = padding || 0;

        offeredSize -= 2*padding;

        var result = [];

        var startIndex = 0;
        var textCount = text.length;

        while(startIndex < textCount){
            var i = startIndex;
            while(getTextDimension(text.substring(i, startIndex + 1), style, false).width < offeredSize){
                startIndex++;
                if(startIndex >= textCount){
                    break;
                }
            }

            if(i == startIndex){
                //
                return ['...'];
            }else{
                var substring = text.substring(i, startIndex);

                if(breakWord == false && startIndex != textCount && startIndex - 1 > i) {

                    var lastChar = text.charAt(startIndex - 1);
                    var nextChar = text.charAt(startIndex);

                    //&&"-"
                    if (/[A-Za-z]/.test(lastChar) && /[A-Za-z]/.test(nextChar)) {
                        var char = text.charAt(startIndex - 2);
                        substring = text.substring(i, startIndex - 1);
                        startIndex--;

                        if (char !== ' ' && char !== '-') {
                            substring += '-';
                        }
                    }
                    //
                    // else if(/[0-9]/.test(lastChar)){
                    //     var lastIndex = startIndex - 1;
                    //
                    //     while (lastIndex > i){
                    //         var char = text.charAt(lastIndex - 1);
                    //         lastIndex--;
                    //         if(!/[0-9]/.test(char)){
                    //             break;
                    //         }
                    //     }
                    //     if(lastIndex == i){//
                    //         lastIndex = startIndex - 1;
                    //     }
                    //
                    //     startIndex = lastIndex + 1;
                    //     substring = text.substring(i, startIndex);
                    // }
                }

                result.push(substring);
            }

        }

        return result;
    }

    function getTextDimensionWithRotation(text, style, useHtml, rotation){

        var dim = getTextDimension(text, style, useHtml);

        return getTextDimRotated(dim, rotation);
    }

    function getTextDimRotated(dim, rotation) {
        var angle = Math.abs(toRadian(rotation || 0));

        var width = dim.width * Math.cos(angle) + dim.height * Math.sin(angle);
        var height = dim.width * Math.sin(angle) + dim.height * Math.cos(angle);

        return {
            width:width,
            height:height
        }
    }

    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (isArray(source)) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            }else{
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }

        return source;
    }

    //stylecss
    function cssNormalization(style){
        var result = {};
        for(var attr in style){
            if(styleToCss[attr]){
                result[styleToCss[attr]] = style[attr];
            }

            if(attr == 'color'){
                result.color = style[attr];
            }

            //px
            if(attr == 'fontSize'){
                var fontSize = style[attr];
                if(fontSize.indexOf('pt') != -1){
                    fontSize = parseFloat(fontSize) * 4 / 3;
                    result['font-size'] = fontSize + 'px';
                }
            }
        }
        return result;
    }

    /**
     * csspaddingmargin~
     */
    function reformCssArray(p) {
        if (p instanceof Array) {
            switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [p[0], p[1], p[2], p[1]];
                case '2':
                    return [p[0], p[1], p[0], p[1]];
                case '1':
                    return [p[0], p[0], p[0], p[0]];
                case '0':
                    return [0, 0, 0, 0];
            }
        }
        else {
            return [p, p, p, p];
        }
    }

    function lineSubPixelOpt(xOry, lineWidth){
        return lineWidth % 2 === 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }

    function rectSubPixelOpt(){

        var x, y, width, height, lineWidth;
        if(arguments.length === 2){
            x = arguments[0].x; y = arguments[0].y; width = arguments[0].width; height = arguments[0].height;
            lineWidth = arguments[1];
        }else{
            x = arguments[0]; y = arguments[1]; width = arguments[2]; height = arguments[3];
            lineWidth = arguments[4];
        }

        lineWidth = lineWidth || 0;
        x = lineSubPixelOpt(x, lineWidth);
        y = lineSubPixelOpt(y, lineWidth);
        width = Math.round(width);
        height = Math.round(height);
        return {x:x, y:y, width:width, height:height};
    }

    function addArray(targetArray, sourceArray){

        var result = [];

        if(targetArray && targetArray.length){
            for(var i = 0, len = targetArray.length; i < len; i++){
                result.push(targetArray[i]);
            }
        }

        if(sourceArray && sourceArray.length){
            for(var i = 0, len = sourceArray.length; i < len; i++){
                result.push(sourceArray[i]);
            }
        }

        return result;
    }

    function toFront(el){
        if(el && el.parentNode){
            el.parentNode.appendChild(el);
        }
    }

    function toBack(el){
        if(el && el.parentNode){
            el.parentNode.insertBefore(el,el.parentNode.firstChild);
        }
    }

    function toFrontOfAll(el){
        el.ownerSVGElement.appendChild(el);
    }

    function toBackOfAll(el){
        el.ownerSVGElement.appendChild(el,el.ownerSVGElement.firstChild);
    }

    //
    function containsRect(biggerOne, smallOne){

        return biggerOne.x <= smallOne.x
                    && biggerOne.y <= smallOne.y
                    && biggerOne.x + biggerOne.width >= smallOne.x + smallOne.width
                    && biggerOne.y + biggerOne.height >= smallOne.y + smallOne.height;

    }

    function rectangleOverlapped(aBounds, bBounds){
        if (!aBounds|| !bBounds) {
            return false;
        }
        var minx = Math.max(aBounds.x, bBounds.x);
        var miny = Math.max(aBounds.y, bBounds.y);
        var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
        var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
        return (minx <= maxx && miny <= maxy);
    }

    function outsideRect(biggerOne, smallOne){

        return !containsRect(biggerOne, smallOne) && !rectangleOverlapped(biggerOne, smallOne);

    }

    function containsPoint(rect, point){

        if(!rect || !point){
            return false;
        }

        var x = pick(point.x || point[0]);

        var y = pick(point.y || point[1]);

        return rect.x < x && rect.x + rect.width > x
                && rect.y < y && rect.y + rect.height > y;
    }

    function isSupportSVG(){
        return !!(window.SVGSVGElement);
    }

    function makeValueInRange(min, max, value){

        var rMin = Math.min(min, max);
        var rMax = Math.max(min, max);
        var gap = rMax - rMin;

        return ((value-rMin) % gap + gap) % gap + rMin;
    }

    function getValueInDomain(value, domain){

        return Math.min(Math.max(value, domain[0]), domain[1]);

    }

    function toRadian(degree){
        return Math.PI * (degree / 180);
    }

    function toDegree(radian){
        return radian * 180 / Math.PI;
    }

    //formatter
    function getFormatterFunction(formatter){

        if(formatter == null || formatter === ''){
            return null;
        }

        if(typeof formatter == 'string'){
            var formatterFunc = (new Function("return "+ formatter))();

            //
            if(typeof formatterFunc == 'string'){
                eval("var _tmpFunc = " + formatterFunc);
                return _tmpFunc;
            }

            return formatterFunc;
        }

        return formatter;
    }

    function format(cv, fmt){

        fmt = getFormatterFunction(fmt);

        return typeof fmt == 'function' ? fmt.bind(cv)(cv) : cv;
    }

    function clone(obj) {
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj) {
            return obj;
        }

        // Handle Date
        if (obj instanceof Date) {
            var copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }

        // Handle Array
        if (obj instanceof Array) {
            var copy = [];
            for (var i = 0, len = obj.length; i < len; ++i) {
                copy[i] = clone(obj[i]);
            }
            return copy;
        }

        if(obj instanceof String){
            // convert String 'object' to 'string'
            // do not use String object
            return obj + '';
        }

        // Handle Object
        if (obj instanceof Object) {
            var copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) {
                    copy[attr] = clone(obj[attr]);
                }
            }
            return copy;
        }
    }

    function isEmpty(value){
        var result = value === "" || value === null || value === undefined;
        return result;
    }

    function isNull(v){
        return v == undefined || v == null
    }

    function isIE() { //ie?
        if (!!window.ActiveXObject || "ActiveXObject" in window)
            return true;
        else
            return false;
    }

    // null == undefined  true
    function hasNotDefined(value){
        return value === null || value === undefined;
    }

    function hasDefined(value){
        return !hasNotDefined(value);
    }

    function makeBounds(){

        var x = 0, y = 0, width = 0, height = 0;

        if(arguments.length === 2){

            var pos = arguments[0];
            var dim = arguments[1];

            x = pick(pos.x, pos[0]);
            y = pick(pos.y, pos[1]);

            width = pick(dim.width, dim[0]);
            height = pick(dim.height, dim[1]);

        }else if(arguments.length === 4){

            x = arguments[0];
            y = arguments[1];

            width = arguments[2];
            height = arguments[3];
        }

        return {
            x:x,
            y:y,
            width:width,
            height:height
        };

    }

    function distance(p1, p2){
        var x1 = pick(p1.x, p1[0]);
        var y1 = pick(p1.y, p1[1]);

        var x2 = pick(p2.x, p2[0]);
        var y2 = pick(p2.y, p2[1]);

        var detX = x1 - x2;
        var detY = y1 - y2;

        return Math.sqrt(detX * detX + detY * detY);
    }

    function isEmptyBounds(bounds){
        return bounds.width <= 0 || bounds.height <= 0;
    }

    function log(logBase, value){
        return accDiv(newMathLog(value), newMathLog(logBase));
    }

    /**
     * Math.pow(Math.E, Math.log(0.1)) = 0.10000000000000003
     *  Math.pow(Math.E, Math.log(10)) = 10
     * @param value
     * @returns {number}
     */
    function newMathLog(value){
        return value < 1 ? -Math.log(accDiv(1,value)) : Math.log(value);
    }

    function getOrder(value) {
        var order = 0;
        if(value > 0 && value < 1) {
            while(value < 1) {
                value = accMul(value, 10);
                order--;
            }
        } else if(value >= 10) {
            while(value >= 10) {
                value = accDiv(value, 10);
                order++;
            }
        }

        return order;
    }

    //
    function getPercentValue(value, total){
        if(value){
            value += '';
            if(value.indexOf('%') != -1){
                value = parseFloat(value) * total / 100;
            }
            return parseFloat(value);
        }
        return 0;
    }

    // 1.1e-7 -> 8
    function getDecimalPlaces(num) {
        var m = (num + '').match(decimalPlacesRegExp);
        return m ? ((m[1] ? m[1].length : 0) + (+m[2] || 0)) : 0;
    }

    function accAdd(arg1, arg2) {
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 + arg2; }

        var r1 = getDecimalPlaces(arg1);
        var r2 = getDecimalPlaces(arg2);

        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }

    function accDiv(arg1,arg2){
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 / arg2; }

        var s1 = arg1 + '', s2 = arg2 + '';
        var m = -getDecimalPlaces(arg1);
        m += getDecimalPlaces(arg2);

        var a = s1.replace(decimalRegExp, '');
        var b = s2.replace(decimalRegExp, '');

        return (m > 0) ? (a / b * Math.pow(10, m)) : (a / b / Math.pow(10, -m));
    }

    function accMul(arg1, arg2){
        if (arg1 % 1 === 0 && arg2 % 1 === 0) { return arg1 * arg2; }

        var s1 = arg1 + '', s2 = arg2 + '';
        var m = getDecimalPlaces(arg1);
        m += getDecimalPlaces(arg2);

        return s1.replace(decimalRegExp, '') * s2.replace(decimalRegExp, '') / Math.pow(10, m);
    }

    function objectToArray(object){
        if (object.length) {
            return [].slice.call(object);
        }
        var result = [];
        for(var key in object){
            result.push(object[key]);
        }
        return result;
    }

    function date2int(date){
        if(date == null) {
            return null;
        }

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }

        var baseDate = new Date("1970/01/01");

        if(typeof date == typeof(0)){
            return date;
        }else{
            return date.getTime() - baseDate.getTime();
        }

    }

    function int2date(milliseconds){

        var baseDate = new Date("1970/01/01");

        milliseconds = milliseconds || 0;

        return new Date(milliseconds + baseDate.getTime());
    }

    function object2date(obj){

        var date = obj;

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }else if(typeof date == typeof(0)){
            date = new Date(date)
        }

        return date;
    }

    function makeTranslate(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);
        return 'translate(' + x + ',' + y + ')';
    }

    function makeTranslate3d(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);
        var z = pick(pos.z, pos[2], 0);
        return 'translate3d(' + x + 'px,' + y + 'px,' + z + 'px)';
    }

    function isImageMarker(markerType){
        var ALL_SYMBOLS = Constants.LOCATION + Constants.STAR + Constants.CIRCLE + Constants.SQUARE + Constants.DIAMOND + Constants.TRIANGLE
            + Constants.CIRCLE_HOLLOW + Constants.SQUARE_HOLLOW + Constants.DIAMOND_HOLLOW + Constants.TRIANGLE_HOLLOW;

        return ALL_SYMBOLS.indexOf(markerType) == -1 && hasDefined(markerType);
    }

    function isNullMarker(marker){
        return hasNotDefined(marker.symbol);
    }

    function getDefaultMarkerSymbol(seriesIndex){
        var ALL_SYMBOLS = [Constants.CIRCLE, Constants.CIRCLE_HOLLOW, Constants.SQUARE, Constants.SQUARE_HOLLOW,
            Constants.DIAMOND, Constants.DIAMOND_HOLLOW, Constants.TRIANGLE, Constants.TRIANGLE_HOLLOW];

        return ALL_SYMBOLS[seriesIndex%ALL_SYMBOLS.length];
    }

    function splitWords (str) {
        str = str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        return str.split(/\s+/);
    }

    function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    function removeEvent(el, type, fn){

        if (el.removeEventListener) {
            el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
            el.detachEvent('on' + type, fn);
        }

    }

    function dealFloatPrecision(v){
        return Math.abs(v) < 1e-6 ? 0 : v;
    }

    function getDomWidth(root){
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
    }

    function getDomHeight(root){
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
    }

    function hasTouch(){
        var doc = window.document;
        return doc && doc.documentElement.ontouchstart !== undefined;
    }

    function getArcPoint(r, radian){
        return [r * Math.sin(radian), -r * Math.cos(radian)]
    }

    function getArcByPoint (x, y) {
        return (2 * Math.PI - (Math.atan2(y, x) - Math.PI/2)) % (2 * Math.PI);
    }

    function calculateAutoMinMaxAndGap (minValue, maxValue, splitNumber){

        if(maxValue < minValue){
            minValue = 0; maxValue = 100;
        }

        var increment = accAdd(maxValue, -minValue);
        var order = getOrder(increment);
        var pow = Math.pow(10, order);

        if(order <= 0){
            minValue = accMul(minValue, Math.pow(10, 1 - order));
            minValue = accDiv(Math.floor(minValue), Math.pow(10, 1 - order));
        }else{
            minValue = Math.floor(minValue / pow) * pow;
        }

        var base = accMul(accDiv(splitNumber, 10),pow);
        var gap = 0;
        while(gap < increment){
            gap = accAdd(base, gap);
        }

        var bd = accDiv(gap, splitNumber);

        while(minValue + bd * splitNumber < maxValue){
            gap = accAdd(base, gap);
            bd = accDiv(gap, splitNumber);
        }
        gap = accDiv(gap, splitNumber);

        maxValue = accAdd(minValue, accMul(gap, splitNumber));

        return [minValue, maxValue, gap];
    }

    //FRArray.prototype.indexOf
    //point-points-series-point
    function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === el) { return i; }
        }
        return -1;
    }
    
    function hasChn(str) {
        return /[\u4E00-\u9FA5]/.test(str);
    }

    //rempx
    //
    //
    function convertREMtoPX(size) {
        size += '';
        if(size.indexOf('rem') != -1){
            size = parseFloat(size);
            size = size * getDefaultFontSize();
        }else if (size.indexOf('pt') != -1){
            size = parseFloat(size) * 4 / 3;
        }else{
            size = parseFloat(size);
        }
        return size;
    }

    /**
     * 
     * @param  {Number} size 
     * @return {Number}      Scale
     */
    function paddingConvertWithScale(size) {
        return Math.round(convertREMtoPX(size) * SCALE);
    }
    /**
     * Scale(px)
     * @param  {[Obejct]} style []
     * @return {[Object]}       []
     */
    function calculateFontSizeWithScale(style){ 
        if(style){ 
            var size = style.fontSize + ''; 
 
            style.FONT_SCALE = style.FONT_SCALE || 1; 
 
            if (size.indexOf('rem') != -1) { 
                size = parseFloat(size) * 16; 
            }else if (size.indexOf('pt') != -1) { 
                size = parseFloat(size) * 4 / 3; 
            }else { 
                size = parseFloat(size); 
            } 
 
            style.fontSize = size * SCALE / style.FONT_SCALE + 'px'; 
            style.FONT_SCALE = SCALE; 
        } 
 
        return style; 
    }

    function getDefaultFontSize() {
        if(hasNotDefined(utils.defaultFontSize)){
            var style = document.documentElement.currentStyle || document.defaultView.getComputedStyle(document.documentElement);
            utils.defaultFontSize = _getDefaultFontSizeToPX(style.fontSize);
        }
        return utils.defaultFontSize;
    }

    function _getDefaultFontSizeToPX(size) {
        if (size.indexOf('px') != -1){
            return parseFloat(size);
        }
        if (size.indexOf('pt') != -1){
            return parseFloat(size) * 4 / 3;
        }

        return 16;
    }

    //1em()=16px.10px0.625rem
    //ie8rempx
    function convertToREMUseDefault16PX(style) {
        if(style) {
            var size = style.fontSize + '';

            if(isSupportSVG()) {
                size = isNaN(parseFloat(size)) ? '0.75rem' : size;

                if (size.indexOf('rem') != -1) {
                    size = parseFloat(size) * 16;
                }else if (size.indexOf('pt') != -1) {
                    size = parseFloat(size) * 4 / 3;
                }

                style.fontSize = parseFloat(size) / 16 + 'rem';
            } else if(size && size.indexOf('rem') != -1){
                style.fontSize = parseFloat(size) * 16 + 'px';
            }
        }
        return style;
    }

    function toPng(url) {
        var a = document.createElement("a");
        var img = document.createElement("img");
        a.style.display = "none";
        a.appendChild(img);
        img.setAttribute('src', url);
        document.body.appendChild(a);
        a.setAttribute("target","_blank");
        a.setAttribute("href", url);
        a.setAttribute("download", 'export.png');
        a.click();
    }

    function getPlainText(val) {
        DIV_CONTAINER.style.cssText = 'visibility: hidden;';
        DIV_CONTAINER.innerHTML = val;

        if (DIV_CONTAINER.textContent) {
            return DIV_CONTAINER.textContent;
        }

        return DIV_CONTAINER.innerText;
    }

    function computeArc (ax, ay, bx, by, c) {
        var th = Math.asin(c),
            absX = Math.abs(ax - bx),
            absY = Math.abs(ay - by),
            l = Math.sqrt(absX * absX + absY * absY) / 2,
            direction = ax > bx ? -1 : 1,
            d = direction * l / Math.tan(th),
            al = Math.atan((ay - by) / (bx - ax)),
            w = d * Math.sin(al),
            h = d * Math.cos(al),
            mx = (ax + bx) / 2,
            my = (ay + by) / 2,
            ox = mx + w,
            oy = my + h,
            sAngX = ax - ox,
            sAngY = ay - oy,
            eAngX = bx - ox,
            eAngY = by - oy,
            sAng = normalRadian(Math.atan2(sAngY, sAngX)),
            eAng = normalRadian(Math.atan2(eAngY, eAngX));

        if (sAng > eAng) {
            eAng += DOUBLE_PI;
        }

        return [ox, oy, l / c, sAng, eAng];
    }

    function normalRadian (angle) {
        angle %= DOUBLE_PI;
        if (angle < 0) {
            angle += DOUBLE_PI;
        }
        return angle;
    }

    // @function formatNum(num: Number, digits?: Number): Number
    // Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
    function formatNum(num, digits){
        var pow = Math.pow(10, digits || 5);
        return Math.round(num * pow) / pow;
    }

    function wrapNum(x, range, includeMax) {
        var max = range[1],
            min = range[0],
            d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
    }

    // @function bind(fn: Function, ): Function
    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
    // Has a `L.bind()` shortcut.
    function bind(fn, obj) {
        var slice = Array.prototype.slice;

        if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
        }

        var args = slice.call(arguments, 2);

        return function () {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
    }

    function getParamString(obj, existingUrl, uppercase){
        var params = [];
        for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
        }
        return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
    }

    function template(str, data) {
        return str.replace(templateRe, function (str, key) {
            var value = data[key];

            if (value === undefined) {
                throw new Error('No value provided for variable ' + str);

            } else if (typeof value === 'function') {
                value = value(data);
            }
            return value;
        });
    }

    // @function setOptions(obj: Object, options: Object): Object
    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `BaseUtils.setOptions` shortcut.
    function setOptions(obj, options) {
        if (!obj.hasOwnProperty('options')) {
            obj.options = obj.options ? Object.create(obj.options) : {};
        }
        for (var i in options) {
            obj.options[i] = options[i];
        }
        return obj.options;
    }

    function createOptions(options, optArray){
        optArray.forEach(function(opt){
            if(opt){
                for(var i in opt){
                    if(hasNotDefined(options[i]) && !skipKeys[i]){
                        options[i] = opt[i];
                    }
                }
            }
        });

        return options;
    }

    // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

    function getPrefixed(name) {
        return window['webkit' + name] || window['moz' + name] || window['ms' + name];
    }

    var lastTime = 0;

    // fallback for IE 7-8
    function timeoutDefer(fn) {
        var time = +new Date(),
            timeToCall = Math.max(0, 16 - (time - lastTime));

        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
    }

    var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
        cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
            getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


    // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
    // `context` if given. When `immediate` is set, `fn` is called immediately if
    // the browser doesn't have native support for
    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
    function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
        } else {
            return requestFn.call(window, bind(fn, context));
        }
    }

    // @function cancelAnimFrame(id: Number): undefined
    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
    function cancelAnimFrame (id) {
        if (id) {
            cancelFn.call(window, id);
        }
    }

    // @function throttle(fn: Function, time: Number, context: Object): Function
    // Returns a function which executes function `fn` with the given scope `context`
    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
    // `fn` will be called no more than one time per given amount of `time`. The arguments
    // received by the bound function will be any arguments passed when binding the
    // function, followed by any arguments passed when invoking the bound function.
    // Has an `L.bind` shortcut.
    function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;

        later = function () {
            // reset lock and call if queued
            lock = false;
            if (args) {
                wrapperFn.apply(context, args);
                args = false;
            }
        };

        wrapperFn = function () {
            if (lock) {
                // called too soon, queue to call later
                args = arguments;

            } else {
                // call and lock until later
                fn.apply(context, arguments);
                setTimeout(later, time);
                lock = true;
            }
        };

        return wrapperFn;
    }

    function rebind(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) {
            target[method = arguments[i]] = _rebind(target, source, source[method]);
        }
        return target;
    }

    function _rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }

    function bindData (layers, dataArray, keyFunction){
        var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [], updateLayers = [];
        var nodeByKeyValue = {}, keyValues = [], keyValue, layer, datum;
        for (i = -1; ++i < n; ) {
            layer = layers[i];
            keyValue = keyFunction ? keyFunction(layer.datum()) : i;
            nodeByKeyValue[keyValue] = layer;
            keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
            datum = dataArray[i];
            keyValue = keyFunction ? keyFunction(datum) : i;
            layer = nodeByKeyValue[keyValue];
            if (!layer) {
                enterFeatures.push(datum);
            }else if(layer !== true){
                layer.datum(datum);
                updateLayers.push(layer);
            }
            nodeByKeyValue[keyValue] = true;
        }

        for (i = -1; ++i < n; ) {
            if (nodeByKeyValue[keyValues[i]] !== true) {
                exitLayers.push(layers[i]);
            }
        }

        return {
            update:updateLayers,
            enter:enterFeatures,
            exit:exitLayers
        }
    }

    function dispatch() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) {
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        }
        return dispatch;
    };

    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) {
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        }
        if (arguments.length === 2) {
            if (listener == null) {
                for (type in this) {
                    if (this.hasOwnProperty(type)) {
                        this[type].on(name, null);
                    }
                }
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new vMap();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) {
                if (l = z[i].on) {
                    l.apply(this, arguments);
                }
            }
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) {
                return l && l.on;
            }
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) {
                listeners.push(listenerByName.set(name, {
                    on: listener
                }))
            };
            return dispatch;
        };
        return event;
    }

    function falseFn() {
        return false;
    }

    function trueFn(){
        return true;
    }

    function emptyFn() {

    }

    /**
     * categoryArray
     * @param array
     * @returns {string}
     */
    function encodeCategoryArray(categoryArray){
        if(!isArray(categoryArray)){ return categoryArray; }

        if(window.JSON) {
            return JSON['stringify'](categoryArray);
        } else {
            var output = '[';
            for(var i = -1; ++i < categoryArray.length;) {
                output += (i > 0 ? ',' : '') + '"' + categoryArray[i] + '"';
            }
            return output + ']';
        }
    }

    /**
     * categoryArray
     * @param  {[string]} categoryArrayStr [description]
     * @return {[array]}                  [description]
     */
    function decodeCategoryArray(categoryArrayStr){
        if(window.JSON) {
            return JSON['parse'](categoryArrayStr);
        } else {
            return eval('(' + categoryArrayStr + ')');
        }
    }

    var utils = {
        dispatch:dispatch,
        rebind:rebind,
        throttle:throttle,
        requestAnimFrame:requestAnimFrame,
        cancelAnimFrame:cancelAnimFrame,
        getParamString:getParamString,
        template:template,
        setOptions:setOptions,
        createOptions:createOptions,
        formatNum:formatNum,
        wrapNum:wrapNum,
        bind:bind,
        initConst:initConst,
        initPaddingScale:initPaddingScale,
        toPng:toPng,
        getDomWidth:getDomWidth,
        getDomHeight:getDomHeight,
        makeTranslate:makeTranslate,
        makeTranslate3d:makeTranslate3d,
        clone:clone,
        date2int:date2int,
        int2date:int2date,
        object2date:object2date,
        log:log,
        getOrder:getOrder,
        getPercentValue:getPercentValue,
        accAdd:accAdd,
        accDiv:accDiv,
        accMul:accMul,
        dealFloatPrecision:dealFloatPrecision,
        isEmpty:isEmpty,
        isEmptyBounds:isEmptyBounds,
        objectToArray:objectToArray,
        toArray:toArray,
        pick:pick,
        isNull:isNull,
        getTextDimension:getTextDimension,
        getTextHeight:getTextHeight,
        splitText:splitText,
        getTextDimensionWithRotation:getTextDimensionWithRotation,
        getTextDimRotated:getTextDimRotated,
        isArray:isArray,
        indexOf:indexOf,
        cssNormalization:cssNormalization,
        reformCssArray:reformCssArray,
        rectSubPixelOpt:rectSubPixelOpt,
        lineSubPixelOpt:lineSubPixelOpt,
        addArray:addArray,
        toFront:toFront,
        toBack:toBack,
        toFrontOfAll:toFrontOfAll,
        toBackOfAll:toBackOfAll,
        containsRect:containsRect,
        rectangleOverlapped:rectangleOverlapped,
        outsideRect:outsideRect,
        containsPoint:containsPoint,
        isSupportSVG:isSupportSVG,
        setTextStyle:setTextStyle,
        domRotate:domRotate,
        makeValueInRange:makeValueInRange,
        getValueInDomain:getValueInDomain,
        toRadian:toRadian,
        toDegree:toDegree,
        getFormatterFunction:getFormatterFunction,
        format:format,
        isIE:isIE,
        hasTouch:hasTouch,
        hasNotDefined:hasNotDefined,
        hasDefined:hasDefined,
        distance:distance,
        makeBounds:makeBounds,
        isImageMarker:isImageMarker,
        isNullMarker:isNullMarker,
        getDefaultMarkerSymbol:getDefaultMarkerSymbol,
        removeEvent:removeEvent,
        getArcPoint:getArcPoint,
        getTextWrapDimension:getTextWrapDimension,
        stamp:stamp,
        splitWords:splitWords,
        trim:trim,
        extend:extend,
        setDomBackground:setDomBackground,
        getArcByPoint:getArcByPoint,
        calculateAutoMinMaxAndGap:calculateAutoMinMaxAndGap,
        hasChn:hasChn,
        convertREMtoPX:convertREMtoPX,
        paddingConvertWithScale:paddingConvertWithScale,
        getDefaultFontSize:getDefaultFontSize,
        convertToREMUseDefault16PX:convertToREMUseDefault16PX,
        getPlainText:getPlainText,
        computeArc:computeArc,
        normalRadian: normalRadian,
        bindData: bindData,
        falseFn:falseFn,
        trueFn:trueFn,
        emptyFn:emptyFn, 
        calculateFontSizeWithScale: calculateFontSizeWithScale,
        decodeCategoryArray: decodeCategoryArray,
        encodeCategoryArray: encodeCategoryArray
    };

    window.VanUtils = utils;//export to the global env

    return utils;
});
/**
 * Created by eason on 15/6/16.
 */

define('utils/QueryUtils',['require'],function(require){

    //optLocation
    function queryList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        for(var i = 0; i < optList.length; i++){
            var result = optList[i] && optList[i][optLocation];
            if(result != undefined){
                return result;
            }
        }
    }

    function merge(target, source, overwrite){
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object') {

                    //target[key]
                    merge(target[key], source[key], overwrite);
                }else if(overwrite || !(key in target) || targetProp == undefined){
                    target[key] = source[key];
                }
            }
        }
        return target;
    }

    return {
        queryList:queryList,
        merge:merge
    };
});
/**
 * Created by eason on 16/5/26.
 *
 * try to use Behavior Delegation
 */

define('utils/Class',['require','./QueryUtils','./BaseUtils'],function(require){

    var QueryUtils = require('./QueryUtils');
    var BaseUtils = require('./BaseUtils');

    function Class(){};

    Class.extend = function(props){

        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            this.callInitHooks();
        };

        var parentProto = NewClass.__super__ = this.prototype;

        var proto = Object.create(parentProto);
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        // inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        // // merge options
        if (proto.options) {
            props.options = BaseUtils.extend(Object.create(proto.options), props.options);
        }

        // mix given properties into the prototype
        BaseUtils.extend(proto, props);

        proto._initHooks = [];

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) { return; }

            if (parentProto.callInitHooks) {
                parentProto.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };

    Class.include = function (props) {
        BaseUtils.extend(this.prototype, props);
        return this;
    };

    // @function addInitHook(fn: Function)
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };

    return Class;
});


/**
 * Created by eason on 16/5/26.
 */

define('dom/Evented',['require','../utils/BaseUtils','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var Class = require('../utils/Class');

    var Evented = Class.extend({

        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function (types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(type, types[type], fn);
                }

            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(types[i], fn, context);
                }
            }

            return this;
        },

        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object.
         */
        off: function (types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(types[i], fn, context);
                }
            }

            return this;
        },

        // attach listener (without syntactic sugar now)
        _on: function (type, fn, context) {

            if(!type || !fn ){//listener
                return ;
            }

            this._events = this._events || {};

            /* get/init listeners for type */
            var typeListeners = this._events[type];
            if (!typeListeners) {
                typeListeners = [];
                this._events[type] = typeListeners;
            }

            if (context === this) {
                // Less memory footprint.
                context = undefined;
            }
            var newListener = {fn: fn, ctx: context},
                listeners = typeListeners;

            // check if fn already there
            for (var i = 0, len = listeners.length; i < len; i++) {
                if (listeners[i].fn === fn && listeners[i].ctx === context) {
                    return;
                }
            }

            listeners.push(newListener);
            typeListeners.count++;
        },

        _off: function (type, fn, context) {
            var listeners,
                i,
                len;

            if (!this._events) { return; }

            listeners = this._events[type];

            if (!listeners) {
                return;
            }

            if (!fn) {
                // Set all removed listeners to noop so they are not called if remove happens in fire
                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].fn = BaseUtils.falseFn;
                }
                // clear all listeners for a type if function isn't specified
                delete this._events[type];
                return;
            }

            if (context === this) {
                context = undefined;
            }

            if (listeners) {

                // find fn and remove it
                for (i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.ctx !== context) { continue; }
                    if (l.fn === fn) {

                        // set the removed listener to noop so that's not called if remove happens in fire
                        l.fn = BaseUtils.falseFn;

                        if (this._firingCount) {
                            /* copy array in case events are being fired */
                            this._events[type] = listeners = listeners.slice();
                        }
                        listeners.splice(i, 1);

                        return;
                    }
                }
            }
        },

        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide an data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function (type, data, propagate) {
            if (!this.listens(type, propagate)) { return this; }

            //todo extend
            var event = data;

            if (this._events) {
                var listeners = this._events[type];

                if (listeners) {
                    this._firingCount = (this._firingCount + 1) || 1;
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        var l = listeners[i];
                        l.fn.call(l.ctx || this, event);
                    }

                    this._firingCount--;
                }
            }

            if (propagate) {
                // propagate the event to parents (set with addEventParent)
                this._propagateEvent(event);
            }

            return this;
        },

        // @method listens(type: String): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        listens: function (type, propagate) {
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) { return true; }

            if (propagate) {
                // also check parents for listeners if event propagates
                for (var id in this._eventParents) {
                    if (this._eventParents[id].listens(type, propagate)) { return true; }
                }
            }
            return false;
        },

        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function (types, fn, context) {

            if (typeof types === 'object') {
                for (var type in types) {
                    this.once(type, types[type], fn);
                }
                return this;
            }

            var handler = BaseUtils.bind(function () {
                this
                    .off(types, fn, context)
                    .off(types, handler, context);
            }, this);

            // add a listener that's executed once and removed after that
            return this
                .on(types, fn, context)
                .on(types, handler, context);
        },

        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function (obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[BaseUtils.stamp(obj)] = obj;
            return this;
        },

        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function (obj) {
            if (this._eventParents) {
                delete this._eventParents[BaseUtils.stamp(obj)];
            }
            return this;
        },

        _propagateEvent: function (e) {
            for (var id in this._eventParents) {
                this._eventParents[id].fire(e.srcEvent.type, e, true);
            }
        }
    });

    return Evented;
});
/**
 * Created by eason on 15/5/18.
 * 
 */
define('ComponentLibrary',[],function(){

    var _registeredComponents = Object.create(null);

    //
    var ComponentsOrder = [
        'tooltip',
        'tools',
        'title',
        'dTools',

        'geo',
        'rangeLegend',
        'legend',
        'zoom',
        'dataSheet',

        'xAxis',
        'yAxis',
        'polar',
        'angleAxis',
        'radiusAxis',

        'gaugeAxis',
        'value',
        'category',

        'multiCategory',

        'datetime',

        'levelBar',
        'processes',
        'timeAxis',

        'moreLabel'
    ];

    /**
     * function
     * @param name 
     */
    function get(name){
        return _registeredComponents[name];
    }

    /**
     * 
     * @param name 
     * @param chart 
     */
    function register(name, compnent){
        _registeredComponents[name] = compnent;
    }

    function getRegisteredComponents(){
        return _registeredComponents;
    }

    return {
        TOOLTIP_COMPONENT:'tooltip',
        TOOLBAR_COMPONENT:'tools',
        GEO_COMPONENT:'geo',
        DRILL_TOOLS:'dTools',

        TITLE_COMPONENT:'title',
        RANGE_LEGEND_COMPONENT:'rangeLegend',
        INTERVAL_RANGE_LEGEND:'intervalRangeLegend',
        GradientRangeLegend:'gradientRangeLegend',
        LEGEND_COMPONENT:'legend',
        DATA_SHEET_COMPONENT:'dataSheet',

        ZOOM_COMPONENT:'zoom',
        X_AXIS_COMPONENT:'xAxis',
        Y_AXIS_COMPONENT:'yAxis',
        POLAR_COMPONENT:'polar',

        RADIUS_AXIS_COMPONENT:'radiusAxis',
        ANGLE_AXIS_COMPONENT:'angleAxis',
        GAUGE_AXIS_COMPONENT:'gaugeAxis',
        VALUE_AXIS_COMPONENT:'value',

        CATEGORY_AXIS_COMPONENT:'category',
        DATE_AXIS_COMPONENT:'datetime',

        LEVELBAR: 'levelBar',
        PROCESSES: 'processes',
        TIMEAXIS: 'timeAxis',

        MORELABEL_COMPONENT: 'moreLabel',
        MULTI_CATEGORY_AXIS_COMPONENT: 'multiCategory', 

        ComponentsOrder:ComponentsOrder,
        getRegisteredComponents:getRegisteredComponents,
        get:get,
        register:register
    }

});
/**
 * Created by eason on 15/8/7.
 */
//
define('utils/BoundsManager',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function BoundsManager(){
        this.addedBounds = [];
    }

    BoundsManager.prototype = {

        constructor:BoundsManager,

        addBounds:function(bounds){
            this.addedBounds.push(bounds);
        },

        isOverlapped:function(bounds){
            for (var i = 0, len = this.addedBounds.length; i < len; i++){
                if (BaseUtils.rectangleOverlapped(bounds, this.addedBounds[i])){
                    return true;
                }
            }
            return false;
        },

        isEmpty:function(){
            return this.addedBounds.length === 0;
        }

    };

    return BoundsManager;
});
/**
 * Created by eason on 15/6/24.
 */
//
//Copyright (c) 2014 Ga?tan Renaudeau
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//    copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//    The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

define('utils/BezierEasing',['require','./vMap'],function(require){

    var vMap = require('./vMap');

    var global = this;

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = 'Float32Array' in global;

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }

    function BezierEasing (mX1, mY1, mX2, mY2) {
        // Validate arguments
        if (arguments.length !== 4) {
            throw new Error("BezierEasing requires 4 arguments.");
        }
        for (var i=0; i<4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                throw new Error("BezierEasing arguments should be integers.");
            }
        }
        if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
            throw new Error("BezierEasing x values must be in [0, 1] range.");
        }

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : [];

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) {return aGuessT;}
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function getTForX (aX) {
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }
            --currentSample;

            // Interpolate to provide an initial guess for t
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;

            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }

        var _precomputed = false;
        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2)
            {calcSampleValues();}
        }

        var f = function (aX) {
            if (!_precomputed) {precompute();}
            if (mX1 === mY1 && mX2 === mY2) {return aX;} // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
            if (aX === 0) {return 0;}
            if (1 - aX  < 0.001) {return 1;}
            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var args = [mX1, mY1, mX2, mY2];
        var str = "BezierEasing("+args+")";
        f.toString = function () { return str; };

        //var css = "cubic-bezier("+args+")";
        //f.toCSS = function () {?return css; };

        return f;
    }

    // CSS mapping
    BezierEasing.css = {
        "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
        "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
        "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
        "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
        "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0),
        "swing":       BezierEasing(0.02, 0.01,0.47, 1.0),
        "ease-in-back":BezierEasing(0.6,-0.28,0.735,0.045),
        "ease-out-back":BezierEasing(0.175, 0.885, 0.32, 1.275),
        "ease-in-quart":BezierEasing(0.895, 0.03, 0.685, 0.22),
        "ease-out-quart":BezierEasing(0.165, 0.84, 0.44, 1),
        "ease-in-quint":BezierEasing(0.755, 0.05, 0.855, 0.06),
        "ease-out-quint":BezierEasing(0.23, 1, 0.32, 1),
        "ease-in-quad":BezierEasing(0.55,0.085,0.68,0.53),
        "ease-out-quad":BezierEasing(0.25,0.46,0.45,0.94),
        "ease-in-out-quad": BezierEasing(0.455, 0.03, 0.515, 0.955),
        "ease-out-cubic":BezierEasing(0.215,0.61,0.355,1)
    };

    BezierEasing.custom = {
        "ease-out":BezierEasing(0.00, 0.0, 0.16, 1.03),
        "ease-out-quint":BezierEasing(0.19, 1, 0.22, 1),
        "ease-out-back":BezierEasing(0.18, 0.89, 0.32, 1.6)
    };

    BezierEasing.calculateCubicOutT = function (det) {
        return (1 - Math.pow(1 - det, 1/3));
    };

    BezierEasing.calculateQuadInT = function (det) {
        return Math.sqrt(det);
    };

    var  = 2 * Math.PI;

    var d3_identity = function(d){
        return d;
    };

    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = new vMap({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = new vMap({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });

    BezierEasing.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
    };

    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * half);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) {
            p = .45;
        }
        if (arguments.length) {
            s = p /  * Math.asin(1 / a);
        }else {
            a = 1, s = p / 4;
        }
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) {
            s = 1.70158;
        }
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }

    return BezierEasing;
});
/**
 * Created by eason on 2016/11/8.
 */


define('vans/VanChartLayout',['require','../Constants','../utils/BaseUtils','../ComponentLibrary','../utils/BoundsManager','../utils/BezierEasing'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var BoundsManager = require('../utils/BoundsManager');
    var BezierEasing = require('../utils/BezierEasing');

    function calculateSeries(vanchart){

        _calculatePercentageRelated(vanchart);

        _calculateTypePercentage(vanchart.seriesOfType(Constants.WORD_CLOUD_CHART));

        calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.BUBBLE_CHART), Constants.BUBBLE_CHART);

        calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.SCATTER_CHART), Constants.SCATTER_CHART);

        calculateBubbleRadius(vanchart.seriesOfType(Constants.BUBBLE_CHART));

        calculateBubbleRadius(vanchart.seriesOfType(Constants.FORCE_BUBBLE_CHART));
    }

    function calculateSeriesShapes(vanchart){
        for(var i = 0, len = vanchart.series.length; i < len; i++){
            var ser = vanchart.series[i];
            if (ser.visible) {
                ser.doLayout();
                ser._calculateLabelPos();
            }
        }

        var manager = new BoundsManager();
        //
        for(var category in vanchart.cateMap){

            var points = vanchart.cateMap[category].filter(function (p) {
                var type = p.series.type;

                var isValidChartType = (type == Constants.BAR_CHART || type == Constants.COLUMN_CHART || type == Constants.AREA_CHART || type == Constants.LINE_CHART);

                return p.labelPos && p.options.dataLabels.autoAdjust && isValidChartType;
            });

            if(!points.length){
                continue;
            }

            var isHorizontalBaseAxis = vanchart.xAxis() && vanchart.xAxis().isHorizontal();
            var key = isHorizontalBaseAxis ? 'y' : 'x';
            var plotBounds = vanchart.bounds, maxY = plotBounds.height, maxX = plotBounds.x;
            points = points.sort(function(a, b){return a.labelPos[key] - b.labelPos[key] + 1});

            var toRightBottom =  isHorizontalBaseAxis ? (points[0].labelPos.y < maxY/2) : (points[0].labelPos.x < maxX/2);

            if(toRightBottom){
                points.reverse();
            }

            for(var i = points.length - 1; i >= 0; i--){
                var point = points[i];
                point.labelPos = point.series._calculateAutoLabelPos(point, point.labelPos, isHorizontalBaseAxis, manager, toRightBottom);
                manager.addBounds(BaseUtils.makeBounds(point.labelPos, point.labelDim));
            }
        }

        _adjustPieRadius(vanchart.seriesOfType(Constants.PIE_CHART));
    }

    function PLANE_SYSTEM_LAYOUT(vanchart){

        calculateSeries(vanchart);

        fixCoordinateSystem(vanchart);
    }

    function _adjustPieRadius (series) {
        var _sCache = [];
        var minRadius = series.reduce(function (min, s) {
            if (!s.options.radius) { // if it's calculated by us
                _sCache.push(s);
                return s.chartInfo.radius // get min calculated radius
            }
        }, 0);

        _sCache.map(function (s) {
            s.adjustRadius(minRadius);
        });
    }

    /**
     *
     * @private
     */
    function _calculatePercentageRelated(vanchart){
        var stackMap = {}, series = vanchart.series;
        for(var i = 0, len = series.length; i < len; i++){
            var ser = series[i], type = ser.type;

            if(ser.isTreeSeries() || type == Constants.WORD_CLOUD_CHART){
                continue;//
            }

            if(ser.isSeriesAccumulated()){
                if(ser._calculatePercentage){
                    ser._calculatePercentage();
                } else {
                    var key = ser.getTargetKey();
                    _calculatePercentage(ser.points, key);
                    _calculateStackedValue(ser.points, key);
                }
            }else{
                if(ser.visible){
                    ser.points.map(function (p) {
                        var stackKey = [type, ser.stack, p.getCategory()].join('-');
                        stackMap[stackKey] || (stackMap[stackKey] = []);
                        stackMap[stackKey].push(p);
                    });
                }
            }
        }

        for (var stackKey in stackMap) {
            var points = stackMap[stackKey];
            var key = points[0].series.getTargetKey();

            _calculatePercentage(points, key);

            _calculateStackedValue(points, key);
        }

        //
        for(var i = 0, len = series.length; i < len; i++){
            var sery = series[i];
            sery.points.forEach(function(p){
                sery.calculateLabelInfo(p);
            });
        }
    }

    function _calculateTypePercentage(series) {
        if(series && series.length){
            var allPoints = [];
            series.forEach(function (ser) {
                allPoints = allPoints.concat(ser.points);
            });

            _calculatePercentage(allPoints, series[0].getTargetKey());
        }
    }

    function calculateDelayTime(vanchart, series, type) {
        var sortFunc, easeFunc;

        if(type == Constants.BUBBLE_CHART){
            easeFunc = 'swing';
            sortFunc = function (pointA, pointB) {
                return pointB.radius - pointA.radius;
            }
        } else if(type == Constants.SCATTER_CHART){
            var isInverted = vanchart.isInverted();
            easeFunc = 'exp-in-out';
            sortFunc = function (pA, pB) {
                return isInverted ? pA.posY - pB.posY : pA.posX - pB.posX;
            }
        }

        var allPoints = [];

        series.forEach(function(sery){
            allPoints = allPoints.concat(sery.points);
        });

        allPoints.sort(sortFunc);

        var len = allPoints.length;
        if (len > 0) {
            allPoints.forEach(function (point, i) {
                point.delayTime = BezierEasing.ease(easeFunc)(i/len) * 800;
            });
        }
    }

    function calculateBubbleRadius(bubbleSeries) {
        //
        bubbleSeries.forEach(function(sery) {
            sery._calculateMinMax4Radius();
        });

        bubbleSeries.forEach(function (sery) {
            sery._calculateBubbleRadius();
        });
    }

    function _calculateStackedValue(points, key){
        if(points && points.length){

            var series = points[0].series;
            var byPercent = series.options.stackByPercent;
            var stack = series.stack || byPercent;
            var stackAxis = series.getStackAxis();
            var dividingLine = stackAxis && stackAxis.isLog() ? 1 : 0;

            var preSumP = dividingLine, preSumN = dividingLine;

            for(var i = 0, count = points.length; i < count; i++){
                var point = points[i], options = point.options;
                if(stack){
                    var usedValue = byPercent ? point.percentage : point.getTargetValue();
                    if(usedValue >= dividingLine){
                        options[key + '0'] = preSumP;
                        preSumP += usedValue;
                    }else{
                        options[key + '0'] = preSumN;
                        preSumN += usedValue;
                    }
                }else{
                    options[key + '0'] = dividingLine;
                }
            }
        }
    }

    function _calculatePercentage(points, key){
        var total = 0;
        points.filter(function (d) {return !d.isNull && d.visible;})
            .forEach(function(d){
                total += Math.abs(d[key]);
            });

        total = total > 0 ? total : 1;

        points.forEach(function(point){
            var series = point.series, key = series.getTargetKey(), baseAxis = series[series.getBaseAxisType()];
            var temp = !series.stack && baseAxis && baseAxis.type != ComponentLibrary.CATEGORY_AXIS_COMPONENT;
           
            //1
            point.percentage = temp ? 1 : Math.abs(point[key]) / total;
        });
    }

    
    function fixCoordinateSystem(vanchart){

        vanchart.bounds = vanchart._getDefaultBounds();

        //
        ComponentLibrary.ComponentsOrder.map(function (c) {

            //axis layoutclip vanchart.bounds,

            if (c in vanchart.components) {
                vanchart.components[c] && vanchart.components[c].doLayout();
            }

        }, this);


        vanchart.plotBounds = vanchart.bounds;//plotBounds

        //, 
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisClip();
        });

        // only for axis bounds now
        _cutPlotBounds(vanchart);

        //, 
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisSizeAndBounds();
        });

        var adjusted = false;
        //, 
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            adjusted = vanchart.components[cName] && vanchart.components[cName].adjustDomain4Radius() || adjusted;
        });

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT,
                    ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.ZOOM_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].fixBoundsByPlot();
        });

        [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT]
            .forEach(function(cName){
                vanchart.components[cName] && vanchart.components[cName].dealOnZero();
            });

        // in case:
        // 'adjustDomain4Radius' adjust yAxis max label 800 -> 1000.
        // Thus yAxis width is changed;
        adjusted && reLayoutPlotBounds(vanchart);

        calculateSeriesShapes(vanchart);
    }


    function reLayoutPlotBounds(vanchart){

        // tmp solution: map has no plotBounds
        if (vanchart.plotBounds) {
            vanchart.bounds = BaseUtils.makeBounds(vanchart.plotBounds, vanchart.plotBounds);
        }

        vanchart.clipPool = {};
        vanchart.axisSize = {
            'left':0, 'right':0, 'bottom':0, 'top':0
        };

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].reCalculateSize();
        });

        //, 
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisClip();
        });

        // only for axis bounds now
        _cutPlotBounds(vanchart);

        //, 
        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].updateAxisSizeAndBounds();
        });

        [ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.X_AXIS_COMPONENT,
            ComponentLibrary.ZOOM_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT].forEach(function(cName){
            vanchart.components[cName] && vanchart.components[cName].fixBoundsByPlot();
        });

        [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT]
            .forEach(function(cName){
                vanchart.components[cName] && vanchart.components[cName].dealOnZero();
            });
    }

    // compare bounds to check if we need cut more
    function _cutPlotBounds(vanchart) {
        var chartBounds = vanchart.getChartBounds();
        var originBounds = vanchart.bounds;
        var x = originBounds.x;
        var y = originBounds.y;
        var width = originBounds.width;
        var height = originBounds.height;

        var left = Math.max(vanchart.clipPool[Constants.LEFT] || 0, x);
        var right = Math.max(vanchart.clipPool[Constants.RIGHT] || 0, chartBounds.width - (x + width));
        var top = Math.max(vanchart.clipPool[Constants.TOP] || 0, y);
        var bottom = Math.max(vanchart.clipPool[Constants.BOTTOM] || 0, chartBounds.height - (y + height));

        originBounds = {
            x: left,
            y: top,
            width: chartBounds.width - left - right,
            height: chartBounds.height - top - bottom
        };

        vanchart.setPlotBounds(originBounds);
    }
    

    return {
        PLANE_SYSTEM_LAYOUT:PLANE_SYSTEM_LAYOUT,
        reLayoutPlotBounds:reLayoutPlotBounds,
        calculateBubbleRadius:calculateBubbleRadius,
        calculateDelayTime:calculateDelayTime,
        calculateSeries:calculateSeries,
        calculateSeriesShapes:calculateSeriesShapes,
        fixCoordinateSystem:fixCoordinateSystem
    }
});
/**
 * Created by eason on 15/5/4.
 * ,
 */
define('ChartLibrary',['require'],function(require){
    var _registeredCharts = {};

    /**
     * function
     * @param name 
     */
    function get(name){
        return _registeredCharts[name];
    }

    /**
     * 
     * @param name 
     * @param chart 
     */
    function register(name, chart){
        _registeredCharts[name] = chart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 2017/1/19.
 */


define('utils/Point2D',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    var Point = function (x, y, round) {
        // @property x: Number; The `x` coordinate of the point
        this.x = (round ? Math.round(x) : x);
        // @property y: Number; The `y` coordinate of the point
        this.y = (round ? Math.round(y) : y);
    };

    Point.prototype = {

        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function () {
            return new Point(this.x, this.y);
        },

        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function (point) {
            // non-destructive, returns a new point
            return this.clone()._add(Point.create(point));
        },

        _add: function (point) {
            // destructive, used directly for performance in situations where it's safe to modify existing point
            this.x += point.x;
            this.y += point.y;
            return this;
        },

        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function (point) {
            return this.clone()._subtract(Point.create(point));
        },

        _subtract: function (point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },

        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function (num) {
            return this.clone()._divideBy(num);
        },

        _divideBy: function (num) {
            this.x /= num;
            this.y /= num;
            return this;
        },

        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function (num) {
            return this.clone()._multiplyBy(num);
        },

        _multiplyBy: function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        },

        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function (point) {
            return new Point(this.x * point.x, this.y * point.y);
        },

        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function (point) {
            return new Point(this.x / point.x, this.y / point.y);
        },

        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function () {
            return this.clone()._round();
        },

        _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },

        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function () {
            return this.clone()._floor();
        },

        _floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },

        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function () {
            return this.clone()._ceil();
        },

        _ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },

        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function (point) {
            point = Point.create(point);

            var x = point.x - this.x,
                y = point.y - this.y;

            return Math.sqrt(x * x + y * y);
        },

        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function (point) {
            point = Point.create(point);

            return point.x === this.x &&
                point.y === this.y;
        },

        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function (point) {
            point = Point.create(point);

            return Math.abs(point.x) <= Math.abs(this.x) &&
                Math.abs(point.y) <= Math.abs(this.y);
        },

        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function () {
            return 'Point(' +
                BaseUtils.formatNum(this.x) + ', ' +
                BaseUtils.formatNum(this.y) + ')';
        }
    };

    Point.create = function(x, y, round){
        if (x instanceof Point) {
            return x;
        }
        if (BaseUtils.isArray(x)) {
            return new Point(x[0], x[1]);
        }
        if (x === undefined || x === null) {
            return x;
        }
        if (typeof x === 'object' && 'x' in x && 'y' in x) {
            return new Point(x.x, x.y);
        }
        return new Point(x, y, round);
    };

    return Point;

});
/**
 * Created by eason on 16/5/26.
 */

define('dom/Browser',[],function(){

    var ua = navigator.userAgent.toLowerCase(),
        doc = document.documentElement,

        ie = 'ActiveXObject' in window,

        webkit    = ua.indexOf('webkit') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android23 = ua.search('android [23]') !== -1,
        chrome    = ua.indexOf('chrome') !== -1,
        gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

        win = navigator.platform.indexOf('Win') === 0,

        mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = window.PointerEvent || msPointer,

        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera12 = 'OTransition' in doc.style;


    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
        (window.DocumentTouch && document instanceof window.DocumentTouch));

    return {

        // @property ie: Boolean
        // `true` for all Internet Explorer versions (not Edge).
        ie: ie,

        // @property ielt9: Boolean
        // `true` for Internet Explorer versions less than 9.
        ielt9: ie && !document.addEventListener,

        // @property edge: Boolean
        // `true` for the Edge web browser.
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),

        // @property webkit: Boolean
        // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
        webkit: webkit,

        // @property gecko: Boolean
        // `true` for gecko-based browsers like Firefox.
        gecko: gecko,

        // @property android: Boolean
        // `true` for any browser running on an Android platform.
        android: ua.indexOf('android') !== -1,

        // @property android23: Boolean
        // `true` for browsers running on Android 2 or Android 3.
        android23: android23,

        // @property chrome: Boolean
        // `true` for the Chrome browser.
        chrome: chrome,

        // @property safari: Boolean
        // `true` for the Safari browser.
        safari: !chrome && ua.indexOf('safari') !== -1,


        // @property win: Boolean
        // `true` when the browser is running in a Windows platform
        win: win,


        // @property ie3d: Boolean
        // `true` for all Internet Explorer versions supporting CSS transforms.
        ie3d: ie3d,

        // @property webkit3d: Boolean
        // `true` for webkit-based browsers supporting CSS transforms.
        webkit3d: webkit3d,

        // @property gecko3d: Boolean
        // `true` for gecko-based browsers supporting CSS transforms.
        gecko3d: gecko3d,

        // @property opera12: Boolean
        // `true` for the Opera browser supporting CSS transforms (version 12 or later).
        opera12: opera12,

        // @property any3d: Boolean
        // `true` for all browsers supporting CSS transforms.
        any3d:(ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


        // @property mobile: Boolean
        // `true` for all browsers running in a mobile device.
        mobile: mobile,

        // @property mobileWebkit: Boolean
        // `true` for all webkit-based browsers in a mobile device.
        mobileWebkit: mobile && webkit,

        // @property mobileWebkit3d: Boolean
        // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
        mobileWebkit3d: mobile && webkit3d,

        // @property mobileOpera: Boolean
        // `true` for the Opera browser in a mobile device.
        mobileOpera: mobile && window.opera,

        // @property mobileGecko: Boolean
        // `true` for gecko-based browsers running in a mobile device.
        mobileGecko: mobile && gecko,


        // @property touch: Boolean
        // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
        touch: !!touch,

        // @property msPointer: Boolean
        // `true` for browsers implementing the Microsoft touch events model (notably IE10).
        msPointer: !!msPointer,

        // @property pointer: Boolean
        // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
        pointer: !!pointer,


        // @property retina: Boolean
        // `true` for browsers on a high-resolution "retina" screen.
        retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
    };

});

/**
 * Created by eason on 16/6/1.
 */

define('dom/DomUtils',['require','../utils/BaseUtils','../utils/Point2D','./Browser'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Point = require('../utils/Point2D');
    var Browser = require('./Browser');

    var DomUtils = {
        // @function get(id: String|HTMLElement): HTMLElement
        // Returns an element given its DOM id, or returns the element itself
        // if it was passed directly.
        get: function (id) {
            return typeof id === 'string' ? document.getElementById(id) : id;
        },

        // @function getStyle(el: HTMLElement, styleAttrib: String): String
        // Returns the value for a certain style attribute on an element,
        // including computed values or values set through CSS.
        getStyle: function (el, style) {

            var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

            if ((!value || value === 'auto') && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }

            return value === 'auto' ? null : value;
        },

        // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
        // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
        create: function (tagName, className, container) {

            var el = document.createElement(tagName);
            el.className = className || '';

            if (container) {
                container.appendChild(el);
            }

            return el;
        },

        // @function remove(el: HTMLElement)
        // Removes `el` from its parent element
        remove: function (el) {
            var parent = el.parentNode;
            if (parent) {
                parent.removeChild(el);
            }
        },

        // @function empty(el: HTMLElement)
        // Removes all of `el`'s children elements from `el`
        empty: function (el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        },

        // @function toFront(el: HTMLElement)
        // Makes `el` the last children of its parent, so it renders in front of the other children.
        toFront: function (el) {
            el.parentNode.appendChild(el);
        },

        // @function toBack(el: HTMLElement)
        // Makes `el` the first children of its parent, so it renders back from the other children.
        toBack: function (el) {
            if(el && el.parentNode){
                var parent = el.parentNode;
                parent.insertBefore(el, parent.firstChild);
            }
        },

        // @function hasClass(el: HTMLElement, name: String): Boolean
        // Returns `true` if the element's class attribute contains `name`.
        hasClass: function (el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = DomUtils.getClass(el);
            return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
        },

        // @function addClass(el: HTMLElement, name: String)
        // Adds `name` to the element's class attribute.
        addClass: function (el, name) {
            if (el.classList !== undefined) {
                var classes = BaseUtils.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!DomUtils.hasClass(el, name)) {
                var className = DomUtils.getClass(el);
                DomUtils.setClass(el, (className ? className + ' ' : '') + name);
            }
        },

        // @function removeClass(el: HTMLElement, name: String)
        // Removes `name` from the element's class attribute.
        removeClass: function (el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                DomUtils.setClass(el, BaseUtils.trim((' ' + DomUtils.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
            }
        },

        // @function setClass(el: HTMLElement, name: String)
        // Sets the element's class.
        setClass: function (el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                // in case of SVG element
                el.className.baseVal = name;
            }
        },

        // @function getClass(el: HTMLElement): String
        // Returns the element's class.
        getClass: function (el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },

        // @function setOpacity(el: HTMLElement, opacity: Number)
        // Set the opacity of an element (including old IE support).
        // `opacity` must be a number from `0` to `1`.
        setOpacity: function (el, value) {

            if ('opacity' in el.style) {
                el.style.opacity = value;

            } else if ('filter' in el.style) {
                DomUtils._setOpacityIE(el, value);
            }
        },

        _setOpacityIE: function (el, value) {
            var filter = false,
                filterName = 'DXImageTransform.Microsoft.Alpha';

            // filters collection throws an error if we try to retrieve a filter that doesn't exist
            try {
                filter = el.filters.item(filterName);
            } catch (e) {
                // don't set opacity to 1 if we haven't already set an opacity,
                // it isn't needed and breaks transparent pngs.
                if (value === 1) { return; }
            }

            value = Math.round(value * 100);

            if (filter) {
                filter.Enabled = (value !== 100);
                filter.Opacity = value;
            } else {
                el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
            }
        },

        // @function testProp(props: String[]): String|false
        // Goes through the array of style names and returns the first name
        // that is a valid style name for an element. If no such name is found,
        // it returns false. Useful for vendor-prefixed styles like `transform`.
        testProp: function (props) {

            var style = document.documentElement.style;

            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },

        // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
        // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
        // and optionally scaled by `scale`. Does not have an effect if the
        // browser doesn't support 3D CSS transforms.
        setTransform: function (el, offset, scale) {
            var pos = offset || {x:0, y:0};

            el.style[DomUtils.TRANSFORM] =
                (Browser.ie3d ?
                'translate(' + pos.x + 'px,' + pos.y + 'px)' :
                'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
                (scale ? ' scale(' + scale + ')' : '');
        },

        // @function setPosition(el: HTMLElement, position: Point)
        // Sets the position of `el` to coordinates specified by `position`,
        // using CSS translate or top/left positioning depending on the browser
        // (used by Leaflet internally to position its layers).
        setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

            /*eslint-disable */
            el._leaflet_pos = point;
            /*eslint-enable */

            if (Browser.any3d) {
                DomUtils.setTransform(el, point);
            } else {
                el.style.left = point.x + 'px';
                el.style.top = point.y + 'px';
            }
        },

        // @function getPosition(el: HTMLElement): Point
        // Returns the coordinates of an element previously positioned with setPosition.
        getPosition: function (el) {
            // this method is only used for elements previously positioned using setPosition,
            // so it's safe to cache the position for performance
            return el._leaflet_pos || Point.create({x:0, y:0});
        },

        getMousePos:function(event, el){
            event = event.touches ?  (event.touches.length ? event.touches[0] : event.changedTouches[0]) : event;
            var docElem = document.documentElement,
                box = el.getBoundingClientRect();

            var top = box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0);
            var left = box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0);

            var chartX, chartY;
            if (event.pageX == null) {
                chartX = Math.min(event.x, event.clientX - left);
                chartY = Math.min(event.y, event.clientY - top);
            } else {
                chartX = event.pageX - left;
                chartY = event.pageY - top;
            }

            return Point.create(chartX, chartY);
        },

        // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
        // and Firefox scrolls device pixels, not CSS pixels
        _wheelPxFactor: (Browser.win && Browser.chrome) ? 2 :
            Browser.gecko ? window.devicePixelRatio :
                1,

        // @function getWheelDelta(ev: DOMEvent): Number
        // Gets normalized wheel delta from a mousewheel DOM event, in vertical
        // pixels scrolled (negative if scrolling down).
        // Events from pointing devices without precise scrolling are mapped to
        // a best guess of 60 pixels.
        getWheelDelta: function (e) {
            return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
                (e.deltaY && e.deltaMode === 0) ? -e.deltaY / DomUtils._wheelPxFactor : // Pixels
                    (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
                        (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
                            (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
                                e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                                    (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
                                        e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
                                            0;
        },

        preventDefault: function (e) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },

        stopPropagation: function (e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
            return this;
        },

        stop: function (e) {
            return DomUtils
                .preventDefault(e)
                .stopPropagation(e);
        },

        attr: function () {
            if(arguments.length < 2){
                return;
            }
            var elem = arguments[0], prop = arguments[1], value = arguments[2];
            var key, ret;
            if (typeof prop == 'string') {
                // set the value
                if (BaseUtils.hasDefined(value)) {
                    elem.setAttribute(prop, value);
                    // get the value
                } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                    ret = elem.getAttribute(prop);
                }
                // else if prop is defined, it is a hash of key/value pairs
            } else if (BaseUtils.hasDefined(prop) && typeof prop == 'object') {
                for (key in prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            return ret;
        }
    };

    (function () {
        // prefix style property names

        // @property TRANSFORM: String
        // Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
        DomUtils.TRANSFORM = DomUtils.testProp(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

        DomUtils.TRANSFORM_ORIGIN = DomUtils.testProp(
            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);


        // webkitTransition comes first because some browser versions that drop vendor prefix don't do
        // the same for the transitionend event, in particular the Android 4.1 stock browser

        // @property TRANSITION: String
        // Vendor-prefixed transform style name.
        var transition = DomUtils.TRANSITION = DomUtils.testProp(
            ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

        DomUtils.TRANSITION_END =
            transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

    })();

    return DomUtils;
});
/**
 * Created by eason on 16/7/28.
 * hammer.js,
 */
/**
 * Created by eason on 16/2/19.
 * 
 */

define('HammerHandler',['require','./utils/BaseUtils','./dom/DomUtils','./Constants','./dom/Evented','./ComponentLibrary'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var DomUtils = require('./dom/DomUtils');
    var Constants = require('./Constants');
    var Evented = require('./dom/Evented');
    var ComponentLibrary = require('./ComponentLibrary');

    var isMobile = BaseUtils.hasTouch();

    // normalizeWheel
    var PIXEL_STEP  = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;

    // states
    var RESIZE_END = null,
        RESIZE_START = 1,
        GANTT_PAN_END = null,
        GANTT_PAN_START = 2;

    var mobileHoverTimer,    
        MOBILE_HOVER_HIDE_DELAY = 4000;

    var Handler = Evented.extend({

        initialize:function(vanchart, container){
            this.vanchart = vanchart;
            this._container = container;
            this._state = null;

            var hammer = this.hammer = new VanHammer.Manager(container, {_handler:this});
            
            hammer.add(new VanHammer.Pan({threshold: 0}));

            hammer.add(new VanHammer.Tap());

            //ie
            if(BaseUtils.isSupportSVG()){
                hammer.add(new VanHammer.Press());
            }

            hammer.on("panstart panmove panend tap press pressup", fireDOMEvent);

            //
            if(!isMobile){
                hammer.on('mouseover mousemove mouseout wheel', fireDOMEvent);
            }

            if(vanchart.isMap() && vanchart._zoomEnabled()){
                hammer.add(new VanHammer.Pinch());
                hammer.on('pinchstart pinchmove', fireDOMEvent);
            }

            var rootHandler = this;
            var rootTarget = vanchart.isMap() ? vanchart : rootHandler;
            this.panTarget = null;
            rootHandler.on(rootHandler.getEvents());

            /**
             * 
             * @param ele  
             * @param type 
             */
            var needPropagateEvent = function (ele, type){
                // 
                if(ele.componentType === ComponentLibrary.LEGEND_COMPONENT && type === "wheel"){
                    return false;
                }

                return true;
            };

            function fireDOMEvent(ev){
                var srcEvent = ev.srcEvent, type = ev.type || srcEvent.type;

                type = (type.indexOf('wheel') != -1) ? 'wheel' : type;

                var src = srcEvent.target || srcEvent.srcElement;
                ev.containerPoint = DomUtils.getMousePos(srcEvent, container);

                var isHover = type === 'tap' || type === 'mouseover' || type == 'mouseout';
                var isPan = type == 'panstart' || type == 'panmove' || type == 'panend';

                //
                if(isMobile && vanchart.chartType() !== Constants.GANTT_CHART){
                    if(type == 'press'){
                        rootHandler.pressed = true;
                    }else if(type != 'panstart' && type != 'panmove'){
                        rootHandler.pressed = false;
                    }
                }else{
                    rootHandler.pressed = true;
                }

                var target;
                if(isPan && rootHandler.panTarget){
                    target = rootHandler.panTarget;
                }else{
                    while (src) {

                        // CHART-1071
                        // linemap
                        // 
                        if (type === 'tap'
                            && rootTarget._lineMapLayer
                            && rootTarget._lineMapLayer.hoverPoint) {
                            target = rootTarget._lineMapLayer.hoverPoint;
                            break;
                        }

                        if(!(target = rootHandler._findTargetByBounds(ev.containerPoint, type))){
                            target = vanchart.findInteractiveTarget(src);
                        }

                        if ((target && target.listens(type, false)) || (src === rootHandler._container)) {
                            break;
                        }

                        src = src.parentNode;
                    }

                    target = target && target.listens(type, false) ? target : rootTarget;
                }

                if(vanchart.force && !rootHandler.panTarget){
                    rootHandler.forceTarget = vanchart.force.dragFire(ev, rootHandler._container);
                }

                if (target && target.listens(type, false)){

                    target.fire(type, ev, needPropagateEvent(target, type));

                    if(type == 'panstart'){

                        rootHandler.removeAllChosen(ev);

                        if(!rootHandler.forceTarget) {
                            rootHandler.panTarget = target;
                        }
                    } else if(type == 'panend'){
                        rootHandler.panTarget = null;
                    }

                    if(isMobile && type === "tap") {
                        clearTimeout(mobileHoverTimer);
                        mobileHoverTimer = setTimeout(function () {
                            rootHandler.removeAllChosen(ev);
                        }, MOBILE_HOVER_HIDE_DELAY);
                    }
                }
            }
        },

        //target
        _findTargetByBounds:function(containerPoint, type){

            var vanchart = this.vanchart, series = vanchart.series, plotBounds = vanchart.bounds;
            var legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            legend = legend || rangeLegend;

            //,
            if((type == 'panstart' || type == 'wheel') && legend && legend.bounds && BaseUtils.containsPoint(legend.bounds, containerPoint)){
                return legend;
            }

            //
            if(BaseUtils.containsPoint(plotBounds, containerPoint)){
                return;
            }

            //
            var gaugeSeries = vanchart.seriesOfType(Constants.GAUGE_CHART);

            if(gaugeSeries && gaugeSeries.length){

                for(var i = 0, len = gaugeSeries.length; i < len; i++){
                    var gauge = gaugeSeries[i];

                    if(gauge.bounds && BaseUtils.containsPoint(gauge.bounds, containerPoint)){
                        return gauge;
                    }

                }
            }

        },

        cursor: function (cursor) {
            this._container.style.cursor = cursor || '';
            this.vanchart.bindIEDragCursor && this.vanchart.bindIEDragCursor();  // IE
        },

        onContainerMouseOver:function(ev){

        },

        //
        onContainerMouseMove:function(ev){
            var plotBounds = this.vanchart.bounds, vanchart = this.vanchart, renderer = vanchart.renderer;

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (vanchart.isResizeEnabled()) {
                    if (BaseUtils.containsPoint(vanchart.resizeBounds, ev.containerPoint)) {
                        this.cursor('col-resize');
                        // mouse
                        this._state = RESIZE_START;
                        this.fire('resizeStart', ev);
                    } else
                    if (this._state === RESIZE_START) {
                        this.cursor();
                        this._state = RESIZE_END;
                        this.fire('resizeEnd', ev);
                    }
                }
                this.fire('over', ev);

                if (this._state === RESIZE_START) {
                    return
                }
            }

            var legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            if(legend && legend.bounds){
                legend.fire(BaseUtils.containsPoint(legend.bounds, ev.containerPoint) ? 'mouseover' : 'mouseout', ev);
            }

            //,
            if(BaseUtils.containsPoint(plotBounds, ev.containerPoint)){

                var event = ev.srcEvent, src = event.target || event.srcElement;

                this.cursor();

                if(!this._highlightShared(ev)){
                    this._removeHightlight(ev);
                    var closestPoint;

                    if(vanchart.isLargeMode() && !vanchart.hoverSeries){//canvas
                        closestPoint = this._getCanvasClosestPoint(ev.containerPoint);
                        if(closestPoint){
                            if(!closestPoint._events){
                                closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                            }
                            vanchart.showTooltip(closestPoint, ev);
                            vanchart.hoverPoint = closestPoint;
                            if (closestPoint.options.click) {
                                this.cursor('pointer');
                            }
                        }
                    }else if(vanchart.hoverSeries){
                        closestPoint = vanchart.hoverSeries.getClosestPoint(ev.containerPoint);
                        if(closestPoint){

                            vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
                            closestPoint.fire('mouseover', ev);
                            vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);

                            if (closestPoint.options.click) {
                                this.cursor('pointer');
                            }
                        }
                    }
                }
            }else{
                this.removeAllChosen(ev);
            }
        },

        removeAllChosen: function (ev) {
            //
            var vanchart = this.vanchart,
                toolbar = vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT],
                toolbarBounds = toolbar.getToolbarBounds(),
                mouseInToolbarBounds = ev ? BaseUtils.containsPoint(toolbarBounds, ev.containerPoint) && toolbar.needTooltip() : false;   // evundefined 

            this._removeHightlight(ev);

            if(vanchart.hoverPoint){
                vanchart.hoverPoint.fire('mouseout', ev);
                vanchart.hoverPoint = null;
            }

            if(vanchart.hoverSeries){
                vanchart.hoverSeries.fire('seriesUnChosen', ev);
                vanchart.hoverSeries = null;
            }

            var tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);

            if(tooltip && vanchart.vanChartType !== 'vanChartMap' && !mouseInToolbarBounds){
                tooltip.immediateHide();
            }

            ev && vanchart.cancelLegendHighlight(ev.containerPoint);
        },

        _getCanvasClosestPoint:function(containerPoint){
            var vanchart = this.vanchart;
            var series = vanchart.seriesOfType(Constants.BUBBLE_CHART).concat(vanchart.seriesOfType(Constants.SCATTER_CHART));

            var isMap = vanchart.isMap(), heatSeries = vanchart.seriesOfType(Constants.HEAT_MAP);
            series = series.concat(heatSeries);

            var plotBounds = this.vanchart.bounds;

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var pointPos = (isMap && point.options.lnglat) ? vanchart.latLngToContainerPoint(point.getLatLng()) : {x:point.posX + plotBounds.x, y:point.posY + plotBounds.y};

                    var detX = pointPos.x  - containerPoint.x;

                    var detY = pointPos.y  - containerPoint.y;

                    var len = Math.sqrt(detX * detX + detY * detY);

                    var radius = point.radius || (point.options.marker && point.options.marker.radius) || 4.5;

                    if(len <= radius && point.visible){
                        return point;
                    }
                }
            }
        },

        onContainerMouseOut:function(ev){

        },

        onContainerTap:function(ev){
            this.onContainerMouseMove(ev);
            var p = this.vanchart.hoverPoint;

            p && p.fire('tap', ev);

        },

        onContainerPanStart:function(ev){
            if(this.forceTarget){
                return;//
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer, mousePos = ev.containerPoint;
            var plotBounds = vanchart.bounds;

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (BaseUtils.containsPoint(vanchart.resizeBounds, mousePos)) {
                    this._state = RESIZE_START;
                    this.fire('resizeStart', ev);
                } else
                if (!this._state && BaseUtils.containsPoint(vanchart.panBounds, mousePos)) {
                    this._state = GANTT_PAN_START;
                    this.fire('pan', ev);
                }
                return
            }

            //
            if(!this.selectRect && this._supportCoordinateZoom() && BaseUtils.containsPoint(plotBounds, mousePos)){
                this.selectRect = renderer.rect().style({'fill':'rgb(69,114,167)', 'fill-opacity':0.25}).add();
                this.downPos = mousePos;

                vanchart.hoverPoint && vanchart.hoverPoint.fire('mouseout');
            }

            //
            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(this._zoomAsTarget(zoom, mousePos)){
                zoom._panStart(ev, zoom.centerRect);
            }

        },

        _zoomAsTarget:function(zoom, mousePos){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, validPos = false;
            var dataSheet = vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
            if(dataSheet){
                validPos = BaseUtils.containsPoint(dataSheet.bounds, mousePos);
            }
            validPos = validPos || BaseUtils.containsPoint(plotBounds, mousePos);

            return zoom && zoom.zoomToolEnabled() && validPos;
        },

        onContainerPanMove:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.options;
            var mousePos = ev.containerPoint, downPos = this.downPos;
            var inverted = vanchart.isInverted();

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (BaseUtils.containsPoint(this.vanchart.panBounds, mousePos)) {
                    if (this._state === RESIZE_START) {
                        this.fire('resizeMove', ev);
                    } else
                    if (this._state === GANTT_PAN_START) {
                        this.fire('pan', ev);
                    }
                }
                return
            }

            if(this.selectRect){
                var zoomType = options.zoom.zoomType;
                var x = Math.min(mousePos.x, downPos.x);
                var y = Math.min(mousePos.y, downPos.y);
                var width = Math.abs(mousePos.x - downPos.x);
                var height = Math.abs(mousePos.y - downPos.y);

                var isXZoom = zoomType.indexOf('x') != -1;
                var isYZoom = zoomType.indexOf('y') != -1;

                if(inverted){
                    isXZoom = zoomType.indexOf('y') != -1;
                    isYZoom = zoomType.indexOf('x') != -1;
                }

                if(isXZoom && !isYZoom){
                    y = plotBounds.y;
                    height = plotBounds.height;
                }else if(isYZoom && !isXZoom){
                    x = plotBounds.x;
                    width = plotBounds.width;
                }
                this.selectRect.attr({x:x, y:y, width:width, height:height});
            }


            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled()){
                zoom._panContainerMove(ev);
            }

        },

        onContainerPanEnd:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.options;
            var mousePos = ev.containerPoint, downPos = this.downPos;
            var toolbar = vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];

            // MoreLabel 
            vanchart.removeMoreLabel(); 

            if (vanchart.chartType() === Constants.GANTT_CHART) {
                if (this._state === RESIZE_START) {
                    this._state = RESIZE_END;
                    this.fire('resizeEnd', ev);
                } else
                if (this._state === GANTT_PAN_START) {
                    this._state = GANTT_PAN_END;
                    this.fire('pan', ev);
                }
                return
            }

            if(this.selectRect){
                //,1410*1.414
                if(BaseUtils.distance(downPos, mousePos) > 14){
                    vanchart.clearAllEffects();
                    vanchart.dealAxisZoom(downPos, mousePos);
                    toolbar && toolbar.showRefreshIconWhenZoom();
                }

                this.selectRect.remove();
                this.selectRect = null;
            }

            this.panTarget = null;

            var zoom = vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled()){
                zoom._panEnd();
            }
        },

        onContainerWheel:function (ev) {

            // preventDefault all wheel events ?

            var vanchart = this.vanchart;

            if (vanchart.chartType() === Constants.GANTT_CHART
                && BaseUtils.containsPoint(vanchart.panBounds, ev.containerPoint)) {

                // `event` is global in IE8
                ev.preventDefault ? ev.preventDefault() : (event.returnValue = false);
                ev.wheel = this.normalizeWheel(ev.srcEvent);

                this.fire('wheelMove', ev);

            }

        },

        _highlightShared: function (event) {

            var axis = this.vanchart.getSharedAxis();

            if(axis && axis.getPointsInCategory){
                var pos = event.containerPoint;
                var catePoints = axis.getPointsInCategory(pos);
                if (catePoints && catePoints.length) {
                    catePoints[0]._onPointMouseOver.call(catePoints[0], event);
                    axis.drawHighlightBackground(catePoints);
                    this.vanchart.showSharedTooltip(catePoints[0], event);
                    return true;
                }
            }

            return false;
        },

        _removeHightlight: function (ev) {
            var vanchart = this.vanchart, axis = vanchart.getSharedAxis(), hoverPoints = vanchart.hoverPoints;

            axis && axis.removeHighlightBackground && axis.removeHighlightBackground();

            hoverPoints && hoverPoints.length && hoverPoints[0]._onPointMouseOut.call(hoverPoints[0], ev);

            vanchart.hoverPoints = null;
        },

        getEvents:function(){
            return {
                'mouseover':this.onContainerMouseOver,
                'mousemove':this.onContainerMouseMove,
                'mouseout':this.onContainerMouseOut,

                'tap':this.onContainerTap,
                'panstart':this.onContainerPanStart,
                'panmove':this.onContainerPanMove,
                'panend':this.onContainerPanEnd,

                'wheel':this.onContainerWheel
            };
        },

        _supportCoordinateZoom:function(){
            var isForceBubble = this.vanchart.hoverPoint && this.vanchart.vanChartType == 'vanChartForceBubble';
            var option = this.vanchart.options;
            return BaseUtils.isSupportSVG() && option.zoom && option.zoom.zoomType && !isForceBubble;
        },

        destroy: function () {
            this.hammer.destroy();
        },

        _inZoomBar:function(containerPoint){
            var zoomBar = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            return zoomBar && zoomBar.bounds && BaseUtils.containsPoint(zoomBar.bounds, containerPoint);
        },

        //
        //pressed
        preventDefault:function(input){
            var srcEvent = input.srcEvent;
            var src = srcEvent.target || srcEvent.srcElement;
            var containerPoint = DomUtils.getMousePos(srcEvent, this._container);

            var prevent = this.pressed || this._inZoomBar(containerPoint);
            var zoom = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(!prevent && zoom){
                prevent = zoom.target || this._zoomAsTarget(zoom, containerPoint);
                // input.angleMath.atan((p2.y - p1.y) / (p2.x - p1.x))
                // defaultpanMoveinput.angle90preventfalse
                // inputanglep2 = p1angle0
                // preventtrue,
                prevent = prevent && (Math.abs(input.angle) < 45 || Math.abs(input.angle) > 135) && input.angle != 0;
            }

            if(this.vanchart.isMap()){
                prevent = this.vanchart._zoomEnabled() && src.nodeName != 'A';
            };

            if (this.vanchart.chartType() === Constants.GANTT_CHART) {
                prevent = BaseUtils.containsPoint(this.vanchart.panBounds, containerPoint)
            }

            // #touchActionAndriod
            if (prevent) {
                this.hammer.touchAction.setTouchActionNone();
            } else {
                this.hammer.touchAction.recoverTouchAction();
            }

            return prevent;
        },

        // worth reading:
        // https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
        //
        normalizeWheel: function normalizeWheel(/*object*/ event) /*object*/ {
            var sX = 0, sY = 0,       // spinX, spinY
                pX = 0, pY = 0;       // pixelX, pixelY

            // Legacy
            if ('detail'      in event) { sY = event.detail; }
            if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
            if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
            if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

            // side scrolling on FF with DOMMouseScroll
            if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
                sX = sY;
                sY = 0;
            }

            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;

            if ('deltaY' in event) { pY = event.deltaY; }
            if ('deltaX' in event) { pX = event.deltaX; }

            if ((pX || pY) && event.deltaMode) {
                if (event.deltaMode === 1) {          // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {                             // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }

            // Fall-back if spin cannot be determined
            if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
            if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

            return { spinX  : sX,
                spinY  : sY,
                pixelX : pX,
                pixelY : pY };
        }
    });

    return Handler;
});
/**
 * Created by eason on 2017/1/20.
 */

define('vector/Layer',['require','../dom/Evented','../utils/BaseUtils'],function(require){

    var Evented = require('../dom/Evented');
    var BaseUtils = require('../utils/BaseUtils');

    var Layer = Evented.extend({
        options: {
            pane: 'overlayPane',
            nonBubblingEvents: []
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        remove: function () {
            return this.removeFrom(this._map || this._mapToAdd);
        },

        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        removeFrom: function (obj) {
            if (obj) {
                obj.removeLayer(this);
            }
            return this;
        },

        // layer
        exitAnimate: function (vanchart){
            var layer = this, group = vanchart._pointLayer;
            group.remove(layer);
        },

        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function (name) {
            return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
        },

        beforeAdd: function (map) {
            // Renderer is set here because we need to call renderer.getEvents
            // before this.getEvents.
            this._renderer = map.getMapRenderer(this);
        },

        _layerAdd: function (e) {
            var map = e.target;

            // check in case layer gets added and then removed before the map is ready
            if (!map.hasLayer(this)) { return; }

            this._map = map;
            this._zoomAnimated = map._zoomAnimated;

            if (this.getEvents) {
                var events = this.getEvents();
                map.on(events, this);
                this.once('remove', function () {
                    map.off(events, this);
                }, this);
            }
            this.onAdd(map);
        },

        _reset:BaseUtils.falseFn,
        _project:BaseUtils.falseFn,
        _update:BaseUtils.falseFn
    });

    return Layer;
});
/**
 * Created by eason on 2017/1/19.
 */
define('utils/Bounds',['require','./Point2D'],function(require){
    var Point = require('./Point2D');

    var Bounds = function (a, b) {
        if (!a) { return; }

        var points = b ? [a, b] : a;

        for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
        }
    };

    Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        extend: function (point) { // (Point)
            point = Point.create(point);

            // @property min: Point
            // The top left corner of the rectangle.
            // @property max: Point
            // The bottom right corner of the rectangle.
            if (!this.min && !this.max) {
                this.min = point.clone();
                this.max = point.clone();
            } else {
                this.min.x = Math.min(point.x, this.min.x);
                this.max.x = Math.max(point.x, this.max.x);
                this.min.y = Math.min(point.y, this.min.y);
                this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
        },

        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function (round) {
            return new Point(
                (this.min.x + this.max.x) / 2,
                (this.min.y + this.max.y) / 2, round);
        },

        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function () {
            return new Point(this.min.x, this.max.y);
        },

        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function () { // -> Point
            return new Point(this.max.x, this.min.y);
        },

        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function () {
            return this.max.subtract(this.min);
        },

        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function (obj) {
            var min, max;

            if (typeof obj[0] === 'number' || obj instanceof Point) {
                obj = Point.create(obj);
            } else {
                obj = Bounds.create(obj);
            }

            if (obj instanceof Bounds) {
                min = obj.min;
                max = obj.max;
            } else {
                min = max = obj;
            }

            return (min.x >= this.min.x) &&
                (max.x <= this.max.x) &&
                (min.y >= this.min.y) &&
                (max.y <= this.max.y);
        },

        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function (bounds) { // (Bounds) -> Boolean
            bounds = Bounds.create(bounds);

            var min = this.min,
                max = this.max,
                min2 = bounds.min,
                max2 = bounds.max,
                xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
                yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

            return xIntersects && yIntersects;
        },

        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function (bounds) { // (Bounds) -> Boolean
            bounds = Bounds.create(bounds);

            var min = this.min,
                max = this.max,
                min2 = bounds.min,
                max2 = bounds.max,
                xOverlaps = (max2.x > min.x) && (min2.x < max.x),
                yOverlaps = (max2.y > min.y) && (min2.y < max.y);

            return xOverlaps && yOverlaps;
        },

        isValid: function () {
            return !!(this.min && this.max);
        }
    };

    Bounds.create = function(a, b){
        if (!a || a instanceof Bounds) {
            return a;
        }
        return new Bounds(a, b);
    };

    return Bounds;
});
/**
 * Created by eason on 2017/2/15.
 */
define('utils/Timer',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    //timer
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = BaseUtils.requestAnimFrame;

    var timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) {
            delay = 0;
        }
        if (n < 3) {
            then = Date.now();
        }
        var time = then + delay, timer = {
            c: callback,
            t: time,
            f: false,
            n: null
        };
        if (d3_timer_queueTail){
            d3_timer_queueTail.n = timer;
        }else {
            d3_timer_queueHead = timer;
        }
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }

    timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };

    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t) {
                d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            }
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }

    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time) {
                    time = t1.t;
                }
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    };

    timer.getActiveTimer = function(){
        return d3_timer_active;
    };

    return timer;
});
/**
 * Created by eason on 2017/2/14.
 */

define('utils/Interpolator',['require','./ColorUtils'],function(require){
    var ColorUtils = require('./ColorUtils');

    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");

    function interpolate(a, b){
        var t = typeof b;
        return (t === "string" ? ColorUtils.hasColorName(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    }

    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }

    function d3_interpolateRgb(a, b) {

        a = (a == 'none' || a == '') ? b : a;

        a = ColorUtils.getRGBAColorArray(a);
        b = ColorUtils.getRGBAColorArray(b);
        var ar = a[0], ag = a[1], ab = a[2], br = b[0] - ar, bg = b[1] - ag, bb = b[2] - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }

    function checkMatrixTransform(string) {
        var trans = string.match(/matrix\((\d+\.?\d*|\.?\d+), 0, 0, (\d+\.?\d*|\.?\d+), ([-+]?\d+\.?\d*|\.?\d+), ([-+]?\d+\.?\d*|\.?\d+)\)/);
        return trans ? "translate(" + trans[3] + "px," + trans[4] + "px)scale(" + trans[1] + ")" : string;
    }
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + ""; b = b + "";
        a = checkMatrixTransform(a);b = checkMatrixTransform(b);
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) {
                    s[i] += bs;
                } else {
                    s[++i] = bs;
                }
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) {
                    s[i] += bm;
                } else {
                    s[++i] = bm;
                }
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) {
                s[i] += bs;
            } else {
                s[++i] = bs;
            }
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) {
                s[(o = q[i]).i] = o.x(t);
            }
            return s.join("");
        });
    }

    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) {
                c[k] = i[k](t);
            }
            return c;
        };
    }

    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }

    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) {
            x.push(interpolate(a[i], b[i]));
        }
        for (;i < na; ++i) {
            c[i] = a[i];
        }
        for (;i < nb; ++i) {
            c[i] = b[i];
        }
        return function(t) {
            for (i = 0; i < n0; ++i) {
                c[i] = x[i](t);
            }
            return c;
        };
    }

    function transform(string) {
        var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        return (transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    }

    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * 180 / Math.PI;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * 180 / Math.PI : 0;
    }

    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    }

    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }

    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };

    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = transform(a), B = transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180) {
                rb += 360;
            } else if (rb - ra > 180) {
                ra += 360;
            }
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n) {
                s[(o = q[i]).i] = o.x(t);
            }
            return s.join("");
        };
    }

    interpolate.identity = function(d){
        return d;
    };

    interpolate.interpolateRound = function(a, b){
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    };

    interpolate.uninterpolateNumber = function (a, b){
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    };

    interpolate.interpolateNumber = function (a, b){
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    };

    interpolate.interpolate = interpolate;
    interpolate.interpolateRgb = d3_interpolateRgb;
    interpolate.interpolateTransform = d3_interpolateTransform;
    interpolate.interpolateArray = d3_interpolateArray;

    return interpolate;
});
/**
 * Created by eason on 2017/2/15.
 */
define('vector/Transition',['require','../utils/BaseUtils','../utils/Timer','../utils/vMap','../utils/Interpolator','../utils/BezierEasing'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Timer = require('../utils/Timer');
    var vMap = require('../utils/vMap');
    var Interpolator = require('../utils/Interpolator');
    var BezierEasing = require('../utils/BezierEasing');
    var isSupportSVG = BaseUtils.isSupportSVG();

    var d3_transitionId = 0;

    var Transition = function(elW, name, transition, noAnimation){
        var id = nextTransitionID(), ns = d3_transitionNamespace(name);

        transition = transition || {
                time: Date.now(),
                // do not know why, css.linear is wrong
                ease: BezierEasing.ease('linear'),
                delay: 0,
                duration: 250
            };

        if(!elW.node){//for elw not elementWrapper but element
            elW.node = function () {
                return elW;
            }
        }
        this.noAnimation = noAnimation || !isSupportSVG;
        if (noAnimation) {
            transition.time = 0;
        }

        d3_transitionNode(elW.node(), ns, id, transition);

        this.elW = elW;
        this.namespace = ns;
        this.id = id;
    };

    BaseUtils.extend(Transition.prototype, {

        setAnimation:function(para){
            for(var key in para){
                this[key] && this[key](para[key]);
            }

            return this;
        },

        /**
         * !!!consider VML
         * @param name
         * @param tween !!!consider VML
         * @returns {*}
         */
        tween:function(name, tween){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 2) {
                return node[ns][id].tween.get(name);
            }
            tween == null ? node[ns][id].tween.remove(name)
                                        : node[ns][id].tween.set(name, tween);

            return this;
        },

        attr:function(nameNS, value){
            if (arguments.length < 2) {
                for (value in nameNS){
                    this.attr(value, nameNS[value]);
                }
                return this;
            }

            if (this.noAnimation) {
                this.elW.attr(nameNS, value);
                return this;
            }

            var interpolate = nameNS == "transform" ? Interpolator.interpolateTransform : Interpolator, name = nameNS;
            function attrNull() {
                this.removeAttribute(name);
            }
            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local);
            }
            function attrTween(b) {
                return b == null ? attrNull : (b += "", function() {
                    var a = this.getAttribute(name), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttribute(name, i(t));
                        });
                });
            }
            function attrTweenNS(b) {
                return b == null ? attrNullNS : (b += "", function() {
                    var a = this.getAttributeNS(name.space, name.local), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                            this.setAttributeNS(name.space, name.local, i(t));
                        });
                });
            }
            return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        },

        attrTween:function(nameNS, tween){

            if (arguments.length < 2) {
                for (tween in nameNS){
                    this.attrTween(tween, nameNS[tween]);
                }
                return this;
            }

            var name = nameNS;

            if (this.noAnimation) {
                var f = tween.call(this.elW.node());
                this.elW.attr(name, f(1));
                return this;
            }

            function attrTween(d, i) {
                var f = tween.call(this, d, i, this.getAttribute(name));
                return f && function(t) {
                        this.setAttribute(name, f(t));
                    };
            }
            function attrTweenNS(d, i) {
                var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                return f && function(t) {
                        this.setAttributeNS(name.space, name.local, f(t));
                    };
            }
            return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        },

        style:function(name, value, priority){
            var n = arguments.length;
            if (n < 3) {
                if (typeof name !== "string") {
                    if (n < 2){
                        value = "";
                    }
                    for (priority in name){
                        this.style(priority, name[priority], value);
                    }
                    return this;
                }
                priority = "";
            }

            if (this.noAnimation) {
                this.elW.style && this.elW.style(name, value);
                return this;
            }

            function styleNull() {
                this.style.removeProperty(name);
            }
            function styleString(b) {
                return b == null ? styleNull : (b += "", function() {
                        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                        return a !== b && (i = Interpolator(a, b), function(t) {
                            this.style.setProperty(name, i(t), priority);
                        });
                });
            }
            return d3_transition_tween(this, "style." + name, value, styleString);
        },

        styleTween:function(name, tween, priority){
            if (arguments.length < 3){
                priority = "";
            }

            if (this.noAnimation) {
                var f = tween.call(this.elW.node());
                this.elW.style(name, f(1));
                return this;
            }

            function styleTween(d, i) {
                var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
                return f && function(t) {
                        this.style.setProperty(name, f(t), priority);
                    };
            }
            return this.tween("style." + name, styleTween);
        },

        remove:function(){
            var ns = this.namespace;
            return this.each("end.transition", function() {
                var p;
                if (this[ns].count < 2 && (p = this.parentNode)) {
                    p.removeChild(this);
                }
            });
        },

        each:function(type, listener){
            var node = this.elW.node(), id = this.id, ns = this.namespace;
            var transition = node[ns][id];
            (transition.event || (transition.event = BaseUtils.dispatch("start", "end", "interrupt"))).on(type, listener);
            return this;
        },

        ease:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].ease;
            }

            if (typeof value !== "function") {
                value = BezierEasing.ease.apply(null, arguments)
            }

            node[ns][id].ease = value;
            return this;
        },

        delay:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].delay;
            }

            value = +value;
            node[ns][id].delay = value;

            return this;
        },

        duration:function(value){
            var id = this.id, ns = this.namespace, node = this.elW.node();
            if (arguments.length < 1) {
                return node[ns][id].duration;
            }
            value = Math.max(1, value);
            node[ns][id].duration = value;
            return this;
        },

        transition:function(para){
            var id0 = this.id, ns = this.namespace, node = this.elW.node();
            var transition = node[ns][id0];

            return new Transition(this.elW, ns, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
            }, this.noAnimation).setAnimation(para);
        },

        animate:function(para){
            return this.setAnimation(para);
        }
    });

    function d3_transition_tween(transition, name, value, tween) {
        var id = transition.id, ns = transition.namespace, value = tween(value);
        transition.elW.node()[ns][id].tween.set(name, value);
        return transition;
    }

    function d3_transitionNode(node, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new vMap(),
                time: time,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease
            };
            inherit = null;
            ++lock.count;
            Timer(function(elapsed) {
                var delay = transition.delay, duration, ease, timer = Timer.getActiveTimer(), tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed) {
                    return start(elapsed - delay);
                }
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id) {
                        return stop();
                    }
                    var active = lock[lock.active];
                    if (active) {
                        --lock.count;
                        delete lock[lock.active];
                        active.event && active.event.interrupt.call(node);
                    }
                    lock.active = id;
                    transition.event && transition.event.start.call(node);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node)) {
                            tweened.push(value);
                        }
                    });
                    ease = transition.ease;
                    duration = transition.duration;
                    Timer(function() {
                        timer.c = tick(elapsed || 1) ? BaseUtils.trueFn : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id) {
                        return 1;
                    }
                    var t = elapsed / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count) {
                        lock[id] = undefined;
                        // delete lock[id];
                    }else{
                        node[ns] = undefined;
                        // IE 11 7: ""
                        // delete node[ns]
                    };
                    return 1;
                }
            }, 0, time);
        }
    }

    function nextTransitionID(){
        return ++d3_transitionId;
    }

    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }

    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }

    Transition.d3_transitionNamespace = d3_transitionNamespace;
    Transition.nextTransitionID = nextTransitionID;

    return Transition;
});
/**
 * Created by eason on 16/7/22.
 */

define('vector/ElementWrapper',['require','../utils/Class','../dom/DomUtils','./Transition','../utils/BaseUtils'],function(require){

    var Class = require('../utils/Class');
    var DomUtils = require('../dom/DomUtils');
    var Transition = require('./Transition');
    var isArray = require('../utils/BaseUtils').isArray;

    var ElementWrapper = Class.extend({

        /**
         * wrap the elements to hide implementation details
         * @param rawElement dom elements for svg and vml,and data object for canvas
         * @param renderer the renderer that the rawElement belongs to
         */
        initialize:function(rawElement, renderer){
            this.rawElement = rawElement;

            this.renderer = renderer;

            return this;
        },

        node: function () {
            return this.rawElement;
        },

        /**
         * add the rawElement to the parent container
         * append to the container for svg and vml
         * or show for canvas
         * @param parentElementWrapper
         * @returns {ElementWrapper}
         */
        addTo:function(parent){

            parent = parent || this.renderer._container;

            parent.append(this);

            return this;
        },

        addToBack:function(parent){

            parent = parent || this.renderer._container;

            parent = parent.node();

            parent.firstChild ? parent.insertBefore(this.node(), parent.firstChild) : parent.appendChild(this.node());

            return this;
        },

        add:function(){
            if (this.type === 'div') {
                return this.addTo(this.renderer._divContainer);
            }
            return this.addTo(this.renderer._container);
        },

        append: function (child) {
            this.node().appendChild(child.node());
            return child;
        },

        //bind data to the elementWrapper
        datum:function(){
            if(arguments.length){
                this._datum = arguments[0];
                return this;
            }
            return this._datum;
        },

        addClass:function(name){
            DomUtils.addClass(this.node(), name);

            return this;
        },

        /**
         * remove from the renderer container
         * for canvas, we shall clear the context and redraw all
         * the other elements on the container
         */
        remove:function(){
            DomUtils.remove(this.node());
            return this;
        },

        removed:function(){
            return !(this.node().parentNode && this.node().parentNode.tagName);
        },

        isVisible:function(){
            return !this.removed() && this.node().style.display != 'none';
        },

        //ievml path,
        setType:function(type){
            this.type = type;
            return this;
        },

        // rotate text(div, svg) according to center
        // for less dom operation, set textContent & style first
        // then rotate
        // delayMove for animation
        vRotate: function (deg, delayMove) {
            this.renderer.vRotate(this, deg, delayMove);
            return this;
        },

        vMiddle: function () {
            this.renderer.vMiddle(this);
        },

        // transition stuff
        animate:function(para){

            if (!para) {
                throw new Error('animate para empty')

            } else
            if (isArray(para)) {
                var transition = this.transition().setAnimation(para[0]);

                for(var i = 1, len = para.length; i < len; i++){
                    transition = transition.transition(para[i]);
                }

                return this.setTransitionEnd(transition, para[len - 1].style);

            } else {
                return this.setTransitionEnd(this.transition().setAnimation(para), para.style)
            }

        },

        setTransitionEnd:function (transition, styles) {
            var el = this;
            var vanchart = this.renderer.vanchart;
            ++vanchart.animationCount;
            return transition.each('end', function () {
                styles && el.style(styles);

                if(vanchart._animationStarted){
                    if(!--vanchart.animationCount) {
                        vanchart.animationCount = -1;
                        // console.log('ani transition end');
                        vanchart.fire('animationEnd');
                    }
                }

            });
        },

        effectTransition:function () {
            return new Transition(this);
        },

        transition:function(name){
            return new Transition(this, name, null, !this.renderer.isAnimation);
        },

        interrupt:function(name){

            var node = this.node(), ns = Transition.d3_transitionNamespace(name);

            var lock;
            if ((lock = node[ns]) && (lock[lock.active])) {
                if (--lock.count){
                    delete lock[lock.active];
                } else {
                    delete node[ns];
                }
                lock.active += .5;
            }

            return this
        }

    });

    return ElementWrapper;
});
/**
 * Created by eason on 16/6/1.
 * js
 */

define('vector/Renderer',['require','./Layer','../dom/DomUtils','../dom/Browser','../utils/Bounds','../utils/BaseUtils','./ElementWrapper'],function(require){

    var Layer = require('./Layer');
    var DomUtils = require('../dom/DomUtils');
    var Browser = require('../dom/Browser');
    var Bounds = require('../utils/Bounds');
    var BaseUtils = require('../utils/BaseUtils');
    var ElementWrapper = require('./ElementWrapper');

    var PADDING = 0;

    var Renderer = Layer.extend({
        /**
         * this._container may be svg,canvas,dom
         */
        initialize:function(dom, vanchart, config){
            this.dom = dom;
            this.vanchart = vanchart;
            this.config = config;
            this.isSupportSVG = BaseUtils.isSupportSVG();
            this.isAnimation = this.isSupportSVG && BaseUtils.pick(this.vanchart.options.plotOptions.animation, true);
        },

        resize:function() {

        },

        remove:function(){
            DomUtils.remove(this._container.node());

            this.off('update', this._updatePaths, this);
        },

        div: function (isHtml) {
            var d = new ElementWrapper(document.createElement('div'), this).setType('div')
                .style({position:'absolute',left:0,top:0})
            d.isHtml = isHtml;// log for IE8
            return d;
        },

        vgroup: function () {
            var divG = this.div();
            var renderG = this.group();
            return {
                divG: divG,
                renderG: renderG,
                type: 'vgroup',
                attr: function () {
                    this.divG.attr.apply(this.divG, arguments);
                    this.renderG.attr.apply(this.renderG, arguments);
                    return this;
                },
                style: function () {
                    this.divG.style.apply(this.divG, arguments);
                    this.renderG.style.apply(this.renderG, arguments);
                    return this;
                },
                append: function (ele) {
                    if (ele.type === 'div' && ele.isHtml) {
                        divG.append(ele);
                    } else if (ele.type === 'vgroup') {
                        divG.append(ele.divG);
                        renderG.append(ele.renderG);
                    } else {
                        renderG.append(ele);
                    }
                    return ele;
                },
                add: function (parentG) {
                    parentG ? this.renderG.addTo(parentG) : this.renderG.add();
                    this.divG.add();
                    return this;
                },
                remove: function () {
                    this.divG.node() && this.divG.remove();
                    this.renderG.node() && this.renderG.remove();
                },
                node:function(){
                    return renderG.node();
                },
                vRotate: function (deg) {
                    if (isNaN(deg)) { return }
                    this.divG.vRotate(deg);
                    this.renderG.vRotate(deg);
                }
            };
        },

        vtext: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div(isHtml); // for IE8, innerText or innerHtml
            }
            return this.text();
        },

        vtspan: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div(isHtml);
            }
            return this.tspan();
        },

        onAdd:function(){
            if (!this._container){
                this._initContainer(); // defined by renderer implementations
                if (this._zoomAnimated) {
                    DomUtils.addClass(this._container.node(), 'leaflet-zoom-animated');
                }
            }

            this.dom.appendChild(this._container.node());

            this._divContainer && this.dom.appendChild(this._divContainer.node());

            this._update();

            this.on('update', this._updatePaths, this);
        },

        _update: function () {
            var size = this.vanchart.getSize();
            this._bounds = new Bounds([0,0], size);
            if(this._map){
                var p = PADDING, min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
                this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
                this._center = this._map.getCenter();
                this._zoom = this._map.getZoom();
            }
        },

        getEvents: function () {
            var events = {
                viewreset: this._reset,
                zoom: this._onZoom,
                moveend: this._update,
                zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
                events.zoomanim = this._onAnimZoom;
            }
            return events;
        },

        _onAnimZoom: function (ev) {
            this._updateTransform(ev.center, ev.zoom);
        },

        _onZoom: function () {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },

        _reset: function () {
            this._update();
            this._updateTransform(this._center, this._zoom);

            var layers = this.vanchart._layers;
            for (var id in layers) {
                layers[id]._path && layers[id]._reset();
            }
        },

        _onZoomEnd: function () {

            var layers = this.vanchart._layers;

            for (var id in layers) {
                layers[id]._path && layers[id]._project();
            }
        },

        _updatePaths: function () {
            var layers = this.vanchart._layers;

            for (var id in layers) {
                layers[id]._path && layers[id]._update();
            }
        },

        _updateTransform: function (center, zoom) {
            var container = this._container.node();

            var scale = this._map.getZoomScale(zoom, this._zoom),
                position = DomUtils.getPosition(container),
                viewHalf = this._map.getSize().multiplyBy(0.5 + PADDING),
                currentCenterPoint = this._map.project(this._center, zoom),
                destCenterPoint = this._map.project(center, zoom),
                centerOffset = destCenterPoint.subtract(currentCenterPoint),

                topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

            if (Browser.any3d) {
                DomUtils.setTransform(container, topLeftOffset, scale);
            } else if(BaseUtils.isSupportSVG()){
                DomUtils.setPosition(container, topLeftOffset);
            }else {
                container.style.left = 0 + 'px';
                container.style.top = 0 + 'px';
            }
        }
    });

    return Renderer;
});
/**
 * Created by eason on 16/6/1.
 */

define('vector/SvgRenderer',['require','./Renderer','../dom/DomUtils','../utils/BaseUtils','./ElementWrapper'],function(require){

    var Renderer = require('./Renderer');
    var DomUtils = require('../dom/DomUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ElementWrapper = require('./ElementWrapper');

    var included = false;

    var Svg = Renderer.extend({

        _initContainer:function(){
            includeElementWrapper();
            this._container = new ElementWrapper(this.create('svg'), this);
            this.defs = new ElementWrapper(this.create('defs'), this).addTo(this._container);

            //svgdivContainer
            this._divContainer = this.div()
                .style({'white-space':'nowrap','pointer-events':'none'});
        },

        resize:function(){
            var width = this.vanchart.width, height = this.vanchart.height;
            this._container.style({width:width + 'px', height:height + 'px'});
        },

        _update: function () {
            if (this._map && this._map._animatingZoom && this._bounds) {
                return;
            }

            Renderer.prototype._update.call(this);

            var b = this._bounds,
                size = b.getSize(),
                container = this._container.node();

            // set size of svg-container if changed
            if (!this._svgSize || !this._svgSize.equals(size)) {
                this._svgSize = size;
                container.setAttribute('width', size.x);
                container.setAttribute('height', size.y);
            }

            // movement: update container viewBox so that we don't have to change coordinates of individual layers

            if(this._map){
                DomUtils.setPosition(container, b.min);   // todo @BI-10054,translate3d,,
                container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
            } else {
                container.style.left = b.min.x + 'px';
                container.style.top = b.min.y + 'px';
            }

            this.fire('update');
        },

        line:function(attrs){
            return new ElementWrapper(this.create('line'), this).attr(attrs);
        },

        rect:function(attrs){
            return new ElementWrapper(this.create('rect'), this).attr(attrs);
        },

        circle:function(attrs){
            return new ElementWrapper(this.create('circle'), this).attr(attrs);
        },

        path:function(attrs){
            return new ElementWrapper(this.create('path'), this).attr(attrs);
        },

        text:function(attrs){
            return new ElementWrapper(this.create('text'), this).attr(attrs);
        },

        tspan:function(attrs){
            return new ElementWrapper(this.create('tspan'), this).attr(attrs);
        },

        image:function(attrs){
            return new ElementWrapper(this.create('image'), this).attr(attrs);
        },

        group:function(attrs){
            return new ElementWrapper(this.create('g'), this).attr(attrs);
        },

        colorGradient:function(attrs, stops, type){
            type = type || 'linearGradient';

            var fillFilter = new ElementWrapper(this.create(type), this);
            attrs.id = BaseUtils.stamp(fillFilter);
            fillFilter.attr(attrs);

            fillFilter.stops = [];
            for(var i = 0, len = stops.length; i < len; i++){
                fillFilter.stops[i] = new ElementWrapper(this.create('stop'), this)
                    .attr(stops[i])
                    .addTo(fillFilter);
            }

            return fillFilter.addTo(this.defs);
        },

        updateColorGradient:function(gradient, attrs, stops){
            gradient.attr(attrs);
            for(var i = 0, len = stops.length; i < len; i++){
                if (gradient.stops[i]) {
                    gradient.stops[i].attr(stops[i]);
                }else {
                    gradient.stops[i] = new ElementWrapper(this.create('stop'), this)
                        .attr(stops[i])
                        .addTo(gradient);
                }
            }
        },

        createClip: function (attrs, type) {
            type = type || 'rect';
            var clip = new ElementWrapper(this.create('clipPath'), this);
            clip.attr('id', BaseUtils.stamp(clip));

            clip.setType(type);

            clip[type] = new ElementWrapper(this.create(type), this).attr(attrs).addTo(clip);

            clip.addTo(this.defs);

            return clip;
        },

        clip:function(elementWrapper, clipWrapper){
            elementWrapper.attr('clip-path', "url(#" + BaseUtils.stamp(clipWrapper) +")");
        },

        updateClip:function(clipWrapper, attrs){
            if(clipWrapper){
                clipWrapper[clipWrapper.type].attr(attrs);
            }
        },

        imagePattern:function(patterAttr, imageAttr, url){

            var pattern = new ElementWrapper(this.create('pattern'), this);
            patterAttr.id = BaseUtils.stamp(pattern);

            pattern.attr(patterAttr);

            pattern.image = new ElementWrapper(this.create('image'), this).addTo(pattern);
            pattern.image.attr(imageAttr);
            pattern.image.imageContent(url);
            pattern.image._imageUrl = url;

            pattern.addTo(this.defs);

            return pattern;
        },

        updateImagePattern:function(imagePattern, patterAttr, imageAttr, url){
            imagePattern.attr(patterAttr);
            imagePattern.image.attr(imageAttr);

            //
            if(imagePattern.image._imageUrl != url){
                imagePattern.image.imageContent(url);
                imagePattern.image._imageUrl = url;
            }
        },

        createDropShadowFilter:function(dx, dy, alpha, deviation, r, g, b){
            r = r || 0; g = g || 0; b = b || 0;

            var dropFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(dropFilter);
            dropFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            this.updateDropShadowFilter(dropFilter, dx, dy, alpha, deviation, r, g, b);

            dropFilter.feBlend = dropFilter.feBlend || new ElementWrapper(this.create('feBlend'), this).addTo(dropFilter);
            dropFilter.feBlend.attr({
                "in": 'SourceGraphic', 'in2':'blurOut', 'mode':'normal'
            });

            dropFilter.addTo(this.defs);

            return dropFilter;
        },

        updateDropShadowFilter:function (dropFilter, dx, dy, alpha, deviation, r, g, b) {
            r = r || 0; g = g || 0; b = b || 0;

            dropFilter.feOffset = dropFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(dropFilter);
            dropFilter.feOffset.attr({
                'in':'SourceGraphic', 'dx':dx, 'dy':dy, 'result':'offOut'
            });

            dropFilter.feColorMatrix = dropFilter.feColorMatrix || new ElementWrapper(this.create('feColorMatrix'), this).addTo(dropFilter);
            dropFilter.feColorMatrix.attr({
                'in':'offOut', 'type':'matrix', 'values':r+' 0 0 0 0 0 ' +g+' 0 0 0 0 0 '+b+' 0 0 0 0 0 '+alpha+' 0','result':'matrixOut'
            });

            dropFilter.feGaussianBlur = dropFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(dropFilter);
            dropFilter.feGaussianBlur.attr({
                'in':'matrixOut', 'stdDeviation':deviation, 'result':'blurOut'
            });
        },

        createInnerShadowFilter:function(dx, dy, alpha, deviation){
            var innerFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(innerFilter);
            innerFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            innerFilter.feComponentTransfer = innerFilter.feComponentTransfer || new ElementWrapper(this.create('feComponentTransfer'), this).attr({'in':'SourceAlpha'}).addTo(innerFilter);
            innerFilter.feComponentTransfer.feFuncA = innerFilter.feComponentTransfer.feFuncA || new ElementWrapper(this.create('feFuncA'), this).attr({'type':'table', 'tableValues': '1 0'}).addTo(innerFilter.feComponentTransfer);

            innerFilter.feGaussianBlur = innerFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(innerFilter);
            innerFilter.feGaussianBlur.attr('stdDeviation', deviation);

            innerFilter.feOffset = innerFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(innerFilter);
            innerFilter.feOffset.attr({'dx': dx, 'dy': dy, 'result':'offsetblur'});

            innerFilter.feFlood = innerFilter.feFlood || new ElementWrapper(this.create('feFlood'), this).addTo(innerFilter);
            innerFilter.feFlood.attr({'flood-color': 'black', 'flood-opacity': alpha, 'result':'color'});

            innerFilter.feComposite1 = innerFilter.feComposite1 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'offsetblur', 'operator':'in'}).addTo(innerFilter);

            innerFilter.feComposite2 = innerFilter.feComposite2 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'SourceAlpha', 'operator':'in'}).addTo(innerFilter);

            innerFilter.merge = innerFilter.merge || new ElementWrapper(this.create('feMerge'), this).addTo(innerFilter);

            innerFilter.merge.feMergeNode1 = innerFilter.merge.feMergeNode1 || new ElementWrapper(this.create('feMergeNode'), this).attr('in', 'SourceGraphic').addTo(innerFilter.merge);
            innerFilter.merge.feMergeNode2 = innerFilter.merge.feMergeNode2 || new ElementWrapper(this.create('feMergeNode'), this).addTo(innerFilter.merge);

            innerFilter.addTo(this.defs);

            return innerFilter;
        },

        create: function (name) {
            return document.createElementNS('http://www.w3.org/2000/svg', name);
        },

        // rotate text(div, svg) according to center
        // for less dom operation, set textContent & style first
        // then rotate
        // delayMove for animation
        vRotate: function (domWrapper, deg, delayMove) {
            var trans, transform, rotateStr, dom = domWrapper.node();
            if (domWrapper.type === 'div') {
                transform = domWrapper.styles[BaseUtils.transPrefix + 'transform'] || '';
                if (transform) {
                    trans = transformParser(transform.replace(/px/gi, ''));
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px) ';
                    }
                }
                rotateStr = 'rotate(' + deg + 'deg)';
                transform += rotateStr;
                var t = BaseUtils.transPrefix + 'transform';
                domWrapper.styles[t] = transform;
                dom.style[t] = transform;
            } else {
                var centerX = dom.getBBox().width / 2; // firefox has no scroll size
                // IE 11 height > text height; result in a wrong position
                var centerY = dom.getBBox().height/ 2 - 1;

                centerX += (+dom.getAttribute('x') || 0);
                centerY += (+dom.getAttribute('y') || 0);

                transform = dom.getAttribute('transform') || '';
                if (transform) {
                    trans = transformParser(transform);
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + ' ' + trans.translate[1] + ') ';
                    }
                }
                rotateStr = 'rotate(' + deg + ' ' + centerX + ' ' + centerY + ')';
                transform += rotateStr;
                if (!delayMove) {
                    domWrapper.attr('transform', transform);
                }
            }
            domWrapper.rotateStr = rotateStr;
            return this;
        },

        vMiddle: function (domWrapper) {
            if (domWrapper.type === 'div') {
                var dom = domWrapper.node();
                var ow = dom.offsetWidth;
                dom.style.marginLeft = -ow / 2 + 'px';
            } else {
                domWrapper.attr('text-anchor', 'middle');
            }

            return this;
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }
    }

    //map specific func
    Svg.include({
        getEvents: function () {
            var events = Renderer.prototype.getEvents.call(this);
            events.zoomstart = this._onZoomStart;
            return events;
        },

        _onZoomStart: function () {
            // Drag-then-pinch interactions might mess up the center and zoom.
            // In this case, the easiest way to prevent this is re-do the renderer
            //   bounds and padding when the zooming starts.
            this._update();
        }
    });

    function includeElementWrapper () {

        if (included) {return}

        included = true;

        ElementWrapper.include({

            imageContent:function(url){
                this.node().setAttributeNS("http://www.w3.org/1999/xlink", "href", url);
                return this;
            },

            textContent:function(text){
                this.type === 'div' ? this.node().innerHTML = text : this.node().textContent = text;
                return this;
            },

            attr:function(){
                if (this.type === 'div') {
                    this.style.apply(this, arguments);
                }else{
                    DomUtils.attr.apply(null, [this.node()].concat(BaseUtils.objectToArray(arguments)));
                }
                return this;
            },

            style:function(style){
                var styles;
                if (arguments.length === 2) {
                    styles = {};
                    styles[arguments[0]] = arguments[1];
                } else {
                    styles = arguments[0];
                }

                var oldStyles = this.styles,
                    newStyles = {},
                    elem = this.node(),
                    serializedCss = '',
                    hasNew = !oldStyles,
                    styleName;

                // convert legacy
                if (styles && styles.color) {
                    styles.fill = styles.color;
                }

                if (styles && styles.fill && this.type === 'div') {
                    styles.color = styles.fill;
                }

                // Filter out existing styles to increase performance (#2640)
                if (oldStyles) {
                    for (styleName in styles) {
                        if (styles[styleName] !== oldStyles[styleName]) {
                            newStyles[styleName] = styles[styleName];
                            hasNew = true;
                        }
                    }
                }

                if (hasNew) {

                    if (this.type === 'div') {
                        // some problems:
                        // 1. rotate
                        // 2. default, here add 'px' to attributes
                        var map = {
                            'x': 'left',
                            'y': 'top',
                            'dx': 'margin-left'
                            // 'dy': 'margin-top'
                        };

                        for (var name in map) {
                            var s;
                            if ((s = newStyles[name]) != null) {
                                // em or +'px' suffix
                                newStyles[map[name]] = /em/gi.test(s) ? s : s + 'px';
                                delete newStyles[name];
                            }
                        }

                        if (newStyles['transform']) {
                            var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                            if (trans.translate) {
                                newStyles[BaseUtils.transPrefix + 'transform'] = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px)';
                            }
                        }
                    }

                    // Merge the new styles with the old ones
                    if (oldStyles) {
                        styles = BaseUtils.extend(oldStyles, newStyles);
                    }

                    this.styles = styles;

                    var hyphenate = function (a, b) {
                        return '-' + b.toLowerCase();
                    };

                    for (styleName in styles) {
                        serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                    }

                    elem.style.cssText = serializedCss;

                    //todo fireFoxstyle'none'
                    //http://stackoverflow.com/questions/15123953/svg-fill-url-behaving-strangely-in-firefox
                    if(styles.fill){
                        elem.style.fill = styles.fill;
                    }
                }

                return this;
            }

        });
    }

    return Svg;
});
/**
 * Created by eason on 16/6/20.
 */
/**
 * Created by eason on 16/6/7.
 * vmlpath,vmlpath
 */

define('utils/PathUtils',['require'],function(require){

    var pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
    var concat = "concat", apply = "apply", upperCase = String.prototype.toUpperCase, mmax = Math.max, math = Math, round = math.round;
    var PI = math.PI, abs = Math.abs, split = "split";
    var p2s = /,?([achlmqrstvxz]),?/gi, val = /-?\d*\.?\d+(?:[eE][\-+]?\d+)?/g;
    var S = " ", E = "", fillString = "fill", zoom = 1;

    function path2vml(path){
        var bites = /([clmz]),?([^clmz]*)/gi;
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"};
        var total =  /[ahqstv]/ig, command = pathToAbsolute;
        String(path).match(total) && (command = path2curve);
        total = /[clmz]/g;
        if (command == pathToAbsolute && !String(path).match(total)) {
            var res = String(path).replace(bites, function (all, command, args) {
                var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                args.replace(val, function (value) {
                    if (isMove && vals.length === 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });
            return res;
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.join(S);
    }

    function parsePathString(pathString){

        if (!pathString && typeof pathString != 'string') {
            return null;
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];

        String(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") {
                data.push([b][concat](params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
        data.toString = path2string;
        return data;
    }

    function path2string(){
        return this.join(",").replace(p2s, "$1");
    }

    function path2curve(path, path2){

        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny, tq = {T:1, Q:1};
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in tq) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny][concat](path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i]="A"); // the same as above
                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") { pcoms1[i] = "C" }; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C")
                {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i-1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i]!="A" && pfirst=="C") { pcoms2[i]="C"; }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
    }

    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    }

    function l2c (x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }

    function a2c (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y}
            };
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }

    function pathToAbsolute(pathArray) {

        if(typeof pathArray == 'string'){
            pathArray = parsePathString(pathArray);
        }

        if(!pathArray || !pathArray.length){
            return [["M", 0, 0]];
        }

        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = path2string;
        return res;

    }

    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }

    function rectPath(x, y, w, h, r){
        if (r) {
            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
        }
        return path2vml([["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]]);
    }

    function circlePath (x, y, r) {
        return path2vml([["M", x, y], ["m", 0, -r], ["a", r, r, 0, 1, 1, 0, 2 * r], ["a", r, r, 0, 1, 1, 0, -2 * r], ["z"]]);
    }

    function linePath(x1, y1, x2, y2){
        return path2vml([["M", x1, y1], ["L", x2, y2]]);
    }

    window.tmp = {
        path2vml:path2vml,
        rectPath:rectPath,
        linePath:linePath,
        circlePath:circlePath
    }

    return window.tmp;

});
/**
 * Created by eason on 16/6/1.
 */

define('vector/VmlRenderer',['require','./Renderer','../utils/PathUtils','../utils/BaseUtils','../utils/ColorUtils','./ElementWrapper','../dom/DomUtils'],function(require){
    var Renderer = require('./Renderer');
    var PathUtils = require('../utils/PathUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var ElementWrapper = require('./ElementWrapper');
    var DomUtils = require('../dom/DomUtils');

    var CSS = "position:absolute;left:0px;top:0px;width:1px;height:1px;behavior:url(#default#VML);display:inline-block;";

    var SubCss = "position:absolute;behavior:url(#default#VML);display:inline-block;";

    var included = false;

    var Vml = Renderer.extend({

        _initContainer: function (){
            includeElementWrapper();
            var root = this.div().style({'white-space':'nowrap','display':'inline-block'});
            DomUtils.addClass(root.node(), 'van-vml');
            this.dom.appendChild(root.node());

            //vmldiv
            this._divContainer = root;

            this._container = root;

            return root;
        },

        line:function(attrs){
            return this._shapeWithPath(attrs, 'line');
        },

        rect:function(attrs){
            return this._shapeWithPath(attrs, 'rect');
        },

        circle:function(attrs){
            return this._shapeWithPath(attrs, 'circle');
        },

        path:function(attrs){
            return this._shapeWithPath(attrs, 'path');
        },

        image:function(attrs){
            var image =  new ElementWrapper(document.createElement('image'), this).setType('image');

            image.attr(attrs);

            return image;
        },

        //ie8 groupgroup,
        group:function(attrs){
            var group = this.div().style({'white-space':'nowrap','pointer-events':'none'});

            return group.attr(attrs);
        },

        colorGradient:function(attrs, stops, type){
            type = type || 'linearGradient';
            return {
                type:type,
                attrs:attrs,
                stops:stops,
                elements:[]
            }
        },

        updateColorGradient:function(gradient, attrs, stops){
            gradient.attrs = attrs;
            gradient.stops = stops;
        },

        //todo svg
        _updateGradientFill:function(elementWrapper, colorGradient){
            var node = elementWrapper.node(), fill = elementWrapper._fill;
            var stops = colorGradient.stops, attrs = colorGradient.attrs;

            if(fill){
                node.removeChild(fill);

                fill.on = true;
                fill.method = "none";
                fill.color = stops[0]['stop-color'];
                fill.color2 = stops[stops.length - 1]['stop-color'];
                var clrs = [];
                for (var i = 0, ii = stops.length; i < ii; i++) {
                    var offset = stops[i].offset * 100 + '%';
                    clrs.push(offset + ' ' + stops[i]['stop-color']);
                }
                // fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                fill.type = "gradient";
                fill.angle = (attrs.x1 == attrs.x2 ? 0 : 270);

                node.appendChild(fill);
            }
        },

        textContent:function(elementW, text){

        },



        text:function(){
            return this.vtext(false);
        },

        tspan:function(){
            return this.vtspan(false);
        },

        _shapeWithPath:function(attrs, type){
            var shape = new ElementWrapper(this.create('shape'), this).setType(type), container = shape.rawElement;
            container.style.cssText = CSS;container.coordsize = '1 1';

            return shape.attr(attrs);
        },

        create:(function () {
            try {
                document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                return function (name) {
                    return document.createElement('<lvml:' + name + ' class="lvml">');
                };
            } catch (e) {
                return function (name) {
                    return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        })(),

        createClip: function (attrs, type) {
            if(type && type != 'rect'){
                return;
            }

            return {
                'x':attrs.x,
                'y':attrs.y,
                'width':attrs.width,
                'height':attrs.height,
                'clipped':[]
            };
        },

        _getClipStr:function(elementWrapper, attrs){
            var top = attrs.y || 0, left = attrs.x || 0, right = left + attrs.width, bottom = top + attrs.height;

            if(elementWrapper.type != 'div'){
                var node = elementWrapper.isLineChart ? elementWrapper.node().parentNode.firstChild : elementWrapper.node();
                
                top -= node.offsetTop;
                bottom -= node.offsetTop;
            }

            return 'rect(' + top + 'px '+ right +'px '+ bottom +'px ' + left + 'px)';
        },

        clip:function(elementWrapper, clipWrapper){
            if(clipWrapper){
                var node;
                if(elementWrapper.node && (node = elementWrapper.node())){
                    node.style.clip = this._getClipStr(elementWrapper, clipWrapper);
                    clipWrapper.clipped.push(elementWrapper);
                }
            }
        },

        updateClip:function(clipWrapper, attrs){
            var renderer = this;
            if(clipWrapper){
                BaseUtils.extend(clipWrapper, attrs);
                clipWrapper.clipped.forEach(function(elementWrapper){
                    var node = elementWrapper.node();
                    if(node){
                        node.style.clip = renderer._getClipStr(elementWrapper, clipWrapper);
                    }
                });
            }
        },

        imagePattern:function(p, attrs){

        },

        createDropShadowFilter:function(){
            return {};
        },

        createInnerShadowFilter:function(){
            return {};
        },

        attr:function(domWrapper, arguments){

            if(!arguments || arguments.length <= 0 || !arguments[0]){
                return;
            }

            var attrs = {}, elem = domWrapper.rawElement;
            if(arguments.length === 2){
                attrs[arguments[0]] = arguments[1];
            }else{
                attrs = arguments[0];
            }

            var oldAttrs = domWrapper.attrs, type = domWrapper.type;

            if(oldAttrs){
                attrs = BaseUtils.extend(oldAttrs, attrs);
            } else {
                // avoid revising original attr obj
                attrs = BaseUtils.extend({}, attrs);
            }

            domWrapper.attrs = attrs;

            //transform,
            if(attrs.transform){
                var transform = transformParser(attrs.transform);
                try {
                    if (transform.translate) {
                        elem.style.left = transform.translate[0] + 'px';
                        elem.style.top = transform.translate[1] + 'px';
                    }
                } catch (e) {
                    
                }

                if(transform.rotate){

                }
            }

            if(type == 'image'){
                elem.style.position = 'absolute';
                elem.style.left = attrs.x + 'px';
                elem.style.top = attrs.y + 'px';
                elem.style.width = attrs.width + 'px';
                elem.style.height = attrs.height + 'px';
            }else if(type != 'group'){

                var pathStr = '';
                if(type == 'rect'){
                    pathStr = PathUtils.rectPath(attrs.x || 0, attrs.y || 0, attrs.width, attrs.height);
                }else if(type == 'line'){
                    pathStr = PathUtils.linePath(attrs.x1, attrs.y1, attrs.x2, attrs.y2);
                }else if(type == 'path'){
                    pathStr = PathUtils.path2vml(attrs.d);
                }else if(type == 'circle'){
                    pathStr = PathUtils.circlePath(attrs.cx || 0, attrs.cy || 0, attrs.r);
                }

                elem.path = pathStr;
            }
        },
        
        style:function(domWrapper, styles){
            var oldStyles = domWrapper.styles,
                newStyles = {},
                elem = domWrapper.rawElement,
                styleName;

            // convert legacy
            if (styles && styles.color) {
                styles.fill = styles.color;
            }

            if (styles && styles.fill && domWrapper.type === 'div') {
                styles.color = styles.fill;
            }

            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                for (styleName in styles) {
                    if (styles[styleName] !== oldStyles[styleName]) {
                        newStyles[styleName] = styles[styleName];
                    }
                }
            }

            if (domWrapper.type === 'div') {

                if (newStyles['transform']) {
                    var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                    if (trans.translate) {
                        newStyles['transform'] = '';
                        newStyles['x'] = trans.translate[0];
                        newStyles['y'] = trans.translate[1];
                    }
                }

                var map = {
                    'x': 'left',
                    'y': 'top',
                    'dx': 'margin-left'
                    // 'dy': 'margin-top'
                };

                for (var name in map) {
                    var s;
                    if ((s = newStyles[name]) != null) {
                        // em or +'px' suffix
                        newStyles[map[name]] = /em/gi.test(s) ? s : s + 'px';
                        delete newStyles[name];
                    }
                }

            }

            // Merge the new styles with the old ones
            if (oldStyles) {
                styles = BaseUtils.extend(oldStyles, newStyles);
            }
            domWrapper.styles = styles;

            if (domWrapper.type === 'div') {
                var hyphenate = function (a, b) {
                    return '-' + b.toLowerCase();
                };

                var alpha = 1;
                if (/rgba/i.test(styles.color)) {
                    var c = ColorUtils.colorToHexAlpha(styles.color);
                    styles.color = c.hex;
                    alpha = c.alpha;
                }

                if(BaseUtils.hasDefined(styles['fill-opacity'])){
                    alpha *= styles['fill-opacity'];
                }

                if(alpha < 1){
                    styles['filter'] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + alpha * 100 + ")";
                }

                var serializedCss = '';
                for (styleName in styles) {
                    serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                }

                elem.style.cssText = serializedCss;
            }else if(domWrapper.type != 'group'){

                if(domWrapper.type == 'image'){
                    domWrapper.node().src = styles.src;
                }else{

                    var stroke = domWrapper._stroke,
                        fill = domWrapper._fill,
                        container = domWrapper.node();

                    container.stroked = true;//
                    container.filled = !!((styles.fill && styles.fill != 'none') || domWrapper.type == 'image');

                    if (!stroke) {
                        stroke = domWrapper._stroke = this.create('stroke');
                        stroke.style.cssText = SubCss;
                    }
                    container.appendChild(stroke);
                    stroke.weight = (styles['stroke-width'] || 0) + 'px';

                    var strokeColor = styles.stroke;
                    var strokeOpacity = BaseUtils.hasDefined(styles['stroke-opacity']) ? styles['stroke-opacity'] : 1;
                    //rgba
                    if(strokeColor && strokeColor.indexOf('rgba') != -1){
                        strokeColor = ColorUtils.colorToHexAlpha(strokeColor);
                        strokeOpacity *= strokeColor.alpha;
                        strokeColor = strokeColor.hex;
                    }
                    stroke.color = strokeColor;
                    stroke.opacity = styles['stroke-width'] ? strokeOpacity : 0;

                    if(styles['stroke-dasharray']){
                        stroke.dashStyle = styles['stroke-dasharray'].replace(/( *, *)/g, ' ');
                    }else{
                        stroke.dashStyle = '';
                    }

                    if(styles['stroke-linecap'] == 'round'){
                        stroke.endcap = 'round';
                    }

                    if (container.filled) {
                        if (!fill) {
                            fill = domWrapper._fill = this.create('fill');
                            fill.style.cssText = SubCss;
                        }
                        container.appendChild(fill);

                        var fillColor = styles.fill;
                        var fillOpacity = BaseUtils.hasDefined(styles['fill-opacity']) ? styles['fill-opacity'] : 1;

                        //rgba
                        if(fillColor.indexOf('rgba') != -1){
                            fillColor = ColorUtils.colorToHexAlpha(fillColor);
                            fillOpacity *= fillColor.alpha;
                            fillColor = fillColor.hex;
                        }

                        fill.color = fillColor;
                        fill.opacity =  Math.min(1, Math.max(fillOpacity, 0));  // todo fillOpacity>1IE8

                    } else if (fill) {
                        container.removeChild(fill);
                        domWrapper._fill = null;
                    }

                }
            }

            if ('display' in styles) {
                domWrapper.node().style.display = styles.display;
            }
            if ('cursor' in styles) {
                domWrapper.node().style.cursor = styles.cursor;
            }
        },

        // assume there's no margin
        // if margin(as offset) is needed,
        // revise this func, record offset to other attr
        // then combine the offset and the rotate adjustment to margin.
        vRotate: function (domWrapper, deg) {
            deg = deg % 360;
            var dom = domWrapper.node();
            BaseUtils.domRotate(dom, 0);
            var ow = dom.offsetWidth, oh = dom.offsetHeight;
            BaseUtils.domRotate(dom, deg);
            var rw = dom.offsetWidth, rh = dom.offsetHeight;
            dom.style.marginLeft = (ow - rw) / 2 + 'px';
            dom.style.marginTop = (oh - rh) / 2 + 'px';
        },

        // again, no dx/margin-left used,
        // or revise it
        vMiddle: function (domWrapper) {
            var dom = domWrapper.node();
            var ow = dom.offsetWidth;
            dom.style.marginLeft = -ow / 2 + 'px';
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }
    }

    function includeElementWrapper () {

        if (included) {return}

        included = true;

        ElementWrapper.include({

            imageContent:function(url){
                this.style({'src':url});
                return this;
            },

            textContent:function(text){
                this.type === 'div' ? this.node().innerHTML = text : this.node().textContent = text;
                return this;
            },

            attr:function(){

                if (this.type === 'div') {
                    this.style.apply(this, arguments);
                } else {
                    this.renderer.attr(this, arguments);
                }
                return this;
            },

            style:function(){
                var styles;
                if (arguments.length === 2) {
                    styles = {};
                    styles[arguments[0]] = arguments[1];
                } else {
                    styles = arguments[0];
                }
                this.renderer.style(this, styles);
                return this;
            }
        });
    }

    return Vml;
});
/**
 * Created by Yuqian on 2017/3/28.
 */
define('locale/localeText',['require','../utils/BaseUtils'],function (require) {

    var BaseUtils = require('../utils/BaseUtils');

    var _locale = 'en';

    var _textMap = {
        'startTime': 'start ',
        'finishTime': 'finish ',
        'duration': 'duration ',
        'progress': 'progress '
    };

    function localeText (key) {
        return _textMap[key] != null ? _textMap[key] : key;
    }

    /**
     * set locale by inner setting
     * @param {string} language - like 'zh-cn'
     */
    localeText.setLocale = function (language) {
        var lan = localeText.normalizeLocale(language);
        if (!lan || _locale === lan) {
            return
        }
        if (!/^en/.test(lan)) { // default
            try{
                var locale = require('./' + lan);
                localeText.setCustomLocale(locale);
            }catch(e){
                // options.languagejs
            }
        }
    };

    /**
     * extend textMap by another Map
     * @param {Object} map - Key-Value object
     *
     * a problem: may conflict if set again
     */
    localeText.setCustomLocale = function (map) {
        if(BaseUtils.hasDefined(map)) {
            BaseUtils.extend(_textMap, map);
            _locale = map._locale;
        }
    };

    localeText.getLocale = function () {
        return _locale
    };

    localeText.getTextMap = function () {
        return _textMap;
    };
    
    localeText.normalizeLocale = function (key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    };

    return localeText

});

/**
 * Created by Yuqian on 2017/3/28.
 */
define('locale/zh-cn',['require'],function (require) {
    return {

        _locale: 'zh-cn',

        'startTime': '',
        'finishTime': '',
        'duration': '',
        'progress': '',

        // used by gantt levelText
        ganttLevels: [
            // 0
            // 2017 | ____
            ['yyyy[]', 'N'],
            // 1
            // 2017 | 
            ['yyyy[]', 'N'],
            // 2
            // 2017 | 
            ['yyyy[]', 'QQQ'],
            // 3
            // 2017, | 01
            ['yyyy[,]N', 'MM'],
            // 4
            // 2017, | 1
            ['yyyy[,]QQQ', 'MMM'],
            // 5
            // 2017, | 1
            ['yyyy[,]QQQ', 'MMM'],
            // 6
            // 20171 | 01
            ['yyyy[]MM[]', 'www'],
            // 7
            // 201712 | ...
            ['yyyy[]MM[]dd[]', 'eeeeee'],
            // 8
            // 20171 | 1...30
            ['yyyy[]MM[]', 'd'],
            // 9
            // 1 | 1...30
            ['MMM', 'd'],
            // 10
            // 11 | 
            ['MM[]dd[]', 'a'],
            // 11
            // 11 | 0~6
            ['MM[]dd[]', 'I'],
            // 12
            // 11 | 1...24
            ['MM[]dd[]', 'H']
        ]
    }
});

/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/LatLng',['require','../../utils/BaseUtils'],function(require){
    var BaseUtils = require('../../utils/BaseUtils');

    var LatLng = function (lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== undefined) {
            this.alt = +alt;
        }
    };

    LatLng.prototype = {

        equals: function (obj, maxMargin) {
            if (!obj) { return false; }

            obj = LatLng.create(obj);

            var margin = Math.max(
                Math.abs(this.lat - obj.lat),
                Math.abs(this.lng - obj.lng));

            return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
        },

        toString: function (precision) {
            return 'LatLng(' +
                BaseUtils.formatNum(this.lat, precision) + ', ' +
                BaseUtils.formatNum(this.lng, precision) + ')';
        },

        distanceTo: function (other) {
            return L.CRS.Earth.distance(this, LatLng.create(other));
        },

        wrap: function () {
            return L.CRS.Earth.wrapLatLng(this);
        },

        clone: function () {
            return new LatLng(this.lat, this.lng, this.alt);
        }
    };

    LatLng.create = function(a, b, c){
        if (a instanceof LatLng) {
            return a;
        }
        if (BaseUtils.isArray(a) && typeof a[0] !== 'object') {
            if (a.length === 3) {
                return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
                return new LatLng(a[0], a[1]);
            }
            return null;
        }
        if (a === undefined || a === null) {
            return a;
        }
        if (typeof a === 'object' && 'lat' in a) {
            return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
        }
        if (b === undefined) {
            return null;
        }
        return new LatLng(a, b, c);
    };

    return LatLng;
});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/Projection',['require','../../utils/Point2D','../../utils/Bounds','./LatLng'],function(require){

    var Point = require('../../utils/Point2D');
    var Bounds = require('../../utils/Bounds');
    var LatLng = require('./LatLng');

    var Projection = {};

    Projection.LonLat = {
        project: function (latlng) {
            return new Point(latlng.lng, latlng.lat);
        },

        unproject: function (point) {
            return new LatLng(point.y, point.x);
        },

        bounds: Bounds.create([-180, -90], [180, 90])
    };

    Projection.SphericalMercator = {

        R: 6378137,
        MAX_LATITUDE: 85.0511287798,

        project: function (latlng) {
            var d = Math.PI / 180,
                max = this.MAX_LATITUDE,
                lat = Math.max(Math.min(max, latlng.lat), -max),
                sin = Math.sin(lat * d);

            return new Point(
                this.R * latlng.lng * d,
                this.R * Math.log((1 + sin) / (1 - sin)) / 2);
        },

        unproject: function (point) {
            var d = 180 / Math.PI;

            return new LatLng(
                (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
                point.x * d / this.R);
        },

        bounds: (function () {
            var d = 6378137 * Math.PI;
            return Bounds.create([-d, -d], [d, d]);
        })()
    };

    Projection.Mercator = {
        R: 6378137,
        R_MINOR: 6356752.314245179,

        bounds: Bounds.create([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

        project: function (latlng) {
            var d = Math.PI / 180,
                r = this.R,
                y = latlng.lat * d,
                tmp = this.R_MINOR / r,
                e = Math.sqrt(1 - tmp * tmp),
                con = e * Math.sin(y);

            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1E-10));

            return new Point(latlng.lng * d * r, y);
        },

        unproject: function (point) {
            var d = 180 / Math.PI,
                r = this.R,
                tmp = this.R_MINOR / r,
                e = Math.sqrt(1 - tmp * tmp),
                ts = Math.exp(-point.y / r),
                phi = Math.PI / 2 - 2 * Math.atan(ts);

            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
                con = e * Math.sin(phi);
                con = Math.pow((1 - con) / (1 + con), e / 2);
                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                phi += dphi;
            }

            return new LatLng(phi * d, point.x * d / r);
        }
    };

    return Projection;
});
/**
 * Created by eason on 2017/2/4.
 */
define('chart/map/Transformation',['require','../../utils/Point2D'],function(require){

    var Point = require('../../utils/Point2D');

    var Transformation = function(a, b, c, d){
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    };

    Transformation.prototype = {
        // @method transform(point: Point, scale?: Number)
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts real `L.Point` instances, not arrays.
        transform: function (point, scale) { // (Point, Number) -> Point
            return this._transform(point.clone(), scale);
        },

        // destructive transform (faster)
        _transform: function (point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },

        // @method untransform(point: Point, scale?: Number)
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts real `L.Point` instances, not arrays.
        untransform: function (point, scale) {
            scale = scale || 1;
            return new Point(
                (point.x / scale - this._b) / this._a,
                (point.y / scale - this._d) / this._c);
        }
    };

    return Transformation;
});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/CRS',['require','../../utils/Bounds','./LatLng','../../utils/BaseUtils','./Projection','./Transformation'],function(require){

    var Bounds = require('../../utils/Bounds');
    var LatLng = require('./LatLng');
    var BaseUtils = require('../../utils/BaseUtils');
    var Projection = require('./Projection');
    var Transformation = require('./Transformation');

    var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function (latlng, zoom) {
            var projectedPoint = this.projection.project(latlng),
                scale = this.scale(zoom);

            return this.transformation._transform(projectedPoint, scale);
        },

        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function (point, zoom) {
            var scale = this.scale(zoom),
                untransformedPoint = this.transformation.untransform(point, scale);

            return this.projection.unproject(untransformedPoint);
        },

        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function (latlng) {
            return this.projection.project(latlng);
        },

        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function (point) {
            return this.projection.unproject(point);
        },

        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function (zoom) {
            return 256 * Math.pow(2, zoom);
        },

        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function (scale) {
            return Math.log(scale / 256) / Math.LN2;
        },

        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function (zoom) {
            if (this.infinite) { return null; }

            var b = this.projection.bounds,
                s = this.scale(zoom),
                min = this.transformation.transform(b.min, s),
                max = this.transformation.transform(b.max, s);

            return Bounds.create(min, max);
        },

        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.

        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.

        // wrapLng: [min, max],
        // wrapLat: [min, max],

        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,

        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function (latlng) {
            var lng = this.wrapLng ? BaseUtils.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
                lat = this.wrapLat ? BaseUtils.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
                alt = latlng.alt;

            return new LatLng(lat, lng, alt);
        }
    };

    CRS.Simple = BaseUtils.extend({}, CRS, {
        projection: Projection.LonLat,
        transformation: new Transformation(1, 0, -1, 0),

        scale: function (zoom) {
            return Math.pow(2, zoom);
        },

        zoom: function (scale) {
            return Math.log(scale) / Math.LN2;
        },

        distance: function (latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng,
                dy = latlng2.lat - latlng1.lat;

            return Math.sqrt(dx * dx + dy * dy);
        },

        infinite: true
    });

    CRS.Earth = BaseUtils.extend({}, CRS, {
        wrapLng: [-180, 180],

        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see http://rosettacode.org/wiki/Haversine_formula
        R: 6371000,

        // distance between two geographical points using spherical law of cosines approximation
        distance: function (latlng1, latlng2) {
            var rad = Math.PI / 180,
                lat1 = latlng1.lat * rad,
                lat2 = latlng2.lat * rad,
                a = Math.sin(lat1) * Math.sin(lat2) +
                    Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

            return this.R * Math.acos(Math.min(a, 1));
        }
    });

    CRS.EPSG3857 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:3857',
        projection: Projection.SphericalMercator,

        transformation: (function () {
            var scale = 0.5 / (Math.PI * Projection.SphericalMercator.R);
            return new Transformation(scale, 0.5, -scale, 0.5);
        }())
    });

    CRS.EPSG900913 = BaseUtils.extend({}, CRS.EPSG3857, {
        code: 'EPSG:900913'
    });


    CRS.EPSG4326 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:4326',
        projection: Projection.LonLat,
        transformation: new Transformation(1 / 180, 1, -1 / 180, 0.5)
    });


    CRS.EPSG3395 = BaseUtils.extend({}, CRS.Earth, {
        code: 'EPSG:3395',
        projection: Projection.Mercator,

        transformation: (function () {
            var scale = 0.5 / (Math.PI * Projection.Mercator.R);
            return new Transformation(scale, 0.5, -scale, 0.5);
        }())
    });

    return CRS;
});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/config',['require','../Constants','../utils/QueryUtils','../utils/BaseUtils','../chart/map/CRS','../dom/Browser'],function (require) {
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var CRS = require("../chart/map/CRS");
    var Browser = require("../dom/Browser");

    var colors = ['#63b2ee', '#76da91', '#f8cb7f', '#f89588', '#7cd6cf', '#9192ab', '#7898e1', '#efa666', '#eddd86', '#9987ce'];

    var defaultColors = [
        '#231815',
        '#727171',
        '#898989',
        '#B5B5B6',
        '#C9CACA'
    ];

    var defaultFontFamily = 'PingFang SC Light, Lantinghei SC-Extralight, Hiragino Sans GB W3, Microsoft Yahei Font, Helvetica, Arial, sans-serif';

    var MAP_CONFIG = {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: CRS.EPSG3857,

        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: undefined,

        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: undefined,

        // @option minZoom: Number = undefined
        // Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
        minZoom: undefined,

        // @option maxZoom: Number = undefined
        // Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
        maxZoom: undefined,

        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],

        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back when he tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: undefined,

        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: undefined,

        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: true,

        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,

        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: true,

        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: true,

        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608, // Precision limit of a 32-bit float

        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 0.5,

        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 0.5,

        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: true,

        // @option dragging: Boolean = true
        // Whether the map be draggable with mouse/touch or not.
        dragging: true,

        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default unless running on old Android devices.
        inertia: !Browser.android23,

        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400, // px/s^2

        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity, // px/s

        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,

        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,

        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0.0,

        // @section Mousewheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,

        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,

        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
    };

    function optionsFun() {

        var options = {

            pie:{
                plotOptions:{
                    rotatable: true,
                    startAngle: 0,
                    endAngle: 360,

                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: seriesValueTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    legend: disabledLegendFun()
                }
            },

            multiPie:{
                plotOptions:{
                    borderWidth: 1,
                    borderColor: 'rgb(255,255,255)',
                    rotatable: true,
                    gradual: 'lighter',
                    innerRadius: 0,
                    startAngle: 0,
                    endAngle: 360,
                    drilldown: true,

                    tooltip: nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,
                    legend: disabledLegendFun()
                }
            },

            treeMap:{
                plotOptions:{
                    borderWidth: 1,
                    borderColor: 'rgb(255,255,255)',
                    zoom: true,

                    tooltip: nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        align: 'top'
                    }
                },

                options:{
                    colors:colors,
                    legend: disabledLegendFun()
                }
            },

            bar:{
                plotOptions:{
                    categoryGap: '20%',
                    gap: '20%',

                    borderRadius: 0,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yCategoryAxisFun()]
                }
            },

            column:{
                plotOptions:{
                    categoryGap: '20%',
                    gap: '20%',

                    borderRadius: 0,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "inside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    style: gradualStyle,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            line:{
                plotOptions:{
                    large: false,
                    connectNulls: false,
                    lineWidth: 2,
                    step: false,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            area:{
                plotOptions:{
                    large: false,
                    connectNulls: false,
                    lineWidth: 2,
                    step: false,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun(),

                    fillColor:true,
                    fillColorOpacity:0.15
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xCategoryAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            gauge:{
                thermometer:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,

                        useHtml: false,

                        align: 'left',

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }
                    },

                    valueLabel: {
                        enabled: false,

                        useHtml: false,

                        align: 'left',

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },

                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }

                    },

                    needle: '#ffffff',
                    slotBackgroundColor: '#eeeeee',
                    thermometerLayout: 'vertical'
                },

                ring:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,

                        useHtml: false,

                        style: {
                            fontSize: 24,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }

                    },

                    valueLabel: {
                        enabled: false,

                        useHtml: false,

                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }
                    },

                    clockwise: false,
                    paneBackgroundColor: '#eeeeee',
                    innerPaneBackgroundColor: '#f4f4f4'

                },

                pointer:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    seriesLabel: {
                        enabled: false,
                        align: Constants.BOTTOM,
                        useHtml: false,
                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}"
                        }
                    },

                    valueLabel: {
                        enabled: false,
                        useHtml: false,
                        backgroundColor: '#F5F5F7',
                        style: {
                            color: defaultColors[1],
                            fontSize: 10,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${SERIES}${VALUE}"
                        }
                    },

                    needle: '#E5715A',
                    hinge: '#656B6D',
                    hingeBackgroundColor: '#DCF2F9',
                    paneBackgroundColor: '#FCFCFC'
                },

                slot:{
                    layout: 'horizontal',
                    tooltip: disabledTooltipFun(),
                    percentageLabel: {
                        enabled: false,
                        useHtml: false,
                        style: {
                            fontSize: 36,
                            fontFamily: defaultFontFamily,
                            fontWeight: 'bold',
                            textShadow: '0px 2px 0px rgba(0,0,0,0.08)'
                        },

                        formatter: {
                            identifier: "${PERCENT}"
                        }
                    },

                    valueLabel: {
                        enabled: false,
                        useHtml: false,
                        style: {
                            color: defaultColors[1],
                            fontSize: 12,
                            fontFamily: defaultFontFamily
                        },
                        formatter: {
                            identifier: "${CATEGORY}${VALUE}"
                        }
                    },

                    needle: '#ffffff',
                    slotBackgroundColor: '#eeeeee'
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    gaugeAxis: [{
                        type: 'value',
                        showLabel: true,
                        step: 1,

                        enableTick: true,
                        tickColor: '#BBBBBB',
                        tickWidth: 1,

                        enableMinorTick: true,
                        minorTickColor: '#e2e2e2',
                        minorTickWidth: 1,

                        labelStyle: {
                            color: defaultColors[1],
                            fontFamily: defaultFontFamily,
                            fontSize: 10
                        }
                    }]
                }
            },

            radar:{
                plotOptions:{

                    fillColorOpacity: 0.15,

                    columnType: false,

                    marker: {
                        radius: 4.5
                    },

                    lineWidth: 2,

                    shape: 'circle',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${Y}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: normalTooltipFun()
                },

                options:{
                    colors:colors,

                    polar: {},

                    legend: disabledLegendFun(),

                    angleAxis: [angleAxisFun()],

                    radiusAxis: [radiusAxisFun()]
                }
            },

            scatter:{
                plotOptions:{
                    large: false,
                    lineWidth: 0,
                    curve: false,

                    marker: {
                        radius: 4.5
                    },

                    opacity: 1,

                    tooltip: seriesXYSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${X}${Y}${SIZE}"
                        },
                        "enabled": false,
                        "align": "outside"
                    }
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    legend: disabledLegendFun(),

                    rangeLegend: disabledRangeLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            bubble:{
                plotOptions:{
                    large: false,
                    displayNegative: true,
                    shadow: true,
                    minSize: 12,
                    maxSize: 60,
                    sizeBy: 'area',
                    opacity: 0.7,

                    tooltip: seriesXYSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${X}${Y}${SIZE}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,

                    zoom: xyZoomFun(),

                    rangeLegend: disabledRangeLegendFun(),

                    legend: disabledLegendFun(),

                    xAxis: [xValueAxisFun()],

                    yAxis: [yValueAxisFun()]
                }
            },

            funnel:{
                plotOptions:{
                    borderColor: "rgb(255,255,255)",
                    borderWidth: 1,

                    sort: true,
                    useSameSlantAngle: true,

                    dataLabels: {
                        "formatter": {
                            "identifier": "${VALUE}"
                        },
                        "enabled": false,
                        "connectorWidth": 1,
                        "align": "outside"
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle
                }
            },

            wordCloud:{
                plotOptions:{
                    "fontFamily": "Microsoft YaHei",
                    "maxRotation": 0,
                    "minRotation": 0,

                    tooltip:nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "enabled": false
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle,

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            structure:{
                plotOptions:{
                    layout:'vertical',
                    force:true,

                    lineColor:'rgb(156,156,156)',
                    lineOpacity:1,

                    borderWidth:1,
                    borderOpacity:1,

                    fillColorOpacity:1,

                    tooltip:nameSeriesValueTooltipFun(),

                    dataLabels: {
                        "enabled": false
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    style: gradualStyle,

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            forceBubble:{
                plotOptions:{
                    large: false,
                    displayNegative: true,
                    shadow: true,
                    minSize: 12,
                    maxSize: 60,
                    sizeBy: 'area',
                    opacity: 1.0,

                    tooltip: normalTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "{SERIES}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    colors:colors,

                    legend: disabledLegendFun(),

                    zoom: xyZoomFun(),

                    rangeLegend: disabledRangeLegendFun()
                }
            },

            areaMap:{

                plotOptions:{
                    nullColor: '#cccccc',
                    opacity: 0.75,
                    borderColor: '#ffffff',
                    borderWidth: 1,
                    borderOpacity: 1,

                    tooltip: nameSeriesValueSizeTooltipFun(),

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}"
                        },
                        "enabled": false,
                        "align": "inside"
                    }
                },

                options:{
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun(),

                    dTools: {
                        style: {
                            "fontFamily": defaultFontFamily,
                            "color": defaultColors[1],
                            "fontSize": 12,
                            "fontWeight": ""
                        },
                        currentColor: '#62b2ef',
                        backgroundColor: 'white',
                        enabled: false
                    }
                }
            },

            pointMap:{

                plotOptions:{
                    opacity: 1,

                    icon: {
                        iconUrl: '../../doc/example/marker-icon.png',
                        iconSize: [25, 41]
                    },

                    dataLabels: {
                        "formatter": {
                            "identifier": "${NAME}${SERIES}${VALUE}"
                        },
                        "enabled": false,
                        "align": "outside"
                    },

                    tooltip: nameSeriesValueSizeTooltipFun()
                },

                options:{
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun(),

                    dTools: {
                        style: {
                            "fontFamily": defaultFontFamily,
                            "color": defaultColors[1],
                            "fontSize": 12,
                            "fontWeight": ""
                        },
                        currentColor: '#62b2ef',
                        backgroundColor: 'white',
                        enabled: false
                    }
                }
            },

            heatMap:{

                plotOptions:{
                    'maxOpacity':1,
                    'minOpacity':0,
                    'radius':15,
                    'blur':0.15
                },

                options:{

                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun()
                }
            },

            lineMap:{

                plotOptions:{
                    "lineWidth": 0.5,
                    "curveness": 0.3,
                    "mouseOverColor": "rgb(253,221,49)",
                    "opacity": 1
                },

                options: {
                    geo:{
                        'zoom':true
                    },

                    colors:colors,

                    title: nullTitleFun(),

                    rangeLegend: rangeLegendFun(),

                    legend: disabledLegendFun()
                }
            },

            gantt: {
                plotOptions: {
                    newLine: true,
                    borderWidth: 1,
                    borderColor: 'white',

                    dataLabels: {
                        "formatter": {
                            "identifier": "${DURATION}${PROGRESS}"
                        },
                        "enabled": false
                    },

                    tooltip: normalTooltipFun()
                },

                options: {
                    processes: {
                        resize: true
                    },
                    levelBar: {
                        enabled: true
                    },
                    timeAxis: {
                        zoom: true,
                        showWeekends: true
                    },
                    colors: colors,
                    legend: disabledLegendFun()
                }
            }
        };


        options.MAP_CONFIG = MAP_CONFIG;
        return options;
    }


    function normalTooltipFun(){
        return {
            formatter: {
                identifier: "${CATEGORY}${SERIES}${VALUE}"
            },
            enabled: true,
            animation: true,
            follow: false,
            backgroundColor: 'rgba(0,0,0,0.5)',
            borderColor: null,
            borderWidth: 0,
            borderRadius: 2,
            shadow: true,
            hideDelay: 500,
            shared: false,
            padding: 5
        }
    }

    function disabledTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {enabled: false}}, true);
    }

    function seriesXYSizeTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${SERIES}${X}${Y}${SIZE}"}}, true);
    }

    function seriesValueTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${SERIES}${VALUE}"}}, true);
    }

    function nameSeriesValueTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${NAME}${SERIES}${VALUE}", shared:true}}, true);
    }

    function nameSeriesValueSizeTooltipFun() {
        return QueryUtils.merge(normalTooltipFun(), {formatter: {identifier: "${NAME}${SERIES}${VALUE}${SIZE}", shared:true}}, true);
    }

    function nullTitleFun() {
        return {
            align: 'center',
            backgroundColor: null,
            borderRadius: 0,
            floating: false,
            x: 0,
            y: 0,
            text: null,
            style: {
                color: defaultColors[1],
                fontSize: 18,
                fontFamily: defaultFontFamily
            },
            useHtml: false
        }
    }

    var gradualStyle = 'gradual';

    function xyZoomFun() {
        return {
            zoomType: 'xy',
            zoomTool: {
                enabled: false,
                resize: true
            }
        }
    }

    function rangeLegendFun() {
        return {
            visible: true,
            enabled: true,
            borderColor: defaultColors[4],
            borderWidth: 0,
            hiddenColor: defaultColors[4],
            hoverColor: '#293C55',
            style: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            position: 'right',
            floating: false,
            x: 0,
            y: 0,
            layout: 'vertical',
            continuous: true,
            margin: 10
        }
    }

    function disabledRangeLegendFun() {
        return QueryUtils.merge(rangeLegendFun(), {enabled:false}, true);
    }

    function disabledLegendFun() {
        return {
            visible: true,
            enabled: false,
            hiddenColor: defaultColors[4],
            hoverColor: '#293C55',
            borderRadius: 0,
            borderColor: defaultColors[4],
            borderWidth: 0,
            backgroundColor: null,
            style: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            position: 'right',
            floating: false,
            layout: 'vertical',
            x: 0,
            y: 0,
            shadow: false,
            margin: 10
        }
    }

    function xCategoryAxisFun() {
        return {
            type: 'category',
            position: 'bottom',
            onZero: false,
            reversed: false,
            title: {
                text: null,
                align: 'center',
                rotation: 0,
                useHtml: false,
                style: {
                    color: defaultColors[1],
                    fontFamily: defaultFontFamily,
                    fontSize: 12
                }
            },
            lineWidth: 0.5,
            lineColor: defaultColors[2],
            showArrow: false,
            enableTick: true,
            enableMinorTick: false,

            minorTickColor: defaultColors[2],
            minorTickWidth: 0.5,
            minorTickLength: 2,

            tickColor: defaultColors[2],
            tickWidth: 0.5,
            tickLength: 4,

            tickPadding: 4,
            gridLineWidth: 0,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function yValueAxisFun() {
        return {
            type: 'value',
            position: 'left',
            onZero: false,
            reversed: false,
            title: {
                text: null,
                align: 'center',
                rotation: 0,
                useHtml: false,
                style: {
                    color: defaultColors[1],
                    fontFamily: defaultFontFamily,
                    fontSize: 12
                }
            },
            lineWidth: 0,
            lineColor: defaultColors[2],
            showArrow: false,
            enableTick: false,
            enableMinorTick: false,

            minorTickColor: defaultColors[2],
            minorTickWidth: 0.5,
            minorTickLength: 2,

            tickColor: defaultColors[2],
            tickWidth: 0.5,
            tickLength: 4,

            tickPadding: 4,
            gridLineWidth: 1,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function xValueAxisFun() {
        return QueryUtils.merge(xCategoryAxisFun(), {type:'value'}, true);
    }

    function yCategoryAxisFun() {
        return QueryUtils.merge(yValueAxisFun(), {type:'category'}, true);
    }

    function angleAxisFun() {
        return {
            type: 'category',
            lineWidth: 0.5,
            lineColor: defaultColors[2],
            gridLineWidth: 1,
            gridLineColor: defaultColors[3],

            showLabel: true,
            labelStyle: {
                color: defaultColors[1],
                fontFamily: defaultFontFamily,
                fontSize: 12
            },
            labelRotation: 0,
            useHtml: false
        }
    }

    function radiusAxisFun() {
        return QueryUtils.merge(angleAxisFun(), {type:'value'}, true);
    }

    function drillTools(){
        return {
            style: {
                "fontFamily": defaultFontFamily,
                "color": defaultColors[1],
                "fontSize": 12,
                "fontWeight": ""
            },
            currentColor: '#62b2ef',
            backgroundColor: 'white',
            enabled: false
        }
    }

    return optionsFun;
});
/**
 * Created by eason on 2017/2/4.
 */
define('vans/VanChartLibrary',['require','../Constants'],function(require){
    var Constants = require('../Constants');

    var _registeredVanCharts = {};

    /**
     * function
     * @param name 
     */
    function get(name){
        return _registeredVanCharts[name] || _registeredVanCharts[Constants.VANCHART];
    }

    /**
     * 
     * @param name 
     * @param VanChart 
     */
    function register(name, VanChart){
        _registeredVanCharts[name] = VanChart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 15/6/17.
 */
define('vans/VanChart',['require','./../utils/BaseUtils','./../utils/QueryUtils','../dom/Evented','./VanChartLayout','./../ComponentLibrary','./../ChartLibrary','./../Constants','./../HammerHandler','./../vector/SvgRenderer','./../vector/VmlRenderer','../utils/Point2D','../locale/localeText','../locale/zh-cn','./../theme/config','./../theme/config','./VanChartLibrary'],function(require){

    var BaseUtils = require('./../utils/BaseUtils');
    var QueryUtils = require('./../utils/QueryUtils');
    var Evented = require('../dom/Evented');
    var VanChartLayout = require('./VanChartLayout');
    var ComponentLibrary = require('./../ComponentLibrary');
    var ChartLibrary = require('./../ChartLibrary');

    var Constants = require('./../Constants');
    var Handler = require('./../HammerHandler');

    var SvgRenderer = require('./../vector/SvgRenderer');
    var VmlRenderer = require('./../vector/VmlRenderer');

    var Point = require('../utils/Point2D');

    var localeText = require('../locale/localeText');

    require('../locale/zh-cn');

    // Cmen: 16px,,BaseUtilsDEFAULT_PADDING_FONTSIZE
    // ,,_FUNSCALE
    var PADDING = 8;
    var PADDING_FUN = function (){
        return BaseUtils.paddingConvertWithScale(PADDING);
    }

    var INTERACTIVE_COMPONENTS = [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.ANGLE_AXIS_COMPONENT];

    var VanChart = Evented.extend({
        vanChartType:'vanChart',
        initialize:function(option, dom, vancharts){

            localeText.setLocale(option.language);

            this.wrapDom = dom;
            this.width = BaseUtils.getDomWidth(dom);
            this.height = BaseUtils.getDomHeight(dom);

            // @CmenCHART-1130: resizedomdominitChart
            // resizeinitializedomresize
            if(!this.width || !this.height) { return; }

            this.vancharts = vancharts;
            this.series = [];
            this.components = {};
            this._targets = {};

            this.animationCount = 0;

            this._changeDataState = false;
            this.fullScreenChart = null;//

            this.setOptions(option);

            this.handler = new Handler(this, dom);

            this._initDomLayout(this.wrapDom);

            this.update();
        },

        setOptions:function(option){

            option.series = option.series || [];//series

            option.series.forEach(function(sery){
                sery.data = sery.data || [];
            });

            //
            this._mergeThemeConfig(option);

            if (option.plotOptions.inverted && option.dataSheet) {
                option.dataSheet.enabled = false;
            }

            this.options = option;

            if(this.fullScreenChart){
                this.fullScreenChart.setData(option);
            }
        },

        _initDomLayout:function(dom){
            this.dom = dom;
            this.renderer = BaseUtils.isSupportSVG() ? new SvgRenderer(dom, this) : new VmlRenderer(dom, this);
            this.renderer.onAdd();

            this.on({
                'animationStart':this._animationStart,
                'animationEnd':this._animationEnd
            })
        },

        _animationStart:function(){
            // console.log('series ani start, count reset to 0');

            //fire'animationEnd'
            this._animationStarted = true;
            this.animationCount = 0;

            this.removeMoreLabel();

            this.series.forEach(function(ser){
                ser._removeDataLabels();
                ser.render();
            });

            if (!this.animationCount) {
                this.fire('animationEnd');
            }
        },

        /**
         * MoreLabel
         * @return {[type]} [description]
         */
        removeMoreLabel: function () { 
            var moreLabel = this.getComponent(ComponentLibrary.MORELABEL_COMPONENT);
            moreLabel && moreLabel.removeAllMoreLabels(); 
        },

        _animationEnd:function(){

            if(!this.renderer){
                return; //has been removed
            }

            this._animationStarted = false;

            this.series.forEach(function(ser){
                ser._animateEnd();
            });

            this._consoleDone();
        },

        _removeChangeDataState: function (series) {
            if(this._changeDataState) {
                this._changeDataSeries = this._changeDataSeries || [];
                this._changeDataSeries.push(series);

                if (this._changeDataSeries.length >= this.series.length) {
                    //,changeData
                    this._changeDataState = false;
                    this._changeDataSeries = [];
                }
            }
        },

        _needShowMoreLabel:function () {
            var moreLabel = this.options.moreLabel;
            return this._changeDataState && moreLabel && moreLabel.enabled && !this.isLargeMode();
        },

        _clearMoreLabels: function () {
            this.series.forEach(function(ser){
                ser._clearMoreLabels();
            });
        },

        _initIntermediateState:function(){
            this.colorMap = {};
            this.orderMap = {};
            this.cateMap = {};
            this.scale = 1;
            this.timeQueue = this.clearTimeQueue();
            this.clipPool = {};
            this.axisSize = {
                'left':0, 'right':0, 'bottom':0, 'top':0
            };

            this.layerMap = this.layerIndex = null;
        },

        //
        refresh:function(options){

            var lastLarge = !!(this.options && this.options.plotOptions && this.options.plotOptions.large),
                currentLarge = !!(options && options.plotOptions && options.plotOptions.large);

            if(lastLarge != currentLarge){
                this.series && this.series.forEach(function (ser) {
                    ser.remove();
                });
            }

            this.setOptions(options);

            this.update();
        },

        //,1. 2.
        //,1. 2.,
        refreshRestore:function(){

            var vanchart = this, components = vanchart.components;

            INTERACTIVE_COMPONENTS.forEach(function(cName){
                components[cName] && vanchart._restoreCategoryAxisBasedSeries(components[cName]);
            });

            //
            var gaugeSeries = this.seriesOfType(Constants.GAUGE_CHART);
            if(gaugeSeries.length == this.series.length){
                this.series.sort(function(a, b){
                    return a.index - b.index;
                });
            }

            //
            this.seriesOfType(Constants.PIE_CHART).forEach(function(sery){

                var map = sery.points.map(function(point){
                    return point.graphic;
                });

                var orderMap = {};
                sery.options.data.forEach(function(datum, i){
                    orderMap[datum.x] = i;
                });

                sery.points.sort(function(sliceA, sliceB){
                    return  orderMap[sliceA.x] - orderMap[sliceB.x];
                });

                sery.points.forEach(function(point, index){
                    point.graphic = map[index];
                });
            });

            //
            var multipie = this.seriesOfType(Constants.MULTIPIE_CHART);
            if(multipie.length){
                multipie[0].orderData(null)
            }


            //
            //
            this.update();
        },

        //pointgraphic,
        orderData:function(){

            var vanchart = this, components = vanchart.components;

            INTERACTIVE_COMPONENTS.forEach(function(cName){
                components[cName] && vanchart._orderCategoryAxisBasedSeries(components[cName]);
            });

            var increaseOrder = this.orderType == Constants.ASCENDING;
            var para = increaseOrder ? 1 : -1;

            //
            var gaugeSeries = this.seriesOfType(Constants.GAUGE_CHART);
            if(gaugeSeries.length == this.series.length){
                this.series.sort(function(serA, serB){
                    var totalA = serA.getSeryTotalValue();
                    var totalB = serB.getSeryTotalValue();
                    return (totalA - totalB) * para;
                });
            }

            //
            this.seriesOfType(Constants.PIE_CHART).forEach(function(sery){
                var map = sery.points
                    .filter(function (point) {
                        return point.visible;
                    })
                    .map(function(point){
                        return point.graphic;
                    });

                sery.points.sort(function(sliceA, sliceB){
                    return  increaseOrder ? sliceA.y - sliceB.y : sliceB.y - sliceA.y;
                });

                var index = 0;
                sery.points.forEach(function(point){
                    if (point.visible) {
                        point.graphic = map[index];
                        ++index;
                    }
                });
            });

            //
            var multipie = this.seriesOfType(Constants.MULTIPIE_CHART);
            if(multipie && multipie.length){
                multipie[0].orderData(increaseOrder)
            }

            this.reRenderSeries();

            //zoom_sortedPoints
            INTERACTIVE_COMPONENTS.concat([ComponentLibrary.ZOOM_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.POLAR_COMPONENT]).forEach(function(cName){
                components[cName] && components[cName].render();
            });
        },

        /**
         * 
         * @param  {[type]} axisComponent [description]
         * @return {[type]}               [description]
         */
        _restoreCategoryAxisBasedSeries:function(axisComponent){
            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex), series = axis.series;

                //orderMap
                if(axis._isBaseAxis() && axis.isCategory() && this.orderMap && Object.keys(this.orderMap).length){

                    var order = this.orderMap[axis.componentType][axisIndex];
                    var keyIndexMap = {};
                    order.forEach(function(p, i){
                        keyIndexMap[p] = i;
                    });

                    var lastOrder = axis._dataDomain;
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i], normalData = true;

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexOf(lastOrder, point.getCategory())] = point.graphic;

                            if(!point.graphic){
                                normalData = false;
                            }
                        });

                        sery.points.forEach(function(point){
                            point.graphic = normalData ? lastOrderMap[keyIndexMap[point.getCategory()]] : point.graphic;

                            //,
                            sery.updatePointGraphic(point);
                        });
                    }
                }
            }
        },

        /**
         * 
         * @param  {[type]} axisComponent [description]
         * @return {[type]}               [description]
         */
        _orderCategoryAxisBasedSeries:function(axisComponent){

            var para = this.orderType == Constants.ASCENDING ? 1 : -1;

            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex);

                this.orderMap[axis.componentType] = this.orderMap[axis.componentType] || [];

                if(!this.orderMap[axis.componentType][axisIndex]){
                    this.orderMap[axis.componentType][axisIndex] = axis._dataDomain;
                }


                var series, valueMap = [], points, keyIndexMap = {} , newCategories = [];

                if(axis._isBaseAxis() && axis.isCategory()){

                    series = axis.series;
                    points = series[0].points;

                    var isMultiCateAxis = axis.isMultiCateAxis && axis.isMultiCateAxis();
                    isMultiCateAxis ? sortMultiCategoryAxis() : sortNormalCategoryAxis();

                    var lastOrder = axis.getOriginalCategories();
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i], normalData = true;

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexOf(lastOrder, point.getCategory())] = point.graphic;

                            if(!point.graphic){
                                normalData = false;
                            }
                        });

                        sery.points.forEach(function(point){
                            point.graphic = normalData ? lastOrderMap[keyIndexMap[point.getCategory()]] : point.graphic;
                            //,
                            sery.updatePointGraphic(point);
                        });
                    }

                    axis.setCategories(newCategories);  // domain
                }

                //
                function sortNormalCategoryAxis(){

                    for(var i = 0, len = points.length; i < len; i++){
                        var point = points[i];
                        var total = 0;
                        point.points.forEach(function(point){
                            if(point.visible && point.series.visible){
                                total += Math.abs(point.getTargetValue());
                            }
                        });

                        valueMap.push({key:point.category, value:total});
                    }

                    valueMap.sort(function(a, b){return (a.value - b.value) * para});
                    
                    valueMap.forEach(function(p, i){
                        keyIndexMap[p.key] = i;
                        newCategories.push(p.key);
                    });
                }  

                // 
                function sortMultiCategoryAxis(){
                    var valueArr = [];

                    for(var i = -1; ++i < points.length;){
                        var point = points[i];
                        var total = 0;
                        point.points.forEach(function (p){
                            if(p.visible && p.series.visible){
                                total += Math.abs(p.getTargetValue());
                            }
                        });

                        var categoryArray = point.options.categoryArray,
                            keyString = BaseUtils.encodeCategoryArray(categoryArray.slice(0, categoryArray.length - 1)),
                            cateString = BaseUtils.encodeCategoryArray(categoryArray);

                        var datum = {
                            key: keyString,
                            cate: cateString,
                            value: total
                        };

                        if(valueMap[keyString] == null){
                            valueMap[keyString] = valueArr.push([datum]) - 1;
                        }else{
                            valueArr[valueMap[keyString]].push(datum);
                        }
                    }

                    valueArr.forEach(function (cateArr){
                        cateArr.sort(function (a, b){
                            return (a.value - b.value) * para;
                        });
                    });

                    var keyIndex = 0;
                    valueArr.forEach(function (cateArr){
                        cateArr.forEach(function (cate){
                            keyIndexMap[cate.cate] = keyIndex;
                            newCategories.push(cate.cate);
                            keyIndex++;
                        })
                    });
                }


                
            }
        },


        /** 
         *  
         * @param options 
         */ 
        addSeries: function (serData){
            // todo 

            // SeresPlotOptionsvanchart.options.plotOptions
            var type = serData.type, option = this.options;

            var config = require('./../theme/config')();
            var defaultPlotOptions = config[type].plotOptions;

            QueryUtils.merge(option, config[type].options, false);
            if(option.plotOptions[type]){
                option.plotOptions[type] = QueryUtils.merge(option.plotOptions[type], defaultPlotOptions, false);
            }else{
                option.plotOptions = QueryUtils.merge(option.plotOptions, defaultPlotOptions, false);
            }

            option.series.push(serData);
        }, 

        /**
         * 
         * add, update, delete 
         *     1. addvanChart.addSeriesseries.addPoint
         *     2. deleteupdate
         * @param  {[type]} options [] example:{add:{...}, update:{...}, delete:{...}}
         * @return {[type]}         [description]
         */
        autoRefresh: function (options, index) {
            var addData = options.add || [],
                removeData = options.remove || [],
                updateData = options.update || [],
                additionalOption = options.option || {};
            var vanchart = this, option = vanchart.options, chartType = option.chartType;

            var seriesMap = {}, type;
            this.series.forEach(function(ser){
                type = ser.type;

                if(type == Constants.GAUGE_CHART){
                    type += (ser.gaugeType + (ser.options.thermometerLayout || ''));
                }

                if(type == Constants.RADAR_CHART){
                    type = ser.columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                }

                var sameNameArray = seriesMap[ser.name + type];
                if(sameNameArray){
                    sameNameArray.push(ser);
                } else {
                    sameNameArray = [ser];
                    seriesMap[ser.name + type] = sameNameArray;
                }
            });

            // 
            removeData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;

                if(ser) {
                    serData.data.forEach(function (datum){
                        var pos = ser.calculatePointIndex(datum);
                        BaseUtils.hasDefined(pos) && ser.removePoint(pos, false);
                    });
                    // datalength0seriessameNameArray1
                    if(ser.options.data.length === 0) {
                        sameNameArray && sameNameArray.splice(0,1);
                    }
                }
            });

            // 
            addData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;
                if(ser) {
                    serData.data.forEach(function (datum){
                        ser.addPoint(datum)
                    })
                } else {
                    vanchart.addSeries(serData);
                }
            });

            // 
            updateData.forEach(function(serData, index){
                var key = createSeriesKey(serData, index);

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;

                if(ser) {
                    serData.data.forEach(function (datum){
                        var pos = ser.calculatePointIndex(datum);
                        BaseUtils.hasDefined(pos) && ser.updatePoint(pos, datum, false);
                    })
                }
            });

            // 

            QueryUtils.merge(this.options, additionalOption, true);

            if(this.isMap()){
                this.options.xAxis = this.options.yAxis = this.options.zoom = undefined;
            }
            // optionsupdate
            this.autoRefreshRender();

            if(this.fullScreenChart) {
                this.fullScreenChart.charts[index].autoRefreshRender();
            }

            // serieskey
            function createSeriesKey(serData, index){
                type = serData.type || chartType;
                var seriesName = BaseUtils.pick(serData.name, 'Series' + index);

                var key = seriesName + type;
                if(type == Constants.GAUGE_CHART){
                    var style = serData.style || option.plotOptions.style;
                    var layout = serData.thermometerLayout || option.plotOptions.thermometerLayout || '';
                    key = seriesName + type + style + layout;
                }else if(type == Constants.RADAR_CHART){
                    var columnType = serData.columnType || option.plotOptions.columnType;
                    columnType = columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                    key = seriesName + columnType;
                }

                return key;
            }
        },

        /**
         * 
         * chartfullScreenChartoptionschartautoRefresh
         * MoreLabel
         * @return {[type]} [description]
         */
        autoRefreshRender: function (){
            // true
            if(this._changeDataState) {
                this._changeDataSeries = [];  //,,_changeDataSeries
            }
            
            this._changeDataState = true;

            this.update();
        },

        //,..
        update:function(){

            this._initIntermediateState();

            var option = this.options, vanchart = this,
                seriesData = option.series, chartType = option.chartType;
            var name, Class;

            //,
            var Components = ComponentLibrary.getRegisteredComponents(), ComponentsOrder = ComponentLibrary.ComponentsOrder;

            for(var index = 0, cCount = ComponentsOrder.length; index < cCount; index++){
                name = ComponentsOrder[index]; Class = Components[name];

                if(name == ComponentLibrary.RANGE_LEGEND_COMPONENT && option[name]){
                    var rangeType = option[name].continuous ? ComponentLibrary.GradientRangeLegend : ComponentLibrary.INTERVAL_RANGE_LEGEND;

                    if(this.components[name] && this.components[name].type != rangeType){
                        this.components[name].remove();
                        this.components[name] = null;
                    }

                    Class = ComponentLibrary.get(rangeType);
                }

                if(Class){
                    var enabled = option[name] && (BaseUtils.hasNotDefined(option[name].enabled) || option[name].enabled);

                    if(!enabled && name == ComponentLibrary.TOOLBAR_COMPONENT){
                        enabled = true;
                        option[name] = {'enabled':true, 'hidden':false};
                    }

                    if(option[name] && enabled){

                        if(this.components[name]){
                            this.components[name].refresh(option[name], vanchart);
                        }else{
                            this.components[name] = new Class(option[name], name, vanchart);
                        }

                    }else if(this.components[name]){
                        this.components[name].remove();
                        this.components[name] = null;
                        delete this.components[name];
                    }
                }
            }

            var seriesMap = {}, type, series = [];
            vanchart.series.forEach(function(ser){
                type = ser.type;

                if(type == Constants.GAUGE_CHART){
                    type += (ser.gaugeType + (ser.options.thermometerLayout || ''));
                }

                if(type == Constants.RADAR_CHART){
                    type = ser.columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                }

                var sameNameArray = seriesMap[ser.name + type];
                if(sameNameArray){
                    sameNameArray.push(ser);
                } else {
                    sameNameArray = [ser];
                    seriesMap[ser.name + type] = sameNameArray;
                }
            });

            seriesData.forEach(function(serData, index){
                // @Cmen SerData serDatarefreshseries.optionpoint.option
                // SerData refreshOptionmarkerColor
                // 
                // seriesserDataseries.data
                serData = BaseUtils.clone(serData);

                type = serData.type || chartType;
                var seriesName = BaseUtils.pick(serData.name, 'Series' + index);

                var Class = ChartLibrary.get(type), key = seriesName + type;
                if(type == Constants.GAUGE_CHART){
                    var style = serData.style || option.plotOptions.style;
                    var layout = serData.thermometerLayout || option.plotOptions.thermometerLayout || '';
                    Class = ChartLibrary.get(style);
                    key = seriesName + type + style + layout;
                }else if(type == Constants.RADAR_CHART){
                    var columnType = serData.columnType || option.plotOptions.columnType;
                    columnType = columnType ? Constants.COLUMN_RADAR : Constants.LINE_RADAR;
                    Class =  ChartLibrary.get(columnType);
                    key = seriesName + columnType;
                }

                var sameNameArray = seriesMap[key];
                var ser = sameNameArray && sameNameArray.length ? sameNameArray[0] : null;
                ser = ser ? ser.refresh(serData, index) : new Class(serData, vanchart, index);
                series.push(ser);
                sameNameArray && sameNameArray.splice(0,1);
            });

            for(var serKey in seriesMap){
                var sameNameArray = seriesMap[serKey];
                sameNameArray && sameNameArray.forEach(function (ser) {
                    ser && ser.remove();
                });
            }

            vanchart.series = series;

            var gaugeAxis = this.components[ComponentLibrary.GAUGE_AXIS_COMPONENT];
            if(gaugeAxis){
                gaugeAxis.initAttributesWithSeries();
            }

            var rangeLegend = this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT];
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            series.forEach(function(ser){
                // try in large mode
                if (ser.type === Constants.LINE_MAP && ser.options.large) {
                    return;
                }
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            vanchart.layoutComponentsAndCharts();
        },

        layoutComponentsAndCharts:function(){
            //
            //

            this.hoverPoint = this.hoverSeries = null;

            VanChartLayout.PLANE_SYSTEM_LAYOUT(this);

            this.render();
        },

        //padding
        _getDefaultBounds:function(){
            var padding = (this.options && this.options.padding) || PADDING_FUN();
            var borderWidth = (this.options && this.options.borderWidth) || 0;
            padding = borderWidth + padding;

            return BaseUtils.makeBounds(padding, padding, Math.max(this.width - 2 * padding, 0), Math.max(this.height - padding, 0));
        },

        reRenderWholePlot:function(){
            VanChartLayout.reLayoutPlotBounds(this);

            VanChartLayout.calculateSeries(this);

            VanChartLayout.calculateSeriesShapes(this);

            this.render();
        },

        dealAxisZoom:function(downPos, upPos){
            var zoomType = this.options.zoom.zoomType,
                xAxis = this.components.xAxis,
                yAxis = this.components.yAxis;

            if(xAxis && zoomType.indexOf('x') !== -1){
                xAxis.axisZoom(downPos, upPos);
            }

            if(yAxis && zoomType.indexOf('y') !== -1){
                yAxis.axisZoom(downPos, upPos);
            }

            this.reRenderWholePlot();
        },

        //
        clearAllEffects:function () {
            this.series.forEach(function(ser){
                ser.points.forEach(function (point) {
                    point.clearPointEffect();
                })
            });
        },

        drawAllEffects:function () {
            this.series.forEach(function(ser){
                ser._drawEffectPoints();
            });
        },

        _calculateZoomParas:function (downPos, upPos) {
            var plotBounds = this.bounds;
            var minX = Math.min(downPos.x, upPos.x) - plotBounds.x;
            var minY = Math.min(downPos.y, upPos.y) - plotBounds.y;

            var detX = Math.abs(downPos.x - upPos.x);
            var detY = Math.abs(downPos.y - upPos.y);

            var scale = Math.min(plotBounds.width/detX, plotBounds.height/detY);

            var wWidth = plotBounds.width / scale;
            var wHeight = plotBounds.height / scale;

            var shiftX = (plotBounds.width - wWidth)/2 - minX;
            var shiftY = (plotBounds.height - wHeight)/2 - minY;

            return {
                shiftX:shiftX,
                shiftY:shiftY,
                scale:scale
            };
        },

        //
        _mergeThemeConfig:function(option){
            var config = require('./../theme/config')();

            var merged = {}, vanchart = this;

            option.series.forEach(function(ser){
                var type = ser.type || option.chartType;
                var defaultPlotOptions = config[type].plotOptions;

                if(type == Constants.GAUGE_CHART){
                    var style = ser.style || (option.plotOptions.gauge && option.plotOptions.gauge.style) || option.plotOptions.style;
                    style = style == 'pointer_semi' ? 'pointer' : style;
                    defaultPlotOptions = config.gauge[style];

                    var gaugeLabelKey = ['seriesLabel', 'valueLabel', 'percentageLabel'];

                    gaugeLabelKey.forEach(function(key){
                        if(BaseUtils.hasDefined(ser[key])){
                            QueryUtils.merge(ser[key], defaultPlotOptions[key], false);
                        }
                    });
                }

                if(!merged[type]){
                    merged[type] = true;
                    QueryUtils.merge(option, config[type].options, false);
                    if(option.plotOptions[type]){
                        option.plotOptions[type] = QueryUtils.merge(option.plotOptions[type], defaultPlotOptions, false);
                    }else{
                        option.plotOptions = QueryUtils.merge(option.plotOptions, defaultPlotOptions, false);
                    }
                }
            });

            if(this.isMap()){
                option.xAxis = option.yAxis = option.zoom = undefined;

                BaseUtils.extend(option, config.MAP_CONFIG)
            }

            if(option.chartType == Constants.RADAR_CHART){
                option.polar = option.polar || {};
            }

            option.tooltip = option.tooltip || {};
        },

        getChartMinMaxValue:function(){

            var min = Number.MAX_VALUE, max = -min;

            this.series.forEach(function(ser){

                ser.points
                    .filter(function (point) {
                        return !point.isNull && !isNaN(point.getTargetValue());})
                    .forEach(function (point) {
                        var value = point.getTargetValue();
                        max = Math.max(max, value);
                        min = Math.min(min, value);
                    });

            });

            if(min > max){
                min = 0;
                max = 100;
            }

            return [min, max];
        },

        getParentDom:function(){
            return this.dom;
        },

        getDivParentDom:function(){
            return this.wrapDom;
        },

        isInverted: function () {
            return !!this.options.plotOptions.inverted;
        },

        setPlotBounds:function(newBounds){
            this.bounds = newBounds;
        },

        getPlotClipBounds:function(){
            var x = 0,  y = 0, width = this.bounds.width, height = this.bounds.height;
            var locationMap = {}, all = [];
            if(this.components.xAxis){
                all = all.concat(this.components.xAxis._axisList);
            }

            if(this.components.yAxis){
                all = all.concat(this.components.yAxis._axisList);
            }

            all.forEach(function(axis){
                var position = axis.getPosition();
                if(!axis.isOnZero() && !locationMap[position]){
                    locationMap[position] = axis.getLineWidth();
                }
            });

            y = locationMap[Constants.TOP] ? Math.ceil(locationMap[Constants.TOP]/2) : 0;
            height -= y;
            height = locationMap[Constants.BOTTOM] ? height - Math.ceil(locationMap[Constants.BOTTOM]/2 - 0.5) : height;

            x = locationMap[Constants.LEFT] ? Math.ceil(locationMap[Constants.LEFT]/2) : 0;
            width -= x;
            width = locationMap[Constants.RIGHT] ? width - Math.ceil(locationMap[Constants.RIGHT]/2) : width;

            //1
            return {
                x:x + this.bounds.x,
                y:y + this.bounds.y,
                width:Math.max(width + 1, 0),
                height:Math.max(height + 1, 0)
            };
        },

        getChartBounds:function(){
            return BaseUtils.makeBounds(0, 0, this.width, this.height);
        },

        xAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.xAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        yAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.yAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        polar:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.polar;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        angleAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.angleAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        radiusAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.radiusAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        gaugeAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.gaugeAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        getSharedAxis: function () {
            var axes = [this.xAxis(), this.yAxis(), this.angleAxis()];
            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                if (axis && axis.isCategory()) {
                    return axis;
                }
            }
            return null;
        },

        getComponent:function(type){
            return this.components[type];
        },

        setComponent:function (component, type) {
            this.components[type] = component;
        },

        /**
         * return color of previous name
         * or set new color and return
         * @param {string} [name] series item (or pie point) name
         * @returns {*}
         */
        getDefaultSeriesColor: function (name) {
            name += '';
            if (!this.colorMap[name]) {
                var colors = this.options.colors;
                var length = 0;
                for (var item in this.colorMap) {
                    ++length;
                }
                // return next color
                this.colorMap[name] = colors[length % colors.length];
            }

            return this.colorMap[name];
        },

        registerPointsPara:function(point){
            if(BaseUtils.hasDefined(point.category)){
                var cateMap = this.cateMap;
                var cateString = point.getCategory();
                cateMap[cateString] = cateMap[cateString] || [];
                cateMap[cateString].push(point);
                return cateMap[cateString];
            }
        },

        getValidPointsPara:function(category){

            var points = this.cateMap[category] || [];

            return points.filter(function (p) {
                return p.isVisible() && p.options.tooltip && p.options.tooltip.shared
            });
        },

        getSharedPoints:function (category) {
            var points = this.cateMap[category] || [];

            if(points && points.length){
                return points.filter(function (p) {
                    return p.options.tooltip && p.options.tooltip.shared
                });
            }

            return [];
        },

        showSharedTooltip:function (point, event) {
            if(!point){
                return;
            }
            var vanchart = this, valid = vanchart.getValidPointsPara(point.getCategory());

            var max = valid
                .reduce(function (prev, curr) {
                    if (!prev) {
                        return curr;
                    }
                    return (curr.getTargetValue() > prev.getTargetValue()) ? curr : prev;
                }, 0);

            // CHART-823
            // get first point(include invisible) among shared points
            vanchart.showTooltip(max, event, vanchart.getSharedPoints(point.getCategory())[0]);
        },

        showTooltip:function(point, event, fmtPoint){
            //
            if(this.handler.selectRect){
                return;
            }

            this.components[ComponentLibrary.TOOLTIP_COMPONENT].showWithPoint(point, event, fmtPoint)
        },

        hideTooltip:function(){
            this.hoverPoint = null;
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].hide();
        },

        /**
         * 
         * @param  {Object} icon    tooltiptoolbarIcon
         * @param  {String} content 
         */
        showToolbarTooltip: function (icon, content) {
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].showWithToolbarIcon(icon, content);
        },

        // set this chart's state, like enable/disable dom event
        set: function (opt) {
            if (('enable' in opt) && this.handler) {
                if (opt['enable']) {
                    this.handler.hammer.set({enable:true});
                } else {
                    this.handler.hammer.set({enable:false});
                    this.handler.removeAllChosen();
                }
            }
        },

        isMap:function(){
            return this.vanChartType == 'vanChartMap';
        },

        chartType:function(){
            return this.options.chartType;
        },

        isHeatMap:function(){
            return this.options.chartType == Constants.HEAT_MAP;
        },

        isAreaMap:function(){
            return this.options.chartType == Constants.AREA_MAP;
        },

        isForceBubble:function(){
            return this.vanChartType == 'vanChartForceBubble';
        },

        isLargeMode:function(){
            return this.options.plotOptions.large;
        },

        hasRangeLegend: function () {
            return !!this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT]
        },

        seriesOfType:function(type){
            return this.series.filter(function(ser){
                return ser.type == type;
            })
        },

        pointsOfType: function (type) {
            var allPoints = [];
            this.series.forEach(function (ser) {
                if(ser.type == type) {
                    allPoints = allPoints.concat(ser.points);
                }
            });
            return allPoints;
        },

        // ussage:
        // vanchart.setTimeout('foo', bar, 100);
        // setting new func for the same key will flush the previous func
        // vanchart.setTimeout('foo'); cancel the func
        //
        // attention: this function fire the delay=0 immediately, no setTimeout(fun, 0)
        //
        setTimeout: function (key, func, delay) {
            if (this.timeQueue[key]) {
                window.clearTimeout(this.timeQueue[key]);
            }
            if (delay) {
                this.timeQueue[key] = window.setTimeout(func, delay);
            } else {
                func && func();
                this.timeQueue[key] = null;
            }
        },

        // should remove all in the end
        clearTimeQueue: function () {
            var timeQueue = this.timeQueue || {};
            Object.keys(timeQueue).map(function (key) {
                window.clearTimeout(timeQueue[key]);
            });

            return {};
        },

        getSize: function () {
            if (!this._size || this._sizeChanged) {
                this._size = new Point(this.width, this.height);
                this._sizeChanged = false;
            }
            return this._size.clone();
        },

        /**
         * 
         * @returns {boolean}
         */
        isZoomingWithLargeModel: function (){
            var totalDataLen = 0, series = this.options.series, i, data;
            for(i = -1; ++i < series.length;) {
                data = series[i].data;
                totalDataLen += data.length;
            }
            
            return totalDataLen > 100 && this._zooming;
        }
    });


    //view
    VanChart.include({

        render:function(){

            this.vancharts.endLoading();

            var vanchart = this, renderer = this.renderer;

            var clipBounds = this.getPlotClipBounds();
            if(!this.plotClip){
                this.plotClip = renderer.createClip(clipBounds);
            }else{
                renderer.updateClip(this.plotClip, clipBounds);
            }

            function createGroup(groupName){
                if(!vanchart[groupName]){
                    vanchart[groupName] = renderer.group().addClass(groupName).add();

                    if(vanchart.isMap()){
                        vanchart[groupName].addClass('map-component');
                    }
                }
            }

            ['backGroup', 'clipSeriesGroup', 'seriesGroup', 'seriesTextRenderGroup', 'frontGroup']
                .forEach(createGroup);

            renderer.clip(vanchart.clipSeriesGroup, vanchart.plotClip);
            renderer.clip(vanchart.seriesTextRenderGroup, vanchart.plotClip);

            this._addDivClipGroup(clipBounds);

            // 
            // 
            if (this._isEmptyDataChart()) {
                this._showEmptyDataTip();
                window.console && console.log('done');
                return;
            } else {
                this.emptyDataGroup && this.emptyDataGroup.remove();
            }

            this._renderBackground();

            this.renderComponents();

            this.renderSeries();

        },

        _addDivClipGroup: function (clipBounds) {
            var vanchart = this;
            if (!vanchart.seriesTextDivGroup) {
                vanchart.seriesTextDivGroup = this.renderer.div().add();
            }
            // clip: rect(<top>, <right>, <bottom>, <left>);
            vanchart.seriesTextDivGroup.style({
                clip: 'rect(' + [
                    clipBounds.y,
                    clipBounds.x + clipBounds.width,
                    clipBounds.y + clipBounds.height,
                    clipBounds.x
                ].join('px ') + 'px)'
            });
        },

        _renderBackground:function(){
            var chartBounds = BaseUtils.makeBounds(0,0,this.width, this.height), plotBounds = this.bounds;

            var options = this.options, renderer = this.renderer;

            var chartConfig =  {
                backgroundColor:options.geo ? '' : options.backgroundColor,
                backgroundImage:options.geo ? '' : options.backgroundImage,
                borderColor:options.borderColor,
                borderWidth:options.geo ? 0 : options.borderWidth,
                borderRadius:options.borderRadius || 0,
                shadow:options.shadow
            };

            var plotConfig = {
                backgroundColor:options.plotBackgroundColor,
                backgroundImage:options.plotBackgroundImage,
                borderColor:options.plotBorderColor,
                borderWidth:options.plotBorderWidth,
                borderRadius:options.plotBorderRadius || 0,
                shadow:options.plotShadow
            };

            if (chartConfig.shadow) {
                chartBounds.width -= 5;
                chartBounds.height -= 5;
            }

            if(chartConfig.backgroundColor || chartConfig.backgroundImage || chartConfig.borderColor){
                this.chartBackgroundGroup = this.chartBackgroundGroup || renderer.group().addTo(this.backGroup);
            }else if(this.chartBackgroundGroup){
                this.chartBackgroundGroup.remove();
                this.chartBackgroundGroup = null;
            }

            if(plotConfig.backgroundColor || plotConfig.backgroundImage || plotConfig.borderColor){
                this.plotBackgroundGroup = this.plotBackgroundGroup || this.renderer.group().addTo(this.backGroup);
            }else if(this.plotBackgroundGroup){
                this.plotBackgroundGroup.remove();
                this.plotBackgroundGroup = null;
            }

            this._renderRectangleBackground(this.chartBackgroundGroup, chartConfig, chartBounds);
            this._renderRectangleBackground(this.plotBackgroundGroup, plotConfig, plotBounds);
        },

        renderComponents: function () {
            for(var c in this.components){
                this.components[c] && this.components[c].render();
            }
        },

        renderSeries:function(){

            this.getComponent(ComponentLibrary.TOOLTIP_COMPONENT).immediateHide();

            this.fire('animationStart');

            this._renderTrendLine();

        },

        /**
         * 
         * @return {Boolean} [description]
         */
        _isEmptyDataChart: function () {
            // 
            return this.series.length === 0 && this.options.emptyDataTip && this.options.emptyDataTip.enabled;
        },

         /** 
         * Chart-925: 
         * @private 
         */ 
        _showEmptyDataTip: function (){

            this._removeAll();

            this.emptyDataGroup && this.emptyDataGroup.remove();
 
            if(this.series.length){ 
                return; 
            } 
 
            var option = this.options, emptyDataTip = option.emptyDataTip;
            var PATTERN_GAP = 10, TEXT_GAP = 5;
 
            if(!emptyDataTip || !emptyDataTip.enabled) { 
                return; 
            } 
 
            var renderer = this.renderer, 
                plotBounds = {
                    width: this.width,
                    height: this.height
                } 
 
            // -120px * 125px 
            var patternPathArray = [ 
                { 
                    d: "M108.5,47.4l-7.7,57.2c-10.7,9.4-25.9,15-41.4,15c-14.1,0.1-27.7-4.8-38.5-13.8l11.8-86.5c0.7-5.3,5.6-9,11-8.3c0,0,0.1,0,0.1,0L85.5,17L108.5,47.4z", 
                    fill: "#fff" 
                }, 
                { 
                    d: "M108.5,47.4l-16.4-2c-5.6-0.8-9.4-5.9-8.6-11.4L85.7,17L108.5,47.4z", 
                    fill: "#F4F4F4" 
                }, 
                { 
                    d: "M6.2,29.7C1.6,31.5-0.7,36.6,1,41.2L2.1,44l20,52.8l10.5-77L8.7,28.8L6.2,29.7z", 
                    fill: "#979797" 
                }, 
                { 
                    d: "M71.4,14.5C69.7,9.9,64.6,7.6,60,9.3l-7.6,2.9l19.3,2.7L71.4,14.5z", 
                    fill: "#979797" 
                }, 
                { 
                    d: "M53,74.6c-1.2,3.4-1,7.2,0.6,10.4l2.9-1.4c-0.9-2.5-0.8-5.3,0.1-7.8c1.6-4.2,4.2-5.2,4.2-5.2l-2.2-2.9C58.7,67.6,55,69.1,53,74.6z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M91.4,79.2c0-13.2-10.7-23.9-24-23.9c-13.2,0-24,10.7-24,23.9c0,13.2,10.7,23.9,24,23.9c4.7,0,9.2-1.4,13.2-3.9l6.4,7.6l2.7-2.2l-6.3-7.5C88.4,92.5,91.3,86,91.4,79.2z M67.4,98c-10.4,0-18.9-8.4-18.9-18.8s8.5-18.8,18.9-18.8s18.9,8.4,18.9,18.8C86.3,89.6,77.9,98,67.4,98C67.4,98,67.4,98,67.4,98z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M105.3,118.4l-8.9-10.2l-0.6-0.7l-2-2.4c-0.8-1-2.3-1.1-3.3-0.2c0,0,0,0,0,0l-3.1,2.7c-1,0.8-1.1,2.3-0.2,3.3c0,0,0,0,0,0l0.9,1.1l0.7,0.8l10,11.4c0.8,1,2.3,1.1,3.3,0.2c0,0,0,0,0,0l3.1-2.7C106,120.8,106.1,119.4,105.3,118.4z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M59.9,0c-21,0-40.6,10.9-51.5,28.8l24.3-9.2v-0.1c0.8-5.4,5.8-9.2,11.2-8.4l8.4,1.2l7.6-2.9c4.6-1.7,9.7,0.6,11.5,5.1l0.1,0.4l13,1.8l0.8,0.1l23.1,30.6l-0.1,0.9l-7.4,55c-1.7,1.4-3.5,2.8-5.3,4.1l0.6,0.7c1.6-1.2,3.1-2.3,4.6-3.6l0,0C113.1,93.1,120.1,77,120,60.1c0.2-33-26.5-60-59.7-60.1C60.2,0,60,0,59.9,0z", 
                    fill: "#DDDDDD" 
                }, 
                { 
                    d: "M59.5,118.2c-14,0.1-27.5-4.6-38.4-13.4c0.1-0.4,0.1-0.7,0.2-1.3l0.9-6.6l-20-52.5C0.7,49.6,0,55,0,60.4c-0.2,17.5,7.5,34.2,20.9,45.4l0,0c10.8,9,24.4,13.8,38.4,13.7c10.1,0,20.1-2.4,29.2-6.8l-0.7-0.8C79,116,69.3,118.2,59.5,118.2z", 
                    fill: "#DDDDDD" 
                } 
            ]; 
            var patternWidth = 120, patternHeight = 125; 
 
            var tipWidth = patternWidth, tipHeight = patternHeight + PATTERN_GAP; 
            var emptyDataGroup = this.emptyDataGroup = renderer.group().addTo(this.seriesGroup); 
 
            emptyDataTip.content = emptyDataTip.content || []; 
 
            //  
            var contentArray = emptyDataTip.content.map( function (contentObj){ 
                var text = contentObj.text, style = BaseUtils.convertToREMUseDefault16PX(contentObj.style); 
                var textDim = BaseUtils.getTextDimension(text, style, false); 
                tipWidth = Math.max(tipWidth, textDim.width); 
                return { 
                    text: contentObj.text, 
                    style: BaseUtils.convertToREMUseDefault16PX(contentObj.style), 
                    width: textDim.width, 
                    height: textDim.height 
                } 
            }); 
            //  
            var patternGroup = renderer.group().attr("transform", "translate(" + ((tipWidth - patternWidth) / 2) +",0)").addTo(emptyDataGroup); 
            patternPathArray.forEach(function (pathData){ 
                var  path = renderer.path().addTo(patternGroup); 
                path.attr({ 
                    "d": pathData.d, 
                    "fill": pathData.fill 
                }) 
            }); 
            //  
            contentArray.forEach(function(contentObj, index, arr){ 
                var x = (tipWidth - contentObj.width) / 2, 
                    y = tipHeight; 
                tipHeight += contentObj.height + (index === arr.length - 1 ? 0 : TEXT_GAP); 
                var text = renderer.text().addTo(emptyDataGroup); 
                text 
                    .textContent(contentObj.text) 
                    .style(contentObj.style) 
                    .attr({ 
                        "dy": (0.85 * contentObj.height), 
                        "transform": "translate(" +x+","+y+")" 
                    }); 
            }); 
 
            var translateX = (plotBounds.width - tipWidth) / 2, 
                translateY = (plotBounds.height - tipHeight) / 2; 
 
            this.emptyDataGroup.attr("transform", "translate(" + translateX+","+ translateY +")"); 
        },

        /**
         * 
         * @return {[type]} [description]
         */
        _removeAll: function (){
            // 
            for(var c in this.components){
                if(c !== ComponentLibrary.TOOLTIP_COMPONENT) {
                    this.components[c] && this.components[c].remove();
                }
            }

            // LinkLine
            this.linkGroup && this.linkGroup.remove();
            this.linkGroup = null;

            // 
            this.chartBackgroundGroup && this.chartBackgroundGroup.remove();
            this.plotBackgroundGroup && this.plotBackgroundGroup.remove();
        },

        /**
         * (,,)
         * @param  {[type]} backgroundGroup [description]
         * @param  {[type]} option          [description]
         * @param  {[type]} bounds          [description]
         * @return {[type]}                 [description]
         */
        _renderRectangleBackground:function(backgroundGroup, option, bounds){

            if(!backgroundGroup){
                return;
            }

            var borderWidth = option.borderWidth || 0, renderer = this.renderer;
            var det = borderWidth / 2;
            var borderBounds = BaseUtils.rectSubPixelOpt(bounds.x + det, bounds.y + det, Math.max(bounds.width - borderWidth, 0), Math.max(bounds.height - borderWidth, 0), borderWidth);
            borderBounds.rx = borderBounds.ry = option.borderRadius;

            if(option.shadow){
                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds, 1);
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                width.forEach(function(w, i){
                    var key = 'shadowRect' + i;
                    backgroundGroup[key] = backgroundGroup[key] || renderer.rect().style({'fill':'none', 'stroke': 'black', 'stroke-width':width[i], 'stroke-opacity':opacity[i]}).addTo(backgroundGroup);

                    backgroundGroup[key].attr(shadowBounds).attr({'rx':option.borderRadius, 'ry':option.borderRadius,'transform':'translate(1, 1)'});
                });
            }

            if(option.backgroundColor && typeof option.backgroundColor == 'object'){

                //ie
                if(BaseUtils.isSupportSVG()){
                    var gradualOption = option.backgroundColor;
                    var attrs = {'x1':gradualOption.x1, 'y1':gradualOption.y1, 'x2':gradualOption.x2, 'y2':gradualOption.y2};
                    var stop1 = {'offset':'0%', 'stop-color':gradualOption.startColor};
                    var stop2 = {'offset':'100%', 'stop-color':gradualOption.endColor};

                    if(backgroundGroup.gradientFill){
                        renderer.updateColorGradient(backgroundGroup.gradientFill, attrs, [stop1,stop2]);
                    }else{
                        backgroundGroup.gradientFill = renderer.colorGradient(attrs, [stop1, stop2]);
                    }
                }else{
                    option.backgroundColor = option.backgroundColor.startColor;
                }
            }

            if(option.backgroundImage){
                backgroundGroup.backgroundImage = backgroundGroup.backgroundImage || renderer.image().addTo(backgroundGroup);
                backgroundGroup.backgroundImage.attr(bounds).attr('preserveAspectRatio', 'none').imageContent(option.backgroundImage);
            }

            if(option.backgroundColor || option.borderWidth){
                backgroundGroup.backgroundColor = backgroundGroup.backgroundColor || renderer.rect().addTo(backgroundGroup);
                backgroundGroup.backgroundColor.attr(borderBounds)
                    .style({'fill':option.backgroundColor ? (typeof option.backgroundColor == 'string' ? option.backgroundColor : "url(#" + BaseUtils.stamp(backgroundGroup.gradientFill) + ")") : 'none',
                        'stroke':option.borderColor, 'stroke-width':BaseUtils.pick(option.borderWidth, 0)});
            }
        },

        //
        filterRender: function () {
            for(var i = 0, len = this.series.length; i < len; i++){
                this.series[i].filterRender();
            }
        },

        cancelLegendHighlight:function(containerPoint){

            var legend = this.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            legend = legend || this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            if(legend){
                if(legend.highlighted && !BaseUtils.containsPoint(legend.bounds, containerPoint)){
                    legend.highlighted = false;
                    this.highlightTarget = null;
                    this._updateSeriesStyle();
                }
            }
        },

        makeLegendHighlight:function(target){
            this.highlightTarget = target;
            this._updateSeriesStyle();
        },

        _updateSeriesStyle:function(){
            this.series.forEach(function(ser){
                if(ser.isSupportLegendHighlight()){
                    if(ser.useCanvas()){
                        ser._canvasRender();
                    }else{
                        // 
                        ser.drawSeries && ser.drawSeries();
                        ser.getDataToDraw()
                            .filter(function (point) {return point.isVisible();})
                            .forEach(function(point) {ser._updatePointGraphicStyle(point);});
                    }
                }
            });
        },

        //,,
        reRenderSeries:function(){

            VanChartLayout.calculateSeries(this);

            VanChartLayout.calculateSeriesShapes(this);

            this.renderSeries();
        },

        _consoleDone:function () {

            var geo = this.options.geo;

            if(!geo || !geo.tileLayer){
                // phantomjs test
                window.console && console.log('done');
            }

        },

        removePointGraphics:function (p) {
            p && p.remove();
        },

        registerInteractiveTarget:function(data, elementWrapper){
            if(elementWrapper) {
                this._targets[BaseUtils.stamp(elementWrapper.node())] = data;
            }
            this.activeDataEvents(data);
        },

        activeDataEvents:function (data) {
            data._events = null;
            data.getEvents && data.on(data.getEvents(), data);
        },

        removeInteractiveTarget:function(data, elementWrapper){
            this._targets[BaseUtils.stamp(elementWrapper.node())] = null;
            data._events = null;
        },

        findInteractiveTarget:function(rawElement){
            return this._targets[BaseUtils.stamp(rawElement)];
        },

        resize:function(){

            var dom = this.wrapDom;
            this.width = BaseUtils.getDomWidth(dom);
            this.height = BaseUtils.getDomHeight(dom);

            // @CmenCHART-1130:initialize
            if(!this.width || !this.height) { return; }

            this.clipPool = {};
            this.axisSize = {
                'left':0, 'right':0, 'bottom':0, 'top':0
            };

            this.renderer.resize();

            if(this.isMap()){
                this.mapRenderer.resize();
                this._onResize();
                this.components.geo.resize();
            }

            // BI-6380
            var multiPie = this.seriesOfType(Constants.MULTIPIE_CHART)[0];
            if (multiPie) {
                multiPie.chartInfo.radius = null;
            }

            this.layoutComponentsAndCharts();
        },

        remove:function(){
            // CHART-996
            // labelrenderremovebug
            // 
            this._animationStarted = false;

            this.force && this.force.endTick(null).stop();
            this.force = null;
            this.clearAllEffects();
            this.clearTimeQueue();
            this.renderer && this.renderer.remove();
            this.handler && this.handler.destroy();

            this.mainRenderer && this.mainRenderer.remove();
            this.animationRenderer && this.animationRenderer.remove();
            this.mainRenderer = null;
            this.animationRenderer = null;
            if (this.largeSeries) {
                Object.keys(this.largeSeries).map(function (key) {
                    if (this.largeSeries[key]._canvas) {
                        this.largeSeries[key]._canvas.remove();
                    }
                    this.largeSeries[key] = null;
                }, this);
            }
            this.largeSeries = null;

            this.renderer = this.plotClip = this._leaflet = this.handler
                = this.chartBackgroundGroup = this.trendLineGroup = this.seriesGroup
                = this.clipSeriesGroup = this.seriesTextRenderGroup = this.seriesTextDivGroup =null;
        }

    });

    require('./VanChartLibrary').register(Constants.VANCHART, VanChart);

    return VanChart;
});
/**
 * Created by Yuqian on 2017/7/12.
 */

define('vector/canvasShape/AbstractShape',['require','../../utils/Class'],function (require) {

    var Class = require('../../utils/Class');

    return Class.extend({

        initialize: function (renderer) {
            this.renderer = renderer;
            this.ctx = renderer.ctx;
            this.cut = null;

            this._initialize(renderer);
        },

        setStyle: function (style) {
            for (var prop in this.style) {
                if (style.hasOwnProperty(prop)) {
                    this.style[prop] = style[prop];
                }
            }
            return this;
        },

        drawStyle: function () {
            var s = this.style;

            this.renderer.lineWidth(s.lineWidth);
            this.renderer.strokeStyle(s.strokeStyle);
            this.renderer.fillStyle(s.fillStyle);

            this.renderer.beginNewPath();

            return this
        },

        contain: function () {
        },

        animate: function () {
            if (!this.cut) {
                this.cut = this.renderer.animation.animate(this.style);
            }
            return this;
        },

        // mixin ?
        delay: function (time) {
            this.cut.delay(time);
            return this;
        },
        duration: function (time) {
            this.cut.duration(time);
            return this;
        },
        tween: function (key, v) {
            this.cut.tween(key, v);
            return this;
        },
        end: function (f) {
            this.cut.end(f);
            return this;
        },
        stop: function () {
            this.cut.stop();
            return this;
        },
        ease: function (easing) {
            this.cut.ease(easing);
            return this;
        },
        remove: function () {
            this.cut && this.cut.stop();
            this.needToRemove = true;
        }

    });

});

define('vector/canvasShape/library',['require'],function (require) {

    var shapes = {};

    return {
        register: function (name, Shape) {
            shapes[name] = Shape;
        },
        shapes: shapes
    }
});
/**
 * make icon shapes as images
 */
define('vector/canvasShape/icons',['require','./library','../../Constants'],function (require) {
    var library = require('./library');
    var Constants = require('../../Constants');

    var Attrs = ['lineWidth', 'strokeStyle', 'fillStyle'];

    var _icons = {};

    _icons[Constants.LOCATION] = 'iconLocation';

    function getShape (name) {
        return library.shapes[_icons[name]]
    }

    function render (name, fakeRenderer, s) {
        var Shape = getShape(name);
        if (!Shape) {
            return
        }

        var shape = new Shape(fakeRenderer);

        shape.setStyle({
            x: 0,
            y: 0,
            size: s.width,
            fillStyle: s.color
        });

        var ctx = fakeRenderer.ctx;

        var i = -1, k;
        while (k = Attrs[++i]) {
            ctx[k] = shape.style[k];
        }

        shape.draw();

        ctx.fill();
        ctx.stroke();

        fakeRenderer.shape = shape;
        fakeRenderer.ready = true;
    }

    return {
        render: render,
        all: _icons
    }

});
/**
 * Created by Yuqian on 2016/12/22.
 */

define('vector/canvasShape/Image',['require','./AbstractShape','./library','./icons'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');
    var icons = require('./icons');

    var ImageCollection = {};

    var I = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                url: null,
                x: null, // image center x
                y: null, // image center y
                width: 0,
                height: 0,
                radian: 0, // rotation center is IMAGE's center
                color: '' // for icon
            };

        },

        _load: function () {
            var s = this.style;
            var url = s.url;
            var key = url + s.color;
            if (!ImageCollection[key]) {

                if (icons.all[url]) {
                    ImageCollection[key] = this._loadIcon(url);
                } else {
                    ImageCollection[key] = this._loadImage(url);
                }

            }
            this._img = ImageCollection[key]
        },

        _loadImage: function (url) {

            var self = this;

            var img = {
                el: null,
                ready: false
            };
            img.el = new Image();
            img.el.crossOrigin = "Anonymous";
            img.el.onload = function () {
                img.ready = true;
                self.renderer.flush();
            };
            img.el.src = url;

            return img
        },

        _loadIcon: function (url) {
            var s = this.style;
            var width = s.width;
            var height = s.height;
            var dpr = this.renderer.dpr;
            var canvas = document.createElement(window.VAN_CANVAS);

            // document.body.append(canvas);
            // canvas.style.position = 'absolute';
            // canvas.style.right = '100px';
            // canvas.style.top = '100px';
            // canvas.style.background = '#888';
            // canvas.style.border = '1px solid #000';

            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            var ctx = canvas.getContext("2d");
            ctx.scale(dpr, dpr);

            var fakeRenderer = {
                el: canvas,
                ctx: ctx,
                ready: false
            };

            icons.render(url, fakeRenderer, s);

            return fakeRenderer

        },

        setStyle: function (style) {
            for (var prop in this.style) {
                if (style.hasOwnProperty(prop)) {
                    this.style[prop] = style[prop];
                }
            }
            !this._img && this._load();
            return this;
        },

        drawStyle: function () {
            return this;
        },

        draw: function () {
            var s = this.style;
            var x = s.x,
                y = s.y,
                width = s.width,
                height = s.height,
                radian = s.radian;
            if (this._img
                && this._img.ready
                && x != null
                && y != null) {

                if (radian) {
                    this.ctx.save();

                    this.ctx.translate(x, y);
                    this.ctx.rotate(radian);
                    this.ctx.drawImage(this._img.el, -width / 2, -height / 2, width, height);

                    this.ctx.restore();
                } else {
                    this.ctx.drawImage(this._img.el, x - width / 2, y - height / 2, width, height);
                }

            }

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x + s.width / 2;
            var dy = pos.y - s.y + s.height / 2;
            // todo, rotate
            return 0 < dx && dx < s.width && 0 < dy && dy < s.height
        }
    });

    library.register('image', I);

    return I
});
/**
 * Created by Yuqian on 2016/12/7.
 */

define('vector/canvasShape/Arc',['require','./AbstractShape','./library','../../utils/BaseUtils','../../dom/Browser'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');
    var BaseUtils = require('../../utils/BaseUtils');
    var isTouch = require('../../dom/Browser').touch;

    var MIN_HOVER_LINE_WIDTH = isTouch ? 10 : 2;

    var DOUBLE_PI = Math.PI * 2;
    var max = Math.max;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var sqrt = Math.sqrt;
    var normalRadian = BaseUtils.normalRadian;

    var Arc = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                r: null,
                startAngle: null,
                endAngle: null,
                lineWidth: null,
                strokeStyle: null, // color
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            if (!s.lineWidth) {
                return this;
            }

            ctx.moveTo(
                s.x + s.r * Math.cos(s.startAngle),
                s.y + s.r * Math.sin(s.startAngle)
            );
            ctx.arc(s.x, s.y, s.r, s.startAngle, s.endAngle);
            return this;
        },

        contain: function (pos) {
            var x = pos.x;
            var y = pos.y;
            var s = this.style;
            var width = max(s.lineWidth, MIN_HOVER_LINE_WIDTH);
            var dx = x - s.x;
            var dy = y - s.y;
            var delta = abs(sqrt(dx * dx + dy * dy) - s.r);
            if (delta > width) {
                return false;
            }
            var th = normalRadian(atan2(dy, dx));
            return (th + DOUBLE_PI - s.startAngle) % DOUBLE_PI <= s.endAngle - s.startAngle
        }

    });

    library.register('arc', Arc);

    return Arc

});
/**
 * Created by Yuqian on 2016/12/8.
 */

define('vector/canvasShape/Circle',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var DOUBLE_PI = 2 * Math.PI;

    var Circle = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                r: null,
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            ctx.moveTo(s.r + s.x, s.y);
            ctx.arc(s.x, s.y, s.r, 0, DOUBLE_PI);
            return this;
        },

        contain: function (pos) {
            var x = pos.x;
            var y = pos.y;
            var s = this.style;
            var dx = x - s.x;
            var dy = y - s.y;
            return s.r > Math.sqrt(dx * dx + dy * dy)
        }
    });

    library.register('circle', Circle);

    return Circle;

});

define('vector/canvasShape/IconLocation',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    function t (num) {
        return +(num.toFixed(3));
    }

    var IconLocation = AbstractShape.extend({
        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null,
                fillStyle: null, // color
                lineWidth: 1,
                strokeStyle: '#ffffff'
            };
        },

        setStyle: function (style) {
            AbstractShape.prototype.setStyle.apply(this, arguments);
            if (style.size) {
                var f = style.size / 40;

                this.R = 14.5 * f;
                this.r = 5.5 * f;
                this.ix = 20 * f;
                this.iy = this.R + 1;
                this.l = style.size - this.iy;
                this.a = Math.acos(this.R / this.l);
                this.dx = t(this.R * Math.sin(this.a));
                this.dy = t(this.R * Math.cos(this.a));
            }
            return this;
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var x = s.x, y = s.y;
            var R = this.R, r = this.r,
                ix = this.ix, iy = this.iy,
                l = this.l, a = this.a,
                dx = this.dx, dy = this.dy;

            var _x = x + ix, _y = y + iy;

            ctx.moveTo(_x, _y + l);
            ctx.lineTo(_x - dx, _y + dy);

            ctx.arc(_x, _y, R, Math.PI / 2 + a, Math.PI / 2 - a);

            ctx.lineTo(_x, _y + l);

            ctx.moveTo(_x + r, _y);
            ctx.arc(_x, _y, r, Math.PI * 2, 0, true);

            this.renderer.dirty = true;

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x + s.size / 2;
            var dy = pos.y - s.y + s.size / 2;
            return 0 < dx && dx < s.size && 0 < dy && dy < s.size
        }
    });

    library.register('iconLocation', IconLocation);

});
define('vector/canvasShape/Rect',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');


    var Rect = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                width: null,
                height: null,
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            ctx.rect(s.x, s.y, s.width, s.height);
            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var dx = pos.x - s.x;
            var dy = pos.y - s.y;
            return 0 < dx && dx < s.width && 0 < dy && dy < s.height
        }
    });

    library.register('rect', Rect);

    return Rect;

});

define('vector/canvasShape/Diamond',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var abs = Math.abs;

    var Diamond = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null, // marker's R
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var R = s.size * Math.SQRT2;
            var x = s.x, y = s.y;
            ctx.moveTo(x - R, y);
            ctx.lineTo(x, y - R);
            ctx.lineTo(x + R, y);
            ctx.lineTo(x, y + R);
            ctx.lineTo(x - R, y);

            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var x = s.x, y = s.y;
            var w = (s.size + s.lineWidth / 2) * Math.SQRT2,  h = w;
            var px = pos.x - x, py = pos.y - y;
            return abs(px * h) + abs(py * w) < h * w;
        }
    });

    library.register('diamond', Diamond);

    return Diamond;

});

define('vector/canvasShape/Triangle',['require','./AbstractShape','./library'],function (require) {

    var AbstractShape  = require('./AbstractShape');
    var library = require('./library');

    var SQRT3 = Math.sqrt(3);

    function sameSide (a, b, c, p) {

    }

    var Triangle = AbstractShape.extend({

        _initialize: function () {

            this.style = {
                x: null,
                y: null,
                size: null, // marker's R
                lineWidth: null,
                strokeStyle: null,
                fillStyle: null
            };
        },

        draw: function () {
            var ctx = this.ctx;
            var s = this.style;

            var R = s.size, x = s.x, y = s.y;

            var d = R / SQRT3;

            ctx.moveTo(x - R, y + d);
            ctx.lineTo(x, y - (2 * d));
            ctx.lineTo(x + R, y + d);
            ctx.lineTo(x - R, y + d);
            return this;
        },

        contain: function (pos) {
            var s = this.style;
            var R = s.size + s.lineWidth / 2, x = s.x, y = s.y;
            var d = R / SQRT3;
            var ax = x - R, ay = y + d,
                bx = x + R, by = y + d,
                cx = x, cy = y - (2 * d);
            var px = pos.x, py = pos.y;

            var v0 = [cx - ax, cy - ay];
            var v1 = [bx - ax, by - ay];
            var v2 = [px - ax, py - ay];

            var dot00 = (v0[0] * v0[0]) + (v0[1] * v0[1]);
            var dot01 = (v0[0] * v1[0]) + (v0[1] * v1[1]);
            var dot02 = (v0[0] * v2[0]) + (v0[1] * v2[1]);
            var dot11 = (v1[0] * v1[0]) + (v1[1] * v1[1]);
            var dot12 = (v1[0] * v2[0]) + (v1[1] * v2[1]);

            var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);

            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

            return ((u >= 0) && (v >= 0) && (u + v < 1));
        }

    });

    library.register('triangle', Triangle);

    return Triangle;

});

define('vector/canvasShape/types',['require','./Image','./Arc','./Circle','./IconLocation','./Rect','./Diamond','./Triangle'],function (require) {

    require('./Image');
    require('./Arc');
    require('./Circle');
    require('./IconLocation');
    require('./Rect');
    require('./Diamond');
    require('./Triangle');

});
/**
 * Created by Yuqian on 2016/12/7.
 */

define('vector/Cut',['require','../utils/BezierEasing'],function (require) {

    var BezierEasing = require('../utils/BezierEasing');

    var interpolateNumber = function (a, b) {
        return function (pct) {
            return +a + (+b - +a) * pct;
        }
    };

    // todo, remove or revise
    var defaultTweenFun = function (target, key, value) {
        var interpolate = interpolateNumber(target[key], value);
        return function (pct) {
            target[key] = interpolate(pct);
        }
    };

    var Cut = function (targets) {
        if (!targets) {
            throw 'animation "targets" empty';
        } else if (targets.length == null) {
            this.targets = [targets];
        } else {
            this.targets = targets;
        }

        this._needsRemove = false;
        this._lastSectionTime = null;

        // a section's time length is a duration
        this._sections = [];

        this.onend = null;
    };

    Cut.prototype = {

        step: function (time) {

            if (!this._lastSectionTime) {
                this._lastSectionTime = time;
            }

            var t = time - this._lastSectionTime;
            var targets = this.targets;

            var section = this._sections[0];

            var pct = Math.min(t / section.time, 1);

            if (! pct > 0) {
                return;
            }

            if (section.easing) {
                pct = section.easing(pct);
            }

            var tweens = section.tweens;
            var len = targets.length;
            for (var i = 0; i < len; i++) {
                for (var k in tweens) {
                    if (!tweens.hasOwnProperty(k)) {
                        continue;
                    }
                    tweens[k][i](pct);
                }
            }

            if (pct === 1) {
                this._lastSectionTime = time;
                this._sections.shift();
                // one loop only
                if (this._sections.length === 0) {
                    this._needsRemove = true;
                    return 'end';
                }
            }
        },

        _fillTweens: function (f) {
            return this.targets.map(function (target, i) {
                return f(target, i);
            });
        },
        // TODO
        // empty loop now,
        // pause the animation
        delay: function (time) {
            this._sections.push({
                time: time,
                tweens: {}
            });
            return this;
        },
        // set section time length
        duration: function (time) {
            this._sections.push({
                time: time,
                tweens : {}
            });
            return this;
        },

        tween: function (key, f) {
            var len = this._sections.length;

            var tweens = this._sections[len - 1].tweens;

            if (typeof f === 'function') {
                tweens[key] = this._fillTweens(f);
            }
            // todo, remove or revise
            // f is plain value
            else {
                tweens[key] = this._fillTweens(function (target, i) {
                    return defaultTweenFun(target, key, f)
                })
            }

            return this;
        },

        attrTween: function (attrKey, f) {
            this.tween('attr' + attrKey, function (target, i) {
                // FIXME, it's not the init value
                var a = +target.getAttribute(attrKey);
                var interpolate = f(target, i, a);

                return function (pct) {
                    target.setAttribute(attrKey, interpolate(pct))
                };
            });
            return this;
        },

        attr: function (attrKey, v) {
            this.attrTween(attrKey, function (target, i, a) {
                if (typeof v === 'function') {
                    return interpolateNumber(a, v.call(null, target, i, a));
                }
                return interpolateNumber(a, v);
            });
            return this;
        },

        // callback when animation finished
        end: function (f) {
            this.onend = f;
            return this;
        },
        stop: function () {
            this._needsRemove = true;
            return this;
        },
        ease: function (easing) {
            var len = this._sections.length;

            this._sections[len - 1].easing =
                typeof easing == 'string' ? BezierEasing.css[easing] : easing;
            return this;
        }
    };

    return Cut;
});
/**
 * Created by Yuqian on 2016/12/5.
 */

define('vector/Animation',['require','./Cut'],function (require) {
    var Cut = require('./Cut');

    var requestAnimationFrame =
        (window.requestAnimationFrame
        || window.msRequestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame)
        || function (func) {
            setTimeout(func, 16);
        };

    // targets {Array}
    var Animation = function () {

        this._initTime = null;
        this._running = false;

        this._cuts = [];
        this._callback = [];

        this.onframe = null;
        this.onend = null;
    };

    Animation.prototype = {
        _update: function () {
            var time = new Date().getTime();// now
            var cuts = this._cuts;
            var len = cuts.length;

            if (!cuts.length) {
                return false;
            }

            // think: remove before/after step
            for (var i = 0; i < len;) {
                if (cuts[i]._needsRemove) {
                    cuts[i] = cuts[len - 1];
                    cuts.pop();
                    len--;
                }
                else {
                    i++;
                }
            }

            for (var i = 0; i < len; i++) {
                var e = cuts[i].step(time);
                if (e && cuts[i]['on' + e]) {
                    this._callback.push(cuts[i]['on' + e]);
                }
            }

            this.onframe && this.onframe();

            var i = -1, cb;
            while(cb = this._callback[++i]) {
                cb();
            }

            this._callback = [];

            return true;
        },

        _startLoop: function() {
            var self = this;

            function loop() {
                if (self._running) {

                    self._running = self._update();
                    requestAnimationFrame(loop);
                }
            }

            requestAnimationFrame(loop);

        },
        frame: function (f) {
            this.onframe = f;
            return this;
        },
        start: function () {
            if (!this._running) {
                this._running = true;
                this._startLoop();
            }
            return this;
        },
        stop: function () {
            this._running = false;
            return this;
        },
        clear: function () {
            this._running = false;
            this._cuts = [];
            return this;
        },
        animate: function (targets) {
            var cut = new Cut(targets);
            cut.animation = this;
            this._cuts.push(cut);

            this.start();

            return cut;
        }
    };

    return Animation

});

/**
 * Created by eason on 16/6/1.
 */

define('vector/CanvasRenderer',['require','./canvasShape/types','./canvasShape/library','../utils/BaseUtils','./Renderer','../Constants','./Animation','./ElementWrapper'],function(require){

    require('./canvasShape/types');

    var library = require('./canvasShape/library');

    var BaseUtils = require('../utils/BaseUtils');
    var Renderer = require('./Renderer');
    var Constants = require('../Constants');
    var Animation = require('./Animation');
    var ElementWrapper = require('./ElementWrapper');

    var strokeStatus = ['lineWidth', 'strokeStyle'];

    var count = 0;

    var FILTER_SIZE = 2;

    var BATCH = 4000;

    var BATCH_TIME = 50; // ms

    var ARRAY_CONSTRUCTOR = window['Uint8Array'] || window['Array'];

    var Canvas = Renderer.extend({

        _initContainer:function(){
            var dom = this.dom;
            var vanchart = this.vanchart;
            var config = this.config;

            var plotBounds = config || vanchart.bounds;
            var dpr = config && config.dpr || 1;

            this._container = new ElementWrapper(this._createCanvas(dom, plotBounds, dpr), this);
            this.ctx = this._container.node().getContext("2d");
            this.ctx.scale(dpr, dpr);

            this.elements = [];
            this.ctx.lineCap = "round";

            // todo,
            this.resetFilter();

            this.animation = new Animation().frame(this.flush.bind(this));
        },

        marker: function (name, s) {
            switch (name) {
                case Constants.LOCATION:
                    return this.iconLocation({
                        x: s.x,
                        y: s.y,
                        size: s.radius * 2,
                        fillStyle: s.color
                    });
                case Constants.SQUARE_HOLLOW:
                    return this.rect({
                        x: s.x - s.radius,
                        y: s.y - s.radius,
                        width : s.radius * 2,
                        height: s.radius * 2,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.SQUARE:
                    return this.rect({
                        x: s.x - s.radius,
                        y: s.y - s.radius,
                        width : s.radius * 2,
                        height: s.radius * 2,
                        fillStyle: s.color
                    });
                case Constants.DIAMOND_HOLLOW:
                    return this.diamond({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.DIAMOND:
                    return this.diamond({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: s.color
                    });
                case Constants.TRIANGLE_HOLLOW:
                    return this.triangle({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                case Constants.TRIANGLE:
                    return this.triangle({
                        x: s.x,
                        y: s.y,
                        size: s.radius,
                        fillStyle: s.color
                    });
                case Constants.CIRCLE_HOLLOW:
                    return this.circle({
                        x: s.x,
                        y: s.y,
                        r: s.radius,
                        fillStyle: null,
                        lineWidth: 2,
                        strokeStyle: s.color
                    });
                default:
                case Constants.CIRCLE:
                    return this.circle({
                        x: s.x,
                        y: s.y,
                        r: s.radius,
                        fillStyle: s.color
                    });
            }
        },

        _create: function (Shape, style) {
            var el = new Shape(this);
            // el.point = style; // tmp for hover event
            el.rawElement = el; // tmp for hover event
            this.elements.push(el);
            style && el.setStyle(style);
            return el;
        },

        _createCanvas:function(dom, plotBounds, dpr){

            var canvas = document.createElement(window.VAN_CANVAS);
            var left = this.left = plotBounds.x,
                top = this.top = plotBounds.y,
                width = this.width = plotBounds.width,
                height = this.height = plotBounds.height;
            this.dpr = dpr;

            canvas.style.position = 'absolute';
            canvas.style.left = left + 'px';
            canvas.style.top = top + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width * dpr;
            canvas.height = height * dpr;

            canvas.onselectstart = function(){return false};
            canvas.style['-webkit-user-select'] = 'none';
            canvas.style['user-select'] = 'none';
            canvas.style['pointer-events'] = 'none';
            canvas.style['-webkit-touch-callout'] = 'none';
            canvas.style['transform'] = 'translateZ(0)';

            dom.appendChild(canvas);

            //excanvas
            window.VanCanvasManager && VanCanvasManager.initElement(canvas);

            return canvas;
        },

        shouldFilter: function (x, y) {
            if (x < 0 || this.width < x ||
                y < 0 || this.height < y) {
                ++count;
                return true
            }
            x = x / FILTER_SIZE | 0;
            y = y / FILTER_SIZE | 0;
            var pos = y * this.width / FILTER_SIZE + x;
            if (this._cache[pos] ) {
                ++count;
                return true
            }
            this._cache[pos] = 1;
            return false
        },

        resetFilter: function () {
            // console.log('filtered:', count);
            count = 0;
            this._cache = new ARRAY_CONSTRUCTOR(Math.floor(this.width / FILTER_SIZE * this.height / FILTER_SIZE));  // IEArray
        },

        flush: function () {

            BaseUtils.cancelAnimFrame(this._frame);
            this.clearAll();

            var elements = this.elements;
            var len = elements.length;

            var exists = [];
            for (var i = 0; i < len; i++) {
                if (!elements[i].needToRemove) {
                    exists.push(elements[i]);
                    // elements[i].drawStyle().draw();
                }
            }
            this.elements = exists;
            // console.log('to draw:', exists.length);

            this.flushIdx = 0;

            this._adaptFlush();
        },

        _nextBatch: function () {
            if (this.flushIdx < this.elements.length) {
                this._frame = BaseUtils.requestAnimFrame(this._adaptFlush, this);
            }
        },

        _flush: function () {
            // console.time('flush');

            this.ctx.beginPath();

            var elements = this.elements;
            var len = elements.length;

            var i = this.flushIdx;
            var to = Math.min(this.flushIdx + BATCH, len);

            for (; i < to; i++) {
                elements[i].drawStyle().draw();
            }

            this._fillStyle && this.ctx.fill();
            this._strokeStyle && this.ctx.stroke();

            this.flushIdx = i;
            this._nextBatch();
            // console.timeEnd('flush');
        },

        _adaptFlush: function () {
            // console.time('flush');

            this._time = +new Date();

            this.ctx.beginPath();

            var elements = this.elements;
            var len = elements.length;

            var i = this.flushIdx - 1;

            while (++i < len) {
                elements[i].drawStyle().draw();
                if (i && !(i % 500)) {
                    var t = +new Date();
                    if (t - this._time > BATCH_TIME) {
                        break;
                    }
                }
            }

            this._fillStyle && this.ctx.fill();
            this._strokeStyle && this.ctx.stroke();
            this.flushIdx = i;
            this._nextBatch();
            // console.timeEnd('flush');

        },

        clearAll:function(){
            this.ctx.clearRect(0, 0, this.width, this.height);
        },

        beginNewPath: function () {
            if (this.needStroke || this.needFill) {
                this._fillStyle && this.ctx.fill();
                this._strokeStyle && this.ctx.stroke();
                this.ctx.beginPath();

                this.ctx.lineWidth = this._lineWidth;
                this.ctx.strokeStyle = this._strokeStyle;
                this.ctx.fillStyle = this._fillStyle;

                this.needStroke = this.needFill = false;
            }
        },

        lineWidth: function (lineWidth) {
            // lineWidth: Zero, negative, Infinity and NaN values are ignored.
            if (lineWidth && lineWidth !== this._lineWidth) {
                this._lineWidth = lineWidth;
                this.needStroke = true;
            }
        },

        strokeStyle: function (strokeStyle) {
            if (strokeStyle !== this._strokeStyle) {
                this._strokeStyle = strokeStyle;
                this.needStroke = true;
            }
        },

        fillStyle: function (fillStyle) {
            if (fillStyle !== this._fillStyle) {
                this._fillStyle = fillStyle;
                this.needFill = true;
            }
        },

        remove: function () {
            this.animation.clear();
            this.ctx = null;
            this._container.remove();
        },

        addBubbleSeries:function(series){
            var ctx = this.ctx;
            ctx.save();

            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];

                if(point.visible && !point.isNull){

                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = this.getPointOpacity(point);

                    ctx.beginPath();
                    ctx.arc(point.posX, point.posY, point.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            ctx.restore();
        },

        getPointOpacity:function(point){
            var series = point.series, target = series.vanchart.highlightTarget;
            if(target){
                var key = series.name;
                return (key == target || point._rangeItem == target) ? 1 : 0.3;
            }
            return point.opacity;
        },

        addScatterSeries:function(series){
            var ctx = this.ctx;
            ctx.save();
            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];
                if(point.visible && !point.isNull){
                    var marker = point.options.marker, markerType = marker.symbol;
                    var radius = isNaN(marker.radius) ? 4.5 : marker.radius;
                    var color = marker.fillColor || point.color;

                    ctx.translate(point.posX, point.posY);
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = this.getPointOpacity(point);

                    this._drawMarker(ctx, markerType, radius);

                    ctx.translate(-point.posX, -point.posY);
                }
            }
            ctx.restore();
        },

        addSeries:function(series){
            if(series.visible){
                series.type == Constants.SCATTER_CHART ?
                    this.addScatterSeries(series) : this.addBubbleSeries(series);
            }

        },

        _drawMarker:function(ctx, markerType, R){

            if(markerType.indexOf(Constants.CIRCLE) != -1){

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }else if(markerType.indexOf(Constants.SQUARE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, -R);
                ctx.lineTo(R, -R);
                ctx.lineTo(R, R);
                ctx.lineTo(-R, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.DIAMOND) != -1){

                R = R * 2 / Math.sqrt(2);
                ctx.beginPath();
                ctx.moveTo(-R, 0);
                ctx.lineTo(0, -R);
                ctx.lineTo(R, 0);
                ctx.lineTo(0, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.TRIANGLE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, R/Math.sqrt(3));
                ctx.lineTo(0, -(2 * Math.sqrt(3) / 3) * R);
                ctx.lineTo(R, R/Math.sqrt(3));
                ctx.closePath();

            }else{
                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);
            }
            if(markerType.indexOf('hollow') == -1){
                //
                ctx.fill();
            }else{
                ctx.fillStyle = 'white';
                ctx.lineWidth = 2;

                ctx.fill();
                ctx.stroke();
            }
        }
    });

    Canvas.addShape = function (name, Shape) {
        Canvas.prototype[name] = function (style) {
            return this._create(Shape, style);
        }
    };

    for (var name in library.shapes) {
        if (library.shapes.hasOwnProperty(name)) {
            Canvas.addShape(name, library.shapes[name]);
        }
    }

    return Canvas;
});

define('chart/map/LineMapLayer',['require','../../utils/BaseUtils','../../dom/DomUtils','../../utils/ColorUtils','../../Constants','../../vector/Layer','../../dom/Browser'],function (require) {

    var BaseUtils = require('../../utils/BaseUtils');
    var DomUtils = require('../../dom/DomUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var LINE_MAP = require('../../Constants').LINE_MAP;
    var Layer = require('../../vector/Layer');
    var Browser = require('../../dom/Browser');

    var SQRT2 = Math.SQRT2;

    var isSupportSVG = BaseUtils.isSupportSVG();

    var INIT_TIME = 800;
    var INIT_EASE = 'ease-in-out-quad';

function lineMap(mainRenderer, animationRenderer, leafletMap) {

    var _data = [];

    function data (data) {
        _data = data;
        return this;
    }

    function clear () {
        _data = [];
        return this;
    }

    function redraw(highlightTarget) {
        draw(true, highlightTarget);
    }

    function draw (redraw, highlightTarget) {
        var len = _data.length;

        if (len && _data[0] && _data[0].series.options.large) {
            _data[0].refreshPointColor();
            var seriesColor = ColorUtils.mixColorWithAlpha(_data[0].color, _data[0].opacity);
        }

        _data.map(function (p) {
            var series = p.series;
            var large = series.options.large;
            var visible = p.visible && series.visible;
            var staged = p.graphic;
            var options = p.options;

            var fLng = options.from.lnglat[0], fLat = options.from.lnglat[1];
            var tLng = options.to.lnglat[0], tLat = options.to.lnglat[1];

            if (fLng === tLng && fLat === tLat) {
                return;
            }

            var from = leafletMap.latLngToContainerPoint([fLat, fLng]);
            var to = leafletMap.latLngToContainerPoint([tLat, tLng]);

            p.ax = from.x;
            p.ay = from.y;
            p.bx = to.x;
            p.by = to.y;
            p.curveness = options.curveness;
            p.curveness === 0 && (p.curveness = 0.01);

            if (visible) {
                if (large) {
                    mainRenderer.ctx.globalCompositeOperation = 'lighter';
                    p._color = seriesColor;
                } else {
                    var opacity = p.opacity;
                    if (highlightTarget) {
                        opacity *= (p.series.name == highlightTarget || p._rangeItem == highlightTarget) ? 1 : 0.3;
                    }
                    p._color = ColorUtils.mixColorWithAlpha(p.color, opacity);
                }
            }

            // enter/update/exit process
            if (visible && !staged) {
                var arc, ani;

                // enter
                p.graphic = mainRenderer.arc();
                p.graphic.point = p;

                arc = mapShapeStyle(p.graphic, p);

                if (isSupportSVG && !redraw && !large && series.options.animation && p.options.lineWidth) {
                    p.graphic.style['endAngle'] = arc[3];

                    ani = p.graphic.animate()
                        .duration(INIT_TIME)
                        .ease(INIT_EASE)
                        .tween('endAngle', arc[4]);
                }

                if (isSupportSVG && !large && visible && p.options.effect && p.options.effect.enabled) {
                    var indexInSeries = series.points.indexOf(p);
                    if (ani) {
                        ani.end(singleEffect.bind(this, p, len, indexInSeries));
                    } else {
                        singleEffect(p, len, indexInSeries);
                    }
                }

            } else if (visible && staged) {

                //update
                mapShapeStyle(p.graphic, p);

                // effect depends on graphic
                // so update graphic = update effect

            } else if (!visible && staged) {

                // exit
                p.graphic.needToRemove = true;
                p.graphic = null;

                removeEffect(p);
            }

        });

    }

    function removeEffect(p) {
        // stop effect animation
        if (p._effect) {
            p._effect.stop();
            p._effect = null;
        }

        // After effect stopped, those last frame dots are left.
        // So remove them manually.
        // Ques:
        // Can those dots be removed automatically?
        if (p._symbol) {
            p._symbol.map(function (dot) {
                dot.needToRemove = true;
            });
            p._symbol = null;
        }
    }

    // animation handle plain value now
    // so make an ugly helper...
    function mapShapeStyle(graphic, p) {
        var arc = BaseUtils.computeArc(p.ax, p.ay, p.bx, p.by, p.curveness);
        graphic.setStyle({
            x: arc[0],
            y: arc[1],
            r: arc[2],
            startAngle: arc[3],
            endAngle: arc[4],
            lineWidth: p.options.lineWidth,
            strokeStyle: p._color
        });
        return arc;
    }

    function stop () {
        animationRenderer.clearAll();
    }

    function singleEffect(p, len, i) {
        if (!p.graphic) {
            return
        }
        var period = p.options.effect.period || 2000;
        p._effect = animationRenderer.animation
            .animate(p.graphic.style)
            .delay(period / 5 * i / len) //
            .duration(period)
            .tween('track', function (target) {
                return drawEffect(target, p)
            })
            .end(singleEffect.bind(this, p, len, i));
    }

    function drawEffect (g, p) {
        var begin = g.startAngle;
        var end = g.endAngle;
        var length = (end - begin) / 3;
        var distance = end - begin + length;
        var options = p.options.effect;

        if (options.symbol) {
            var url = options.symbol;
            var width = options.width;
            var height = options.height;
            var dpr = window.devicePixelRatio || 1;

            if (!p._symbol) {
                p._symbol = [];
                p._symbol[0] = animationRenderer.image({
                    url: url,
                    width: width,
                    height: height
                });
            }

            return function (t) {
                var style = drawSymbol(distance * t, g.x, g.y, g.r, g.startAngle, g.endAngle, length, url, width, height, dpr);
                p._symbol[0].setStyle(style || {x: null});
            }
        }

        var d = 1.4; // px
        var maxR = 1.5; // px

        return function (t) {
            // Remove old tail dots.
            // Instead of move old dots,
            // we create new dots every time.
            p._symbol && p._symbol.map(function (dot) {
               dot.needToRemove = true;
            });
            p._symbol = drawTail(distance * t, g.x, g.y, g.r, g.startAngle, g.endAngle, length, maxR, d, p.color);
        }
    }

    function drawSymbol(progress, ox, oy, r, begin, end, length, url, width, height, dpr) {
        var base = progress - length + begin;
        if (progress + begin > end) { return }
        var th = length + base;
        var x = r * Math.cos(th) + ox;
        var y = r * Math.sin(th) + oy;

        return {
            x: x,
            y: y,
            radian: Math.PI + th
        }

    }

    function drawTail (progress, ox, oy, r, begin, end, length, maxR, d, color) {

        var from = progress > length ? 0 : length - progress;
        var to = progress + begin < end ? length : length - (progress + begin - end);

        var base = progress - length + begin;

        var dots = [];
        for (var pos = to; pos > from; pos -= d / r) {
            var th = pos + base;
            var x = r * Math.cos(th) + ox;
            var y = r * Math.sin(th) + oy;
            var ratio = pos / length;

            dots.push(animationRenderer.circle({
                x: x,
                y: y,
                r: ratio * maxR,
                fillStyle: color
            })
            );
        }

        return dots;
    }

    return {
        data: data,
        clear: clear,
        draw: draw,
        redraw: redraw,
        stop: stop,
        removeEffect: removeEffect
    }
}

var LineMapLayer = Layer.extend({

    options: {
        mainRenderer: null,
        animationRenderer: null,
        vanchart: null
    },

    initialize: function (options) {
        BaseUtils.setOptions(this, options);
    },

    setData: function (pairs) {
        this._pairs = pairs;
        return this._draw(); //todo, ->redraw
    },

    addData: function (pair) {
        this._pairs.push(pair);
        return this._draw();
    },

    setOptions: function (options) {
        BaseUtils.setOptions(this, options);
        if (this._lineMap) {
            this._updateOptions();
        }
        return this._draw();
    },

    redraw: function () {
        this._lineMap.redraw(this.options.vanchart.highlightTarget);

        this.options.mainRenderer.flush();
        return this;
    },

    removeEffect: function (p) {
        if (this._lineMap) {
            this._lineMap.removeEffect(p);
        }
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._lineMap) {
            this._initRenderer();
        }

        map.on('moveend', this._reset, this);

        if (map.options.zoomAnimation && Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }

        map.on(this._events, this);

        this._reset();
    },

    onRemove: function (map) {
        if (this.options.pane) {
            this.getPane().removeChild(this._canvas);
            this.getPane().removeChild(this._animCanvas);
        }else{
            map.getPanes().overlayPane.removeChild(this._canvas);
            map.getPanes().overlayPane.removeChild(this._animCanvas);
        }

        map.off('moveend', this._reset, this);

        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }

        map.off(this._events, this);
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    _initRenderer: function () {
        var canvas = this._canvas = this.options.mainRenderer._container.node();
        var animCanvas = this._animCanvas = this.options.animationRenderer._container.node();

        var originProp = DomUtils.TRANSFORM_ORIGIN;
        canvas.style[originProp] = animCanvas.style[originProp] = '50% 50%';

        var animated = this._map.options.zoomAnimation && Browser.any3d;
        var zoomStyle = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');
        var layerStyle = 'leaflet-linemap-layer leaflet-layer ';
        DomUtils.addClass(canvas, layerStyle + zoomStyle);
        DomUtils.addClass(animCanvas, layerStyle + zoomStyle);

        this._lineMap = lineMap(this.options.mainRenderer, this.options.animationRenderer, this._map);
    },

    _updateOptions: function () {

    },

    _reset: function () {
        this._lineMap.stop();
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        DomUtils.setPosition(this._canvas, topLeft);
        DomUtils.setPosition(this._animCanvas, topLeft);

        this._draw();

        // todo,
        // flash sometimes, don't know why
        //
        // var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        // var size = this._map.getSize();
        //
        // var mainRenderer = this.options.mainRenderer;
        // var animationRenderer = this.options.animationRenderer;
        //
        // if (mainRenderer.left !== topLeft.x ||
        //     mainRenderer.top !== topLeft.y ||
        //     mainRenderer.width !== size.x ||
        //     mainRenderer.height !== size.y) {
        //
        //     this._lineMap.stop();
        //
        //     mainRenderer.setPosition(topLeft.x, topLeft.y);
        //     mainRenderer.setSize(size.x, size.y);
        //
        //     animationRenderer.setPosition(topLeft.x, topLeft.y);
        //     animationRenderer.setSize(size.x, size.y);
        //
        //     this._draw();
        // }
    },

    _draw: function () {
        if (!(this._map && this._pairs && this._pairs.length)) {
            this.options.mainRenderer.flush();
            return;
        }

        this._lineMap.data(this._pairs).draw();

        this.options.mainRenderer.flush();
    },

    _animateZoom: function (e) {
        this._lineMap.stop();
        var scale = this._map.getZoomScale(e.zoom),
            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        if (DomUtils.setTransform) {
            // todo, use our own functions
            // this.options.animationRenderer.left =
            //     this.options.mainRenderer.left = offset.x;
            // this.options.animationRenderer.top =
            //     this.options.mainRenderer.top = offset.y;
            DomUtils.setTransform(this._canvas, offset, scale);
            DomUtils.setTransform(this._animCanvas, offset, scale);

        } else {
            var trans = BaseUtils.makeTranslate(offset) + ' scale(' + scale + ')';
            this._canvas.style[DomUtils.TRANSFORM] = trans;
            this._animCanvas.style[DomUtils.TRANSFORM] = trans;
        }
    },

    _events: {
        tap: function (ev) {
            var point = this.hoverPoint;
            point && point._onPointTap(ev); // fire('tap') no effect?
        },
        mousemove: function (ev) {

            var mainRenderer = this.options.mainRenderer;
            var vanchart = this.options.vanchart;
            var self = this;

            var elements = mainRenderer.elements, el, len = mainRenderer.elements.length;

            var target,
                pos = ev.containerPoint;

            // find target element
            while(el = elements[--len]) {
                if (el.contain(pos)) {
                    target = el;
                    break;
                }
            }

            var targetPoint = target && target.point;
            var large = targetPoint && targetPoint.series.options.large;

            if (targetPoint) {
                // found target
                vanchart.showTooltip(targetPoint, ev);
                vanchart.handler.cursor('pointer');

                // has hover color and needs to change
                if (targetPoint.mouseOverColor && !large &&
                    targetPoint !== self.hoverPoint) {

                    // change target element color
                    target.style.strokeStyle = target.point.mouseOverColor;
                }

            } else {
                if (!vanchart.hoverPoint) {
                    vanchart.hideTooltip();
                }
                vanchart.handler.cursor('');
            }

            // different from last
            if (!large && self.hoverPoint != targetPoint) {
                if (self.hoverPoint) {
                    // recover
                    self.hoverPoint.graphic.style.strokeStyle = self.hoverPoint._color;
                }

                self.hoverPoint = targetPoint;
                vanchart.hoverPoint = targetPoint;
                mainRenderer.flush();
            }
        }
    }

});

return function (options) {
    return new LineMapLayer(options);
};

});

/**
 * Created by Yuqian on 2017/7/7.
 */
define('chart/map/CanvasLayer',['require','../../utils/BaseUtils','../../dom/DomUtils','../../utils/ColorUtils','../../Constants','../../vector/Layer','../../dom/Browser'],function (require) {
    var BaseUtils = require('../../utils/BaseUtils');
    var DomUtils = require('../../dom/DomUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var Constants = require('../../Constants');
    var Layer = require('../../vector/Layer');
    var Browser = require('../../dom/Browser');

    return Layer.extend({

        options: {
            renderer: null,
            vanchart: null
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        setOptions: function (options) {
            BaseUtils.setOptions(this, options);
            this._draw();
        },

        onAdd: function (map) {
            this._map = map;

            this._initRenderer();

            map.on('moveend', this._reset, this);

            if (map.options.zoomAnimation && Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }

            map.on(this._events, this);

            this._reset();
        },

        onRemove: function (map) {
            if (this.options.pane) {
                this.getPane().removeChild(this._canvas);
            }else{
                map.getPanes().overlayPane.removeChild(this._canvas);
            }

            map.off('moveend', this._reset, this);

            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }

            map.off(this._events, this);
        },

        setData: function (points) {
            this._points = points;
            this._draw();
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        _initRenderer: function () {
            var canvas = this._canvas = this.options.renderer._container.node();

            var originProp = DomUtils.TRANSFORM_ORIGIN;
            canvas.style[originProp] = '50% 50%';

            var animated = this._map.options.zoomAnimation && Browser.any3d;
            var zoomStyle = 'leaflet-zoom-' + (animated ? 'animated' : 'hide');
            var layerStyle = 'leaflet-linemap-layer leaflet-layer ';
            DomUtils.addClass(canvas, layerStyle + zoomStyle);

        },

        _reset: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            DomUtils.setPosition(this._canvas, topLeft);
            this._draw();
        },

        _draw: function () {
            if (this._map && this._points && this._points.length) {
                this._drawPoints(this._points);
            }

            this.options.renderer.flush();
        },

        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

            DomUtils.setTransform(this._canvas, offset, scale);
        },

        _events: {
            tap: function (ev) {
                var point = this.hoverPoint;
                point && point._onPointTap(ev);
            },
            mousemove: function (ev) {

                var renderer = this.options.renderer;
                var vanchart = this.options.vanchart;
                var self = this;

                var elements = renderer.elements, el, len = renderer.elements.length;

                var target,
                    pos = ev.containerPoint;

                // find target element
                while(el = elements[--len]) {
                    if (el.contain(pos)) {
                        target = el;
                        break;
                    }
                }

                var targetPoint = target && target.point;
                var large = targetPoint && targetPoint.series.options.large;

                if (targetPoint) {
                    // found target
                    vanchart.showTooltip(targetPoint, ev);
                    vanchart.handler.cursor('pointer');

                    // // has hover color and needs to change
                    // if (targetPoint.mouseOverColor && !large &&
                    //     targetPoint !== self.hoverPoint) {
                    //
                    //     // change target element color
                    //     target.style.color = target.point.mouseOverColor;
                    // }

                } else {
                    if (!vanchart.hoverPoint) {
                        vanchart.hideTooltip();
                    }
                    vanchart.handler.cursor('');
                }

                // different from last
                if (self.hoverPoint != targetPoint) {
                    // if (self.hoverPoint) {
                    //     // recover
                    //     self.hoverPoint.graphic.style.color = self.hoverPoint._color;
                    // }

                    self.hoverPoint = targetPoint;
                    // renderer.flush();
                }
            }
        }

    });

});

/**
 * Created by Yuqian on 2017/7/11.
 */
define('chart/map/CanvasMapLayer',['require','./CanvasLayer','../../utils/BaseUtils','../../utils/ColorUtils','../../Constants'],function (require) {
    var CanvasLayer = require('./CanvasLayer');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var Constants = require('../../Constants');

    var DET = 30;
    var LOCATION_RADIUS = 20;

    return CanvasLayer.extend({

        _drawPoints: function (points) {
            var vanchart = this.options.vanchart,
                renderer = this.options.renderer;

            var hasRangelegend = vanchart.hasRangeLegend();

            var width = renderer.width;
            var height = renderer.height;

            var len = points.length, i = len;

            // todo
            renderer.elements = [];

            // 
            while (i--) {
                var p = points[i];
                var latlng = p.getLatLng();

                var pos = vanchart.latLngToContainerPoint(latlng);
                var x = pos.x, y = pos.y;

                if (x < -DET || width + DET < x || y < -DET || height + DET < y
                    || !hasRangelegend && renderer.shouldFilter(x, y)) {
                    if (p.graphic) {
                        p.graphic.needToRemove = true;
                        // todo, remove from canvas but save in point
                        p.graphic = null;
                    }
                    continue
                }

                p.x = pos.x;
                p.y = pos.y;

                if (p.graphic) {
                    renderer.elements.push(p.graphic);

                    var y = p.y;
                    var marker = p.options.marker;
                    if (marker) {
                        var symbol = marker.symbol,
                            radius = marker.radius;
                        // todo, remove this condition
                        if (symbol === Constants.LOCATION) {
                            y -= LOCATION_RADIUS;
                        }
                    }
                    p.graphic.setStyle({
                        x: p.x,
                        y: y
                    });
                } else {
                    p.graphic = this._getGraphic(p, renderer);
                    p.graphic.point = p;
                }
            }

            var left = null;
            var right = null;
            var array = renderer.elements;
            for (left = 0, right = length - 1; left < right; left += 1, right -= 1)
            {
                var temporary = array[left];
                array[left] = array[right];
                array[right] = temporary;
            }


            renderer.resetFilter();

        },

        _getGraphic: function (p, renderer) {
            if (p.series.type === Constants.SCATTER_CHART) {
                var marker = p.options.marker,
                    symbol = marker.symbol,
                    radius = marker.radius,
                    color = marker.fillColor || p.color;

                if (symbol === Constants.LOCATION) {
                    return renderer.image({
                        url: Constants.LOCATION,
                        x: p.x,
                        y: p.y - LOCATION_RADIUS,
                        width: LOCATION_RADIUS * 2,
                        height: LOCATION_RADIUS * 2,
                        color: p.color
                    })
                }

                return renderer.marker(symbol, {
                    x: p.x,
                    y: p.y,
                    radius: radius,
                    color: color
                })
            } else {
                // bubble
                return renderer.circle({
                    x: p.x,
                    y: p.y,
                    r: p.radius,
                    fillStyle: ColorUtils.mixColorWithAlpha(p.color, p.opacity)
                })
            }
        }

    });
});
/*
 * heatmap.js v2.0.5 | JavaScript Heatmap Library
 *
 * Copyright 2008-2016 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.
 * Dual licensed under MIT and Beerware license
 *
 * :: 2016-09-05 01:16
 */
;(function (name, context, factory) {

    // Supports UMD. AMD, CommonJS/Node.js and browser context
    if (typeof module !== "undefined" && module.exports) {
        module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
        define('chart/map/heatmap',factory);
    } else {
        context[name] = factory();
    }

})("h337", this, function () {

// Heatmap Config stores default values and will be merged with instance config
    var HeatmapConfig = {
        defaultRadius: 40,
        defaultRenderer: 'canvas2d',
        defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
        defaultMaxOpacity: 1,
        defaultMinOpacity: 0,
        defaultBlur: .85,
        defaultXField: 'x',
        defaultYField: 'y',
        defaultValueField: 'value',
        plugins: {}
    };
    var Store = (function StoreClosure() {

        var Store = function Store(config) {
            this._coordinator = {};
            this._data = [];
            this._radi = [];
            this._min = 10;
            this._max = 1;
            this._xField = config['xField'] || config.defaultXField;
            this._yField = config['yField'] || config.defaultYField;
            this._valueField = config['valueField'] || config.defaultValueField;

            if (config["radius"]) {
                this._cfgRadius = config["radius"];
            }
        };

        var defaultRadius = HeatmapConfig.defaultRadius;

        Store.prototype = {
            // when forceRender = false -> called from setData, omits renderall event
            _organiseData: function(dataPoint, forceRender) {
                var x = dataPoint[this._xField];
                var y = dataPoint[this._yField];
                var radi = this._radi;
                var store = this._data;
                var max = this._max;
                var min = this._min;
                var value = dataPoint[this._valueField] || 1;
                var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

                if (!store[x]) {
                    store[x] = [];
                    radi[x] = [];
                }

                if (!store[x][y]) {
                    store[x][y] = value;
                    radi[x][y] = radius;
                } else {
                    store[x][y] += value;
                }
                var storedVal = store[x][y];

                if (storedVal > max) {
                    if (!forceRender) {
                        this._max = storedVal;
                    } else {
                        this.setDataMax(storedVal);
                    }
                    return false;
                } else if (storedVal < min) {
                    if (!forceRender) {
                        this._min = storedVal;
                    } else {
                        this.setDataMin(storedVal);
                    }
                    return false;
                } else {
                    return {
                        x: x,
                        y: y,
                        value: value,
                        radius: radius,
                        min: min,
                        max: max
                    };
                }
            },
            _unOrganizeData: function() {
                var unorganizedData = [];
                var data = this._data;
                var radi = this._radi;

                for (var x in data) {
                    for (var y in data[x]) {

                        unorganizedData.push({
                            x: x,
                            y: y,
                            radius: radi[x][y],
                            value: data[x][y]
                        });

                    }
                }
                return {
                    min: this._min,
                    max: this._max,
                    data: unorganizedData
                };
            },
            _onExtremaChange: function() {
                this._coordinator.emit('extremachange', {
                    min: this._min,
                    max: this._max
                });
            },
            addData: function() {
                if (arguments[0].length > 0) {
                    var dataArr = arguments[0];
                    var dataLen = dataArr.length;
                    while (dataLen--) {
                        this.addData.call(this, dataArr[dataLen]);
                    }
                } else {
                    // add to store
                    var organisedEntry = this._organiseData(arguments[0], true);
                    if (organisedEntry) {
                        // if it's the first datapoint initialize the extremas with it
                        if (this._data.length === 0) {
                            this._min = this._max = organisedEntry.value;
                        }
                        this._coordinator.emit('renderpartial', {
                            min: this._min,
                            max: this._max,
                            data: [organisedEntry]
                        });
                    }
                }
                return this;
            },
            setData: function(data) {
                var dataPoints = data.data;
                var pointsLen = dataPoints.length;


                // reset data arrays
                this._data = [];
                this._radi = [];

                for(var i = 0; i < pointsLen; i++) {
                    this._organiseData(dataPoints[i], false);
                }
                this._max = data.max;
                this._min = data.min || 0;

                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            removeData: function() {
                // TODO: implement
            },
            setDataMax: function(max) {
                this._max = max;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setDataMin: function(min) {
                this._min = min;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setCoordinator: function(coordinator) {
                this._coordinator = coordinator;
            },
            _getInternalData: function() {
                return {
                    max: this._max,
                    min: this._min,
                    data: this._data,
                    radi: this._radi
                };
            },
            getData: function() {
                return this._unOrganizeData();
            }/*,

           TODO: rethink.

           getValueAt: function(point) {
           var value;
           var radius = 100;
           var x = point.x;
           var y = point.y;
           var data = this._data;

           if (data[x] && data[x][y]) {
           return data[x][y];
           } else {
           var values = [];
           // radial search for datapoints based on default radius
           for(var distance = 1; distance < radius; distance++) {
           var neighbors = distance * 2 +1;
           var startX = x - distance;
           var startY = y - distance;

           for(var i = 0; i < neighbors; i++) {
           for (var o = 0; o < neighbors; o++) {
           if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
           if (data[startY+i] && data[startY+i][startX+o]) {
           values.push(data[startY+i][startX+o]);
           }
           } else {
           continue;
           }
           }
           }
           }
           if (values.length > 0) {
           return Math.max.apply(Math, values);
           }
           }
           return false;
           }*/
        };


        return Store;
    })();

    var Canvas2dRenderer = (function Canvas2dRendererClosure() {

        var _getColorPalette = function(config) {
            var gradientConfig = config.gradient || config.defaultGradient;
            var paletteCanvas = document.createElement(window.VAN_CANVAS);

            if(paletteCanvas.getContext){
                var paletteCtx = paletteCanvas.getContext('2d');

                paletteCanvas.width = 256;
                paletteCanvas.height = 1;

                var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
                for (var key in gradientConfig) {
                    gradient.addColorStop(key, gradientConfig[key]);
                }

                paletteCtx.fillStyle = gradient;
                paletteCtx.fillRect(0, 0, 256, 1);

                return paletteCtx.getImageData(0, 0, 256, 1).data;
            }

            return {};
        };

        var _getPointTemplate = function(radius, blurFactor) {
            var tplCanvas = document.createElement(window.VAN_CANVAS);
            var tplCtx = tplCanvas.getContext('2d');
            var x = radius;
            var y = radius;
            tplCanvas.width = tplCanvas.height = radius*2;
            tplCanvas.blur = blurFactor;

            if (blurFactor === 1) {
                tplCtx.beginPath();
                tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
                tplCtx.fillStyle = 'rgba(0,0,0,1)';
                tplCtx.fill();
            } else {
                var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                tplCtx.fillStyle = gradient;
                tplCtx.fillRect(0, 0, 2*radius, 2*radius);
            }

            return tplCanvas;
        };

        var _prepareData = function(data) {
            var renderData = [];
            var min = data.min;
            var max = data.max;
            var radi = data.radi;
            var data = data.data;

            var xValues = Object.keys(data);
            var xValuesLen = xValues.length;

            while(xValuesLen--) {
                var xValue = xValues[xValuesLen];
                var yValues = Object.keys(data[xValue]);
                var yValuesLen = yValues.length;
                while(yValuesLen--) {
                    var yValue = yValues[yValuesLen];
                    var value = data[xValue][yValue];
                    var radius = radi[xValue][yValue];
                    renderData.push({
                        x: xValue,
                        y: yValue,
                        value: value,
                        radius: radius
                    });
                }
            }

            return {
                min: min,
                max: max,
                data: renderData
            };
        };


        function Canvas2dRenderer(config) {
            var container = config.container;
            var shadowCanvas = this.shadowCanvas = document.createElement(window.VAN_CANVAS);
            var canvas = this.canvas = config.canvas || document.createElement(window.VAN_CANVAS);

            //excanvas
            window.VanCanvasManager && VanCanvasManager.initElement(canvas);
            window.VanCanvasManager && VanCanvasManager.initElement(shadowCanvas);

            var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

            var computed = config.container.currentStyle || getComputedStyle(config.container) || {};

            canvas.className = 'heatmap-canvas';

            this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));
            this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));

            this.shadowCtx = shadowCanvas.getContext('2d');
            this.ctx = canvas.getContext('2d');

            // @TODO:
            // conditional wrapper

            canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

            container.style.position = 'relative';
            container.appendChild(canvas);

            this._palette = _getColorPalette(config);
            this._templates = {};

            this._setStyles(config);
        };

        Canvas2dRenderer.prototype = {
            renderPartial: function(data) {
                if (data.data.length > 0) {
                    if(this.ctx.getImageData){
                        this._drawAlpha(data);
                        this._colorize();
                    }else{
                        this._drawPoints(data);
                    }
                }
            },
            renderAll: function(data) {
                // reset render boundaries
                this._clear();
                if (data.data.length > 0) {
                    var data = _prepareData(data);
                    if(this.ctx.getImageData){
                        this._drawAlpha(data);
                        this._colorize();
                    }else{
                        this._drawPoints(data);
                    }
                }
            },

            _drawPoints:function(data){
                var min = this._min = data.min, max = this._max = data.max;
                var data = data.data || [], dataLen = data.length;
                var blur = 1 - this._blur, ctx = this.ctx;
                while(dataLen--) {
                    var point = data[dataLen], radius = +point.radius;
                    var value = Math.min(point.value, max);
                    var x = +point.x, y = +point.y;

                    var templateAlpha = (value-min)/(max-min);
                    templateAlpha = isNaN(templateAlpha) ? 1 : templateAlpha;

                    ctx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

                    var gradient = ctx.createRadialGradient(x, y, radius*blur, x, y, radius);

                    var gradientConfig = this._gradientConfig;
                    for (var key in gradientConfig) {
                        gradient.addColorStop(+key, gradientConfig[key]);
                    }

                    ctx.fillStyle = gradient;

                    ctx.beginPath();

                    ctx.moveTo(x, y);

                    ctx.arc(x, y, radius, 0, Math.PI * 2, false);

                    ctx.fill();
                }
            },

            _updateGradient: function(config) {
                this._palette = _getColorPalette(config);
            },
            updateConfig: function(config) {
                if (config['gradient']) {
                    this._updateGradient(config);
                }
                this._setStyles(config);
            },
            setDimensions: function(width, height) {
                this._width = width;
                this._height = height;
                this.canvas.width = this.shadowCanvas.width = width;
                this.canvas.height = this.shadowCanvas.height = height;
            },
            _clear: function() {
                this.shadowCtx.clearRect(0, 0, this._width, this._height);
                this.ctx.clearRect(0, 0, this._width, this._height);
            },
            _setStyles: function(config) {
                this._blur = (config.blur === 0)?0:(config.blur || config.defaultBlur);

                this._gradientConfig = config.gradient || config.defaultGradient;

                if (config.backgroundColor) {
                    this.canvas.style.backgroundColor = config.backgroundColor;
                }

                this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
                this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;


                this._opacity = (config.opacity || 0) * 255;
                this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
                this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
                this._useGradientOpacity = !!config.useGradientOpacity;
            },
            _drawAlpha: function(data) {
                var min = this._min = data.min;
                var max = this._max = data.max;
                var data = data.data || [];
                var dataLen = data.length;
                // on a point basis?
                var blur = 1 - this._blur;

                while(dataLen--) {

                    var point = data[dataLen];

                    var x = point.x;
                    var y = point.y;
                    var radius = point.radius;
                    // if value is bigger than max
                    // use max as value
                    var value = Math.min(point.value, max);
                    var rectX = x - radius;
                    var rectY = y - radius;
                    var shadowCtx = this.shadowCtx;

                    var tpl;
                    if (!this._templates[radius] || this._templates[radius].blur !== blur) { // @BI-8874
                        this._templates[radius] = tpl = _getPointTemplate(radius, blur);
                    } else {
                        tpl = this._templates[radius];
                    }
                    // value from minimum / value range
                    // => [0, 1]
                    var templateAlpha = (value-min)/(max-min);
                    // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData
                    shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

                    shadowCtx.drawImage(tpl, rectX, rectY);

                    // update renderBoundaries
                    if (rectX < this._renderBoundaries[0]) {
                        this._renderBoundaries[0] = rectX;
                    }
                    if (rectY < this._renderBoundaries[1]) {
                        this._renderBoundaries[1] = rectY;
                    }
                    if (rectX + 2*radius > this._renderBoundaries[2]) {
                        this._renderBoundaries[2] = rectX + 2*radius;
                    }
                    if (rectY + 2*radius > this._renderBoundaries[3]) {
                        this._renderBoundaries[3] = rectY + 2*radius;
                    }
                }
            },
            _colorize: function() {
                var x = this._renderBoundaries[0];
                var y = this._renderBoundaries[1];
                var width = this._renderBoundaries[2] - x;
                var height = this._renderBoundaries[3] - y;
                var maxWidth = this._width;
                var maxHeight = this._height;
                var opacity = this._opacity;
                var maxOpacity = this._maxOpacity;
                var minOpacity = this._minOpacity;
                var useGradientOpacity = this._useGradientOpacity;

                if (x < 0) {
                    x = 0;
                }
                if (y < 0) {
                    y = 0;
                }
                if (x + width > maxWidth) {
                    width = maxWidth - x;
                }
                if (y + height > maxHeight) {
                    height = maxHeight - y;
                }

                var img = this.shadowCtx.getImageData(x, y, width, height);
                var imgData = img.data;
                var len = imgData.length;
                var palette = this._palette;


                for (var i = 3; i < len; i+= 4) {
                    var alpha = imgData[i];
                    var offset = alpha * 4;


                    if (!offset) {
                        continue;
                    }

                    var finalAlpha;
                    if (opacity > 0) {
                        finalAlpha = opacity;
                    } else {
                        if (alpha < maxOpacity) {
                            if (alpha < minOpacity) {
                                finalAlpha = minOpacity;
                            } else {
                                finalAlpha = alpha;
                            }
                        } else {
                            finalAlpha = maxOpacity;
                        }
                    }

                    imgData[i-3] = palette[offset];
                    imgData[i-2] = palette[offset + 1];
                    imgData[i-1] = palette[offset + 2];
                    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

                }

                img.data = imgData;
                this.ctx.putImageData(img, x, y);

                this._renderBoundaries = [1000, 1000, 0, 0];

            },
            getValueAt: function(point) {
                var value;
                var shadowCtx = this.shadowCtx;
                var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
                var data = img.data[3];
                var max = this._max;
                var min = this._min;

                value = (Math.abs(max-min) * (data/255)) >> 0;

                return value;
            },
            getDataURL: function() {
                return this.canvas.toDataURL();
            }
        };


        return Canvas2dRenderer;
    })();


    var Renderer = (function RendererClosure() {

        var rendererFn = false;

        if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
            rendererFn = Canvas2dRenderer;
        }

        return rendererFn;
    })();


    var Util = {
        merge: function() {
            var merged = {};
            var argsLen = arguments.length;
            for (var i = 0; i < argsLen; i++) {
                var obj = arguments[i]
                for (var key in obj) {
                    merged[key] = obj[key];
                }
            }
            return merged;
        }
    };
// Heatmap Constructor
    var Heatmap = (function HeatmapClosure() {

        var Coordinator = (function CoordinatorClosure() {

            function Coordinator() {
                this.cStore = {};
            };

            Coordinator.prototype = {
                on: function(evtName, callback, scope) {
                    var cStore = this.cStore;

                    if (!cStore[evtName]) {
                        cStore[evtName] = [];
                    }
                    cStore[evtName].push((function(data) {
                        return callback.call(scope, data);
                    }));
                },
                emit: function(evtName, data) {
                    var cStore = this.cStore;
                    if (cStore[evtName]) {
                        var len = cStore[evtName].length;
                        for (var i=0; i<len; i++) {
                            var callback = cStore[evtName][i];
                            callback(data);
                        }
                    }
                }
            };

            return Coordinator;
        })();


        var _connect = function(scope) {
            var renderer = scope._renderer;
            var coordinator = scope._coordinator;
            var store = scope._store;

            coordinator.on('renderpartial', renderer.renderPartial, renderer);
            coordinator.on('renderall', renderer.renderAll, renderer);
            coordinator.on('extremachange', function(data) {
                scope._config.onExtremaChange &&
                scope._config.onExtremaChange({
                    min: data.min,
                    max: data.max,
                    gradient: scope._config['gradient'] || scope._config['defaultGradient']
                });
            });
            store.setCoordinator(coordinator);
        };


        function Heatmap() {
            var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
            this._coordinator = new Coordinator();
            if (config['plugin']) {
                var pluginToLoad = config['plugin'];
                if (!HeatmapConfig.plugins[pluginToLoad]) {
                    throw new Error('Plugin \''+ pluginToLoad + '\' not found. Maybe it was not registered.');
                } else {
                    var plugin = HeatmapConfig.plugins[pluginToLoad];
                    // set plugin renderer and store
                    this._renderer = new plugin.renderer(config);
                    this._store = new plugin.store(config);
                }
            } else {
                this._renderer = new Renderer(config);
                this._store = new Store(config);
            }
            _connect(this);
        };

        // @TODO:
        // add API documentation
        Heatmap.prototype = {
            addData: function() {
                this._store.addData.apply(this._store, arguments);
                return this;
            },
            removeData: function() {
                this._store.removeData && this._store.removeData.apply(this._store, arguments);
                return this;
            },
            setData: function() {
                this._store.setData.apply(this._store, arguments);
                return this;
            },
            setDataMax: function() {
                this._store.setDataMax.apply(this._store, arguments);
                return this;
            },
            setDataMin: function() {
                this._store.setDataMin.apply(this._store, arguments);
                return this;
            },
            configure: function(config) {
                this._config = Util.merge(this._config, config);
                this._renderer.updateConfig(this._config);
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            repaint: function() {
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            getData: function() {
                return this._store.getData();
            },
            getDataURL: function() {
                return this._renderer.getDataURL();
            },
            getValueAt: function(point) {

                if (this._store.getValueAt) {
                    return this._store.getValueAt(point);
                } else  if (this._renderer.getValueAt) {
                    return this._renderer.getValueAt(point);
                } else {
                    return null;
                }
            }
        };

        return Heatmap;

    })();


// core
    var heatmapFactory = {
        create: function(config) {
            return new Heatmap(config);
        },
        register: function(pluginKey, plugin) {
            HeatmapConfig.plugins[pluginKey] = plugin;
        }
    };

    return heatmapFactory;
});
/**
 * Created by eason on 2017/3/13.
 */
define('chart/map/HeatMapOverlay',['require','./heatmap','../../vector/Layer','../../dom/DomUtils','../../utils/Point2D','../../utils/BaseUtils','./LatLng'],function(require){

    var h337 = require('./heatmap');

    var Layer = require('../../vector/Layer');
    var DomUtils = require('../../dom/DomUtils');
    var Point = require('../../utils/Point2D');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('./LatLng');

    var MOBILE_TOOLTIP_TIMER,
        MOBILE_TOOLTIP_DELAY = 4000;

    var HeatMapOverlay = Layer.extend({

        initialize: function (config) {
            this.cfg = config;
            this._el = DomUtils.create('div', 'leaflet-zoom-hide');
            this._el.style.zIndex = 201;
            this._data = [];
            this._max = 1;
            this._min = 0;
            this.cfg.container = this._el;
        },

        onAdd: function (map) {
            var size = map.getSize();

            this._map = map;

            this._width = size.x;
            this._height = size.y;

            this._el.style.width = size.x + 'px';
            this._el.style.height = size.y + 'px';
            this._el.style.position = 'absolute';

            this._origin = this._map.layerPointToLatLng(new Point(0, 0));

            map.getPanes().overlayPane.appendChild(this._el);

            if (!this._heatmap) {
                this._heatmap = h337.create(this.cfg);
            }

            // this resets the origin and redraws whenever
            // the zoom changed or the map has been moved
            map.on('moveend', this._reset, this);

            map.on(this._events, this);
            this._draw();
        },

        addTo: function (map) {
            map.addLayer(this);
            return this;
        },

        onRemove: function (map) {
            // remove layer's DOM elements and listeners
            map.getPanes().overlayPane.removeChild(this._el);

            map.off('moveend', this._reset, this);
            map.off(this._events, this);
        },
        _draw: function() {
            if (!this._map) { return; }

            var mapPane = this._map.getPanes().mapPane;
            var point = mapPane._leaflet_pos;

            // reposition the layer

            if(BaseUtils.isSupportSVG()){
                this._el.style[HeatMapOverlay.CSS_TRANSFORM] = 'translate(' +
                    -Math.round(point.x) + 'px,' +
                    -Math.round(point.y) + 'px)';
            }else{
                this._el.style.left = -Math.round(point.x) + 'px';
                this._el.style.bottom = Math.round(point.y) + 'px';
            }

            this._update();
        },
        _update: function() {
            var bounds, zoom, scale;
            var generatedData = { max: this._max, min: this._min, data: [] };

            bounds = this._map.getBounds();
            zoom = this._map.getZoom();
            scale = Math.pow(2, zoom);

            if (this._data.length === 0) {
                if (this._heatmap) {
                    this._heatmap.setData(generatedData);
                }
                return;
            }


            var latLngPoints = [];
            var radiusMultiplier = this.cfg.scaleRadius ? scale : 1;
            var localMax = 0;
            var localMin = 0;
            var valueField = this.cfg.valueField;
            var len = this._data.length;

            while (len--) {
                var entry = this._data[len];
                var value = entry[valueField];
                var latlng = entry.latlng;


                // we don't wanna render points that are not even on the map ;-)
                if (!bounds.contains(latlng)) {
                    continue;
                }
                // local max is the maximum within current bounds
                localMax = Math.max(value, localMax);
                localMin = Math.min(value, localMin);

                var point = this._map.latLngToContainerPoint(latlng);
                var latlngPoint = { x: Math.round(point.x), y: Math.round(point.y) };
                latlngPoint[valueField] = value;

                var radius;

                if (entry.radius) {
                    radius = entry.radius * radiusMultiplier;
                } else {
                    radius = (this.cfg.radius || 2) * radiusMultiplier;
                }
                latlngPoint.radius = radius;
                latLngPoints.push(latlngPoint);
            }
            if (this.cfg.useLocalExtrema) {
                generatedData.max = localMax;
                generatedData.min = localMin;
            }

            generatedData.data = latLngPoints;

            this._heatmap.setData(generatedData);
        },
        setData: function(data) {
            this._max = data.max || this._max;
            this._min = data.min || this._min;
            var lnglatField = this.cfg.lnglatField || 'lnglat';
            var valueField = this.cfg.valueField || 'value';

            // transform data to latlngs
            var data = data.data;
            var len = data.length;
            var d = [];

            while (len--) {
                var entry = data[len].options;
                var latlng = new LatLng(entry[lnglatField][1], entry[lnglatField][0]);
                var dataObj = { latlng: latlng };
                dataObj[valueField] = entry[valueField];
                if (entry.radius) {
                    dataObj.radius = entry.radius;
                }
                d.push(dataObj);
            }
            this._data = d;

            this._draw();
        },
        // experimential... not ready.
        addData: function(pointOrArray) {
            if (pointOrArray.length > 0) {
                var len = pointOrArray.length;
                while(len--) {
                    this.addData(pointOrArray[len]);
                }
            } else {
                var lnglatField = this.cfg.lnglatField || 'lnglat';
                var valueField = this.cfg.valueField || 'value';
                var entry = pointOrArray;
                var latlng = new LatLng(entry[lnglatField][1], entry[lnglatField][0]);
                var dataObj = { latlng: latlng };

                dataObj[valueField] = entry[valueField];
                this._max = Math.max(this._max, dataObj[valueField]);
                this._min = Math.min(this._min, dataObj[valueField]);

                if (entry.radius) {
                    dataObj.radius = entry.radius;
                }
                this._data.push(dataObj);
                this._draw();
            }
        },
        _reset: function () {
            this._origin = this._map.layerPointToLatLng(new Point(0, 0));

            var size = this._map.getSize();
            if (this._width !== size.x || this._height !== size.y) {
                this._width  = size.x;
                this._height = size.y;

                this._el.style.width = this._width + 'px';
                this._el.style.height = this._height + 'px';

                this._heatmap._renderer.setDimensions(this._width, this._height);
            }
            this._draw();
        },

        _events: {
            tap: function (ev) {  // todo, Tap
                var vanchart = this._map;

                // showToolTip
                if(BaseUtils.hasTouch()){
                    vanchart.fire('mousemove', ev);

                    if(vanchart.hoverPoint){
                        clearTimeout(MOBILE_TOOLTIP_TIMER);
                        MOBILE_TOOLTIP_TIMER = setTimeout(function () {
                            vanchart.hideTooltip();
                        }, MOBILE_TOOLTIP_DELAY)
                    }
                }

                vanchart.hoverPoint && vanchart.hoverPoint._onPointTap(ev);
            },
            mousemove: function (ev) {
                var vanchart = this._map;
                var closestPoint = vanchart.handler._getCanvasClosestPoint(ev.containerPoint);
                if(closestPoint){
                    if(!closestPoint._events){
                        closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                    }
                    vanchart.showTooltip(closestPoint, ev);
                    vanchart.hoverPoint = closestPoint;
                } else  {
                    vanchart.hideTooltip();
                }
            }
        }
    });

    HeatMapOverlay.CSS_TRANSFORM = (function() {
        var div = document.createElement('div');
        var props = [
            'transform',
            'WebkitTransform',
            'MozTransform',
            'OTransform',
            'msTransform'
        ];

        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (div.style[prop] !== undefined) {
                return prop;
            }
        }
        return props[0];
    })();


    return HeatMapOverlay;
});
/**
 * Created by eason on 2017/2/7.
 */
define('chart/map/Icon',['require','../../utils/Class','../../utils/BaseUtils','../../utils/Point2D','../../dom/Browser','../../dom/DomUtils'],function(require){

    var Class = require('../../utils/Class');
    var BaseUtils = require('../../utils/BaseUtils');
    var Point = require('../../utils/Point2D');
    var Browser = require('../../dom/Browser');
    var DomUtils = require('../../dom/DomUtils');

    var Icon = Class.extend({

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function (oldIcon) {
            return this._createIcon('icon', oldIcon);
        },

        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function (oldIcon) {
            return this._createIcon('shadow', oldIcon);
        },

        _createIcon: function (name, oldIcon) {
            var src = this._getIconUrl(name);

            if (!src) {
                if (name === 'icon') {
                    throw new Error('iconUrl not set in Icon options (see the docs).');
                }
                return null;
            }

            var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
            this._setIconStyles(img, name);

            return img;
        },

        _setIconStyles: function (img, name) {
            var options = this.options;
            var sizeOption = options[name + 'Size'];

            if (typeof sizeOption === 'number') {
                sizeOption = [sizeOption, sizeOption];
            }

            var size = Point.create(sizeOption),
                anchor = Point.create(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
                    size && size.divideBy(2, true));

            img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

            // focusoutline
            // outline0onfocus
            img.style.outline = "0";

            if (anchor) {
                img.style.marginLeft = (-anchor.x) + 'px';
                img.style.marginTop  = (-anchor.y) + 'px';
            }

            if (size) {
                img.style.width  = size.x + 'px';
                img.style.height = size.y + 'px';
            }
        },

        _createImg: function (src, el) {
            el = el || document.createElement('img');
            el.src = src;
            return el;
        },

        _getIconUrl: function (name) {
            return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
        }
    });


    Icon.Default = Icon.extend({

        options: {
            iconUrl:       'marker-icon.png',
            iconRetinaUrl: 'marker-icon-2x.png',
            shadowUrl:     'marker-shadow.png',
            iconSize:    [25, 41],
            iconAnchor:  [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize:  [41, 41]
        },

        _getIconUrl: function (name) {
            if (!Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
                Icon.Default.imagePath = this._detectIconPath();
            }

            // @option imagePath: String
            // `Icon.Default` will try to auto-detect the absolute location of the
            // blue icon images. If you are placing these images in a non-standard
            // way, set this option to point to the right absolute path.
            return (this.options.imagePath || Icon.Default.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },

        _detectIconPath: function () {
            var el = DomUtils.create('div',  'leaflet-default-icon-path', document.body);
            var path = DomUtils.getStyle(el, 'background-image') ||
                DomUtils.getStyle(el, 'backgroundImage');	// IE8

            document.body.removeChild(el);

            return path.indexOf('url') === 0 ?
                path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
        }
    });


    return Icon;
});
/**
 * Created by eason on 2017/1/20.
 */
define('vector/shape/LayerGroup',['require','./../Layer','../../utils/BaseUtils'],function(require){

    var Layer = require('./../Layer');
    var BaseUtils = require('../../utils/BaseUtils');

    var LayerGroup = Layer.extend({

        initialize: function (layers) {
            this._layers = {};

            var i, len;

            if (layers) {
                for (i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            }
        },

        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function (layer) {
            var id = this.getLayerId(layer);

            this._layers[id] = layer;

            if (this._map) {
                this._map.addLayer(layer);
            }

            return this;
        },

        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function (layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);

            if (this._map && this._layers[id]) {
                this._map.removeLayer(this._layers[id]);
            }

            delete this._layers[id];

            return this;
        },

        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        hasLayer: function (layer) {
            return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
        },

        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function () {
            for (var i in this._layers) {
                this.removeLayer(this._layers[i]);
            }
            return this;
        },

        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function (methodName) {
            var args = Array.prototype.slice.call(arguments, 1),
                i, layer;

            for (i in this._layers) {
                layer = this._layers[i];

                if (layer[methodName]) {
                    layer[methodName].apply(layer, args);
                }
            }

            return this;
        },

        onAdd: function (map) {
            for (var i in this._layers) {
                map.addLayer(this._layers[i]);
            }
        },

        onRemove: function (map) {
            for (var i in this._layers) {
                map.removeLayer(this._layers[i]);
            }
        },

        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },

        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function (id) {
            return this._layers[id];
        },

        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function () {
            var layers = [];

            for (var i in this._layers) {
                layers.push(this._layers[i]);
            }
            return layers;
        },

        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function (zIndex) {
            return this.invoke('setZIndex', zIndex);
        },

        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function (layer) {
            return BaseUtils.stamp(layer);
        }
    });


    return LayerGroup;
});
/**
 * Created by eason on 2017/2/8.
 */

define('vector/shape/Path',['require','./../Layer','../../dom/Browser','../../utils/BaseUtils'],function(require){

    var Layer = require('./../Layer');
    var Browser = require('../../dom/Browser');
    var BaseUtils = require('../../utils/BaseUtils');

    var INIT_TIME = 1200;
    var INIT_EASE = 'cubic-out';
    var EXIT_TIME = 300;
    var EXIT_EASE = 'ease';
    var RESHOW_TIME = 1000;
    var RESHOW_EASE = INIT_EASE;

    var Path = Layer.extend({

        onAdd: function () {
            this._path = this._renderer.path().style(this.options);
            this._reset();
            this._path.add();
        },

        onRemove: function () {
            this._path.remove();
        },

        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function () {
            if (this._map) {
                this._reset();
            }
            return this;
        },

        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function (style) {

            //path 
            this.options = style || this.options;

            if (this._renderer) {
                this._path.style(this.options);
            }

            return this;
        },

        initAnimate:function () {
            this._path.style({'fill-opacity':0})
                .animate({
                    style:this.options,
                    duration:INIT_TIME,
                    ease:INIT_EASE});
        },

        exitAnimate:function (vanchart, animate) {
            var geo = vanchart.getCurrentGeo();
            animate == false ? this._path.style(geo.defaultAreaStyle())
                : this._path.animate({
                    style:geo.defaultAreaStyle(),
                    duration: EXIT_TIME,
                    ease:EXIT_EASE})
        },

        reShowAnimate:function () {
            this._path.style({'fill-opacity':0})
                .animate({
                style:this.options,
                duration:RESHOW_TIME,
                ease:RESHOW_EASE});
        },

        _onMouseState:function (isChosen,duration,ease,style) {
            style.filter = "none";  // todo filtereffectattr.filter
            this._path .animate({
                duration:duration,
                ease:ease,
                style:style
            });
        },

        _reset: function () {
            // defined in children classes
            this._project();
            this._update();
        },

        _clickTolerance: function () {
            // used when doing hit detection for Canvas layers
            return (this.options['stroke-width'] ? this.options['stroke-width'] / 2 : 0) + (Browser.touch ? 10 : 0);
        },

        node:function(){
            return this._path.node();
        }

    });

    return Path;

});
/**
 * Created by eason on 2017/1/19.
 */
define('chart/map/LatLngBounds',['require','./LatLng'],function(require){

    var LatLng = require('./LatLng');

    var LatLngBounds = function (corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
        if (!corner1) { return; }

        var latlngs = corner2 ? [corner1, corner2] : corner1;

        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    };

    LatLngBounds.prototype = {

        extend: function (obj) {
            var sw = this._southWest,
                ne = this._northEast,
                sw2, ne2;

            if (obj instanceof LatLng) {
                sw2 = obj;
                ne2 = obj;

            } else if (obj instanceof LatLngBounds) {
                sw2 = obj._southWest;
                ne2 = obj._northEast;

                if (!sw2 || !ne2) { return this; }

            } else {
                return obj ? this.extend(LatLng.create(obj) || LatLngBounds.create(obj)) : this;
            }

            if (!sw && !ne) {
                this._southWest = new LatLng(sw2.lat, sw2.lng);
                this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
                sw.lat = Math.min(sw2.lat, sw.lat);
                sw.lng = Math.min(sw2.lng, sw.lng);
                ne.lat = Math.max(ne2.lat, ne.lat);
                ne.lng = Math.max(ne2.lng, ne.lng);
            }

            return this;
        },

        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
        pad: function (bufferRatio) {
            var sw = this._southWest,
                ne = this._northEast,
                heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

            return new LatLngBounds(
                new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
                new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },

        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function () {
            return new LatLng(
                (this._southWest.lat + this._northEast.lat) / 2,
                (this._southWest.lng + this._northEast.lng) / 2);
        },

        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function () {
            return this._southWest;
        },

        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function () {
            return this._northEast;
        },

        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function () {
            return new LatLng(this.getNorth(), this.getWest());
        },

        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function () {
            return new LatLng(this.getSouth(), this.getEast());
        },

        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function () {
            return this._southWest.lng;
        },

        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function () {
            return this._southWest.lat;
        },

        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function () {
            return this._northEast.lng;
        },

        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function () {
            return this._northEast.lat;
        },

        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.

        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
            if (typeof obj[0] === 'number' || obj instanceof LatLng) {
                obj = LatLng.create(obj);
            } else {
                obj = LatLngBounds.create(obj);
            }

            var sw = this._southWest,
                ne = this._northEast,
                sw2, ne2;

            if (obj instanceof LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else {
                sw2 = ne2 = obj;
            }

            return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
                (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
        },

        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            var sw = this._southWest,
                ne = this._northEast,
                sw2 = bounds.getSouthWest(),
                ne2 = bounds.getNorthEast(),

                latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
                lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

            return latIntersects && lngIntersects;
        },

        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            var sw = this._southWest,
                ne = this._northEast,
                sw2 = bounds.getSouthWest(),
                ne2 = bounds.getNorthEast(),

                latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
                lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

            return latOverlaps && lngOverlaps;
        },

        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
        },

        // @method equals(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
        equals: function (bounds) {
            if (!bounds) { return false; }

            bounds = LatLngBounds.create(bounds);

            return this._southWest.equals(bounds.getSouthWest()) &&
                this._northEast.equals(bounds.getNorthEast());
        },

        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function () {
            return !!(this._southWest && this._northEast);
        },

        isSame: function () {
            var sw = this._southWest, ne = this._northEast;
            return sw.lat === ne.lat && sw.lng === ne.lng
        }
    };

    LatLngBounds.create = function(a, b){
        if (a instanceof LatLngBounds) {
            return a;
        }
        return new LatLngBounds(a, b);
    };

    return LatLngBounds;
});
/**
 * Created by eason on 2017/2/14.
 */
define('utils/PathGenerator',['require','./vMap','../Constants'],function(require){

    var vMap = require('./vMap');
    var Constants = require('../Constants');

    var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
    var abs = Math.abs;

    function d3_asin(x) {
        return x > 1 ? half : x < -1 ? -half : Math.asin(x);
    }

    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }

    function d3_identity(d) {
        return d;
    }

    function d3_true() {
        return true;
    }

    var svg = {};
    function d3_zero() {
        return 0;
    }
    svg.arc = function() {
        var toCenter = true;
        var closePath = true;
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) {
                rc = r1, r1 = r0, r0 = rc;
            }
            if (da >= ) {
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            }
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) {
                    p1 *= -1;
                }
                if (r1) {
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                }
                if (r0) {
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
                }
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (x1 != null) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    } else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    } else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                } else if(toCenter){
                    path.push("L", x2, ",", y2);
                }
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) {
                    path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                }
                if (toCenter) {
                    path.push("L", x2, ",", y2);
                }
                if (x3 != null) {
                    path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
                }
            }
            if(closePath) {
                path.push("Z");
            }
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }

        arc.toCenter = function(v){
            if (!arguments.length) {
                return toCenter;
            }
            toCenter = !!v;
            return arc;
        };

        arc.closePath = function(v){
            if (!arguments.length) {
                return closePath;
            }
            closePath = !!v;
            return arc;
        };

        arc.innerRadius = function(v) {
            if (!arguments.length) {
                return innerRadius;
            }
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function(v) {
            if (!arguments.length) {
                return outerRadius;
            }
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) {
                return cornerRadius;
            }
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) {
                return padRadius;
            }
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) {
                return startAngle;
            }
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) {
                return endAngle;
            }
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) {
                return padAngle;
            }
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
            cx0 = cx1, cy0 = cy1;
        }
        return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
    }

    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }

    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }

    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) {
                segment();
            }
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) {
                return x;
            }
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) {
                return y;
            }
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) {
                return defined;
            }
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) {
                return interpolateKey;
            }
            if (typeof _ === "function") {
                interpolateKey = interpolate = _;
            } else {
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            }
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) {
                return tension;
            }
            tension = _;
            return line;
        };
        return line;
    }

    svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = new vMap({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        }
        if (n > 1) {
            path.push("H", p[0]);
        }
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("V", (p = points[i])[1], "H", p[0]);
        }
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) {
            path.push("H", (p = points[i])[0], "V", p[1]);
        }
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
            points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) {
            return d3_svg_lineLinear(points);
        }
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) {
            return d3_svg_lineLinear(points);
        }
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length){
                segment();
            }
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length){
                return x1;
            }
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) {
                return x0;
            }
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) {
                return x1;
            }
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) {
                return y1;
            }
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length){
                return y0;
            }
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length){
                return y1;
            }
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) {
                return defined;
            }
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) {
                return interpolateKey;
            }
            if (typeof _ === "function") {
                interpolateKey = interpolate = _;
            } else {
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            }
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length){
                return tension;
            }
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };

    svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) { return source; }
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) { return target; }
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) { return projection; }
            projection = x;
            return diagonal;
        };
        return diagonal;
    };

    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }

    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }

    svg.getMarkerPath = function(markerType, radius){
        switch(markerType){
            case Constants.CIRCLE:
            case Constants.CIRCLE_HOLLOW:
                return svg.arc().outerRadius(radius)({startAngle:0, endAngle:2 * Math.PI});

            case Constants.SQUARE:
            case Constants.SQUARE_HOLLOW:
                var leftTop = -radius + ',' + -radius;
                var rightTop = radius + ',' + -radius;
                var rightBottom = radius + ',' + radius;
                var leftBottom = -radius + ',' + radius;
                return 'M' + leftTop + 'L' + rightTop + 'L' + rightBottom + 'L' + leftBottom + 'Z';

            case Constants.DIAMOND:
            case Constants.DIAMOND_HOLLOW:
                radius = radius * 2 / Math.sqrt(2);
                var left = -radius + ',' + 0;
                var top = 0 + ',' + -radius;
                var right = radius + ',' + 0;
                var bottom = 0 + ',' + radius;
                return 'M' + left + 'L' + top + 'L' + right + 'L' + bottom + 'Z';

            case Constants.TRIANGLE:
            case Constants.TRIANGLE_HOLLOW:
                var sqrt3 = Math.sqrt(3);
                var left = -2 * radius / sqrt3  + ',' + radius;
                var top = 0 + ',' + -radius;
                var right = 2 * radius / sqrt3  + ',' + radius;
                return 'M' + left + 'L' + top + 'L' + right + 'Z';
            case Constants.STAR:
                radius *= 1.4;
                var r = getr(radius);
                var d = '';
                var i = -1;
                while (++i < 5) {
                    var th = i * deg2rad(72),
                        al = th + deg2rad(36);

                    var a = getPos(th, radius, 3);
                    var b = getPos(al, r, 3);

                    var cmd = i ? 'L' : 'M';
                    d += cmd + a[0] + ',' + a[1];
                    d += 'L' + b[0] + ',' +b[1];
                }
                d += 'z';
                return d;
            case Constants.LOCATION:
                // todo,
                // (40 x 40)
                return 'M14.8-24.2C14.8-32.3,8.3-39,0.1-39s-14.8,6.5-14.8,14.6c0,3.2,1,6.3,2.9,8.9L0,0l11.9-15.5l0,0  C13.8-18,14.8-21.1,14.8-24.2z M0-18.1c-3.2,0-5.8-2.6-5.8-5.8s2.6-5.8,5.8-5.8s5.8,2.7,5.8,5.9S3.2-18.1,0-18.1L0-18.1z';
            default:
                return ''
        }
    };

    function deg2rad (deg) {return deg / 180 * Math.PI}

    function getr (R) {
        return R * Math.sin(deg2rad(18)) / (Math.sin(deg2rad(36)) + Math.sin(deg2rad(18)) * Math.cos(deg2rad(36)) )
    }

    function getPos (th, r, l){
        return [
            (Math.sin(th) * r).toFixed(l),
            (-Math.cos(th) * r).toFixed(l)
        ]
    }

    return svg;
});
/**
 * Created by eason on 2017/4/10.
 */

define('vector/shape/CircleMarker',['require','./Path','../../utils/BaseUtils','../../chart/map/LatLng','../../chart/map/LatLngBounds','../../utils/PathGenerator','../../Constants'],function(require){

    var Path = require("./Path");
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('../../chart/map/LatLng');
    var Bounds = require('../../chart/map/LatLngBounds');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');

    var CircleMarker = Path.extend({

        initialize: function (latlng, options, radius) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
            this._radius = radius;
            this._circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);
        },

        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function (latlng) {
            this._latlng = LatLng.create(latlng);
            this.redraw();
            return this.fire('move', {latlng: this._latlng});
        },

        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function () {
            return this._latlng;
        },

        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function (radius) {
            this._radius = radius;
            return this.redraw();
        },

        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function () {
            return this._radius;
        },

        initAnimate:function (point) {
            this._animate(500, point.delayTime)
        },

        reShowAnimate:function () {
            this._animate(300);
        },

        _animate:function (duration, delayTime) {
            this._path.attr({'d' : this._circle.outerRadius(0)()})
                .animate({
                    delay:delayTime || 0,
                    ease:'bounce',
                    duration:duration,
                    attr:{'d': this._circle.outerRadius(this._radius)()}
                })
        },

        exitAnimate:function (vanchart, animate) {
            var layer = this, group = vanchart._pointLayer;
            animate == false ? group.removeLayer(layer)
                : this._path.animate({
                    ease:'back-in',
                    duration:300,
                    attr:{'d' : this._circle.outerRadius(0)()}
                }).remove().each('end', function () {group.removeLayer(layer);});
        },

        _onMouseState:function(isChosen, duration, ease, style){
            var radius = this._radius + (isChosen ? 1 : 0);
            this._path
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({ease:ease, duration:duration, style:style, attr:{'d': this._circle.outerRadius(radius)()}});
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
        },

        _updateBounds: function () {
            var r = this._radius,
                r2 = this._radiusY || r,
                w = this._clickTolerance(),
                p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },

        _update: function () {
            if (this._map) {
                this._updatePath();
            }
        },

        _updatePath: function () {
            this._path.attr({
                'd': this._circle.outerRadius(this._radius)(),
                'transform': BaseUtils.makeTranslate(this._point)
            });
            this.setStyle();
        },

        _empty: function () {
            return !this._renderer._bounds.intersects(this._pxBounds);
        }
    });

    return CircleMarker;
});
/**
 * Created by eason on 2017/2/7.
 */
define('chart/map/Marker',['require','./../../vector/Layer','./Icon','../../utils/BaseUtils','./LatLng','../../dom/DomUtils','../../vector/Transition','../../dom/Browser','../../utils/BezierEasing'],function(require){

    var Layer = require('./../../vector/Layer');
    var Icon = require('./Icon');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('./LatLng');
    var DomUtils = require('../../dom/DomUtils');
    var Transition = require('../../vector/Transition');
    var Browser = require('../../dom/Browser');
    var BezierEasing = require('../../utils/BezierEasing');

    var Marker = Layer.extend({

        // @section
        // @aka Marker options
        options: {
            // @option icon: Icon = *
            // Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
            icon: new Icon.Default(),

            // Option inherited from "Interactive layer" abstract class
            interactive: true,

            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,

            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,

            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            title: '',

            // @option alt: String = ''
            // Text for the `alt` attribute of the icon image (useful for accessibility).
            alt: '',

            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,

            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,

            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,

            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,

            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: 'markerPane',

            // FIXME: shadowPane is no longer a valid option
            nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
        },

        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */

        initialize: function (latlng, options) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
        },

        onAdd: function (map) {
            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

            if (this._zoomAnimated) {
                map.on('zoomanim', this._animateZoom, this);
            }

            this._initIcon();
            this.update();
        },

        onRemove: function (map) {

            if (this._zoomAnimated) {
                map.off('zoomanim', this._animateZoom, this);
            }

            this._removeIcon();
        },

        getEvents: function () {
            return {
                zoom: this.update,
                viewreset: this.update
            };
        },

        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function () {
            return this._latlng;
        },

        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function (latlng) {
            var oldLatLng = this._latlng;
            this._latlng = LatLng.create(latlng);
            this.update();

            // @event move: Event
            // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
            return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
        },

        update: function () {

            if (this._icon) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }

            return this;
        },

        initAnimate: function (point) {
            var marker = this, lastTranslate;
            // initMarkertranslatetranslate,markerzoommarker
            // translate
            function getTranslate(){
                var trans;
                if(Browser.ie3d || !Browser.any3d){
                    trans = marker._icon ? BaseUtils.makeTranslate(marker._icon._leaflet_pos) : lastTranslate;
                } else {
                    trans = marker._icon ? BaseUtils.makeTranslate3d(marker._icon._leaflet_pos) : lastTranslate;
                }
                lastTranslate = trans;
                return trans;
            }

            function tween() {
                return function (t) {
                    return getTranslate() + 'scale(' + t + ')';
                }
            }

            var useFilterRender = point.series.vanchart.useFilterRender;

            // exituseFilterRenderinitAnimate
            if(useFilterRender){
                this._icon.style.transform =  getTranslate() + 'scale(1)';
            } else {
                this._icon.style.transform = getTranslate() + 'scale(0.01)';
                this._icon.style["transform-origin"] =  "bottom";

                new Transition(this._icon)
                    .delay(point.delayTime || 0)
                    .ease('back-out')
                    .duration(600)
                    .styleTween('transform', tween)
            }
        },

        exitAnimate:function (vanchart) {
            var group = vanchart._pointLayer;
            group.removeLayer(this);
        },

        _onMouseState:function (isChosen) {
            var options = this.options.icon.options, width = options.iconSize[0], height = options.iconSize[1];
            var diff = isChosen ? 2 : 0;
            new Transition(this._icon)
                .ease(BezierEasing.custom["ease-out-back"])
                .duration(300)
                .style({'margin-left':(-width/2-diff)+'px','margin-top':(-height/2-diff)+'px',width:(width+diff*2)+'px',height:(height+2*diff)+'px'});
        },

        _initIcon: function () {
            var options = this.options,
                classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

            var icon = options.icon.createIcon(this._icon),
                addIcon = false;

            // if we're not reusing the icon, remove the old one and init new one
            if (icon !== this._icon) {
                if (this._icon) {
                    this._removeIcon();
                }
                addIcon = true;

                if (options.title) {
                    icon.title = options.title;
                }
                if (options.alt) {
                    icon.alt = options.alt;
                }
            }

            DomUtils.addClass(icon, classToAdd);

            if (options.keyboard) {
                icon.tabIndex = '0';
            }

            this._icon = icon;

            if (addIcon) {
                this.getPane().appendChild(this._icon);
            }
        },

        _removeIcon: function () {

            DomUtils.remove(this._icon);

            this._icon = null;
        },

        _setPos: function (pos) {
            DomUtils.setPosition(this._icon, pos);

            if (this._shadow) {
                DomUtils.setPosition(this._shadow, pos);
            }

            this._zIndex = pos.y + this.options.zIndexOffset;

            this._resetZIndex();
        },

        _updateZIndex: function (offset) {
            this._icon.style.zIndex = this._zIndex + offset;
        },

        _animateZoom: function (opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

            this._setPos(pos);
        },

        _resetZIndex: function () {
            this._updateZIndex(0);
        },

        node:function(){
            return this._icon;
        },

        setStyle:function(){

        }
    });

    return Marker;
});
/**
 * Created by eason on 2017/4/10.
 */

define('vector/shape/ScatterMarker',['require','./Path','../../utils/BaseUtils','../../chart/map/LatLng','../../utils/PathGenerator','../../Constants','../../utils/BezierEasing'],function(require){

    var Path = require('./Path');
    var BaseUtils = require('../../utils/BaseUtils');
    var LatLng = require('../../chart/map/LatLng');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');
    var BezierEasing = require('../../utils/BezierEasing');

    var ScatterMarker = Path.extend({

        initialize: function (latlng, options, marker) {
            BaseUtils.setOptions(this, options);
            this._latlng = LatLng.create(latlng);
            this._marker = marker;
        },

        setLatLng: function (latlng) {
            this._latlng = LatLng.create(latlng);
            this.redraw();
            return this.fire('move', {latlng: this._latlng});
        },

        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function () {
            return this._latlng;
        },

        initAnimate:function (point) {
            this._animate(point.delayTime);
        },

        reShowAnimate:function () {
            this._animate();
        },

        _animate:function (delayTime) {
            var self = this, lastTranslate;

            function getTranslate(){
                var translate = self._point ? BaseUtils.makeTranslate(self._point) : lastTranslate;
                lastTranslate = translate;
                return translate;
            }

            function translateTween(){
                return function (t){
                     return getTranslate() + 'scale('+t+')';
                }
            }

            this._path.attr({'transform' : BaseUtils.makeTranslate(this._point) + 'scale(0.01)'})
                .animate({
                    delay: delayTime || 0,
                    ease: 'back-out',
                    duration: 300,
                    attrTween: {
                        "transform" : translateTween
                    }
                });
        },

        exitAnimate:function (vanchart, animate) {
            var layer = this, group = vanchart._pointLayer;
            animate == false ? group.removeLayer(layer)
                : this._path.animate({
                    ease:'back-in',
                    duration:300,
                    attr:{'transform' : BaseUtils.makeTranslate(this._point) + 'scale(0)'}
                }).remove().each('end', function () {group.removeLayer(layer);});
        },


        _onMouseState:function(isChosen){
            var markerType = this._marker.symbol || "circle";
            var radius = this._marker.radius || 4.5;
            radius = radius + (isChosen ? 2 : 0);

            this._path
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:300,
                    ease:BezierEasing.custom["ease-out-back"],
                    attr:{'d':PathGenerator.getMarkerPath(markerType, radius)}
                })
        },


        _getMarkerPath:function(){
            var markerType = this._marker.symbol || "circle";
            var r = this._marker.radius || 4.5;
            return PathGenerator.getMarkerPath(markerType, r);
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },

        _update: function () {
            if (this._map) {
                this._updatePath();
            }
        },

        _updatePath: function () {
            this._path.attr({
                'd':this._getMarkerPath(),
                'transform':BaseUtils.makeTranslate(this._point)
            });
        },

        _empty: function () {
            return !this._renderer._bounds.intersects(this._pxBounds);
        }

    });

    return ScatterMarker;
});
/**
 * Created by eason on 2017/4/10.
 */
define('vector/shape/TextLayer',['require','../../vector/Layer','../../chart/map/LatLng','../../utils/BaseUtils','../../utils/ColorUtils','../../dom/DomUtils','../Transition','../../utils/BezierEasing'],function(require){

    var Layer = require('../../vector/Layer');
    var LatLng = require('../../chart/map/LatLng');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var DomUtils = require('../../dom/DomUtils');
    var Transition = require('../Transition');
    var BezierEasing = require('../../utils/BezierEasing');

    var GAP = 4;

    var Text = Layer.extend({

        initialize: function (latlng, dataPoint) {
            this._latlng = LatLng.create(latlng);
            this._dataPoint = dataPoint;
        },

        setStyle:function(latlng){

            this._latlng = latlng;

            this.onRemove();

            this.onAdd();
        },

        beforeAdd: function (map) {
            this._renderer = map.getMapRenderer(this);
        },

        _fontSizeState:function (isChosen, duration, ease) {
            var scale = isChosen ? 'translate(0,0)scale(1.1)' : 'translate(0,0)scale(1)';

            new Transition(this._text)
                .ease(ease)
                .duration(duration)
                .style({transform:scale});
        },

        _transformState:function (isChosen) {
            var top = this._point.y - (isChosen ? 2 : 0);

            new Transition(this._text)
                .ease(BezierEasing.custom["ease-out-back"])
                .duration(300)
                .style({top:top+'px'});
        },

        onAdd: function () {

            //html
            this._text = document.createElement('div');
            this._text.style.position = 'absolute';
            this._text.style.zIndex = 1001;
            this._text.style['pointer-events'] = 'none';
            this.getPane().appendChild(this._text);

            var dataPoint = this._dataPoint, labelContent = dataPoint.labelContent,  marker = dataPoint.options.marker, chartType = dataPoint.series.type;
            var centerX = 0, startY = -dataPoint.labelDim.height/2;

            if(chartType == 'scatter' || chartType == 'pointMap'){
                if(marker && !BaseUtils.isImageMarker(marker.symbol)){
                    var radius = marker.radius || 4.5;
                    startY = - radius - dataPoint.labelDim.height;
                }else{
                    var iconHeight = marker ? marker.height : dataPoint.options.icon.iconSize[1];
                    startY = -iconHeight/2 - dataPoint.labelDim.height;
                }
            }

            startY -= GAP;//

            for(var i = 0, count = labelContent.length; i < count; i++){
                var label = labelContent[i];

                var labelDim = label.dim;
                var labelText = label.text;
                var labelStyle = label.style;

                var div = document.createElement('div');
                div.innerHTML = labelText;
                div.style.zIndex = 1001;
                div.style.position = 'absolute';
                div.style.left = -labelDim.width/2 + 'px';
                div.style.top = startY + 'px';
                div.style.overflow = 'hidden';
                div.style.whiteSpace = 'nowrap';

                for(var fontStyle in labelStyle){
                    //ie789color16
                    if(fontStyle == 'color' && labelStyle.color != 'inherit'){
                        div.style.color = ColorUtils.colorToHex(labelStyle.color);
                    }else {
                        div.style[fontStyle] = labelStyle[fontStyle];
                    }
                }
                this._text.appendChild(div);

                startY += (labelDim.height + 2);
            }

            this._reset();
        },

        onRemove: function () {
            DomUtils.remove(this._text);
        },

        getEvents: function () {
            return {
                zoomend: this._project,
                moveend: this._update,
                viewreset: this._reset
            };
        },

        _reset: function () {
            // defined in children classes
            this._project();
            this._update();
        },

        _project: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },

        _update: function () {
            if (this._map) {
                this._text.style.left = this._point.x + 'px';
                this._text.style.top = this._point.y + 'px';
            }
        }
    });

    return Text;

});
/**
 * Created by eason on 2017/2/7.
 */

define('chart/map/PosAnimation',['require','../../dom/Evented','../../dom/DomUtils','../../utils/BaseUtils'],function(require){

    var Evented = require('../../dom/Evented');
    var DomUtils = require('../../dom/DomUtils');
    var BaseUtils = require('../../utils/BaseUtils');


    var PosAnimation = Evented.extend({

        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function (el, newPos, duration, easeLinearity) {
            this.stop();

            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

            this._startPos = DomUtils.getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();

            // @event start: Event
            // Fired when the animation starts
            this.fire('start');

            this._animate();
        },

        // @method stop()
        // Stops the animation (if currently running).
        stop: function () {
            if (!this._inProgress) { return; }

            this._step(true);
            this._complete();
        },

        _animate: function () {
            // animation loop
            this._animId = BaseUtils.requestAnimFrame(this._animate, this);
            this._step();
        },

        _step: function (round) {
            var elapsed = (+new Date()) - this._startTime,
                duration = this._duration * 1000;

            if (elapsed < duration) {
                this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
                this._runFrame(1);
                this._complete();
            }
        },

        _runFrame: function (progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
                pos._round();
            }

            DomUtils.setPosition(this._el, pos);

            // @event step: Event
            // Fired continuously during the animation.
            this.fire('step');
        },

        _complete: function () {
            BaseUtils.cancelAnimFrame(this._animId);

            this._inProgress = false;
            // @event end: Event
            // Fired when the animation ends.
            this.fire('end');
        },

        _easeOut: function (t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });

    return PosAnimation;
});
/**
 * Copyright (c) 2010-2016, Vladimir Agafonkin
 Copyright (c) 2010-2011, CloudMade
 All rights reserved.

 Redistribution and use in source and binary forms, with or without modification, are
 permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this list of
 conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice, this list
 of conditions and the following disclaimer in the documentation and/or other materials
 provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/

/**
 * Created by eason on 2017/1/18.
 */
define('vans/VanChartBaseMap',['require','./VanChart','../utils/BaseUtils','../dom/DomUtils','../Constants','../dom/Evented','../dom/Browser','../utils/Point2D','../utils/Bounds','../chart/map/LatLng','../chart/map/LatLngBounds','../chart/map/PosAnimation'],function(require){

    var VanChart = require('./VanChart');

    var BaseUtils = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var Constants = require('../Constants');

    var Evented = require('../dom/Evented');
    var Browser = require('../dom/Browser');
    var Point = require('../utils/Point2D');
    var Bounds = require('../utils/Bounds');
    var LatLng = require('../chart/map/LatLng');
    var LatLngBounds = require('../chart/map/LatLngBounds');
    var PosAnimation = require('../chart/map/PosAnimation');

    var DEFAULT_ZOOM_LEVEL = 6;

    var VanChartMap = VanChart.extend({

        // @section Methods for modifying map state

        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function (center, zoom, options) {

            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(LatLng.create(center), zoom, this.options.maxBounds);
            options = options || {};

            this._stop();

            if (this._loaded && !options.reset && options !== true) {

                if (options.animate !== undefined) {
                    options.zoom = BaseUtils.extend({animate: options.animate}, options.zoom);
                    options.pan = BaseUtils.extend({animate: options.animate, duration: options.duration}, options.pan);
                }

                // try animating pan or zoom
                var moved = (this._zoom !== zoom) ? this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

                if (moved) {
                    // prevent resize handler call, the view will refresh after animation anyway
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }

            // animation didn't start, just reset the map view
            this._resetView(center, zoom);

            return this;
        },

        // @method setZoom(zoom: Number, options: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function (zoom, options) {
            if (!this._loaded) {
                this._zoom = zoom;
                return this;
            }
            return this.setView(this.getCenter(), zoom, {zoom: options});
        },

        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function (delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
        },

        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function (delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
        },

        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function (latlng, zoom, options) {
            var scale = this.getZoomScale(zoom),
                viewHalf = this.getSize().divideBy(2),
                containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

                centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

            return this.setView(newCenter, zoom, {zoom: options});
        },

        _getBoundsCenterZoom: function (bounds, options) {

            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : LatLngBounds.create(bounds);

            var paddingTL = Point.create(options.paddingTopLeft || options.padding || [0, 0]),
                paddingBR = Point.create(options.paddingBottomRight || options.padding || [0, 0]),

                zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

            zoom = isFinite(zoom) ? zoom : DEFAULT_ZOOM_LEVEL;  //@Cmen:CHART-995

            zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

                swPoint = this.project(bounds.getSouthWest(), zoom),
                nePoint = this.project(bounds.getNorthEast(), zoom),
                center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

            return {
                center: center,
                zoom: zoom
            };
        },

        // @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function (bounds, options) {

            var _bounds = LatLngBounds.create(bounds);

            if (!_bounds.isValid()) {
                throw new Error('Bounds are not valid.');
            }

            if (_bounds.isSame()) {
                return this.setView(bounds[0], DEFAULT_ZOOM_LEVEL, options);
            } else {
                var target = this._getBoundsCenterZoom(_bounds, options);
                return this.setView(target.center, target.zoom, options);
            }
        },

        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function (options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
        },

        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function (center, options) { // (LatLng)
            return this.setView(center, this._zoom, {pan: options});
        },

        // @method panBy(offset: Point): this
        // Pans the map by a given number of pixels (animated).
        panBy: function (offset, options) {
            offset = Point.create(offset).round();
            options = options || {};

            if (!offset.x && !offset.y) {
                return this.fire('moveend');
            }
            // If we pan too far, Chrome gets issues with tiles
            // and makes them disappear or appear in the wrong place (slightly offset) #2602
            if (options.animate !== true && !this.getSize().contains(offset)) {
                this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
                return this;
            }

            if (!this._panAnim) {
                this._panAnim = new PosAnimation();

                this._panAnim.on({
                    'step': this._onPanTransitionStep,
                    'end': this._onPanTransitionEnd
                }, this);
            }

            // don't fire movestart if animating inertia
            if (!options.noMoveStart) {
                this.fire('movestart');
            }

            // animate pan unless animate: false specified
            if (options.animate !== false) {
                DomUtils.addClass(this._mapPane, 'leaflet-pan-anim');

                var newPos = this._getMapPanePos().subtract(offset).round();
                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire('move').fire('moveend');
            }

            return this;
        },

        // @method setMaxBounds(bounds: Bounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function (bounds) {
            bounds = LatLngBounds.create(bounds);

            if (!bounds.isValid()) {
                this.options.maxBounds = null;
                return this.off('moveend', this._panInsideMaxBounds);
            } else if (this.options.maxBounds) {
                this.off('moveend', this._panInsideMaxBounds);
            }

            this.options.maxBounds = bounds;

            if (this._loaded) {
                this._panInsideMaxBounds();
            }

            return this.on('moveend', this._panInsideMaxBounds);
        },

        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function (bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(),
                newCenter = this._limitCenter(center, this._zoom, LatLngBounds.create(bounds));

            if (!center.equals(newCenter)) {
                this.panTo(newCenter, options);
            }

            this._enforcingBounds = false;
            return this;
        },

        // @method invalidateSize(options: Zoom/Pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.

        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function (options) {
            if (!this._loaded) { return this; }

            options = BaseUtils.extend({
                animate: false,
                pan: true
            }, options === true ? {animate: true} : options);

            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;

            var newSize = this.getSize(),
                oldCenter = oldSize.divideBy(2).round(),
                newCenter = newSize.divideBy(2).round(),
                offset = oldCenter.subtract(newCenter);

            if (!offset.x && !offset.y) { return this; }

            if (options.animate && options.pan) {
                this.panBy(offset);

            } else {
                if (options.pan) {
                    this._rawPanBy(offset);
                }

                this.fire('move');

                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(BaseUtils.bind(this.fire, this, 'moveend'), 200);
                } else {
                    this.fire('moveend');
                }
            }

            // @section Map state change events
            // @event resize: ResizeEvent
            // Fired when the map is resized.
            return this.fire('resize', {
                oldSize: oldSize,
                newSize: newSize
            });
        },

        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function () {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
                this.fire('viewreset');
            }
            return this._stop();
        },

        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function () {

            DomUtils.remove(this._mapPane);

            DomUtils.remove(this._controlContainer);

            if (this._loaded) {
                // @section Map state change events
                // @event unload: Event
                // Fired when the map is destroyed with [remove](#map-remove) method.
                this.fire('unload');
            }

            for (var i in this._layers) {
                this._layers[i].remove();
            }

            VanChart.prototype.remove.call(this);
            return this;
        },

        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a children of `container`, or
        // as a children of the main map pane if not set.
        createPane: function (name, container) {
            var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
                pane = DomUtils.create('div', className, container || this._mapPane);

            if (name) {
                this._panes[name] = pane;
            }
            return pane;
        },

        // @section Methods for Getting Map State

        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function () {
            this._checkIfLoaded();

            if (this._lastCenter && !this._moved()) {
                return this._lastCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },

        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function () {
            return this._zoom;
        },

        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function () {
            var bounds = this.getPixelBounds(),
                sw = this.unproject(bounds.getBottomLeft()),
                ne = this.unproject(bounds.getTopRight());

            return new LatLngBounds(sw, ne);
        },

        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function () {
            return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
        },

        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function () {
            return this.options.maxZoom === undefined ?
                (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
                this.options.maxZoom;
        },

        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
            bounds = LatLngBounds.create(bounds);
            padding = Point.create(padding || [0, 0]);

            var zoom = this.getZoom() || 0,
                min = this.getMinZoom(),
                max = this.getMaxZoom(),
                nw = bounds.getNorthWest(),
                se = bounds.getSouthEast(),
                size = this.getSize().subtract(padding),
                boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
                snap = Browser.any3d ? this.options.zoomSnap : 1;

            var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
            zoom = this.getScaleZoom(scale, zoom);

            if (snap) {
                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
            }

            return Math.max(min, Math.min(max, zoom));
        },

        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function (center, zoom) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },

        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function () {
            this._checkIfLoaded();
            return this._pixelOrigin;
        },

        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function (zoom) {
            return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
        },

        // @section Other Methods

        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function (pane) {
            return typeof pane === 'string' ? this._panes[pane] : pane;
        },

        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function () {
            return this._panes;
        },

        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function () {
            return this._container;
        },


        // @section Conversion Methods

        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function (toZoom, fromZoom) {
            // TODO replace with universal implementation after refactoring projections
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
        },

        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function (scale, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
            var zoom = crs.zoom(scale * crs.scale(fromZoom));
            return isNaN(zoom) ? Infinity : zoom;
        },

        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function (latlng, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(LatLng.create(latlng), zoom);
        },

        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function (point, zoom) {
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(Point.create(point), zoom);
        },

        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function (point) {
            var projectedPoint = Point.create(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },

        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function (latlng) {
            var projectedPoint = this.project(LatLng.create(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },

        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function (latlng) {
            return this.options.crs.wrapLatLng(LatLng.create(latlng));
        },

        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function (latlng1, latlng2) {
            return this.options.crs.distance(LatLng.create(latlng1), LatLng.create(latlng2));
        },

        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function (point) { // (Point)
            return Point.create(point).subtract(this._getMapPanePos());
        },

        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function (point) { // (Point)
            return Point.create(point).add(this._getMapPanePos());
        },

        // @method containerPointToLatLng(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function (point) {
            var layerPoint = this.containerPointToLayerPoint(Point.create(point));
            return this.layerPointToLatLng(layerPoint);
        },

        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function (latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(LatLng.create(latlng)));
        },

        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function (e) {
            return DomUtils.getMousePos(e, this._container);
        },

        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function (e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },

        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function (e) { // (MouseEvent)
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },

        _initContainer: function (id) {
            var container = this._container = DomUtils.get(id);

            !this.bindIEDragCursor() && DomUtils.addClass(container, 'leaflet-grab');
        },

        /**
         * IEdrag&dragging
         * @returns {boolean}
         */
        bindIEDragCursor: function (){
            var _bind = false, option = this.options;
            if(Browser.ie && option.cursor){
                var type = this._mapDragged ? "dragging" : "drag";
                this._container.style.cursor = "url("+option.cursor[type]+"), auto";
                _bind = true;
            }
            return _bind;
        },

        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function (control) {
            control.addTo(this);
            return this;
        },

        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function (control) {
            control.remove();
            return this;
        },

        _initControlPos: function () {
            var corners = this._controlCorners = {},
                l = 'leaflet-',
                container = this._controlContainer =
                    DomUtils.create('div', l + 'control-container', this._container);

            function createCorner(vSide, hSide) {
                var className = l + vSide + ' ' + l + hSide;

                corners[vSide + hSide] = DomUtils.create('div', className, container);
            }

            createCorner('top', 'left');
            createCorner('bottom', 'right');
        },

        // private methods that modify map state

        // @section Map state change events
        _resetView: function (center, zoom) {
            DomUtils.setPosition(this._mapPane, new Point(0, 0));

            var loading = !this._loaded;
            this._loaded = true;
            zoom = this._limitZoom(zoom);

            this.fire('viewprereset');

            var zoomChanged = this._zoom !== zoom;
            this
                ._moveStart(zoomChanged)
                ._move(center, zoom)
                ._moveEnd(zoomChanged);

            // @event viewreset: Event
            // Fired when the map needs to redraw its content (this usually happens
            // on map zoom or load). Very useful for creating custom overlays.
            this.fire('viewreset');

            // @event load: Event
            // Fired when the map is initialized (when its center and zoom are set
            // for the first time).
            if (loading) {
                this.fire('load');
            }
        },

        _moveStart: function (zoomChanged) {
            // @event zoomstart: Event
            // Fired when the map zoom is about to change (e.g. before zoom animation).
            // @event movestart: Event
            // Fired when the view of the map starts changing (e.g. user starts dragging the map).
            if (zoomChanged) {
                this.fire('zoomstart');
            }
            return this.fire('movestart');
        },

        _move: function (center, zoom, data) {
            if (zoom === undefined) {
                zoom = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom;

            this._zoom = zoom;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);

            // @event zoom: Event
            // Fired repeatedly during any change in zoom level, including zoom
            // and fly animations.
            if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
                this.fire('zoom', data);
            }

            // @event move: Event
            // Fired repeatedly during any movement of the map, including pan and
            // fly animations.
            return this.fire('move', data);
        },

        _moveEnd: function (zoomChanged) {
            // @event zoomend: Event
            // Fired when the map has changed, after any animations.
            if (zoomChanged) {
                this.drawAllEffects();
                var vanchart = this;
                // 
                // 
                // zoomzoom
                // moveEndzoomChangedrenderLabel
                // 2017-08-03  ()>1zoom&setView
                // validPoints(vanchartMap.layoutComponentsAndChartsgeo.doLayoutanimateZoomvalidPoints)
                // 
                this.validPoints && this.setTimeout("zoom_label_update", function (){
                    vanchart._updateNormalLabel();
                }, 350);
                this.fire('zoomend');
            }

            // @event moveend: Event
            // Fired when the center of the map stops changing (e.g. user stopped
            // dragging the map).
            return this.fire('moveend');
        },

        _stop: function () {
            BaseUtils.cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
                this._panAnim.stop();
            }
            return this;
        },

        _rawPanBy: function (offset) {
            DomUtils.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },

        _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom();
        },

        _panInsideMaxBounds: function () {
            if (!this._enforcingBounds) {
                this.panInsideBounds(this.options.maxBounds);
            }
        },

        _checkIfLoaded: function () {
            if (!this._loaded) {
                throw new Error('Set map center and zoom first.');
            }
        },

        _onResize: function () {
            BaseUtils.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = BaseUtils.requestAnimFrame(
                function () { this.invalidateSize({debounceMoveend: true}); }, this);
        },

        _performZoom: function () {
            var map = this,
                zoom = map.getZoom(),
                snap = this.options.zoomSnap || 0;

            map._stop(); // stop panning and fly animations if any

            // map the delta with a sigmoid function to -4..4 range leaning on -1..1
            var d2 = this._delta / (this.options.wheelPxPerZoomLevel * 4),
                d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
                d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
                delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

            this._delta = 0;
            this._startTime = null;

            if (!delta) { return; }

            if (map.options.scrollWheelZoom === 'center') {
                map.setZoom(zoom + delta);
            } else {
                map.setZoomAround(this._lastMousePos, zoom + delta);
            }
        },

        // @section Other Methods

        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function (callback, context) {
            if (this._loaded) {
                callback.call(context || this, {target: this});
            } else {
                this.on('load', callback, context);
            }
            return this;
        },

        _getMapPanePos: function () {
            return DomUtils.getPosition(this._mapPane) || new Point(0, 0);
        },

        _moved: function () {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
        },

        _getTopLeftPoint: function (center, zoom) {
            var pixelOrigin = center && zoom !== undefined ?
                this._getNewPixelOrigin(center, zoom) :
                this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
        },

        _getNewPixelOrigin: function (center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },

        _latLngToNewLayerPoint: function (latlng, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return this.project(latlng, zoom)._subtract(topLeft);
        },

        _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom);
            return Bounds.create([
                this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
                this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
            ]);
        },

        // layer point of the current center
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },

        // offset of the specified place to the current center in pixels
        _getCenterOffset: function (latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },

        // adjust center for view to get inside bounds
        _limitCenter: function (center, zoom, bounds) {

            if (!bounds) { return center; }

            var centerPoint = this.project(center, zoom),
                viewHalf = this.getSize().divideBy(2),
                viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                offset = this._getBoundsOffset(viewBounds, bounds, zoom);

            // If offset is less than a pixel, ignore.
            // This prevents unstable projections from getting into
            // an infinite loop of tiny offsets.
            if (offset.round().equals([0, 0])) {
                return center;
            }

            return this.unproject(centerPoint.add(offset), zoom);
        },

        // adjust offset for view to get inside bounds
        _limitOffset: function (offset, bounds) {
            if (!bounds) { return offset; }

            var viewBounds = this.getPixelBounds(),
                newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },

        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
            var projectedMaxBounds = Bounds.create(
                this.project(maxBounds.getNorthEast(), zoom),
                this.project(maxBounds.getSouthWest(), zoom)
                ),
                minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
                maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

                dx = this._rebound(minOffset.x, -maxOffset.x),
                dy = this._rebound(minOffset.y, -maxOffset.y);

            return new Point(dx, dy);
        },

        _rebound: function (left, right) {
            return left + right > 0 ?
            Math.round(left - right) / 2 :
            Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },

        _limitZoom: function (zoom) {
            var min = this.getMinZoom(),
                max = this.getMaxZoom(),
                snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
                if(Browser.any3d){
                    zoom = Math.round(zoom / snap) * snap;
                } else {
                    zoom = (zoom / snap) * snap;
                    zoom = zoom > this._zoom ? Math.ceil(zoom) : Math.floor(zoom); // zoom = 5.5, this._zoom = 6; IE8snap1math.round(5.5) = 6
                }
            }
            return Math.max(min, Math.min(max, zoom));
        },

        _onPanTransitionStep: function () {
            this.fire('move');
        },

        _onPanTransitionEnd: function () {
            DomUtils.removeClass(this._mapPane, 'leaflet-pan-anim');
            this.fire('moveend');
        },

        _tryAnimatedPan: function (center, options) {
            // difference between the new and current centers in pixels
            var offset = this._getCenterOffset(center)._floor();

            // don't animate too far unless animate: true specified in options
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

            this.panBy(offset, options);

            return true;
        },

        _nothingToAnimate: function () {
            return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
        },

        _tryAnimatedZoom: function (center, zoom, options) {
            // @CmenMoreLabel, 
            this.removeMoreLabel();

            if (this._animatingZoom) { return true; }

            options = options || {};

            // don't animate if disabled, not supported or zoom difference is too large
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
                Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

            // offset is the pixel coords of the zoom origin relative to the current center
            var scale = this.getZoomScale(zoom),
                offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

            // don't animate if the zoom origin isn't within one screen from the current center, unless forced
            if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

            BaseUtils.requestAnimFrame(function () {
                this
                    ._moveStart(true)
                    ._animateZoom(center, zoom, true);
            }, this);

            return true;
        },

        _animateZoom: function (center, zoom, startAnim, noUpdate) {
            if (startAnim) {
                this._animatingZoom = true;

                // remember what center/zoom to set after animation
                this._animateToCenter = center;
                this._animateToZoom = zoom;

                DomUtils.addClass(this._mapPane, 'leaflet-zoom-anim');
            }

            // @event zoomanim: ZoomAnimEvent
            // Fired on every frame of a zoom animation
            this.fire('zoomanim', {
                center: center,
                zoom: zoom,
                noUpdate: noUpdate
            });

            // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
            setTimeout(BaseUtils.bind(this._onZoomTransitionEnd, this), 250);
        },

        _onZoomTransitionEnd: function () {
            if (!this._animatingZoom) { return; }

            DomUtils.removeClass(this._mapPane, 'leaflet-zoom-anim');

            this._animatingZoom = false;

            this._move(this._animateToCenter, this._animateToZoom);

            // This anim frame should prevent an obscure iOS webkit tile loading race condition.
            BaseUtils.requestAnimFrame(function () {
                this._moveEnd(true);
            }, this);
        },

        addLayer: function (layer) {
            var id = BaseUtils.stamp(layer);
            if (this._layers[id]) { return this; }
            this._layers[id] = layer;

            layer._mapToAdd = this;

            if (layer.beforeAdd) {
                layer.beforeAdd(this);
            }

            this.whenReady(layer._layerAdd, layer);

            return this;
        },

        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function (layer) {
            var id = BaseUtils.stamp(layer);

            if (!this._layers[id]) { return this; }

            if (this._loaded) {
                layer.onRemove(this);
            }

            delete this._layers[id];

            if (this._loaded) {
                this.fire('layerremove', {layer: layer});
                layer.fire('remove');
            }

            layer._map = layer._mapToAdd = null;

            return this;
        },

        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function (layer) {
            return !!layer && (BaseUtils.stamp(layer) in this._layers);
        },

        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },

        _addZoomLimit: function (layer) {
            if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
                this._zoomBoundLayers[BaseUtils.stamp(layer)] = layer;
                this._updateZoomLevels();
            }
        },

        _removeZoomLimit: function (layer) {
            var id = BaseUtils.stamp(layer);

            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }
        },

        _updateZoomLevels: function () {
            var minZoom = Infinity,
                maxZoom = -Infinity,
                oldZoomSpan = this._getZoomSpan();

            for (var i in this._zoomBoundLayers) {
                var options = this._zoomBoundLayers[i].options;

                minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
                maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }

            this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

            if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
                this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
                this.setZoom(this._layersMinZoom);
            }
        }
    });

    return VanChartMap;
});


/**
 * Created by eason on 2017/4/10.
 */

define('vans/VanChartMap',['require','../vector/SvgRenderer','../vector/VmlRenderer','../vector/CanvasRenderer','./VanChartLayout','../ChartLibrary','../ComponentLibrary','../chart/map/LineMapLayer','../chart/map/CanvasMapLayer','../chart/map/HeatMapOverlay','../chart/map/Icon','../utils/QueryUtils','../utils/BaseUtils','../dom/DomUtils','../dom/Browser','../Constants','../utils/BoundsManager','../chart/map/CRS','../utils/Point2D','../chart/map/LatLng','../vector/shape/LayerGroup','../vector/shape/CircleMarker','../chart/map/Marker','../vector/shape/ScatterMarker','../vector/shape/TextLayer','./VanChartBaseMap','./VanChartLibrary','./VanChartLibrary','./VanChartLibrary','./VanChartLibrary'],function(require){

    var SvgRenderer = require('../vector/SvgRenderer');
    var VmlRenderer = require('../vector/VmlRenderer');
    var CanvasRenderer = require('../vector/CanvasRenderer');

    var VanChartLayout = require('./VanChartLayout');
    var ChartLibrary = require('../ChartLibrary');
    var ComponentLibrary = require('../ComponentLibrary');
    var lineMapLayer = require('../chart/map/LineMapLayer');
    var CanvasMapLayer = require('../chart/map/CanvasMapLayer');
    var HeatMapOverlay = require('../chart/map/HeatMapOverlay');
    var Icon = require('../chart/map/Icon');

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var Browser = require('../dom/Browser');
    var Constants = require('../Constants');
    var BoundsManager = require('../utils/BoundsManager');

    var CRS = require('../chart/map/CRS');
    var Point = require('../utils/Point2D');
    var LatLng = require('../chart/map/LatLng');
    var LayerGroup = require('../vector/shape/LayerGroup');
    var CircleMarker = require('../vector/shape/CircleMarker');
    var Marker = require('../chart/map/Marker');
    var ScatterMarker = require('../vector/shape/ScatterMarker');
    var TextLayer = require('../vector/shape/TextLayer');

    var VanChartBaseMap = require("./VanChartBaseMap");

    var PINCH_SCALE = 1,  // pinch,pinchstart1pinch.scale
        PINCH_SCALE_INTERVAL = 0.1;  // pinchscale,

    var VanChartMap = VanChartBaseMap.extend({

        vanChartType:'vanChartMap',

        _initDomLayout: function (dom) {

            var options = this.options;

            this._initContainer(dom);
            this._initLayout();

            this.on(this.getEvents(), this);

            this.dom = this._controlCorners['topleft'];

            if (options.maxBounds) {
                this.setMaxBounds(options.maxBounds);
            }

            if (options.zoom !== undefined) {
                this._zoom = this._limitZoom(options.zoom);
            }

            if (options.center && options.zoom !== undefined) {
                this.setView(LatLng.create(options.center), options.zoom, {reset: true});
            }

            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;

            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
            this._zoomAnimated = DomUtils.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

            // zoom transitions run with the same duration for all layers, so if one of transitionend events
            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
            if (this._zoomAnimated) {
                // this._createAnimProxy();
                // L.DomEvent.on(this._proxy, DomUtils.TRANSITION_END, this._catchTransitionEnd, this);
            }

            VanChartBaseMap.prototype._initDomLayout.call(this, this._controlCorners['topleft']);
        },

        setOptions:function(options){

            VanChartBaseMap.prototype.setOptions.call(this, options);

            options = this.options;

            if(options.backgroundImage || options.backgroundColor || options.borderWidth){
                BaseUtils.setDomBackground(this.wrapDom, {
                    backgroundImage:options.backgroundImage,
                    backgroundColor:options.backgroundColor,
                    borderColor:options.borderColor,
                    borderWidth:options.borderWidth,
                    borderRadius:options.borderRadius,
                    shadow:options.shadow
                });
            }


            if(this.layerIndex === 0){
                return;
            }

            //
            if(this.layerMap && this.layerMap.length){

                this.series.forEach(function(ser){
                    ser.remove();
                });

                this.components.geo.remove();

                this.series = this.layerMap[0].series;
                this.components.geo = this.layerMap[0].geo;
            }

            if(this.options.initDrillPath && this.options.initDrillPath.length > 1){
                this.series.forEach(function(ser){
                    ser.remove();
                });
                this.series = [];
            }
        },

        getMapRenderer:function(){

            var dom = this._panes['overlayPane'];

            if(!this.mapRenderer){
                this.mapRenderer = BaseUtils.isSupportSVG() ? new SvgRenderer(dom, this) : new VmlRenderer(dom, this);
                this.addLayer(this.mapRenderer);
            }

            return this.mapRenderer;
        },

        getEvents:function(){

            return {
                'mousemove':this._onMouseMove,

                'scroll':this._onScroll,

                'panstart':this._onPanStart,

                'panmove':this._onPanMove,

                'panend':this._onPanEnd,

                'wheel':this._onWheelScroll,

                'pinchstart': this._pinchStart,

                'pinchmove':this._onPinch,

                'zoom':this._onZoom
            };
        },

        registerInteractiveTarget: function (data, elementWrapper) {
            VanChartBaseMap.prototype.registerInteractiveTarget.call(this, data, elementWrapper);
            data.addEventParent(this);
        },

        _zoomEnabled:function(){
            return this.options.geo.zoom;
        },

        _onMouseMove:function(ev){
            this.cancelLegendHighlight(ev.containerPoint);
        },

        _onScroll: function () {
            this._container.scrollTop  = 0;
            this._container.scrollLeft = 0;
        },

        //mark the start of drag
        _onPanStart:function(event){

            if(this._zoomEnabled()){

                this._initPos = DomUtils.getPosition(this._mapPane);

                this._startPoint = event.containerPoint;

                // MoreLabel
                this.removeMoreLabel();

                // dragging,this._container
                this._mapDragged = true;
                this.bindIEDragCursor();

                this._stop();
            }
        },

        _onPanMove:function(event){

            if(this._zoomEnabled()){

                BaseUtils.cancelAnimFrame(this._animRequest);

                var offset = event.containerPoint.subtract(this._startPoint);
                this._newPos = this._initPos.add(offset);
                this._animRequest = BaseUtils.requestAnimFrame(function(){

                    DomUtils.setPosition(this._mapPane, this._newPos);

                }, this, true);

                DomUtils.addClass(document.body, 'leaflet-dragging');

            }

        },

        _onPanEnd: function () {

            if(this._zoomEnabled()){

                this.fire('moveend');
                // drag
                this._mapDragged = false;
                this.bindIEDragCursor();

                DomUtils.removeClass(document.body, 'leaflet-dragging');

                var pos = this._getMapPanePos();
                if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
                    // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
                    this._resetView(this.getCenter(), this.getZoom());
                }

            }

        },


        _pinchStart: function(){
            PINCH_SCALE = 1;
        },

        _onPinch:function(e){
            var eventScale = e.scale, map = this, pointCenterArray = [];
            if(!this._zoomEnabled()){
                return;
            }
            // 
            if(Math.abs(PINCH_SCALE - eventScale) < PINCH_SCALE_INTERVAL) {
                return;
            }

            var zoomType = PINCH_SCALE > eventScale ? -1 : 1;  // 

            // @Cmen=CHART-839:-->
            // chartTypechartTypeareaMaplineMap
            map.series.forEach(function (ser){
                var isPointMap = ser.type === Constants.POINT_MAP,
                    isAreaMap  = ser.type === Constants.AREA_MAP;
                if(isPointMap || isAreaMap ) {
                    var points = ser.points;
                    points.forEach(function (point) {
                        var layers = point.layers || [];
                        layers.forEach(function (layer) {
                            var center = isPointMap ? point.getLatLng() : (layer.getCenter ? layer.getCenter() : null);  // layer.getCenter
                            center && pointCenterArray.push({
                                point : point,
                                distance : map.latLngToContainerPoint(center).distanceTo(e.containerPoint)
                            })
                        })
                    });
                }
            });

            pointCenterArray.sort(function (p1, p2){
                return p1.distance - p2.distance;
            });

            this.hoverPoint = pointCenterArray.length && pointCenterArray[0].point;


            this._pinchZoom = map._limitZoom(map.getZoom() + zoomType * Math.abs(eventScale - 1));
            this._pinchCenter = e.center;

            if (!this._pinchStartTime) {
                this._pinchStartTime = +new Date();
            }

            var debounce = this.options.wheelDebounceTime;
            var left = Math.max(debounce - (+new Date() - this._pinchStartTime), 0);

            // 
            clearTimeout(this._pinchTimer);
            this._pinchTimer = setTimeout(function(){
                map._stop(); // stop panning and fly animations if any
                map._pinchStartTime = null;
                map.setZoomAround(Point.create(map._pinchCenter),  map._pinchZoom);
            }, left);


            PINCH_SCALE = eventScale;
        },

        _onWheelScroll:function(e){

            if(!this._zoomEnabled()){
                return;
            }

            e = e.srcEvent;
            var delta = DomUtils.getWheelDelta(e);

            var debounce = this.options.wheelDebounceTime;

            this._delta = BaseUtils.pick(this._delta, 0);
            this._delta += delta;
            this._lastMousePos = this.mouseEventToContainerPoint(e);

            if (!this._startTime) {
                this._startTime = +new Date();
            }

            var left = Math.max(debounce - (+new Date() - this._startTime), 0);

            clearTimeout(this._timer);
            this._timer = setTimeout(BaseUtils.bind(this._performZoom, this), left);

            DomUtils.stop(e);
        },

        //
        _animationEnd:function(){
            this._animationStarted = false;
            this._consoleDone();

            this.drawAllEffects();
        },

        _animationStart:function(){
            //fire'animationEnd'
            this._animationStarted = true;
            // this.animationCount = 0;   renderSeries

            var vanchart = this;

            // renderSeriesanimationEnd,
            // effectanimationStartanimationEnd
            // 250
            if (!this.animationCount) {
                this.setTimeout("chart_animation_end", function (){
                    vanchart.fire('animationEnd');
                }, 250)
            }
        },

        _initLayout: function () {
            var container = this._container;

            this._fadeAnimated = !this.options.toPhantom && this.options.fadeAnimation && Browser.any3d;

            DomUtils.addClass(container, 'leaflet-container' +
                (Browser.touch ? ' leaflet-touch' : '') +
                (Browser.retina ? ' leaflet-retina' : '') +
                (Browser.ielt9 ? ' leaflet-oldie' : '') +
                (Browser.safari ? ' leaflet-safari' : '') +
                (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

            var position = DomUtils.getStyle(container, 'position');

            if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                container.style.position = 'relative';
            }

            this._initPanes();

            this._initControlPos();
        },

        _initPanes: function () {
            var panes = this._panes = {};

            this._mapPane = this.createPane('mapPane', this._container);
            DomUtils.setPosition(this._mapPane, new Point(0, 0));

            // @pane tilePane: HTMLElement = 200
            // Pane for `GridLayer`s and `TileLayer`s
            this.createPane('tilePane');
            // @pane overlayPane: HTMLElement = 400
            // Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
            this.createPane('overlayPane');
            // @pane markerPane: HTMLElement = 600
            // Pane for `Icon`s of `Marker`s
            this.createPane('markerPane');

            if (!this.options.markerZoomAnimation) {
                DomUtils.addClass(panes.markerPane, 'leaflet-zoom-hide');
            }
        },

        layoutComponentsAndCharts:function(){

            this.initLayerInfo();

            var vanchart = this;
            vanchart.bounds = vanchart._getDefaultBounds();

            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in vanchart.components) {
                    vanchart.components[c].doLayout();
                }
            }, this);

            this.reRenderSeries();
        },

        filterRender:function(){
            /**
             * exitupdaterender
             * renderer.isAnimationfalserenderSeries
             * 
             * noAnimation, ele.animateJS
             * +
             * useFilterRendertruelayeruseFilterRender
             * @type {boolean}
             */
            this.useFilterRender = true;
            this.renderSeries();
            this.useFilterRender = false;
        },

        _updateSeriesStyle:function(){

            this.validPoints.forEach(function(point){

                if(!point.layers || !point.visible){
                    return ;//removed
                }

                var style = point.series._getDynamicStyle(point);

                point.layers.forEach(function(layer){

                    layer.setStyle(style);

                });

            });

        },

        reRenderWholePlot:function(){
            var legend = this.components[ComponentLibrary.LEGEND_COMPONENT];
            legend && legend.render();
            this.reRenderSeries();
        },

        //
        refreshRestore:function(){
            this._initIntermediateState();

            for(var component in this.components){
                this.components[component].refresh();
            }

            this.series.forEach(function(ser, index){
                ser.refresh(ser.options, index);
            });

            var rangeLegend = this.components[ComponentLibrary.RANGE_LEGEND_COMPONENT];
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            this.series.forEach(function(ser){
                // try in large mode
                if (ser.type === Constants.LINE_MAP && ser.options.large) {
                    return;
                }
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            this.layoutComponentsAndCharts();
        },

        reRenderSeries:function(){

            this.hoverPoint = this.hoverSeries = null;

            this.calculateMapSeries();

            this.render();
        },

        calculateMapSeries:function(){
            var vanchart = this;
            vanchart.hoverPoint = null; vanchart.hoverSeries = null;

            var bubbleSeries = vanchart.seriesOfType(Constants.BUBBLE_CHART);
            VanChartLayout.calculateBubbleRadius(bubbleSeries);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.BUBBLE_CHART), Constants.BUBBLE_CHART);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.SCATTER_CHART), Constants.SCATTER_CHART);
            VanChartLayout.calculateDelayTime(vanchart, vanchart.seriesOfType(Constants.POINT_MAP), Constants.BUBBLE_CHART);

            //
            var nameMap = {}, nullNameMap = {}, series = this.series;
            for(var i = 0, count = series.length; i < count; i++){
                var total = 0, ser = series[i], type = ser.type, points = ser.points;
                points.forEach(function(point){
                    total = BaseUtils.accAdd(total, Math.abs(point.getTargetValue()));
                });

                points.forEach(function(point){
                    point.percentage = Math.abs(point.getTargetValue()/total);
                    var key = point.options.lnglat ?  point.options.lnglat.join('-') : point.name;
                    key = key + type;

                    var usedMap = point.isNull ? nullNameMap : nameMap;
                    usedMap[key] = usedMap[key] || [];
                    usedMap[key].push(point);
                });
            }

            // todo
            // dev 
            // 1. linemap 
            // 2. 
            for(var name in nameMap){
                var allPoints = nameMap[name].concat(nullNameMap[name] || []);

                allPoints.forEach(function(point){
                    if(point.series.type === Constants.LINE_MAP){
                        return;
                    }

                    point.points = allPoints;//points

                    // @eason:
                    // 1. meaningless nesting loop
                    // 2. this search from end to beginning thoroughly without a break?
                    if(!point.options.drilldown){//drilldown
                        for(var i = allPoints.length - 1; i >= 0; i--){
                            if(allPoints[i].options.drilldown){
                                point.options.drilldown = allPoints[i].options.drilldown;
                                point.geo = allPoints[i].geo;
                            }
                        }
                    }

                    point.series.calculateLabelInfo(point);
                });
            }

            this.validPoints = this._getMapPoints();
        },

        //
        //2.()
        //3.feature,
        _getMapPoints:function(){
            var vanchart = this;
            var keyMap = {}, validPoints = [];
            var geo = vanchart.getCurrentGeo();
            var isNormalLegend = this.getComponent(ComponentLibrary.LEGEND_COMPONENT);

            vanchart.series.forEach(function(ser, seriesIndex){

                var points = ser.points, type = ser.type;

                if(type === Constants.LINE_MAP ){ 
                    return; 
                } 

                for(var i = 0, len = points.length; i < len; i++){
                    var point = points[i];

                    if(!vanchart.isMapPointVisible(point)){
                        vanchart.removePointGraphics(point);
                        continue;
                    }

                    //drilldown
                    if(seriesIndex === 0 && point.isNull && point.options.drilldown){
                        continue;
                    }

                    var features = geo.getFeaturesByName(point.name, type);

                    if(features || point.options.lnglat){

                        var key = type == Constants.AREA_MAP ? point.name : geo.getDataPointLngLat(point, features && features[0]).join('-');

                        if(!keyMap[key] || (isNormalLegend && type == Constants.BUBBLE_CHART)){

                            validPoints.push(point);

                            keyMap[key] = true;
                        }else{
                            vanchart.removePointGraphics(point,type, false); // 
                        }
                    }
                }
            });
            return validPoints;
        },

        isMapPointVisible:function(point){
            var hasRangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

            if(hasRangeLegend && point.points && point.points.length){
                point = point.points[0];
            }

            if(point.isNull){

                //
                //areaMapdrilldown
                var type = point.series.type;
                var marker = point.options.marker;
                var isImageMarker = marker && BaseUtils.isImageMarker(marker.symbol);

                var nullVisibility = type == Constants.AREA_MAP ? point.options.drilldown : (type == Constants.POINT_MAP || isImageMarker);

                return point && point.visible && point.series.visible && nullVisibility;
            }

            return point.isVisible();
        },

        initLayerInfo:function(){

            if(this.layerMap){
                //options
                return;
            }

            this.layerMap = []; this.layerIndex = 0;

            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);
            var series = this.series;
            this.layerMap = [{series:series, geo:geo, layerIndex:this.layerIndex, drillUpDataPoint:(series[0] && series[0].points[0])}];

            var drillPath = this.options.initDrillPath;
            if(drillPath && drillPath.length > 1){
                for (var i = 1; i < drillPath.length; i++) {
                    var name = drillPath[i];

                    var point = null;
                    for (var j = 0; j < series.length; j++) {
                        var points = series[j].points;

                        for (var k = 0; k < points.length; k++) {
                            if (points[k].options.drilldown && points[k].options.drilldown.geo.name == name) {
                                point = points[k];
                                break;
                            }
                        }

                        if (point) {
                            break;
                        }
                    }
                    if(point){

                        this._createChildSeriesWhenLoaded(point);

                        this.layerMap[this.layerIndex].drillUpDataPoint = point;

                        this.series = series = point.childSeries;
                        var rangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
                        if(rangeLegend){
                            rangeLegend.initAttributesWithSeries();
                        }

                        series.forEach(function(ser){
                            for(var i = 0, len = ser.points.length; i < len; i++){
                                ser.points[i].refreshPointColor();
                            }
                        });

                        this.layerIndex++;

                        geo = point.geo;

                        this.layerMap[this.layerIndex] = {geo:geo, series:series, layerIndex:this.layerIndex};

                        this.setComponent(geo, ComponentLibrary.GEO_COMPONENT);
                    }
                }
            }
        },

        _createChildSeriesWhenLoaded:function(point){
            if(point.childSeries){
                return;
            }
            var childSeries = [], vanchart = this;
            vanchart.parentPoint = point;

            point.options.drilldown.series.forEach(function(sery, index){
                var classType = sery.type || vanchart.options.chartType;
                var Class = ChartLibrary.get(classType);
                childSeries.push(new Class(sery, vanchart, index));
            });

            point.childSeries = childSeries;
        },

        drillDown:function(dataPoint){
            var lastLayer = this.layerMap[this.layerIndex - 1];
            if(dataPoint.options.drilldown && dataPoint.options.drilldown.series && (!lastLayer || lastLayer.drillUpDataPoint != dataPoint)){

                this._createChildSeriesWhenLoaded(dataPoint);

                this.layerMap[this.layerIndex].drillUpDataPoint = dataPoint;

                this._setNewGeoAndSeries(dataPoint.geo, dataPoint.childSeries, this.layerIndex + 1);
            }
        },

        drillUp:function(iconData){
            var vanchart = this;

            if(iconData.series == vanchart.series){
                return;
            }

            this._setNewGeoAndSeries(iconData.geo, iconData.series, iconData.layerIndex);
        },

        _setNewGeoAndSeries:function(geo, series, newLayerIndex){

            var vanchart = this;

            //layer
            for(var i = 0, len = vanchart.series.length; i < len; i++){
                var ser = vanchart.series[i], type = ser.type, points = ser.points;
                points.forEach(function(point){
                    vanchart.removePointGraphics(point, type);
                });
            }
            this._canvasMapLayer && this._canvasMapLayer.setData([]);

            vanchart.series = series;

            var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                rangeLegend.initAttributesWithSeries();
            }

            series.forEach(function(ser){
                for(var i = 0, len = ser.points.length; i < len; i++){
                    ser.points[i].refreshPointColor();
                }
            });

            var lastGeo = this.layerMap[this.layerIndex] ? this.layerMap[this.layerIndex].geo : undefined;

            this.layerMap[newLayerIndex] = {geo:geo, series:series, layerIndex:newLayerIndex, drillUpDataPoint:(series[0] && series[0].points[0])};

            this.layerIndex = newLayerIndex;

            this.layerMap = this.layerMap.slice(0, newLayerIndex + 1);

            lastGeo && lastGeo.remove();

            this.setComponent(geo, ComponentLibrary.GEO_COMPONENT);

            this.layoutComponentsAndCharts()
        },

        cancelLegendHighlight:function(containerPoint){
            var highlightTarget = this.highlightTarget;
            VanChartBaseMap.prototype.cancelLegendHighlight.call(this, containerPoint);
            if (this._lineMapLayer && highlightTarget) {
                this._lineMapLayer.redraw();
            }
        },

        makeLegendHighlight:function(target){
            VanChartBaseMap.prototype.makeLegendHighlight.call(this, target);
            if (this._lineMapLayer) {
                this._lineMapLayer.redraw();
            }
        },

        getEffectLayer:function () {
            var vanchart = this;

            if(!vanchart._effectLayer){
                vanchart._effectLayer = new LayerGroup().addTo(vanchart);
            }

            return vanchart._effectLayer;
        },

        renderSeries:function(){
            this.removeMoreLabel();
            this.animationCount = 0;  // renderSeries

            this.getComponent(ComponentLibrary.TOOLTIP_COMPONENT).immediateHide();

            //
            var vanchart = this, series = vanchart.series, geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);

            this._pointLayer = this._pointLayer || new LayerGroup().addTo(this);

            vanchart.seriesOfType(Constants.SCATTER_CHART)
                .concat(vanchart.seriesOfType(Constants.BUBBLE_CHART))
                .forEach(function (ser) {
                    vanchart.activeDataEvents(ser);
                });

            var largeTypes = [Constants.SCATTER_CHART, Constants.BUBBLE_CHART];

            this.largeSeries = largeTypes.reduce(function (obj, type) {
                obj[type] = obj[type] || {visible: true, type: type};
                obj[type].points = [];
                return obj
            }, this.largeSeries || {});

            var largeSeries = this.largeSeries;
            var markerSymbolChanged = this._isMarkerSymbolChanged();

            this.validPoints.forEach(function(point){
                // todo heatMapvalidPointsvalidPoints
                if(point.series.type == Constants.HEAT_MAP) { 
                    return; 
                }

                var visible = vanchart.isMapPointVisible(point);
                var type = point.series.type;

                // FIXME
                // wow!!!
                // dirty again

                // large mode
                if (point.series.options.large && largeSeries[type]) {
                    if (!visible) { return }
                    // todo series as patch
                    largeSeries[type].points.push(point);

                } else {
                    // normal mode
                    point.graphic && point.graphic.remove();point.graphic = null;//last is large mode
                    if (visible) {

                        var options = point.series.getStyle(point);
                        var features = geo.getFeaturesByName(point.name, type);

                        features = point.options.lnglat ? ['null'] : features;

                        var animate = vanchart.renderer.isAnimation;
                        if (point.layers && point.layers[0]._map) {
                            var reshow = point.series.reShowPoint(point);

                            point.layers.forEach(function (layer, index) {
                                markerSymbolChanged && vanchart._updateLayerMarker(layer, point);  // @BI-GIS

                                layer.setLatLng && layer.setLatLng(point.getLatLng(features[index]));
                                layer.setStyle(options);

                                animate && reshow && layer.initAnimate && layer.initAnimate(point);

                                vanchart.registerInteractiveTarget(point, layer);
                            });
                        } else {
                            point.layers = [];
                            features.forEach(function (feature) {
                                var layer;
                                if (type == Constants.AREA_MAP) {
                                    layer = geo.getLayerByFeature(feature);
                                    layer.setStyle(options);
                                } else {
                                    layer = vanchart.createPointLayer(feature, point, options);
                                }

                                point.layers.push(layer);
                                animate && layer.initAnimate && layer.initAnimate(point);

                                vanchart.registerInteractiveTarget(point, layer);
                            });
                        }

                    } else {
                        vanchart.removePointGraphics(point, type);
                    }
                }
            });

            this._renderHeatMap();

            this._renderLineMap();

            this._renderMapOnCanvas(largeSeries);

            vanchart.updateLabel();


            this.fire('animationStart');


        },

        _onZoom:function(){

            var vanchart = this, hoverPoint = vanchart.hoverPoint, zoomLevel = vanchart.getZoom();

            //,,
            if(hoverPoint && hoverPoint.geo){
                var zoomListener = hoverPoint.geo.getZoomListener();
                if(zoomListener && zoomListener <= zoomLevel){
                    vanchart.drillDown(hoverPoint);
                    return ;
                }
            }

            var lastLayer = vanchart.layerMap[vanchart.layerIndex - 1];
            if(lastLayer && lastLayer.geo.getZoomListener() > zoomLevel){
                vanchart.drillUp(lastLayer);
            }
        },

        updateLabel:function(){
            var needShowMoreLabel = this._needShowMoreLabel();
            if(!needShowMoreLabel || this.layerIndex > 0){
                this._updateNormalLabel();
                return;
            }

            var vanchart = this;

            vanchart._updateNormalLabel();

            // renderSeriesanimateZoom
            // showMoreLabelanimateZoom
            // hack350_updateMoreLabels250msanimateZoom
            needShowMoreLabel && this.setTimeout("map_label_timer", function (){
                vanchart._updateMoreLabels();
            }, 350);

            vanchart._changeDataState = false;
        },

        _updateMoreLabels: function () {
            var vanchart = this;

            this.validPoints && this.validPoints
                .filter(function (point) {
                    return point.series.type != Constants.LINE_CHART; 
                })
                .forEach(function(point){
                    var latlng = point.getLatLng();

                    if(vanchart.isMapPointVisible(point) && latlng) {

                        var pixels = vanchart.latLngToLayerPoint(latlng);
                        var y = pixels.y, centerYFun = null;

                        var serType = point.series.type;

                        if(serType == Constants.POINT_MAP){
                            y -= point.options.icon.iconSize[1]/2;
                        }

                        // points[0]validPointspoint.points
                        if(serType == Constants.AREA_MAP || serType === Constants.POINT_MAP) {
                            var points = point.points;
                            points.length && points.forEach( function (p){
                                p.series._showMoreLabel(p, pixels.x, y); 
                            }) 
                        } else if(serType != Constants.LINE_MAP) {  // 
                            point.series._showMoreLabel(point, pixels.x, y); 
                        } 
                    }
                });
        },

        _removeNormalLabels: function () {
            var labelPoints = this.validPoints.concat(this._getHeatMapPoints());
            var textG = this._textGroup;

            labelPoints.forEach(function(point){
                if(point.textLayers){
                    point.textLayers.forEach(function(layer){
                        textG.removeLayer(layer);
                    });
                    point.textLayers = null;
                }
            });
        },

        _updateNormalLabel:function(){
            this._fixConflictLabel();

            var vanchart = this, geo = vanchart.getCurrentGeo();
            var labelPoints = this.validPoints.concat(this._getHeatMapPoints());

            this._textGroup = this._textGroup || new LayerGroup().addTo(vanchart);
            var textG = this._textGroup;

            labelPoints.forEach(function(point){

                var type = point.series.type;

                var features = geo.getFeaturesByName(point.name, type);
                features = point.options.lnglat ? ['null'] : features;

                var enabled = point.options.dataLabels && point.options.dataLabels.enabled;

                if(enabled && point.labelPos && point.labelContent && features){

                    features.forEach(function(feature, index){
                        if(point.labelPos[index]){
                            point.textLayers = point.textLayers || [];
                            if(point.textLayers[index]){
                                point.textLayers[index].setStyle(point.getLatLng(feature));
                            }else{
                                point.textLayers[index] = new TextLayer(point.getLatLng(feature),  point).addTo(vanchart._textGroup);
                            }
                        }
                    });

                }else if(point.textLayers){
                    point.textLayers.forEach(function(layer){
                        textG.removeLayer(layer);
                    });
                    point.textLayers = null;
                }
            });
        },

        _fixConflictLabel:function(){
            var vanchart = this, manager = new BoundsManager();
            var geo = vanchart.getCurrentGeo(), labelPoints = this.validPoints.concat(this._getHeatMapPoints());

            labelPoints.forEach(function(point){

                var type = point.series.type;
                point.labelPos = null;

                if(!vanchart.isMapPointVisible(point)){
                    return;
                }

                if((type == Constants.AREA_MAP) && point.labelContent){
                    var features = geo.getFeaturesByName(point.name, type);

                    features.forEach(function(feature, index){
                        point.labelPos = point.labelPos || [];
                        if(feature.properties.center){
                            var labelBounds = vanchart._getTextBounds(point, feature);
                            point.labelPos[index] = labelBounds;
                            manager.addBounds(labelBounds);
                        }else{
                            point.labelPos[index] = null;
                        }
                    });

                    if(point.labelPos && !point.labelPos.filter(function(p){return !!p}).length){
                        point.labelPos = null;
                    }
                }
            });

            labelPoints.forEach(function(point){

                if(point.labelContent && vanchart.isMapPointVisible(point)){
                    var type = point.series.type;
                    var features = geo.getFeaturesByName(point.name, type);
                    features = point.options.lnglat ? ['null'] : features;
                    if(features){
                        features.forEach(function(feature, index){
                            if(!point.labelPos || !point.labelPos[index]){
                                var labelBounds = vanchart._getTextBounds(point, feature);
                                if(!manager.isOverlapped(labelBounds)){
                                    point.labelPos = point.labelPos || [];
                                    point.labelPos[index] = labelBounds;
                                    manager.addBounds(labelBounds);
                                }else{
                                    point.labelPos = point.labelPos || [];
                                    point.labelPos[index] = null;
                                }
                            }

                            if(point.labelPos && !point.labelPos.filter(function(p){return !!p}).length){
                                point.labelPos = null;
                            }
                        });
                    }
                }
            });
        },

        _getTextBounds:function(point, feature){
            var vanchart = this;
            var latlng = point.getLatLng(feature);
            var pixels = vanchart.latLngToContainerPoint(latlng);
            var y = pixels.y, seriesType = point.series.type;
            var marker = point.options.marker, icon = point.options.icon;
            if(seriesType == Constants.AREA_MAP || seriesType == Constants.BUBBLE_CHART || seriesType == Constants.HEAT_MAP){
                y -= point.labelDim.height/2
            }else if(marker && !BaseUtils.isImageMarker(marker.symbol)){
                var radius = marker.radius || 4.5;
                y -= (radius + point.labelDim.height);
            }else{
                var iconHeight = icon ? icon.iconSize[1] : marker.height;
                y -= (iconHeight/2 + point.labelDim.height);
            }
            return BaseUtils.makeBounds([pixels.x, y], point.labelDim);
        },

        createPointLayer:function(feature, point, options){
            var type = point.series.type;
            var latlng = point.getLatLng(feature);

            var layer;

            switch (type){
                case Constants.BUBBLE_CHART:
                    layer = new CircleMarker(latlng, options, point.radius).addTo(this._pointLayer);
                    break;
                case Constants.POINT_MAP:
                    layer = new Marker(latlng, {icon:new Icon(point.options.icon)}).addTo(this._pointLayer);
                    break;
                case Constants.SCATTER_CHART:
                    var marker = point.options.marker;
                    var isImageMarker = BaseUtils.isImageMarker(marker.symbol);
                    if(isImageMarker){
                        options = {icon:new Icon({iconSize: [marker.width, marker.height], iconUrl: marker.symbol})}
                    }

                    layer = isImageMarker ? new Marker(latlng, options) : new ScatterMarker(latlng, options, point.options.marker);
                    layer.addTo(this._pointLayer);
            }

            return layer;
        },

        getCurrentGeo:function(){
            return this.layerMap ? this.layerMap[this.layerMap.length - 1].geo : this.components.geo;
        },

        _getHeatMapPoints:function(){
            var heatMapSeries = this.seriesOfType(Constants.HEAT_MAP);
            var vanchart = this;
            var points = [], geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            if(heatMapSeries && heatMapSeries.length){
                for(var i = 0, len = heatMapSeries.length; i < len; i++){
                    heatMapSeries[i].points.forEach(function(point){
                        if(!point.options.lnglat){
                            var feature = geo.getFeaturesByName(point.name, Constants.HEAT_MAP);
                            point.options.lnglat = geo.getDataPointLngLat(point, feature && feature[0]);
                        }
                        if(!point.isNull && point.visible && point.options.lnglat){
                            points.push(point);
                        }else{
                            vanchart.removePointGraphics(point, Constants.HEAT_MAP);
                        }
                    });
                }
            }
            return points;
        },

        _renderHeatMap:function(){

            var heatMapSeries = this.seriesOfType(Constants.HEAT_MAP);
            var rangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

            if(!heatMapSeries || !heatMapSeries.length || !rangeLegend){
                return;
            }

            var data = {
                'min':rangeLegend._getMin(),
                'max':rangeLegend._getMax(),
                'data':this._getHeatMapPoints()
            };

            var options = heatMapSeries[0].options;
            var config = {
                'maxOpacity':options.maxOpacity,
                'minOpacity':options.minOpacity,
                'radius':options.radius,
                'blur':options.blur,
                'gradient':rangeLegend._getGradient(),
                'valueField':'value'
            };
            if(!this._heatMapOverlay){
                this._heatMapOverlay = new HeatMapOverlay(config).addTo(this);
            } else {
                this._heatMapOverlay._heatmap.configure(config);   // @BI-8870&&BI-8874
            }

            this._heatMapOverlay.setData(data);
        },

        removePointGraphics:function(point, type, animate){
            if(point) {
                type = type || point.series.type;

                var vanchart = this;

                if (type === Constants.LINE_MAP) {
                    this._lineMapLayer.removeEffect(point);
                    point.remove();
                }

                if (point.layers) {
                    point.layers.forEach(function (layer) {
                        vanchart.removeInteractiveTarget(point, layer);
                        // removeLayerexitAnimate.end
                        var useFilterRender = vanchart.useFilterRender;
                        layer.exitAnimate && layer.exitAnimate(vanchart, useFilterRender ? !useFilterRender : animate);
                    });
                    if (type != Constants.AREA_MAP) {
                        point.layers = null;
                    }

                    var textG = this._textGroup;
                    if (point.textLayers) {
                        point.textLayers.forEach(function (layer) {
                            textG.removeLayer(layer);
                        });
                        point.textLayers = null;
                        point.labelPos = null;
                    }

                    point.clearPointEffect();
                }
            }
        },

        _renderLineMap: function () {
            var lineMapSeries = this.seriesOfType(Constants.LINE_MAP);

            var data = lineMapSeries.reduce(function (accum, seriesItems) {
                return accum.concat(seriesItems.points);
            }, []);

            if (!lineMapSeries.length || !data.length) {
                this._lineMapLayer && this._lineMapLayer.setData([]);
                return;
            }

            if (!this._lineMapLayer) {
                var vanchart = this;
                var size = this.getSize();
                var options = {
                    width: size.x,
                    height: size.y,
                    x: 0,
                    y: 0,
                    dpr: window.devicePixelRatio || 1
                };
                var mainRenderer = this.mainRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                var animationRenderer = this.animationRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                mainRenderer.onAdd();
                animationRenderer.onAdd();

                this._lineMapLayer = lineMapLayer({
                    mainRenderer: mainRenderer,
                    animationRenderer: animationRenderer,
                    vanchart: vanchart
                }).addTo(this);
            }

            this._lineMapLayer.setData(data);
        },

        _renderMapOnCanvas: function (largeSeries) {

            var data = largeSeries[Constants.SCATTER_CHART].points.concat(
                largeSeries[Constants.BUBBLE_CHART].points
            );

            if (!this._canvasMapLayer) {
                var vanchart = this;
                var size = this.getSize();
                var options = {
                    width: size.x,
                    height: size.y,
                    x: 0,
                    y: 0,
                    dpr: window.devicePixelRatio || 1
                };
                var mainRenderer = this.mapCanvasRenderer = new CanvasRenderer(this._panes.overlayPane, this, options);
                mainRenderer.onAdd();

                this._canvasMapLayer = new CanvasMapLayer({
                    renderer: mainRenderer,
                    vanchart: vanchart
                }).addTo(this);
            }

            this._canvasMapLayer.setData(data);
        },

        /**
         * marker.symbol
         * @returns {boolean}
         * @private
         */
        _isMarkerSymbolChanged: function (){
            var marker = this.options.plotOptions.marker, symbol = marker && marker.symbol;
            var changed = this._lastMarkerSymbol !== symbol;

            this._lastMarkerSymbol = symbol;
            return changed;
        },

        /**
         * Marker.symbol
         * todo symbol
         * @private
         */
        _updateLayerMarker: function (layer, point){
            var newMarker = point.options.marker,
                layerMarker = layer._marker;
            if(newMarker && layerMarker && layerMarker.symbol){
                layer._marker.symbol = newMarker.symbol;
                layer._updatePath && layer._updatePath();
            }
        }
    });

    require('./VanChartLibrary').register(Constants.POINT_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.AREA_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.LINE_MAP, VanChartMap);
    require('./VanChartLibrary').register(Constants.HEAT_MAP, VanChartMap);

    return VanChartMap;
});
/**
 * Created by eason on 2017/2/20.
 */
define('utils/QuadTree',[],function(){

    function d3_geom_pointX(d) {
        return d[0];
    }

    function d3_geom_pointY(d) {
        return d[1];
    }

    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }

    var abs = Math.abs;

    function quadtree(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) {
                        x1_ = d.x;
                    }
                    if (d.y < y1_) {
                        y1_ = d.y;
                    }
                    if (d.x > x2_) {
                        x2_ = d.x;
                    }
                    if (d.y > y2_) {
                        y2_ = d.y;
                    }
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) {
                        x1_ = x_;
                    }
                    if (y_ < y1_) {
                        y1_ = y_;
                    }
                    if (x_ > x2_) {
                        x2_ = x_;
                    }
                    if (y_ > y2_) {
                        y2_ = y_;
                    }
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) {
                y2_ = y1_ + dx;
            } else {
                x2_ = x1_ + dy;
            }
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) {
                    return;
                }
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) {
                    x1 = xm;
                }else {
                    x2 = xm;
                }

                if (below) {
                    y1 = ym;
                }else {
                    y2 = ym;
                }
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else {
                data.forEach(root.add);
            }
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) {
                return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
            }
            if (_ == null) {
                x1 = y1 = x2 = y2 = null;
            } else {
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            }
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) {
                return x1 == null ? null : [ x2 - x1, y2 - y1 ];
            }

            if (_ == null) {
                x1 = y1 = x2 = y2 = null;
            } else {
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            }

            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) {
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            }
            if (children[1]) {
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            }
            if (children[2]) {
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            }
            if (children[3]) {
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
            }
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) {
                return;
            }
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) {
                    switch (i & 3) {
                        case 0:
                            find(node, x1, y1, xm, ym);
                            break;

                        case 1:
                            find(node, xm, y1, x2, ym);
                            break;

                        case 2:
                            find(node, x1, ym, xm, y2);
                            break;

                        case 3:
                            find(node, xm, ym, x2, y2);
                            break;
                    }
                }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }

    return quadtree;
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/ForceLayout',['require','../utils/QuadTree','../utils/Timer','../utils/BaseUtils'],function(require){

    var quadtree = require('../utils/QuadTree');
    var Timer = require('../utils/Timer');
    var BaseUtils = require('../utils/BaseUtils');

    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;

    var forceLayout = function() {
        var force = {}, size = [ 1, 1 ], alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;

        var _scale = 1, _eachTick, _startTick, _endTick, _events, _targets = {};

        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                alpha = 0;
                _endTick && _endTick();
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i] * _scale) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) {
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }

            _eachTick && _eachTick({alpha:alpha});
        };
        force.nodes = function(x) {
            if (!arguments.length) {
                return nodes;
            }
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) {
                return links;
            }
            links = x;
            return force;
        };

        force.eachTick = function(x){
            if (!arguments.length) {
                return _eachTick;
            }
            _eachTick = x;
            return force;
        };

        force.endTick = function (x) {
            if (!arguments.length) {
                return _endTick;
            }
            _endTick = x;
            return force;
        };

        force.size = function(x) {
            if (!arguments.length) {
                return size;
            }
            size = x;
            return force;
        };
        force.scale = function(x) {
            if (!arguments.length) {
                return _scale;
            }
            _scale = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) {
                return linkDistance;
            }
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) {
                return linkStrength;
            }
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) {
                return friction;
            }
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) {
                return charge;
            }
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) {
                return Math.sqrt(chargeDistance2);
            }
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) {
                return gravity;
            }
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) {
                return Math.sqrt(theta2);
            }
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) {
                return alpha;
            }
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                } else {
                    alpha = 0;
                }
            } else if (x > 0) {
                alpha = x;
                Timer(force.tick);
            }
            return force;
        };
        //
        force.start = function() {
            force.preparePara();
            return force.resume();
        };
        //
        force.simulateForce = function () {
            force.preparePara();

            force.alpha(0.1);
            while(force.alpha() >= 0.005) {
                force.tick();
            }

            _endTick && _endTick();
            return force;
        };
        //ie
        force.simpleSimulateForce = function () {
            force.preparePara();

            var start = 0.1, end = 0.005;
            var padding = 2, clusterPadding = 2;
            var paddingAlpha = 0.5;
            var gravity = 0.02;
            var friction = 0.9;

            for(var alpha = start; alpha >= end; alpha -= (alpha > 0.07 ? 0.001 : 0.0005)){

                var n = nodes.length, i, o, k, x, y;

                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) {
                        while (++i < n) {
                            o = nodes[i];
                            o.x += (x - o.x) * k;
                            o.y += (y - o.y) * k;
                        }
                    }
                }
                i = -1;
                while (++i < n) {
                    o = nodes[i];
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }

                nodes.forEach(function(d){
                    //
                    var cluster = d.series.cluster;

                    if (cluster && cluster != d){
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;
                        if (l != r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            cluster.x += x;
                            cluster.y += y;
                        }
                    }});

                for(var i = 0; i < n; i++){
                    var d = nodes[i];

                    for(var j = 0; j < n; j++){
                        var point = nodes[j];

                        if (point !== d) {
                            var x = d.x - point.x,
                                y = d.y - point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + point.radius + (d.series.cluster === point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * paddingAlpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                point.x += x;
                                point.y += y;
                            }
                        }
                    }
                }
            }

            _endTick && _endTick();
            return force;
        };
        force.preparePara = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") {
                    o.source = nodes[o.source];
                }
                if (typeof o.target == "number") {
                    o.target = nodes[o.target];
                }
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) {
                    o.x = position("x", w);
                }
                if (isNaN(o.y)) {
                    o.y = position("y", h);
                }
                if (isNaN(o.px)) {
                    o.px = o.x;
                }
                if (isNaN(o.py)) {
                    o.py = o.y;
                }
            }
            distances = [];
            if (typeof linkDistance === "function") {
                for (i = 0; i < m; ++i){
                    distances[i] = +linkDistance.call(this, links[i], i);
                }
            }else {
                for (i = 0; i < m; ++i){
                    distances[i] = linkDistance;
                }
            }
            strengths = [];
            if (typeof linkStrength === "function") {
                for (i = 0; i < m; ++i) {
                    strengths[i] = +linkStrength.call(this, links[i], i);
                }
            } else {
                for (i = 0; i < m; ++i) {
                    strengths[i] = linkStrength;
                }
            }
            charges = [];
            if (typeof charge === "function") {
                for (i = 0; i < n; ++i) {
                    charges[i] = +charge.call(this, nodes[i], i);
                }
            }else {
                for (i = 0; i < n; ++i) {
                    charges[i] = charge;
                }
            }
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = [];
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l) {
                    if (!isNaN(x = candidates[j][dimension])) {
                        return x;
                    }
                }
                return Math.random() * size;
            }
            return force;
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.registerDragTarget = function(data, elementWrapper){
            if(!_events){
                _events = getEvents();
            }
            _targets[BaseUtils.stamp(elementWrapper.node())] = data;
        };
        force.dragFire = function (ev, container) {
            if(!_events){
                return;
            }

            var srcEvent = ev.srcEvent, type = ev.type || srcEvent.type;
            var isPan = type === 'panstart' || type === 'panmove' || type === 'panend';

            var target;
            if(isPan && force.panTarget){
                target = force.panTarget;
            } else {
                var src = srcEvent.target || srcEvent.srcElement;
                target = findDragTarget(_targets, src, container);
            }

            if(target && _events[type]){
                _events[type](target, force, ev);
                return target;
            }
        };
        return force;
    };

    function findDragTarget(_targets, src, container){
        var target;
        while (src) {
            target = _targets[BaseUtils.stamp(src)];

            if (target) {
                return target;
            }

            if(src === container){
                return null;
            }

            src = src.parentNode;
        }
    }

    function getEvents() {
        return {
            'mouseover':d3_layout_forceMouseover,
            'mouseout':d3_layout_forceMouseout,
            'panstart':d3_layout_forceDragstart,
            'panmove':d3_layout_forceDragmove,
            'panend':d3_layout_forceDragend
        }
    }

    function d3_layout_forceDragmove(d, force, ev) {
        var transX = ev.containerPoint.x - force.currentPoint.x,
            transY = ev.containerPoint.y - force.currentPoint.y;
        force.currentPoint = ev.containerPoint;

        d.px += transX; d.py += transY;
        force.resume();
    }
    function d3_layout_forceDragstart(d, force, ev) {
        d.fixed |= 2;
        force.panTarget = d;
        force.currentPoint = ev.containerPoint;
    }
    function d3_layout_forceDragend(d, force) {
        d.fixed &= ~6;
        force.panTarget = null;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x; d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }

    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) {
                    continue;
                }
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }

    return forceLayout;
});
/**
 * Created by eason on 16/8/29.
 */

define('vans/VanChartForceBubble',['require','./VanChart','./../utils/BaseUtils','./../Constants','./ForceLayout','../utils/QuadTree','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var BaseUtils = require('./../utils/BaseUtils');
    var Constants = require('./../Constants');
    var ForceLayout = require('./ForceLayout');
    var QuadTree = require('../utils/QuadTree');

    var padding = 2, clusterPadding = 4;
    var BUBBLE_UPDATE_TIME = 500;

    var VanChartForceBubble = VanChart.extend({

        vanChartType:'vanChartForceBubble',

        renderSeries:function(){
            VanChart.prototype.renderSeries.call(this);
            var vanchart = this, plotBounds = vanchart.bounds;
            var nodes = this.nodes = []; this.maxRadius = 0;
            var isAnimation = vanchart.renderer.isAnimation;

            vanchart.force && vanchart.force.stop();
            vanchart.force = vanchart.force || ForceLayout();

            this.series.forEach(function(ser){
                var cluster;
                ser.points.forEach(function(point){
                    if(point.isVisible()){
                        // 
                        // _posXundefined,ForceLayoutpoint.x0-w
                        point.x = point._posX;
                        point.y = point._posY;
                        if(isAnimation) {
                            vanchart.force.registerDragTarget(point, point.graphic);
                        }
                        nodes.push(point);
                        vanchart.maxRadius = Math.max(vanchart.maxRadius, point.radius);
                        cluster = cluster || point;
                        cluster = point.radius > cluster.radius ? point : cluster;
                    }
                });
                ser.cluster = cluster;
            });

            vanchart.force.nodes(nodes)
                    .size([plotBounds.width, plotBounds.height])
                    .gravity(0.05).charge(0).eachTick(eachTick);

            BaseUtils.isSupportSVG()
                ? (isAnimation ? vanchart.force.start() : vanchart.force.simulateForce())
                : vanchart.force.endTick(_simpleSimulateEnd).simpleSimulateForce();

            function eachTick(e){
                if(vanchart._animationStarted && e.alpha < 0.05){
                    VanChart.prototype._animationEnd.bind(vanchart)();
                }
                var clusterFuc = cluster(10 * e.alpha * e.alpha);
                var collideFuc = collide(0.5, nodes, vanchart.maxRadius);

                nodes.forEach(function(point){
                    clusterFuc(point);
                });

                nodes.forEach(function(point){
                    collideFuc(point);
                });

                vanchart._updateGraphics();
            }

            function _simpleSimulateEnd() {
                vanchart._updateGraphics();
                VanChart.prototype._animationEnd.bind(vanchart)();
            }
        },

        _updateGraphics: function() {
            var vanchart = this;
            vanchart.nodes && vanchart.nodes.forEach(function (point) {
                point._posX = point.x;
                point._posY = point.y;

                vanchart._calculateLabelPos(point);

                //createinit
                point.textGraphic && point.textGraphic
                    .interrupt(Constants.SELECT_ANIMATION)
                    .attr('transform', BaseUtils.makeTranslate(point.series._labelTrans(point)));

                point.graphic.attr(point.series.getPointUpdateAnimationAttr(point));
            })
        },

        _animationEnd:function() {

        },

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, plotBounds = vanchart.bounds;

            vanchart.force && vanchart.force.stop();

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            vanchart.nodes.forEach(function(node){

                node.radius *= scale;

                var x = node.x + shiftX;
                var y = node.y + shiftY;

                x -= plotBounds.width/2;
                y -= plotBounds.height/2;

                node.x = x * scale + plotBounds.width/2 - shiftX;
                node.y = y * scale + plotBounds.height/2 - shiftY;

                vanchart._calculateLabelPos(node);
                vanchart._updatePointTextGraphic(node);

                var series = node.series, attrs = series.getPointUpdateAnimationAttr(node);

                node.graphic.animate({
                    duration:BUBBLE_UPDATE_TIME,
                    ease:'back-out',
                    attr: attrs
                });

            });

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        refreshRestore:function(){
            this.scale = 1;
            this.update();
        },

        _calculateLabelPos:function(node){
            if(node.labelContent && node.labelDim){
                var radius = node.radius;
                if((node.labelDim.width > 2 * radius) || (node.labelDim.height > 2 * radius)){
                    node.labelPos = null;
                }else{
                    node.labelPos = {
                        x:-node.labelDim.width/2 + node.x,
                        y:-node.labelDim.height/2 + node.y
                    }
                }
            }
        },

        orderData:function(){

        },

        _updatePointTextGraphic:function(point){
            if(point.textGraphic){
                if(point.labelPos){
                    point.textGraphic.attr('transform', BaseUtils.makeTranslate(point.series._labelTrans(point)));
                }else{
                    point.textGraphic.remove();
                    point.textGraphic = null;
                }
            }else{
                point.series._createTextGraphic(point);
            }
        }
    });

    // Move d to be adjacent to the cluster node.
    function cluster(alpha) {
        return function(d) {
            var cluster = d.series.cluster;
            if (!cluster || cluster === d) {return;}
            var x = d.x - cluster.x,
                y = d.y - cluster.y,
                l = Math.sqrt(x * x + y * y),
                r = d.radius + cluster.radius;
            if (l != r && l) {
                l = (l - r) / l * alpha;
                d.x -= x *= l;
                d.y -= y *= l;
                cluster.x += x;
                cluster.y += y;
            }
        };
    }

    // Resolves collisions between d and all other circles.
    function collide(alpha, nodes, maxRadius) {
        var quadtree = QuadTree(nodes);
        return function(d) {
            var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
            quadtree.visit(function(quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== d)) {
                    var x = d.x - quad.point.x,
                        y = d.y - quad.point.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + quad.point.radius + (d.series.cluster === quad.point.series.cluster ? padding : clusterPadding);
                    if (l < r && l) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        quad.point.x += x;
                        quad.point.y += y;
                    }
                }
                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            });
        };
    }

    require('./VanChartLibrary').register(Constants.FORCE_BUBBLE_CHART, VanChartForceBubble);
    return VanChartForceBubble;
});
/**
 * Created by eason on 2017/2/14.
 */
define('utils/Scale',['require','./BaseUtils','./Interpolator','./vMap'],function(require){

    var BaseUtils = require('./BaseUtils');

    var Interpolator = require('./Interpolator');
    var vMap = require('./vMap');

    function scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }

    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }

    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }

    function bisect(a, x, lo, hi) {
        if (arguments.length < 3) {
            lo = 0;
        }
        if (arguments.length < 4) {
            hi = a.length;
        }
        while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (d3_ascending(a[mid], x) > 0){
                hi = mid;
            }else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function d3_scale_linearRebind(scale, linear) {
        return BaseUtils.rebind(scale, linear, "range", "rangeRound", "interpolate");
    }

    function d3_scale_linear(domain, range, interpolate, uninterpolate) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            return rescale();
        };

        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(Interpolator.interpolateRound);
        };

        scale.interpolate = function(x) {
            if (!arguments.length) {
                return interpolate;
            }
            interpolate = x;
            return rescale();
        };

        scale.uninterpolate = function(x) {
            if (!arguments.length) {
                return uninterpolate;
            }
            uninterpolate = x;
            return rescale();
        };

        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, uninterpolate);
        };
        return rescale();
    }

    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) {
                return base;
            }
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }

    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            var range = [], length = domain.length;
            for(var i = 0; i < length; i++){
                range.push(start + step * i);
            }
            return range;
        }
        scale.domain = function(x) {
            if (!arguments.length) {
                return domain;
            }
            domain = [];
            index = new vMap();
            var i = -1, n = x.length, xi;
            while (++i < n) {
                if (!index.has(xi = x[i])) {
                    index.set(xi, domain.push(xi));
                }
            }
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2,
                0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2),
                0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            if (arguments.length < 3) {
                outerPadding = padding;
            }
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse){
                range.reverse();
            }
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) {
                padding = 0;
            }
            if (arguments.length < 3) {
                outerPadding = padding;
            }
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) {
                range.reverse();
            }
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }

    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) {
                return [ x0, x1 ];
            }
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) {
                return range;
            }
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [ y, y + 1 / kx ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }

    function linear() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], Interpolator.interpolateNumber, Interpolator.uninterpolateNumber);
    }

    function log() {
        return d3_scale_log(linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    }

    function quantize() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    }

    function ordinal(){
        return d3_scale_ordinal([], {t: "range", a: [ [] ]});
    }

    return {
        linear:linear,
        quantize:quantize,
        log:log,
        quantize:quantize,
        ordinal:ordinal
    };
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/CloudLayout',['require','./../utils/BaseUtils'],function(require){
    var BaseUtils = require('./../utils/BaseUtils');

    var cloudRadians = Math.PI / 180,
        cw = 1 << 11 >> 5,
        ch = 1 << 11;

    return function() {

        var size = [256, 256],
            text = cloudText,
            font = cloudFont,
            fontSize = cloudFontSize,
            fontStyle = cloudFontNormal,
            fontWeight = cloudFontNormal,
            rotate = cloudRotate,
            padding = cloudPadding,
            spiral = archimedeanSpiral,
            path = null,
            simpleLayout = !BaseUtils.isSupportSVG(),
            renderFun = null,
            words = [],
            timeInterval = Infinity,
            timer = null,
            random = Math.random,
            cloud = {},
            canvas = cloudCanvas;

        cloud.canvas = function(_) {
            return arguments.length ? (canvas = functor(_), cloud) : canvas;
        };

        cloud.start = function() {
            var contextAndRatio = getContext(canvas()),
                board = imageShape() ? imageDataArray(contextAndRatio, stepInterval)
                    : (simpleLayout ? [] :zeroArray((size[0] >> 5) * size[1])),
                bounds = null,
                n = words.length,
                i = -1,
                tags = [],
                data = words.map(function(d, i) {
                    d.text = text.call(this, d, i);
                    d.font = font.call(this, d, i);
                    d.style = fontStyle.call(this, d, i);
                    d.weight = fontWeight.call(this, d, i);
                    d.rotate = rotate.call(this, d, i);
                    d.size = ~~fontSize.call(this, d, i);
                    d.padding = padding.call(this, d, i);
                    return d;
                }).sort(function(a, b) { return b.size - a.size; });

            if(!imageShape()) {
                stepInterval();
            }

            function stepInterval(temp){
                if(simpleLayout){
                    simpleStep(temp)
                } else {

                    if (timer) {
                        clearInterval(timer);
                    }
                    timer = setInterval(step, 0);
                    step(temp);
                }
            }


            return cloud;

            function step(temp) {
                board = temp ? temp : board;
                var start = Date.now();
                while (Date.now() - start < timeInterval && ++i < n && timer) {
                    var d = data[i];
                    d.x = (size[0] * (random() + .5)) >> 1;
                    d.y = (size[1] * (random() + .5)) >> 1;
                    cloudSprite(contextAndRatio, d, data, i, simpleLayout);

                    function oncePlace() {
                        if (d.hasText && place(board, d, bounds)) {
                            tags.push(d);
                            if (bounds) {cloudBounds(bounds, d);}
                            else {bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];}
                            // Temporary hack
                            d.x -= size[0] >> 1;
                            d.y -= size[1] >> 1;
                            return true;
                        }
                        return false;
                    }

                    if(!oncePlace()){//
                        oncePlace();
                    }
                }
                if (i >= n) {
                    cloud.stop();
                    renderFun(tags);
                }
            }

            //ie8 simpleLayout
            function simpleStep(temp) {
                while (++i < n) {
                    var d = data[i];
                    d.x = (size[0] * (random() + .5)) >> 1;
                    d.y = (size[1] * (random() + .5)) >> 1;

                    var dim = BaseUtils.getTextDimension(d.text, {'fontSize':d.size + 'px', 'fontFamily':d.fontFamily}, false);
                    d.height = dim.height;
                    d.y0 = -d.height >> 1;
                    d.y1 = -d.y0;
                    d.width = dim.width;
                    d.x0 = -d.width >> 1;
                    d.x1 = -d.x0;
                    if (place(board, d, bounds)) {
                        tags.push(d);
                        if (bounds) {
                            bounds.push({x:d.x, y:d.y, x0:d.x0, y0:d.y0, x1:d.x1, y1:d.y1});
                        } else {
                            bounds = [{x:d.x, y:d.y, x0:d.x0, y0:d.y0, x1:d.x1, y1:d.y1}];
                        }
                        d.x -= size[0] >> 1;
                        d.y -= size[1] >> 1;
                        d.x -= d.width >> 1;
                        d.y -= d.height >> 1;
                    }
                }
                if (i >= n) {
                    cloud.stop();
                    renderFun(tags);
                }
            }
        };

        cloud.stop = function() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
            return cloud;
        };

        function imageShape() {
            return path && !simpleLayout;
        }

        function imageDataArray(contextAndRatio, complete) {

            var c = contextAndRatio.context,
                ratio = contextAndRatio.ratio;

            var width = (size[0] >> 5)/ratio, height = size[1]/ratio;
            c.clearRect(0, 0, width, height);

            var img = new Image();
            img.onload = function(){
                c.drawImage(img, 0, 0, width, height);
                var data = c.getImageData(0, 0, width, height).data;

                c.clearRect(0, 0, width, height);

                var len = data.length, board = [];
                for(var i = 0; i < len; i+=4){
                    board[i/4] = data[i+3] ? 0 : 1;
                }

                complete(board);

            };

            //srconloadjs
            img.src = path;
        }

        function getContext(canvas) {
            canvas.width = canvas.height = 1;

            var context = canvas.getContext("2d");

            var ratio = simpleLayout ? 1 : Math.sqrt(context.getImageData(0, 0, 1, 1).data.length >> 2);
            canvas.width = (cw << 5) / ratio;
            canvas.height = ch / ratio;

            context.fillStyle = context.strokeStyle = "red";
            context.textAlign = "center";

            return {context: context, ratio: ratio};
        }

        function collideRectsArray(a, array) {
            var minx_a = a.x + a.x0, maxx_a = a.x + a.x1, miny_a = a.y + a.y0, maxy_a = a.y + a.y1;
            for(var i = 0,len = array.length;i<len;i++){
                var b = array[i];
                var minx_b = b.x + b.x0, maxx_b = b.x + b.x1, miny_b = b.y + b.y0, maxy_b = b.y + b.y1;
                var minx = Math.max(minx_a, minx_b),
                    maxx = Math.min(maxx_a, maxx_b),
                    miny = Math.max(miny_a, miny_b),
                    maxy = Math.min(maxy_a, maxy_b);
                if(minx < maxx && miny < maxy){
                    return true;
                }
            }

            return false;
        }

        function place(board, tag, bounds) {
            var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
                startX = tag.x,
                startY = tag.y,
                maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
                s = spiral(size),
                dt = random() < .5 ? 1 : -1,
                t = -dt,
                dxdy,
                dx,
                dy;

            while (dxdy = s(t += dt)) {
                dx = ~~dxdy[0];
                dy = ~~dxdy[1];

                if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) {break;}

                tag.x = startX + dx;
                tag.y = startY + dy;

                if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
                    tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) {continue;}

                if(simpleLayout){
                    if(!bounds || !collideRectsArray(tag, bounds)){
                        return true;
                    }
                }
                // TODO only check for collisions within current bounds.
                //cloudCollide
                else if ((!bounds && !path) || !cloudCollide(tag, board, size[0])) {
                    if (!bounds || collideRects(tag, bounds)) {
                        var sprite = tag.sprite,
                            w = tag.width >> 5,
                            sw = size[0] >> 5,
                            lx = tag.x - (w << 4),
                            sx = lx & 0x7f,
                            msx = 32 - sx,
                            h = tag.y1 - tag.y0,
                            x = (tag.y + tag.y0) * sw + (lx >> 5),
                            last;
                        for (var j = 0; j < h; j++) {
                            last = 0;
                            for (var i = 0; i <= w; i++) {
                                board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                            }
                            x += sw;
                        }
                        delete tag.sprite;
                        return true;
                    }
                }
            }
            return false;
        }

        cloud.timeInterval = function(_) {
            return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
        };

        cloud.words = function(_) {
            return arguments.length ? (words = _, cloud) : words;
        };

        cloud.path = function (_) {
            return arguments.length ? (path = _, cloud) : path;
        };

        cloud.renderFun = function (_) {
            return arguments.length ? (renderFun = _, cloud) : renderFun;
        };

        cloud.size = function(_) {
            return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
        };

        cloud.font = function(_) {
            return arguments.length ? (font = functor(_), cloud) : font;
        };

        cloud.fontStyle = function(_) {
            return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
        };

        cloud.fontWeight = function(_) {
            return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
        };

        cloud.rotate = function(_) {
            return arguments.length ? (rotate = functor(_), cloud) : rotate;
        };

        cloud.text = function(_) {
            return arguments.length ? (text = functor(_), cloud) : text;
        };

        cloud.spiral = function(_) {
            return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
        };

        cloud.fontSize = function(_) {
            return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
        };

        cloud.padding = function(_) {
            return arguments.length ? (padding = functor(_), cloud) : padding;
        };

        cloud.random = function(_) {
            return arguments.length ? (random = _, cloud) : random;
        };

        return cloud;
    };

    function cloudText(d) {
        return d.text;
    }

    function cloudFont() {
        return "serif";
    }

    function cloudFontNormal() {
        return "normal";
    }

    function cloudFontSize(d) {
        return Math.sqrt(d.value);
    }

    function cloudRotate() {
        return (~~(Math.random() * 6) - 3) * 30;
    }

    function cloudPadding() {
        return 1;
    }

// Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.
    function cloudSprite(contextAndRatio, d, data, di, simpleLayout) {
        if (d.sprite) {return;}
        var c = contextAndRatio.context,
            ratio = contextAndRatio.ratio;

        c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
        var x = 0,
            y = 0,
            maxh = 0,
            n = data.length;
        --di;
        while (++di < n) {
            d = data[di];
            c.save();
            c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
            var w = c.measureText(d.text + "m").width * ratio,
                h = d.size << 1;
            if (d.rotate) {
                var sr = Math.sin(d.rotate * cloudRadians),
                    cr = Math.cos(d.rotate * cloudRadians),
                    wcr = w * cr,
                    wsr = w * sr,
                    hcr = h * cr,
                    hsr = h * sr;
                w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
                h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
            } else {
                w = (w + 0x1f) >> 5 << 5;
            }
            if (h > maxh) {maxh = h;}
            if (x + w >= (cw << 5)) {
                x = 0;
                y += maxh;
                maxh = 0;
            }
            if (y + h >= ch && !simpleLayout) {break;}
            c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
            if (d.rotate) {c.rotate(d.rotate * cloudRadians);}
            c.fillText(d.text, 0, 0);
            if (d.padding && !simpleLayout) {c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);}
            c.restore();
            d.width = w;
            d.height = h;
            d.xoff = x;
            d.yoff = y;
            d.x1 = w >> 1;
            d.y1 = h >> 1;
            d.x0 = -d.x1;
            d.y0 = -d.y1;
            d.hasText = true;
            x += w;
        }
        if(simpleLayout){return}
        var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
            sprite = [];
        while (--di >= 0) {
            d = data[di];
            if (!d.hasText) {continue;}
            var w = d.width,
                w32 = w >> 5,
                h = d.y1 - d.y0;
            // Zero the buffer
            for (var i = 0; i < h * w32; i++) {sprite[i] = 0;}
            x = d.xoff;
            if (x == null) {return;}
            y = d.yoff;
            var seen = 0,
                seenRow = -1;
            for (var j = 0; j < h; j++) {
                for (var i = 0; i < w; i++) {
                    var k = w32 * j + (i >> 5),
                        m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
                    sprite[k] |= m;
                    seen |= m;
                }
                if (seen) {seenRow = j;}
                else {
                    d.y0++;
                    h--;
                    j--;
                    y++;
                }
            }
            d.y1 = d.y0 + seenRow;
            d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
        }
    }

// Use mask-based collision detection.
    function cloudCollide(tag, board, sw) {
        sw >>= 5;
        var sprite = tag.sprite,
            w = tag.width >> 5,
            lx = tag.x - (w << 4),
            sx = lx & 0x7f,
            msx = 32 - sx,
            h = tag.y1 - tag.y0,
            x = (tag.y + tag.y0) * sw + (lx >> 5),
            last;
        for (var j = 0; j < h; j++) {
            last = 0;
            for (var i = 0; i <= w; i++) {
                if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
                    & board[x + i]) {return true;}
            }
            x += sw;
        }
        return false;
    }

    function cloudBounds(bounds, d) {
        var b0 = bounds[0],
            b1 = bounds[1];
        if (d.x + d.x0 < b0.x) {b0.x = d.x + d.x0;}
        if (d.y + d.y0 < b0.y) {b0.y = d.y + d.y0;}
        if (d.x + d.x1 > b1.x) {b1.x = d.x + d.x1;}
        if (d.y + d.y1 > b1.y) {b1.y = d.y + d.y1;}
    }

    function collideRects(a, b) {
        return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
    }

    function archimedeanSpiral(size) {
        var e = size[0] / size[1];
        return function(t) {
            return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
        };
    }

    function rectangularSpiral(size) {
        var dy = 4,
            dx = dy * size[0] / size[1],
            x = 0,
            y = 0;
        return function(t) {
            var sign = t < 0 ? -1 : 1;
            // See triangular numbers: T_n = n * (n + 1) / 2.
            switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
                case 0:  x += dx; break;
                case 1:  y += dy; break;
                case 2:  x -= dx; break;
                default: y -= dy; break;
            }
            return [x, y];
        };
    }

// TODO reuse arrays?
    function zeroArray(n) {
        var a = [],
            i = -1;
        while (++i < n) {a[i] = 0;}
        return a;
    }

    function cloudCanvas() {
        var canvas = document.createElement(window.VAN_CANVAS);

        window.VanCanvasManager && VanCanvasManager.initElement(canvas);

        return canvas;
    }

    function functor(d) {
        return typeof d === "function" ? d : function() { return d; };
    }

    var spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
    };
});
/**
 * Created by Mitisky on 16/11/30.
 */

define('vans/VanChartWordCloud',['require','./VanChart','./../Constants','./../utils/BaseUtils','../utils/Scale','./CloudLayout','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var Constants = require('./../Constants');
    var BaseUtils = require('./../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var CloudLayout = require('./CloudLayout');

    var SHOW_TIME = 800;//

    var VanChartWordCloud = VanChart.extend({

        vanChartType:'vanChartWordCloud',

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, series = vanchart.series;

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            series.forEach(function(ser){
                ser.points.forEach(function(point){

                    if(point.word){

                        var x = point.word.x, y = point.word.y;

                        point.word.x = (x + shiftX) * scale  - shiftX;
                        point.word.y = (y + shiftY) * scale - shiftY;
                        point.word.size *= scale;

                        ser._drawUpdatePoints(point);
                    }
                });

            });

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        _getTranslate:function(){
            var plotBounds = this.bounds;
            return[plotBounds.x + plotBounds.width / 2, plotBounds.y + plotBounds.height / 2];
        },

        _animationStart:function () { 
            this._animationStarted = true; 
            this.animationCount = 0; 
 
            this.removeMoreLabel(); 
        }, 

        renderSeries:function(){

            this.fire('animationStart');

            var vanchart = this, renderer = vanchart.renderer, plotOptions = vanchart.options.plotOptions;
            var bounds = vanchart.bounds, width = bounds.width, height = bounds.height;
            var minR = plotOptions.minRotation, maxR = plotOptions.maxRotation;
            var fontFamily = plotOptions.fontFamily, minFontSize = plotOptions.minFontSize, maxFontSize = plotOptions.maxFontSize;

            var allPoints = vanchart.pointsOfType(Constants.WORD_CLOUD_CHART)
                .filter(function (p) {return !p.isNull;})
                .sort(function (pointA, pointB) {return Math.abs(pointB.value) - Math.abs(pointA.value);});

            if(allPoints.length === 0){
                return;
            }

            minFontSize = BaseUtils.hasDefined(minFontSize) ? minFontSize : 10;
            maxFontSize = BaseUtils.hasDefined(maxFontSize) ? maxFontSize : vanchart._calculateNiceMaxFontSize(width, height, allPoints[0].name, fontFamily);
            vanchart.minFontSize = Math.min(parseFloat(minFontSize), parseFloat(maxFontSize));
            vanchart.maxFontSize = Math.max(parseFloat(minFontSize), parseFloat(maxFontSize));

            var sizeScale = Scale.linear()
                .domain([Math.abs(allPoints[allPoints.length - 1].value), Math.abs(allPoints[0].value)]).range([vanchart.minFontSize, vanchart.maxFontSize]);

            var layout = CloudLayout()
                .size([width, height])
                .words(
                    allPoints.filter(function (p) {return p.visible;}).map(function(p) {
                    var word = {text: p.name, size: sizeScale(Math.abs(p.value)) * vanchart.scale, point: p, fontFamily: fontFamily};
                    p.word = word;
                    return word;
                }))
                .path(plotOptions.path)
                .padding(5)
                .rotate(function() { return minR + Math.random() * (maxR - minR); })
                .font(fontFamily)
                .fontSize(function(p) { return p.size; })
                .renderFun(draw);

            layout.start();

            function draw(words) {

                if(!vanchart.group){
                    vanchart.group = renderer.group().addTo(vanchart.clipSeriesGroup);
                }
                vanchart.group.attr('transform', BaseUtils.makeTranslate(vanchart._getTranslate()));

                var series = vanchart.seriesOfType(Constants.WORD_CLOUD_CHART);
                if(series && series.length){
                    var ser = series[0];

                    vanchart.registerInteractiveTarget(ser, vanchart.group);

                    ser._removeDataLabels();

                    var each = SHOW_TIME/parseFloat(words.length), delayTime = 0;
                    allPoints.forEach(function (point) {
                        var word = point.word;
                        if(words.indexOf(word) != -1){
                            point.delayTime = delayTime;
                            delayTime += each;
                        }
                        if(word) {//visible==falseword
                            point.labelDim = BaseUtils.getTextDimension(word.text, {
                                'fontSize': word.size + 'px',
                                'fontFamily': word.fontFamily
                            }, false);
                        }
                        ser.drawPoint(point);
                    });

                    vanchart.setTimeout('effect', function(){
                        allPoints.forEach(function (point) {
                            ser.drawPointEffect(point);
                        });
                    }, 800);
                }
                window.console && console.log('done');
            }
        },

        _consoleDone:function () {
        },

        _calculateNiceMaxFontSize: function (width, height, text, fontFamily) {
            var range = {'min':0, 'max':100}, validInterval = function () {return (range.max - range.min) > 2;};
            var style = {'fontSize':range.max + 'px', 'fontFamily': fontFamily};
            var maxDim = BaseUtils.getTextDimension(text, style, false);

            while(validInterval() && (maxDim.width > width || maxDim.height > height)){

                var middle = Math.ceil(range.min + (range.max - range.min)/2);//
                style.fontSize = middle + 'px';
                var middleDim = BaseUtils.getTextDimension(text, style, false);
                if(middleDim.width > width || middleDim.height > height){
                    range.max = middle;
                    maxDim = middleDim;
                } else {
                    range.min = middle;
                }
            }

            return validInterval() ? range.max : range.min;
        }

    });

    require('./VanChartLibrary').register(Constants.WORD_CLOUD_CHART, VanChartWordCloud);

    return VanChartWordCloud;
});
/**
 * Created by eason on 2017/2/20.
 */
define('vans/TreeMapLayout',['require','../utils/BaseUtils'],function(require){
    var BaseUtils = require('../utils/BaseUtils');

    var hierarchyLayout = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [ root ], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value) {
                        node.value = 0;
                    }
                    node.children = childs;
                } else {
                    if (value) {
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    }
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) {
                    childs.sort(sort);
                }
                if (value && (parent = node.parent)) {
                    parent.value += node.value;
                }
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) {
                return sort;
            }
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) {
                return children;
            }
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) {
                return value;
            }
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) {
                        node.value = 0;
                    }
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) {
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    }
                    if (parent = node.parent) {
                        parent.value += node.value;
                    }
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        BaseUtils.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [ node ];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0) {
                    nodes.push(children[n]);
                }
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [ node ], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n) {
                    nodes.push(children[i]);
                }
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    
    var treeLayout = function() {
        var hierarchy = hierarchyLayout().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) {
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            } else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) {
                        left = node;
                    }
                    if (node.x > right.x) {
                        right = node;
                    }
                    if (node.depth > bottom.depth) {
                        bottom = node;
                    }
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [ root0 ]
            }, queue = [ root1 ], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) {
                return separation;
            }
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) {
                return nodeSize ? null : size;
            }
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) {
                return nodeSize ? size : null;
            }
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    var treemapLayout = function() {
        var hierarchy = hierarchyLayout(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) {
                    continue;
                }
                if (r < rmin) {
                    rmin = r;
                }
                if (r > rmax) {
                    rmax = r;
                }
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) {
                    v = rect.dy;
                }
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) {
                    v = rect.dx;
                }
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies) {
                hierarchy.revalue(root);
            }
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) {
                stickies = nodes;
            }
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) {
                return size;
            }
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) {
                return padding;
            }
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ],
                padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) {
                return round != Number;
            }
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) {
                return sticky;
            }
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) {
                return ratio;
            }
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length){
                return mode;
            }
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }

    return{
        treeLayout: treeLayout,
        treemapLayout: treemapLayout
    }
});
/**
 * Created by Mitisky on 16/8/10.
 */
define('dom/EventObject',['require','../dom/Evented'],function(require){

    var Evented = require('../dom/Evented');

    var EventObject = Evented.extend({

        initialize: function (events) {
            this.events = events;
        },

        getEvents: function () {
            return this.events
        }
    });

    return EventObject;
});

/**
 * Created by shine on 2017/1/10.
 */
define('vans/VanChartStructure',['require','./VanChart','./../Constants','./../utils/BaseUtils','./../utils/BezierEasing','./../utils/BoundsManager','./TreeMapLayout','./ForceLayout','../utils/Scale','../utils/PathGenerator','../dom/EventObject','./VanChartLibrary'],function(require){

    var VanChart = require('./VanChart');
    var Constants = require('./../Constants');
    var BaseUtils = require('./../utils/BaseUtils');
    var BezierEasing = require('./../utils/BezierEasing');
    var BoundsManager = require('./../utils/BoundsManager');
    var TreeLayout = require('./TreeMapLayout').treeLayout;
    var ForceLayout = require('./ForceLayout');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    var EventObject = require('../dom/EventObject');

    var LINK_TIME = 1200;
    var NODE_TIME = 300;
    var UPDATE_TIME = 500;
    var LINK_EASE = BezierEasing.css['ease-in-quad'];
    var NODE_EASE = BezierEasing.css['swing'];

    var LABEL_GAP = 2;

    function nodeRadius(node, maxLevel) {
        return node.radius = node.options.radius ? node.options.radius : (9 + (maxLevel - node.level) * 3)/2;
    }

    function forceDelayTimeArray(maxLevel) {
        if(maxLevel === 0){
            return [0];
        }
        var array = [], level = 0, temp = 0, length = 2 - Math.pow(2, -(maxLevel - 1));
        while (level <= maxLevel){
            array[level] = LINK_TIME * BezierEasing.calculateQuadInT(temp/length);
            temp += Math.pow(2, -level);
            level++;
        }
        return array;
    }

    function treeDelayTimeArray(maxLevel) {
        if(maxLevel === 0){
            return [0];
        }
        var array = [], level = 0;
        while (level <= maxLevel){
            array[level] = LINK_TIME * BezierEasing.calculateQuadInT(level/maxLevel);
            level++;
        }
        return array;
    }

    function strokeWidth(edge, maxLevel) {
        return maxLevel - edge.source.level;
    }

    var VanChartStructure =  VanChart.extend({

        vanChartType:'vanChartStructure',

        dealAxisZoom:function(downPos, upPos){
            var vanchart = this, plotBounds = vanchart.bounds,
                isHorizontal = vanchart._horizontalLayout(),
                isRadial = vanchart._radialLayout();

            var zoomParas = vanchart._calculateZoomParas(downPos, upPos),
                shiftX = zoomParas.shiftX, shiftY = zoomParas.shiftY, scale = zoomParas.scale;

            vanchart.nodes.forEach(function(node){

                var x = node.posX + shiftX;
                var y = node.posY + shiftY;

                x -= plotBounds.width/2;
                y -= plotBounds.height/2;

                node.posX = x * scale + plotBounds.width/2 - shiftX;
                node.posY = y * scale + plotBounds.height/2 - shiftY;
                node.x = isHorizontal ? node.posY : node.posX;
                node.y = isHorizontal ? node.posX : node.posY;
                node.radius *= scale;

                node.labelPos = vanchart._labelPos(node);

                var nodeAttrs = vanchart._nodeAttrs(node),
                    textAttrs = {transform:BaseUtils.makeTranslate(node.labelPos)};

                var trans = 'translate('+ node.posX +','+ node.posY +')';

                node.graphic.animate({
                    duration:UPDATE_TIME,
                    attr:{'transform':trans}
                });

                node.graphic.nodeGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:nodeAttrs
                });

                node.textGraphic && node.textGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:textAttrs
                })
            });

            vanchart.edges.forEach(function (edge) {
                var edgeAttrs = isRadial ? vanchart._forceLinkAttrs(edge) : {d:vanchart._treeLinkPath(edge)};
                edge.linkGraphic.animate({
                    duration:UPDATE_TIME,
                    attr:edgeAttrs
                });
            });

            if(vanchart._forceDragEnabled()) {
                vanchart.force.scale(scale);
            }

            this.scale = scale * BaseUtils.pick(this.scale, 1);
        },

        renderSeries:function(){
            this.fire('animationStart');

            var vanchart = this, renderer = vanchart.renderer, plotBounds = vanchart.bounds;
            var series = vanchart.seriesOfType(Constants.STRUCTURE_CHART);

            if(!(vanchart.nodes && series && series.length)){
                return;
            }

            vanchart.layout = vanchart.options.plotOptions.layout;
            vanchart.animation = vanchart.options.plotOptions.animation;
            vanchart.lineWidth = vanchart.options.plotOptions.lineWidth;
            if(BaseUtils.hasNotDefined(vanchart.lineWidth)){
                vanchart.lineWidth = null;
            }

            if(!vanchart.linkGroup){
                vanchart.linkGroup = renderer.group().addTo(vanchart.clipSeriesGroup);
                vanchart.nodeGroup = renderer.group().addTo(vanchart.clipSeriesGroup);
            }

            vanchart.linkGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            vanchart.nodeGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            vanchart.groupTrans = null;
            vanchart.registerInteractiveTarget(series[0], vanchart.linkGroup);

            if(vanchart._radialLayout()) {
                vanchart._forceRenderer();
            } else {
                vanchart._treeRenderer();
            }

            if (!this.animationCount) {
                this.fire('animationEnd');
            }
        },

        _animationStart:function(){
            //fire'animationEnd'
            this._animationStarted = true;
            this.animationCount = 0;

            this.removeMoreLabel();

            this.series.forEach(function(ser){
                ser._removeDataLabels();
            });
        },

        _forceDragEnabled:function () {
            return this.animation && this._radialLayout() && this.options.plotOptions.force;
        },

        _treeDragEnabled:function () {
            return this.animation && !this._radialLayout() && this.options.plotOptions.force;
        },

        _verticalLayout:function () {
            return this.layout === 'vertical';
        },

        _horizontalLayout:function () {
            return this.layout === 'horizontal';
        },

        _radialLayout:function () {
            return this.layout === 'radial';
        },

        _validPosition:function (pos, minGap, maxGap, max) {
            return Math.min(max - maxGap, Math.max(pos, minGap));
        },

        _forceRenderer:function () {
            var vanchart = this, plotBounds = vanchart.bounds;

            var nodes = vanchart.nodes, edges = vanchart.edges, maxLevel = vanchart.maxLevel;

            var maxLength = Math.min(plotBounds.width, plotBounds.height)/4;
            function linkDistance(edge) {
                return maxLength * Math.pow(2, -edge.source.level);
            }

            var centerX = plotBounds.width/2, centerY = plotBounds.height/2;
            function initTick() {
                tick(true);
            }

            function tick(init) {
                //init
                var diffX = init ? vanchart.ancestor.x - centerX : 0, diffY = init ? vanchart.ancestor.y - centerY : 0;
                nodes.forEach(function (node) {
                    node.x -= diffX; node.y -= diffY;
                    node.labelPos = vanchart._labelPos(node);

                    nodeRadius(node, vanchart.maxLevel);
                    var left = node.radius, right = node.radius,
                        top = node.radius, bottom = node.radius;

                    if (node.hasValidDataLabel()) {
                        left = Math.max(left, node.x - node.labelPos.x);
                        right = Math.max(right, node.labelPos.x + node.labelDim.width - node.x);
                        top = Math.max(top, node.y - node.labelPos.y);
                        bottom = Math.max(bottom, node.labelPos.y + node.labelDim.height - node.y);
                    }

                    node.x = vanchart._validPosition(node.x, left, right, plotBounds.width);
                    node.y = vanchart._validPosition(node.y, top, bottom, plotBounds.height);
                    node.labelPos = vanchart._labelPos(node);

                    node.posX = node.x; node.posY = node.y;

                    node.graphic && node.graphic
                        .attr('transform', BaseUtils.makeTranslate(node));
                    node.textGraphic && node.textGraphic
                        .attr('transform', BaseUtils.makeTranslate(node.labelPos));
                });

                edges.forEach(function (edge) {
                    edge.linkGraphic && edge.linkGraphic
                        .attr("x1", edge.source.x)
                        .attr("y1", edge.source.y)
                        .attr("x2", edge.target.x)
                        .attr("y2", edge.target.y);

                });

            }

            vanchart.force && vanchart.force.stop();
            vanchart.force = ForceLayout().nodes(nodes).links(edges)
                .size([plotBounds.width, plotBounds.height])
                .linkDistance(linkDistance).gravity(0).charge(-150)
                .eachTick(initTick)
                .simulateForce();

            var delayTimeArray = forceDelayTimeArray(maxLevel);

            vanchart._rendererNodes(delayTimeArray);

            vanchart._renderLabels(delayTimeArray);

            vanchart._renderForceLink(delayTimeArray);

            vanchart.force.eachTick(dragTick);
            function dragTick() {
                tick(false);
            }
        },

        _renderForceLink:function (delayTimeArray) {
            var vanchart = this, renderer = vanchart.renderer;

            vanchart.edges.forEach(function (edge) {
                edge.linkGraphic && edge.linkGraphic.remove();
                edge.linkGraphic = null;

                var attrs = vanchart._forceLinkAttrs(edge);
                var plotOptions = vanchart.options.plotOptions,
                    styles = {
                        'fill':'none',
                        'stroke': plotOptions.lineColor,
                        'stroke-opacity': plotOptions.lineOpacity,
                        'stroke-width': vanchart.lineWidth == null ? strokeWidth(edge, vanchart.maxLevel) : vanchart.lineWidth
                    };

                edge.linkGraphic = renderer.line(attrs).style(styles).addTo(vanchart.linkGroup);
                edge.linkGraphic.datum(edge);

                if(vanchart.animation){
                    var sourceDelay = delayTimeArray[edge.source.level],
                        targetDelay = delayTimeArray[edge.target.level];

                    var st = sourceDelay/LINK_TIME,
                        tt = targetDelay/LINK_TIME,
                        sx = LINK_EASE(st),
                        tx = LINK_EASE(tt);

                    var tScale = Scale.linear().domain([0,1]).range([st, tt]),
                        xScale = Scale.linear().domain([sx, tx]).range([0, 1]);

                    edge.linkGraphic
                        .attr('x2', attrs.x1)
                        .attr('y2', attrs.y1)
                        .animate({
                            delay:sourceDelay,
                            ease:'linear',
                            duration:targetDelay - sourceDelay,
                            attrTween:{
                                'x2':function () {return function (t) {return attrs.x1 + (attrs.x2 - attrs.x1) * xScale(LINK_EASE(tScale(t)));}},
                                'y2':function () {return function (t) {return attrs.y1 + (attrs.y2 - attrs.y1) * xScale(LINK_EASE(tScale(t)));}}
                            }
                        });
                }
            });
        },

        _forceLinkAttrs:function (edge) {
            return {x1: edge.source.x, x2: edge.target.x, y1: edge.source.y, y2: edge.target.y}
        },

        _treeRenderer:function () {
            var vanchart = this, plotBounds = vanchart.bounds;
            var maxLevel = vanchart.maxLevel;

            var size =  vanchart._verticalLayout() ? [plotBounds.width, plotBounds.height]
                : [plotBounds.height, plotBounds.width];

            var tree = TreeLayout().size(size);

            var nodes = tree.nodes(vanchart.ancestor).reverse();

            vanchart._adjustTreeSize(tree, size, nodes, maxLevel);

            var delayTimeArray = treeDelayTimeArray(maxLevel);

            vanchart._rendererNodes(delayTimeArray);

            vanchart._renderLabels(delayTimeArray);

            vanchart._renderTreeLink();
        },

        //,&
        _adjustTreeSize: function (tree, size, nodes, maxLevel) {
            var vanchart = this, isVertical = vanchart._verticalLayout();
            var left = 0, right = size[0], top = 0, bottom = size[1];

            nodes.forEach(function (node) {
                var radius = nodeRadius(node, maxLevel);
                radius += (node.options.borderWidth || 0);
                var dataLabels = node.options.dataLabels, labelDim = node.labelDim;
                if(dataLabels && dataLabels.enabled) {
                    var width = labelDim.width, height = labelDim.height, out = dataLabels.align == Constants.OUTSIDE;
                    if(isVertical) {
                        left = Math.min(left, node.x - width / 2);
                        right = Math.max(right, node.x + width / 2);
                        top = Math.min(top, node.y - (out ? height + LABEL_GAP + radius : height / 2));
                        bottom = Math.max(bottom, node.y + (out ? 0 : height / 2));
                    } else {
                        left = Math.min(left, node.x - (out ? 0 : height / 2));
                        right = Math.max(right, node.x + (out ? radius + LABEL_GAP + height : height / 2));
                        top = Math.min(top, node.y - width / 2);
                        bottom = Math.max(bottom, node.y + width / 2);
                    }
                }
                left = Math.min(left, node.x - radius);
                right = Math.max(right, node.x + radius);
                top = Math.min(top, node.y - radius);
                bottom = Math.max(bottom, node.y + radius);
            });

            left = -left; right = right - size[0];top = -top;bottom = bottom - size[1];
            size = [size[0] - left - right, size[1] - top - bottom];

            tree.size(size);
            tree.nodes(vanchart.ancestor).reverse();

            nodes.forEach(function (node) {
                node.x = node.x + left;
                node.y = node.y + top;
            });
        },

        _treeLinkPath: function (link) {
            var vanchart = this, maxLevel = vanchart.maxLevel;

            var diagonalFun = vanchart._verticalLayout() ? function (d) {return [d.x, d.y];}
                : function (d) {return [d.y, d.x];};

            if(vanchart.lineWidth){
                var diagonal = PathGenerator.diagonal()
                    .projection(diagonalFun);
                return diagonal(link);
            }

            var source = link.source, target = link.target,
                width = strokeWidth(link, maxLevel), gap = width/2;

            var sx = source.x, sy = source.y,
                tx = target.x, ty = target.y, m = (sy + ty) / 2;
            var sx1 = sx - gap, tx1 = Math.min(tx - 0.25, tx - gap + 0.5),
                sx2 = sx + gap, tx2 = Math.max(tx + 0.25, tx + gap - 0.5);

            var p = [{x:sx1, y:sy},{x:sx1, y:m},{x:tx1, y:m},{x:tx1, y:ty},
                {x:tx2, y:ty},{x:tx2, y:m},{x:sx2, y:m},{x:sx2, y:sy}];

            p = p.map(diagonalFun);

            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3]
                + "L" + p[4] + "C" + p[5]  + " " + p[6] + " " + p[7];
        },

        _renderTreeLink:function () {
            var vanchart = this, renderer = vanchart.renderer, plotBounds = vanchart.bounds;

            var plotOptions = vanchart.options.plotOptions, styles;
            if(vanchart.lineWidth == null){
                styles = {
                    'fill': plotOptions.lineColor,
                    'fill-opacity': plotOptions.lineOpacity
                }
            } else {
                styles = {
                    'fill':'none',
                    'stroke':plotOptions.lineColor,
                    'stroke-opacity':plotOptions.lineOpacity,
                    'stroke-width':vanchart.lineWidth
                }
            }

            var minx = plotBounds.width, miny = plotBounds.height, maxx = 0, maxy = 0;
            vanchart.edges.forEach(function (link) {
                link.linkGraphic && link.linkGraphic.remove();
                link.linkGraphic = null;

                link.linkGraphic = renderer.path().addTo(vanchart.linkGroup);
                link.linkGraphic.attr('d', vanchart._treeLinkPath(link)).style(styles);

                link.linkGraphic.datum(link);

                var source = link.source, target = link.target;
                minx = Math.min(minx, source.posX);miny = Math.min(miny, source.posY);maxx = Math.max(maxx, source.posX);maxy = Math.max(maxy, source.posY);
                minx = Math.min(minx, target.posX);miny = Math.min(miny, target.posY);maxx = Math.max(maxx, target.posX);maxy = Math.max(maxy, target.posY);
            });

            var lineWidth = vanchart.lineWidth || 1,
                isHorizontal = vanchart.layout === Constants.HORIZONTAL_LAYOUT;

            if(vanchart.animation && BaseUtils.isSupportSVG()){
                // @CHART-1379
                var attrs = {
                    'x':minx - (isHorizontal ? 0 : lineWidth / 2),
                    'y':miny - (isHorizontal ? lineWidth / 2 : 0),
                    'width':(maxx - minx) + (isHorizontal ? 0 : lineWidth),
                    'height':(maxy - miny) + (isHorizontal ? lineWidth : 0)
                };

                if(!vanchart.linkGroup.clipG){
                    vanchart.linkGroup.clipG = renderer.createClip(attrs);
                    renderer.clip(vanchart.linkGroup, vanchart.linkGroup.clipG);
                }else{
                    renderer.updateClip(vanchart.linkGroup.clipG, attrs);
                }

                var clipKey = vanchart._verticalLayout() ? 'height' : 'width';
                var endAttr = {};endAttr[clipKey] = attrs[clipKey];

                vanchart.linkGroup.clipG.rect
                    .attr(clipKey, 0)
                    .animate({
                        ease:LINK_EASE,
                        duration:LINK_TIME,
                        attr:endAttr
                    });
            }
        },

        //with node.x node.y delayTime
        _rendererNodes:function (delayArray) {
            var vanchart = this, renderer = vanchart.renderer, maxLevel = vanchart.maxLevel;

            vanchart.nodes.forEach(function (node) {
                node._events = null;
                node.graphic && node.graphic.remove();
                node.graphic = null;

                var radius = nodeRadius(node, maxLevel), delay = delayArray[node.level];

                node.posX = parseInt(vanchart._horizontalLayout() ? node.y : node.x);
                node.posY = parseInt(vanchart._horizontalLayout() ? node.x : node.y);

                var attrs = vanchart._nodeAttrs(node),
                    style = node.series.getStyle(node);

                node.graphic = renderer.group()
                    .attr('transform', 'translate('+ node.posX +','+ node.posY +')')
                    .addTo(vanchart.nodeGroup);

                if(node.options.image){
                    node.graphic.nodeGraphic = renderer.image(attrs).imageContent(node.options.image).addTo(node.graphic)
                }else {
                    node.graphic.nodeGraphic = renderer.circle(attrs).style(style).addTo(node.graphic);
                }

                function createNodeEventObject() {
                    var nodeEventObject = new EventObject(vanchart.getEvents());
                    nodeEventObject.vanchart = vanchart;
                    return nodeEventObject;
                }

                function registerTarget(object, graphic) {
                    graphic && vanchart.registerInteractiveTarget(object, graphic);
                }

                registerTarget(node, node.graphic);
                registerTarget(createNodeEventObject(), node.graphic.nodeGraphic);

                node.graphic
                    .attr('transform', 'translate('+ node.posX +','+ node.posY +') scale(0.01)')
                    .animate([{
                        delay:delay,
                        ease:NODE_EASE,
                        duration:NODE_TIME/2,
                        attr:{'transform': 'translate('+ node.posX +','+ node.posY +') scale(1.5)'}
                    },{
                        ease:NODE_EASE,
                        duration:NODE_TIME/2,
                        attr:{'transform': 'translate('+ node.posX +','+ node.posY +') scale(1)'}
                    }]);

                if(vanchart._forceDragEnabled()) {
                    vanchart.force.registerDragTarget(node, node.graphic);
                }

            });

        },

        _nodeAttrs:function (node) {
            var radius = node.radius;
            return node.options.image ? {'preserveAspectRatio':'none', 'x':-radius, 'y':-radius, 'width':radius*2, 'height':radius*2}
                : {'cx':0, 'cy':0, 'r':radius}
        },

        _labelPos:function (node) {
            if(!node.labelDim){
                return;
            }
            var dataLabels = node.options.dataLabels;
            var dim = node.labelDim, alignInside = dataLabels.align == Constants.INSIDE;
            return alignInside ? {x: node.posX - dim.width / 2, y: node.posY - dim.height / 2}
                : {x: node.posX - dim.width / 2, y: node.posY - node.radius - LABEL_GAP - dim.height};
        },

        _animationEnd:function () {
            this._animationStarted = false;
            this._consoleDone();
        },

        _renderLabels:function (delayArray) {
            var manager = new BoundsManager(), vanchart = this;
            var needShowMoreLabel = this._needShowMoreLabel();

            vanchart.nodes && vanchart.nodes.forEach(function (node) {
                node.textGraphic && node.textGraphic.remove();
                node.textGraphic = null;

                var dataLabels = node.options.dataLabels, series = node.series;

                if (dataLabels && dataLabels.enabled) {
                    var pos = vanchart._labelPos(node);

                    if (dataLabels.autoAdjust) {
                        pos = series._calculateAutoLabelPos(node, pos, vanchart._horizontalLayout(), manager);
                    }

                    if (pos) {
                        node.labelPos = pos;
                        manager.addBounds(BaseUtils.makeBounds(node.labelPos, node.labelDim));
                    }

                    series._createTextGraphic(node);

                    // moreLabel
                    if(needShowMoreLabel) {
                        setTimeout(function (){
                            series._showMoreLabel(node);
                        }, delayArray[node.level])
                    }

                    node.textGraphic.style('opacity', 0).animate({
                        delay:delayArray[node.level],
                        duration:0,
                        style:{opacity:1}
                    })
                }
            });
        },

        _onPanStart:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            vanchart.groupTrans = vanchart.groupTrans || vanchart.bounds;

            vanchart.currentPoint = ev.containerPoint;
        },

        _onPanMove:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            var transX = ev.containerPoint.x - vanchart.currentPoint.x,
                transY = ev.containerPoint.y - vanchart.currentPoint.y;

            vanchart.groupTrans.x += transX;
            vanchart.groupTrans.y += transY;
            vanchart.currentPoint = ev.containerPoint;

            var trans = BaseUtils.makeTranslate(vanchart.groupTrans);
            vanchart.linkGroup.attr('transform', trans);
            vanchart.nodeGroup.attr('transform', trans);
            if (vanchart.ancestor.series.textGraphicGroup) {
                vanchart.ancestor.series.textGraphicGroup.attr('transform', trans);
            }
        },

        _onPanEnd:function(ev){
            var eventObject = this, vanchart = eventObject.vanchart;

            vanchart.handler.panTarget = null;
        },

        getEvents: function(){
            var vanchart = this;

            return vanchart._treeDragEnabled() ? {
                    'panstart':vanchart._onPanStart,
                    'panmove':vanchart._onPanMove,
                    'panend':vanchart._onPanEnd
                } : {};
        }

    });

    require('./VanChartLibrary').register(Constants.STRUCTURE_CHART, VanChartStructure);

    return VanChartStructure;
});
/**
 * Created by Yuqian on 2017/2/22.
 */

/*
 Copyright (c) JS Foundation and other contributors

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 https://github.com/moment/moment
 */

define('dateUnits/dateFormat',['require'],function (require) {

    var defaultValues = {

        duration: {
            year: 'years',
            month: 'months',
            day: 'days',
            hour: 'hours',
            minute: 'minutes',
            second: 'seconds'
        },

        halfYears: ['H1', 'H2'],
        quarters: 'Q1_Q2_Q3_Q4'.split('_'),
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        meridiem: ['am', 'pm'],
        qDay: '0h~6h_6h~12h_12h~18h_18h~24h'.split('_')
    };

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w{1,3}|wo|W[o|W]?|Q{2,3}|Qo?|[yY]{2,6}|gg(ggg?)?|GG(GGG?)?|e{2,6}|E|a|A|hh?|HH?H?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    var durationTokenFunctions = {};

    function zeroFill (number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        // if (ordinal) {
        //     formatTokenFunctions[ordinal] = function () {
        //         return this.localeData().ordinal(func.apply(this, arguments), token);
        //     };
        // }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    function formatDate (m, format) {
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    // according to Wang Jun's doc
    // 1.222 -> 1.22; 1.20 -> 1.2
    function decimalAdjust(value, exp) {
        // Shift
        value = value.toString().split('e');
        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
        // Shift back
        value = value.toString().split('e');
        return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
    }

    // default format like: '25.5hours'
    function defaultDurationFormatFunc(token, d) {
        return decimalAdjust(d.get(token), -2) + defaultValues.duration[token]
    }

    function formatDuration (d, token) {

        if (durationTokenFunctions[token] == null) {
            if (typeof defaultValues.duration[token] === 'string') {
                durationTokenFunctions[token] = defaultDurationFormatFunc.bind(null, token);
            } else { // function
                durationTokenFunctions[token] = defaultValues.duration[token]
            }
        }

        return durationTokenFunctions[token](d)
    }

    function setLocale (config) {

        // if we had to change the locale after load
        // clear and re-init following cache
        // formatFunctions = {};
        // formatTokenFunctions = {};
        // durationTokenFunctions = {};

        for (var prop in config) {
            if (prop.charAt(0) === '_') {
                continue
            }
            if (prop === 'base') {
                config.base(addFormatToken, defaultValues);
            } else {
                defaultValues[prop] = config[prop];
            }
        }
    }

    // format according to
    // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
    //
    // custom:
    // half year = N
    // 1/4 day = I
    // HHH

    var add = addFormatToken;

    // year
    add('y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    add(0, ['yy', 2], 0, function () {
        return this.year() % 100;
    });
    add(0, ['yyyy',   4],       0, 'year');
    add('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });
    add(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });
    add(0, ['YYYY',   4],       0, 'year');

    // useful?
    add(0, ['yyyyy',  5],       0, 'year');
    add(0, ['yyyyyy', 6, true], 0, 'year');

    // half year
    add('N', 0, 0, function () {
        return defaultValues.halfYears[this.halfYear() - 1]
    });

    // quarter
    add('Q', ['QQ', 2], 0, 'quarter');
    add('QQQ', 0, 0, function () {
        return defaultValues.quarters[this.quarter() - 1];
    });

    // month
    add('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });
    add('MMM', 0, 0, function () {
        return defaultValues.monthsShort[this.month()]
    });
    add('MMMM', 0, 0, function () {
        return defaultValues.months[this.month()]
    });

    // week of year
    add('w', ['ww', 2], 0, 'week');
    add('www', 0, 0, function () {
        return 'Week' + this.week();
    });

    // week day
    add('e', ['ee', 2], 0, 'day');
    add('eee', 0, 0, function () {
        return defaultValues.weekdaysShort[this.day()]
    });
    add('eeee', 0, 0, function () {
        return defaultValues.weekdays[this.day()]
    });
    add('eeeeee', 0, 0, function () {
        return defaultValues.weekdaysMin[this.day()]
    });

    // date
    add('d', ['dd', 2], 0, 'date');

    // am/pm
    add('a', 0, 0, function () {
        return defaultValues.meridiem[this.meridiem() - 1]
    });

    // 1/4 day
    add('I', 0, 0, function () {
        return defaultValues.qDay[this.qDay() - 1];
    });

    // hour
    add('H', ['HH', 2], 0, 'hour');
    // custom format
    add('HHH', 0, 0, function () {
        return this.hour() + 'h'
    });

    // minute
    add('m', ['mm', 2], 0, 'minute');

    // second
    add('s', ['ss', 2], 0, 'second');

    return {
        // addFormatToken: addFormatToken,
        formatDate: formatDate,
        formatDuration: formatDuration,
        setLocale: setLocale
    };
});

/**
 * Created by Yuqian on 2017/3/2.
 */

define('dateUnits/dateDuration',['require','./dateFormat'],function (require) {

    var formatDuration = require('./dateFormat').formatDuration;

    var SECOND = 1000,
        MINUTE = 60 * SECOND,
        HOUR = 60 * MINUTE,
        DAY = 24 * HOUR,
        WEEK = 7 * DAY,

        // not accurate
        YEAR = 365 * DAY,
        MONTH = 30 * DAY,
        QUARTER = 3 * MONTH;

    /**
     * read a millisecond, get x unit duration
     * @param dur
     * @constructor
     */
    var Duration = function (dur) {
        this._ms = +dur;
    };

    var proto = Duration.prototype = {

        valueOf: function () {
            return this._ms
        },

        as: function (units) {
            return formatDuration(this, units)
        },

        get: function (units) {
            var result = this._ms;
            switch (units) {
                case 'millisecond': break;
                case 'second': result /= SECOND ; break;
                case 'hour': result /= HOUR; break;
                case 'minute': result /= MINUTE; break;
                case 'day': result /= DAY; break;
                case 'month': result /= MONTH; break;
                case 'year': result /= YEAR; break;
                default: throw new Error('Unknown unit ' + units);
            }
            return result
        }
    };

    var duration = function (dur) {
        return new Duration(dur)
    };

    return duration

});

/**
 * Created by Yuqian on 2017/2/13.
 */

define('dateUnits/dateUnits',['require','./dateFormat','./dateDuration'],function (require) {

    var dateFormat = require('./dateFormat');
    var duration = require('./dateDuration');
    var formatDate = dateFormat.formatDate;

    // change locale:
    // dateUnits.locale(require('./locale/zh-cn'));

    var DAY = 864e5;

    var aliasList = ["year", "month", "halfYear", "quarter", "week", "day", "date", "meridiem", "qDay", "hour", "minute", "second", "millisecond"];
    var ALIAS = {};

    aliasList.map(function (unit) {
        ALIAS[unit + 's'] = unit;
    });

    /**
     *
     * @param num
     * @param from
     * @param to
     * @returns {{
     * c: number,  c circles
     * r: number   r remainder
     * }}
     */
    function getCR (num, from, to) {
        var c = Math.floor((num - from) / (to - from + 1));
        var r = num - (to - from + 1) * c;
        return {
            c: c,
            r: r
        }
    }

    function isLeapYear (year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function daysInYear (year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#First_week
    // 4 Jan is always in the first week
    function firstWeekOffset (year) {
        var jan4Day = new Date(year, 0, 4).getDay() || 7;
        return 4 - jan4Day;
    }

    function weeksInYear (year) {
        var weekOffset = firstWeekOffset(year),
            weekOffsetNext = firstWeekOffset(year + 1);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    /**
     * get local date unit
     * @param date
     * @constructor
     */
    var DateUnits = function (date) {
        this._d = date;
    };

    var proto = DateUnits.prototype = {

        valueOf: function () {
            return +this._d
        },

        year: function (year) {
            if (year != null) {
                this._d.setFullYear(year);
                return this
            }
            return this._d.getFullYear()
        },

        /**
         * month from 0
         * @returns {number|Object}
         */
        month: function (month) {
            if (month != null) {
                this._d.setMonth(month);
                return this
            }
            return this._d.getMonth()
        },

        /**
         * get 1 or 2 (h1 or h2)
         * @returns {number|Object}
         */
        halfYear: function (h) {
            if (h != null) {
                var o = getCR(h, 1, 2);
                o.c && (this.year(this.year() + o.c));
                this.month(o.r === 1 ? 0 : 6);
                return this
            }
            return this.month() < 6 ? 1 : 2
        },

        /**
         * quarter 1, 2, 3, 4
         * @returns {number|Object}
         */
        quarter: function (q) {
            if (q != null) {
                var o = getCR(q, 1, 4);
                o.c && (this.year(this.year() + o.c));
                this.month((o.r - 1) * 3);
                return this
            }
            return Math.ceil((this.month() + 1) / 3)
        },

        dayOfYear: function () {
            return Math.floor((this._d - new Date(this.year(), 0, 1)) / DAY) + 1;
        },

        /**
         * 1-53 week of year
         * https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
         * @returns {{week: number, year: number}}
         */
        // moving to 'doy, dow' version may be better
        // doy = 1, dow = 4 now
        weekOfYear: function () {
            var week = Math.floor(
                (this.dayOfYear() - (this.day() || 7) + 10) / 7
            );
            var year = this.year();

            if (week < 1) {
                year -= 1;
                week = weeksInYear(year);
            } else
            if (week > weeksInYear(year)) {
                week = week - weeksInYear(year);
                year += 1;
            }

            return {
                week: week,
                year: year
            }
        },

        week: function () {
            return this.weekOfYear().week
        },

        day: function (day) {
            if (day != null) {
                var diff = day - (this.day() || 7);
                this._d.setDate(this.date() + diff);
                return this
            }
            return this._d.getDay()
        },

        date: function (date) {
            if (date != null) {
                this._d.setDate(date);
                return this
            }
            return this._d.getDate()
        },

        /**
         * 1 for a.m.; 2 for p.m.
         * @returns {number|Object}
         */
        meridiem: function (m) {
            if (m != null) {
                var o = getCR(m, 1, 2);
                o.c && (this.date(this.date() + o.c));
                this.hours(o.r === 1 ? 0 : 12);
                return this
            }
            return this.hours() < 12 ? 1 : 2
        },

        /**
         * 1 for 0~6; 2 for 6~12; 3 for 12~18; 4 for 18~24
         * @param q
         * @returns {number|object}
         */
        qDay: function (q) {
            if (q != null) {
                var o = getCR(q, 1, 4);
                o.c && (this.date(this.date() + o.c));
                this.hour((o.r - 1) * 6);
                return this
            }
            return Math.ceil((this.hour() + 1) / 6)
        },

        hour: function (h) {
            if (h != null) {
                this._d.setHours(h);
                return this
            }
            return this._d.getHours()
        },

        minute: function (min) {
            if (min != null) {
                this._d.setMinutes(min);
                return this
            }
            return this._d.getMinutes()
        },

        second: function (s) {
            if (s != null) {
                this._d.setSeconds(s);
                return this
            }
            return this._d.getSeconds()
        },

        millisecond: function (ms) {
            if (ms != null) {
                this._d.setMilliseconds(ms);
                return this
            }
            return this._d.getMilliseconds();
        },

        startOf: function (units) {
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'halfYear':
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'day':
                case 'date':
                    this.hours(0);
                /* falls through */
                case 'hour':
                case 'meridiem':
                case 'qDay':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
            }

            if (units === 'week') {
                this.day(1);
            } else
            if (['quarter', 'halfYear', 'meridiem', 'qDay'].indexOf(units) !== -1) {
                this[units](this[units]());
            }

            return this
        },

        endOf: function (units) {
            if (!units || units === 'millisecond') {
                return this;
            }
            return this.add(1, units).startOf(units).add(-1, 'millisecond')
        },
        
        add: function (number, period) {
            period = ALIAS[period] || period;

            if (period === 'halfYear') {
                this.add(number * 6, 'month');
            } else
            if (period === 'quarter') {
                this.add(number * 3, 'month');
            } else
            if (period === 'week') {
                this.add(number * 7, 'date');
            } else
            if (period === 'meridiem') {
                this.add(number * 12, 'hour');
            } else
            if (period === 'qDay') {
                this.add(number * 6, 'hour');
            } else {
                if (period === 'day') {
                    period = 'date';
                }
                var now = this.get(period);
                this[period](now + number);
            }

            return this
        },

        isWeekend: function () {
            var d = this.day();
            return d === 6 || d === 0
        }

    };

    // alias
    aliasList.map(function (unit) {
        proto[unit + 's'] = proto[unit];
    });

    proto.get = function (unit) {
        return this[unit]();
    };

    proto.format = function (inputString) {
        return formatDate(this, inputString);
    };

    var dateUnits = function (date) {
        var dateObject;
        if (date instanceof DateUnits) {
            dateObject = new Date(date._d);
        } else
        if (date) { // loose check
            dateObject = new Date(date);
        } else {
            dateObject = new Date();
        }
        return new DateUnits(dateObject)
    };

    dateUnits.isLeapYear = isLeapYear;
    dateUnits.daysInYear = daysInYear;
    dateUnits.firstWeekOffset = firstWeekOffset;
    dateUnits.weeksInYear = weeksInYear;
    dateUnits.setLocale = dateFormat.setLocale;
    dateUnits.duration = duration;

    return dateUnits
});

/**
 * Created by eason on 16/2/19.
 * 
 */
define('chart/Point',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary','../dom/Evented'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var Evented = require('../dom/Evented');

    var NEGATIVE_COLOR = 'rgb(138, 138, 138)';

    var Point = Evented.extend({

        vanChartType: 'point',

        initialize:function(options, series){
            this.series = series;

            this.refresh(options || {});
        },

        refresh:function(options){
            var series = this.series, vanchart = series.vanchart;

            //
            this.originalColor = options.color;this.originalMarkerFillColor = options.marker && options.marker.fillColor;

            options = this.options = BaseUtils.createOptions(options, [series.options]);

            var isSeriesAcc = series.isSeriesAccumulated();
            var category = series.type == Constants.BAR_CHART ? options.y : options.x;
            var seriesName = series.name;

            this.category = isSeriesAcc ? seriesName : category;
            this.seriesName = isSeriesAcc ? category : seriesName;
            this.value = this.getTargetValue();
            this.name = BaseUtils.pick(this.options.x, this.options.name);

            // point.categoryArray
            this.categoryArray = BaseUtils.isArray(options.categoryArray) ?
                options.categoryArray.map(function (cate){  return cate; }) :
                [this.category];
            this.categoryArrayStr = BaseUtils.encodeCategoryArray(this.categoryArray);  // 

            //shine:yvaluevaluesizebubble chart
            this.x = options.x;
            this.y = options.y;    // ytargetKey y
            this.size = options.size;

            this.visible = true;
            this.isNull = series.isNullValue(this);
            this.points = isSeriesAcc ? series.points : vanchart.registerPointsPara(this);

            // try to eliminate properties in large mode
            // if (series.options.large) {
            //     return;
            // }
            // geo

            if(options.drilldown && options.drilldown.geo){
                var Geo = ComponentLibrary.get(ComponentLibrary.GEO_COMPONENT);
                this.geo = new Geo(options.drilldown.geo, ComponentLibrary.GEO_COMPONENT, vanchart);
            }
            BaseUtils.calculateFontSizeWithScale(options.dataLabels && options.dataLabels.style);
            BaseUtils.calculateFontSizeWithScale(options.tooltip && options.tooltip.style);

            //@deprecated H5,
            this.jsonHyperlink = options.jsonHyperlink;
            this.drillUpLink = options.drillUpLink;

            //todo 
            this.hyperlink = options.hyperlink;
            this.options.onClick = this.options.onClick || this.options.click;
        },

        //
        refreshPointColor:function(){
            var point = this, options = point.options, series = point.series, vanchart = series.vanchart;
            if (!series.isTreeSeries()) {
                //colors
                //colorsplotOptions

                var _opacity = options.opacity, _markerOpacity = options.opacity;
                var colorKey;
                if(series.type == Constants.STRUCTURE_CHART){
                    colorKey = this.level;
                }else{
                    // options.namecreateOptions
                    colorKey = series.isSeriesAccumulated() ? BaseUtils.pick(options.x, options.name, series.options.name) : series.name;
                }
                //
                var _color = vanchart.getDefaultSeriesColor(colorKey);
                var _markerColor = _color;

                if(options.marker){
                    options.marker = BaseUtils.clone(options.marker);
                    _markerColor = options.marker.fillColor || _markerColor;
                }

                // 
                // large lineMap cannot use range
                if (!(series.type === Constants.LINE_MAP && series.options.large)) {
                    var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
                    if (rangeLegend) {
                        _color = rangeLegend.getColorWithSize(this.getTargetValue(), series.options.large);
                        _markerColor = _color;
                        this.visible = !!_color;
                    }
                }

                //
                _markerColor = series.originalColor || _markerColor;
                _markerColor = series.originalMarkerFillColor || _markerColor;

                //
                _color = this.originalColor || series.originalColor || _color;
                _markerColor = this.originalColor || _markerColor;
                _markerColor = this.originalMarkerFillColor || _markerColor;

                //bands
                if((series.type == Constants.BUBBLE_CHART || series.type == Constants.FORCE_BUBBLE_CHART) && !rangeLegend) {
                    if(point.getTargetValue() < 0 && point.options.displayNegative){
                        _color = NEGATIVE_COLOR;
                    } else if(point.getTargetValue() < 0){
                        _color = null;
                    }
                }

                if(_color){
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(_color, _opacity);
                    _color = hexAlpha.hex;
                    _opacity = hexAlpha.alpha;
                }

                if(_markerColor){
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, _markerOpacity);
                    _markerColor = hexAlpha.hex;
                    _markerOpacity = hexAlpha.alpha;
                }

                var marker = options.marker;
                if(marker) {
                    marker.fillColor = _markerColor;
                    marker.fillColorOpacity = _markerOpacity;
                    marker.radius = isNaN(marker.radius) ? 4.5 : marker.radius;
                    marker.symbol = marker.symbol || (series.marker && series.marker.symbol) || '';
                }

                if(_color){
                    this.color = _color;
                    this.opacity = _opacity;
                    this.mouseOverColor = this.options.mouseOverColor || ColorUtils.getHighLightColor(_color);
                    this.clickColor = ColorUtils.getClickColor(_color);
                    this.clickOpacity = _opacity * 0.95;
                }

                this.borderColor = this.options.borderColor;
                this.borderOpacity = this.options.borderOpacity;
            }
        },

        getTargetValue:function(){
            //
            var value = this.options[this.series.getTargetKey()];

            if(isNaN(+value)){

                return this.series.isNullValue(this) ? 0 : value;

            }else{
                return +value;
            }
        },

        getLatLng:function(feature){
            var lnglat = this.options.lnglat;

            if(!lnglat){
                var geo = this.series.vanchart.getCurrentGeo();

                if(!feature){
                    feature = geo.getFeaturesByName(this.name, this.series.type);
                    feature = feature && feature[0];
                }

                if(feature){
                    lnglat = geo.getDataPointLngLat(this, feature);
                }
            }

            return lnglat ? [lnglat[1], lnglat[0]] : null;
        },

        getStackPointPreSufPoint:function (point) {

            var series = point.series, stackKey = [series.type, series.stack, point.category].join('-');

            var preP, sufP, find = false;
            for(var dataIndex = 0, dataCount = point.points.length; dataIndex < dataCount; dataIndex++){
                var p = point.points[dataIndex], ser = p.series, key = [ser.type, ser.stack, p.category].join('-');
                if(p == point){
                    find = true;
                } else if(key == stackKey && p.isVisible()){
                    if(find){
                        sufP = p;
                        break;
                    } else {
                        preP = p;
                    }
                }
            }
            return {pre:preP, suf:sufP};
        },

        _mapPointOnMouseState:function (isChosen, duration, ease, style) {
            var point = this, series = point.series, vanchart = series.vanchart;
            if(vanchart.isMapPointVisible(point) && point.layers){

                point.layers && point.layers.forEach(function(layer){
                    layer._onMouseState(isChosen, duration, ease, style);
                });

            }
        },

        /**
         * pointiddomain
         * !!!tooltippoint.category
         * @return {[type]} [description]
         */
        getCategory: function(){
            var series = this.series, isMultiCategoryBased = series.isMultiCategoryAxisBased();
            return isMultiCategoryBased ? this.categoryArrayStr : this.category;
        }
    });


    Point.include({

        _onPointMouseOver: function (ev) {

            var point = this, options = point.options, series = this.series, vanchart = series.vanchart, renderer = vanchart.renderer;
            var hoverPoint = vanchart.hoverPoint, hoverSeries = vanchart.hoverSeries,
                hoverPoints = vanchart.hoverPoints, sharedAxis = vanchart.getSharedAxis();

            if(hoverPoint === point){
                return;
            }
            var share = options.tooltip && options.tooltip.shared && point.points && sharedAxis && point.series.supportTooltipShared();
            var hoverSameCategory = hoverPoints && hoverPoints.length && point.getCategory() == hoverPoints[0].getCategory();
            if(share && hoverSameCategory && series.defaultMarker){
                //   
                // returnover-create-default-marker then out-delete-default-marker
                return;
            }

            if (series.isTreeSeries()) {
                series.vanchart.showTooltip(point, ev);
                series.fire('pointMouseOver', point);
                return;
            }

            hoverPoint && hoverPoint.fire('mouseout', ev);

            if (share) {
                var valid = vanchart.getValidPointsPara(point.getCategory());

                //outoverover series.createDefaultMarker then out delete
                // todo hoverPoints
                if (hoverPoints && hoverPoints.length && hoverPoints[0] != valid[0]) {
                    hoverPoints[0]._onPointMouseOut.call(hoverPoints[0], ev);

                    if(!point.series.defaultMarker && hoverPoints[0].series.defaultMarker){
                        //
                        hoverPoints[0].points.forEach(function (p) {
                             p.series.fire('pointMouseOut', p);
                        });
                    }
                }

                var max = valid
                    .reduce(function (prev, curr) {
                        curr.series._onPointMouseOver.call(curr, curr);  //  mouseOvercurr

                        if (!prev) {
                            return curr;
                        }
                        return (curr.getTargetValue() > prev.getTargetValue()) ? curr : prev;
                    }, 0);

                if(sharedAxis && valid.length){
                    sharedAxis.drawHighlightBackground(valid);
                }

                series.vanchart.showSharedTooltip(point, ev);

                vanchart.hoverPoints = valid;   // todo hoverPointshighLight

            }else{

                series.vanchart.showTooltip(point, ev);

                series.fire('pointMouseOver', point);

                if(hoverSeries != point.series){
                    hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                    point.series.fire('mouseover', ev);
                }

                vanchart.hoverSeries = point.series;
                vanchart.hoverPoint = point;

            }
        },

        _onPointMouseMove:function(ev){
            var point = this, options = point.options, series = this.series, vanchart = series.vanchart, sharedAxis = vanchart.getSharedAxis();
            var share = options.tooltip && options.tooltip.shared && point.points && sharedAxis && point.series.supportTooltipShared();

            share ? vanchart.showSharedTooltip(vanchart.hoverPoints && vanchart.hoverPoints[0], ev)
                : vanchart.showTooltip(vanchart.hoverPoint, ev);
        },

        _onPointMouseOut: function (ev) {
            var point = this, tooltip = point.options.tooltip;
            var series = this.series, vanchart = series.vanchart, sharedAxis = vanchart.getSharedAxis();

            if (series.isTreeSeries()) {
                series.fire('pointMouseOut', point);
                return;
            }

            if (tooltip && tooltip.shared && point.points && point.points.length && sharedAxis) {
                point.points.forEach(function (point) {
                    //||
                    var fire = point.graphic || (point.series.defaultMarker && !BaseUtils.containsPoint(vanchart.bounds, ev.containerPoint));

                    fire && point.series.fire('pointMouseOut', point);

                    point.series.fire('seriesUnChosen', ev);

                });
            } else {

                point.series.fire('pointMouseOut', point);

            }

            series.vanchart.hideTooltip();
        },

        _onPointTap: function (ev) {
            var point = this, options = point.options, series = this.series, vanchart = series.vanchart;

            var visible = vanchart.isMap() ? vanchart.isMapPointVisible(point) : point.isVisible();
            if(!visible){
                return;
            }

            if (series.isTreeSeries()) {
                series.onPointTap(point);
            }

            //
            var srcEvent = ev.srcEvent;
            var touch = srcEvent.touches && (srcEvent.touches.length ? srcEvent.touches[0] : srcEvent.changedTouches[0]);
            if(touch){//clientYclientXevent
                srcEvent.clientX = touch.clientX;
                srcEvent.clientY = touch.clientY;
            }

            point.onClick(srcEvent);

            //
            if(BaseUtils.hasTouch()){
                point.fire('mouseover', ev);
            }

            vanchart.drillDown && vanchart.drillDown(point);

        },

        hasValidDataLabel:function(){
            var point = this;
            var hasLabel = point.labelPos && !isNaN(point.labelPos.x) && !isNaN(point.labelPos.y) && point.options.dataLabels && point.options.dataLabels.enabled;
            return point.series.visible && !point.isNull && point.visible && hasLabel;
        },

        clearPointEffect:function(){
            var point = this;
            clearInterval(point.effectInterval);
            point.effectGraphic && point.effectGraphic.remove();
            point.effectGraphic = null;
        },

        isVisible: function () {
            var point = this;
            return point && point.visible && point.series.visible && !point.isNull;
        },

        getEffectTime: function () {
            var point = this;
            if(BaseUtils.isSupportSVG() && point.isVisible() && point.options.effect && point.options.effect.enabled){
                return point.series._getEffectTime(point);
            }
            return 0;
        },

        hasEffect:function(){
            return this.getEffectTime() > 0;
        },

        //dataLabels for gauge
        autoLabelColor: function (dataLabels) {
            var point = this;
            var options = point.options, series = point.series, dataLabels = dataLabels || options.dataLabels, align = dataLabels.align;
            var useSeriesColor = align == Constants.TOP || align == Constants.BOTTOM || align == Constants.OUTSIDE;

            if(series.type == Constants.BUBBLE_CHART || series.type == Constants.TREEMAP_CHART || series.type == Constants.FORCE_BUBBLE_CHART || series.columnType){
                useSeriesColor = false;
            } else if(series.type == Constants.SCATTER_CHART || series.type == Constants.POINT_MAP){
                useSeriesColor = true;
            }

            return useSeriesColor ? (options.marker && options.marker.fillColor || point.color) : '#ffffff'
        },

        _onPointPress:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPress.call(point, ev);
            }
        },

        _onPointPressUp:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPressUp.call(point, ev);

                hoverPoint._onPointTap(ev);
            }
        },


        onClick:function(ev){
            var point = this, options = point.options;
            var clickFunc = options.onClick;
            if(clickFunc){
                BaseUtils.getFormatterFunction(clickFunc).call(point, ev);
            }
        },

        getEvents: function(){
            return {
                'mouseover':this._onPointMouseOver,
                'mouseout':this._onPointMouseOut,
                'mousemove':this._onPointMouseMove,
                'tap':this._onPointTap,
                'press':this._onPointPress,
                'pressup':this._onPointPressUp
            }
        },

        remove:function(){
            this.visible = false;
            this.graphic && this.graphic.remove();
            this.textGraphic && this.textGraphic.remove();
            this.leadLine && this.leadLine.remove();
            this.moreLabelG && this.moreLabelG.remove();

            this.clearPointEffect();

            this.graphic = this.textGraphic = this.moreLabelG = this.leadLine = null;
        },


        // FIXME
        // itself is removed from parent.children
        // thus the name 'clearChild' is confused
        clearChild: function(){
            var point = this;
            if(point.parent){
                var childs = point.parent.children;
                 childs && childs.splice(BaseUtils.indexOf(childs, point), 1);
            }
            if(point.children) {
                var len = point.children.length;
                while (--len > -1) {
                    point.children[len].clearChild();
                }
            }
            point.remove();
        },

        getTooltipRect:function(){
            var tooltip = this.series.vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);
            if(tooltip){
                return tooltip._tooltipRect;
            }
        }

    });

    return Point;
});

/**
 * Created by eason on 2017/3/6.
 * series
 */

define('component/FormattedText',['require','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var LABEL_NAME_VALUE_GAP = 0.02;
    var isSupportSVG = BaseUtils.isSupportSVG();

    //format
    var SERIES = '{SERIES}', CATEGORY = '{CATEGORY}', X = '{X}', Y = '{Y}', NAME = '{NAME}', SIZE = '{SIZE}', DESCRIPTION = '{DESCRIPTION}';

    var VALUE = '{VALUE}', PERCENT = '{PERCENT}', ARRIVALRATE = '{ARRIVALRATE}', FROM = '{FROM.NAME}', TO = '{TO.NAME}';

    var PROCESSES = '{PROCESSES}', STARTTIME = '{STARTTIME}', FINISHTIME = '{FINISHTIME}', DURATION = '{DURATION}',
        PROGRESS = '{PROGRESS}', LEVEL = '{LEVEL}';

    var propMap = {};
    ["name", "category", "value", "processes", "startTime", "finishTime", "duration", "progress", "level", "arrivalRate"]
        .map(function (prop) {
            var key = '{' + prop.toUpperCase() + '}';
            propMap[key] = [prop, prop + 'Format'];
        });
    propMap[SERIES] = ['seriesName', 'seriesFormat'];
    propMap[PERCENT] = ['percentage', 'percentFormat'];

    var TOOLTIP_CATEGORY_STYLE =  '<span style="font-size:' + (isSupportSVG ? '1rem' : '16px') + ';font-family:Verdana;color:white;">';
    var TOOLTIP_SERIES_STYLE ='<span style="font-size:' + (isSupportSVG ? '0.875rem' : '14px') + ';font-family:Verdana;color:white">';
    var TOOLTIP_VALUE_STYLE = '<span style="font-size:' + (isSupportSVG ? '0.875rem' : '14px') + ';font-family:Verdana;font-weight:bold;color:white">';

    var LABEL_GAP = 2;

    function _getXYSizeString(point, formatter, identifier) {
        var options = point.options;
        var xString = BaseUtils.format(options.x, formatter.XFormat);
        var yString = BaseUtils.format(options.y, formatter.YFormat);
        var sizeString = options.size == '-' ? '-' : BaseUtils.format(options.size, formatter.sizeFormat);

        var text = '';

        if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1){
            text = '(';
            if(identifier.indexOf(X) != -1){
                text += xString;
                if(identifier.indexOf(Y) != -1){
                    text = text + ',' + yString;
                }
                text += ')';
            } else {
                text += yString;
                text += ')';
            }
            text += Constants.BLANK_VALUE_PERCENTAGE;
        }

        if(identifier.indexOf(SIZE) != -1 && sizeString != '-'){
            text += sizeString;
        }
        return text;
    }

    function calculateTextDim(labelContent, point){

        var outsideDim = labelContent && (labelContent.nameLabelContent || labelContent.valueLabelContent);

        if(outsideDim && point.series.type == 'funnel'){

            return calculateFunnelOutSideTextDim(point, labelContent);

        }else{
            var width = 0, height = 0;
            if(labelContent && labelContent.length){

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var dim = labelContent[i].dim;

                    width = Math.max(width, dim.width);

                    height += dim.height;
                }

                height += (count - 1) * LABEL_GAP;
            }

            return {width:width, height:height};

        }
    }

    function calculateFunnelOutSideTextDim(point, labelContent){

        var width = 0, height = 0, gapWidth = 0;

        if(labelContent.nameLabelContent){
            var dim = labelContent.nameLabelContent.dim;
            width += dim.width;
            height = Math.max(height, dim.height);
        }

        if(labelContent.valueLabelContent){
            var dim = labelContent.valueLabelContent.dim;
            width += dim.width;
            height = Math.max(height, dim.height);
        }

        if(labelContent.nameLabelContent && labelContent.valueLabelContent){
            var funnel = point.series, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;
            gapWidth = plotBounds.width * LABEL_NAME_VALUE_GAP;
            width += gapWidth;
        }

        return {
            width:width,
            height:height,
            nameValueGap:gapWidth
        };
    }

    function calculateSingleLineLabelContent(formatter, data){

        if(!formatter){
            return '';
        }

        if(typeof formatter == 'object'){
            var content = '';
            var label = formatter.identifier;
            var categoryString = BaseUtils.format(BaseUtils.pick(data.category, ''), formatter.categoryFormat);
            var seriesString = BaseUtils.format(BaseUtils.pick(data.seriesName, ''), formatter.seriesFormat);

            if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){
                if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                    content += (categoryString + ' ' + seriesString);
                }else if(label.indexOf(CATEGORY) != -1){
                    content += categoryString;
                }else{
                    content += seriesString;
                }
            }

            if(!data.isNull && label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                if(!BaseUtils.isEmpty(content)){
                    content += ':';
                }

                var valueString = BaseUtils.format(data[data.series.getTargetKey()], formatter.valueFormat);
                var percentString = BaseUtils.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                    content += (valueString + ' ' + percentString);
                }else if(label.indexOf(VALUE) != -1){
                    content += valueString;
                }else{
                    content += percentString;
                }
            }
            return content;
        }else{
            return BaseUtils.getFormatterFunction(formatter).call(data);
        }
    }

    function createMultiLineLabelContent(formatter, data){
        if(!formatter){
            return [];
        }

        if(typeof formatter == 'object'){
            var content = [];

            var label = formatter.identifier;
            var categoryString = BaseUtils.format(data.category, formatter.categoryFormat);
            var seriesString = BaseUtils.format(data.seriesName, formatter.seriesFormat);
            var valueString = BaseUtils.format(data.value, formatter.valueFormat);
            var percentString = BaseUtils.format(data.percentage, formatter.percentFormat);

            if(label.indexOf(CATEGORY) != -1){
                content.push(categoryString);
            }

            if(label.indexOf(SERIES) != -1){
                content.push(seriesString)
            }

            if(label.indexOf(VALUE) != -1){
                content.push(valueString);
            }

            if(label.indexOf(PERCENT) != -1){
                content.push(percentString);
            }

            return content;
        }else{
            return [BaseUtils.getFormatterFunction(formatter).call(data)];
        }
    }

    //
    function dataLabelGenerator(){
        function valid(point, dataLabels){
            dataLabels = dataLabels || point && point.options && point.options.dataLabels;

            return dataLabels && dataLabels.enabled && dataLabels.formatter && point.isVisible();
        }

        function calculateLabel(point, dataLabels){

            // returnpoints
            if(!valid(point, dataLabels)){
                point.labelDim = { width: 0, height: 0 };   
                point.labelContent = [];
                return ;
            }

            dataLabels = dataLabels || point.options.dataLabels;

            var formatter = dataLabels.formatter;

            point.labelContent = typeof formatter == 'object' ? calculateNormalLabel(point, dataLabels) : calculateCustomLabel(point, dataLabels);

            point.labelDim = calculateTextDim(point.labelContent, point);
        }

        function defaultValueStyle(point, dataLabels){
            dataLabels = dataLabels || point.options.dataLabels;

            return dataLabels.style || BaseUtils.calculateFontSizeWithScale({
                fontSize:'0.75rem',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,0.15)',

                color: point.autoLabelColor(dataLabels)
            });
        }

        function calculateCustomLabel(point, dataLabels){

            dataLabels = dataLabels || point.options.dataLabels;

            var formatter = dataLabels.formatter, text = "";
            try{
                //window.FR.contentFormat
                text = BaseUtils.getFormatterFunction(formatter).call(point);
            } catch (e){

            }

            var style = dataLabels.style || defaultValueStyle(point);
            var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);

            if(dataLabels.useHtml){
                dim.width = isNaN(parseFloat(dataLabels.labelWidth)) ? dim.width : parseFloat(dataLabels.labelWidth);
                dim.height = isNaN(parseFloat(dataLabels.labelHeight)) ? dim.height : parseFloat(dataLabels.labelHeight);
            }

            return [{text:text, style:style, dim:dim}];
        }

        function defaultCategoryStyle(point, dataLabels){
            // var shadowOpacity = position === Constants.OUTSIDE ? 0.1 : 0.15;
            dataLabels = dataLabels || point.options.dataLabels;

            return dataLabels.style || BaseUtils.calculateFontSizeWithScale({
                color: point.autoLabelColor(dataLabels),
                fontSize:'0.75rem',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0, 0.15)',
                fontWeight:'bold'
            });
        }

        function calculateNormalLabel(point, dataLabels){

            var series = point.series, type = series.type;

            if(series.vanchart.isMap()){
                return calculateMapLabel(point, dataLabels);
            }

            if(type == Constants.BUBBLE_CHART || type == Constants.SCATTER_CHART){
                return bubbleLabelContent(point);
            }else if(type == Constants.FUNNEL_CHART){
                return funnelLabelContent(point);
            }else{
                return defaultLabelContent(point, dataLabels);
            }
        }

        function bubbleLabelContent(point){

            var dataLabels = point.options.dataLabels, formatter = dataLabels.formatter, identifier = formatter.identifier;
            var content = [];

            if(identifier.indexOf(DESCRIPTION) != -1){
                var descriptionStyle = dataLabels.style || defaultCategoryStyle(point);
                var descriptionDim = BaseUtils.getTextDimension(point.options.description, descriptionStyle, dataLabels.useHtml);

                content.push({text:point.options.description, style:descriptionStyle, dim:descriptionDim});
            }

            if(identifier.indexOf(SERIES) != -1){
                var seriesString = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                var seriesStyle = dataLabels.style || defaultCategoryStyle(point);
                var seriesDim = BaseUtils.getTextDimension(seriesString, seriesStyle, dataLabels.useHtml);

                content.push({ text:seriesString, style:seriesStyle, dim:seriesDim});
            }

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1){
                var text = _getXYSizeString(point, formatter, identifier);
                var style = dataLabels.style || defaultValueStyle(point);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);
                content.push({text:text, style:style, dim:dim });
            }

            return content;
        }

        function funnelLabelContent(point) {
            var dataLabels = point.options.dataLabels, formatter = dataLabels.formatter, identifier = formatter.identifier;

            if(dataLabels.align == Constants.INSIDE) {
                return defaultLabelContent(point);
            }

            var funnel = point.series, content = [];
            if(identifier.indexOf(NAME) != -1){
                var nameString = BaseUtils.format(point.name, formatter.nameFormat);
                var nameStyle = defaultCategoryStyle(point);
                var nameDim = BaseUtils.getTextDimension(nameString, nameStyle, dataLabels.useHtml);

                content.nameLabelContent = {text:nameString, style:nameStyle, dim:nameDim};

                if(!funnel.maxNameLabelWidth){
                    funnel.maxNameLabelWidth = 0;
                }
                funnel.maxNameLabelWidth = Math.max(funnel.maxNameLabelWidth, nameDim.width);
            }

            if(identifier.indexOf(VALUE) != -1 || identifier.indexOf(PERCENT) != -1 || identifier.indexOf(ARRIVALRATE) != -1){
                var items = [];
                if(identifier.indexOf(VALUE) != -1){
                    items.push(BaseUtils.format(point.value, formatter.valueFormat));
                }
                if(identifier.indexOf(PERCENT) != -1){
                    items.push(BaseUtils.format(point.percentage, formatter.percentFormat));
                }
                if(identifier.indexOf(ARRIVALRATE) != -1){
                    items.push(BaseUtils.format(point.arrivalRate, formatter.arrivalRateFormat));
                }

                var text = items.join(Constants.BLANK_VALUE_PERCENTAGE);
                var style = defaultValueStyle(point);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);

                content.valueLabelContent = {text:text, style:style, dim:dim};

                if(!funnel.maxValueLabelWidth) {
                    funnel.maxValueLabelWidth = 0;
                }

                funnel.maxValueLabelWidth = Math.max(funnel.maxValueLabelWidth, dim.width);
            }
            return content;
        }

        function defaultLabelContent(point, dataLabels) {
            dataLabels = dataLabels || point.options.dataLabels;
            var series = point.series, formatter = dataLabels.formatter, identifier = formatter.identifier;

            var names = [NAME, CATEGORY, SERIES], values = [VALUE, PERCENT, ARRIVALRATE, LEVEL];

            var cateStyleFun = defaultCategoryStyle, valueStyleFun = defaultValueStyle;

            // adjust the sequence and style here
            if (series.type === Constants.TREEMAP_CHART) {
                values.unshift(names.shift());
                valueStyleFun = cateStyleFun;
            } else if (series.type === Constants.GANTT_CHART) {
                names = [];
                values = [PROCESSES, SERIES, STARTTIME, FINISHTIME, DURATION, PROGRESS];
            }

            var content = [];
            addContent(content, getContentItems(names), cateStyleFun);
            addContent(content, getContentItems(values), valueStyleFun);

            function getContentItems(items) {
                return items.map(fmtStr).filter(clean);
            }

            function fmtStr(item) {
                if (identifier.indexOf(item) !== -1) {
                    var propKey = propMap[item][0];
                    var fmtKey = propMap[item][1];
                    var value = series._formatValue ? series._formatValue(point, propKey) : point[propKey];
                    var fmt = formatter[fmtKey] || series._getLabelFormatFn && series._getLabelFormatFn(propKey);

                    var str = BaseUtils.format(value, fmt);

                    return series._postLabel ? series._postLabel(str, propKey) : str;
                }
                return null
            }

            function clean(item) { return item !== null; }

            function addContent(content, items, styleFun) {
                if (!items.length) {
                    return;
                }
                var text = items.join(Constants.BLANK_VALUE_PERCENTAGE);
                var style = styleFun(point, dataLabels);
                var dim = BaseUtils.getTextDimension(text, style, dataLabels.useHtml);
                content.push({text: text, style: style, dim: dim });
            }

            return content;
        }

        function calculateMapLabel(point, dataLabels){

            if(!point || point.isNull || !dataLabels || !dataLabels.enabled){
                return {};
            }

            var formatter =  dataLabels.formatter, useHtml = dataLabels.useHtml;
            var chartType = point.series.type;

            var labelPosition = (chartType == Constants.SCATTER_CHART || chartType == Constants.POINT_MAP) ? Constants.OUTSIDE : Constants.INSIDE;

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(NAME) != -1){
                    var text = BaseUtils.format(point.name, formatter.nameFormat);
                    var style = defaultCategoryStyle(point, dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

                var line = '';
                var hasSeries = label.indexOf(SERIES) != -1, hasValue = label.indexOf(VALUE) != -1 || label.indexOf(SIZE) != -1, hasPercent = label.indexOf(PERCENT) != -1;
                var seriesLabel = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                var valueLabel = BaseUtils.format(point.getTargetValue(), formatter.valueFormat);
                var percentLabel = BaseUtils.format(point.percentage, formatter.percentFormat);
                if(hasSeries){
                    line += seriesLabel;
                    if(hasValue || hasPercent){
                        line += ':'
                    }
                }

                if(hasValue){
                    line += valueLabel;
                    if(hasPercent){
                        line += ' '
                    }
                }

                if(hasPercent){
                    line += percentLabel;
                }

                if(line){
                    var style = defaultValueStyle(point, dataLabels);
                    var dim = BaseUtils.getTextDimension(line, style, useHtml);
                    content.push({text:line, style:style, dim:dim});
                }
            }
            return content;
        }

        return calculateLabel;
    }


    function tooltipGenerator(){

        function valid(point){
            var tooltip = point.options.tooltip;
            return tooltip && tooltip.enabled && point.isVisible();
        }

        function shareValid(point){
            var tooltip = point.options.tooltip;
            return valid(point) && tooltip.shared;
        }

        function calculateTooltipContent(point){

            var series = point.series, type = series.type, tooltip = point.options.tooltip, formatter = tooltip.formatter;

            if(!(valid(point) || tooltip.shared )){
                return '';
            }


            if(typeof formatter !== 'object') {
                try{
                    //window.FR.contentFormat
                    return BaseUtils.getFormatterFunction(formatter).call(point);
                } catch (e){
                    return '';
                }
            }

            var contentFn;
            switch (type) {
                case Constants.BUBBLE_CHART:
                case Constants.SCATTER_CHART:
                    contentFn = series.vanchart.isMap() ? defaultTooltipContent : bubbleTooltipContent;
                    break;
                case Constants.TREEMAP_CHART:
                    contentFn = treeMapTooltipContent;
                    break;
                case Constants.GANTT_CHART:
                    contentFn = ganttTooltipContent;
                    break;
                case Constants.LINE_MAP:
                    contentFn = lineMapTooltipContent;
                    break;
                default:
                    contentFn = defaultTooltipContent;
            }

            return contentFn(point, tooltip);
        }


        function bubbleTooltipContent(point, tooltip){
            var series = point.series, formatter = tooltip.formatter;
            var style = tooltip.style, identifier = formatter.identifier;

            var content = '';

            content += _createBubbleTooltipSeriesLine(point, identifier, style, formatter);

            content += _createBubbleTooltipXYSizeLine(point, identifier, style, formatter);

            return content;
        }

        //
        function _createBubbleTooltipSeriesLine(data, identifier, style, formatter){
            var content = '';

            if(identifier.indexOf(SERIES) != -1){

                var seriesString = BaseUtils.format(data.seriesName, formatter.seriesFormat);
                seriesString = _escapeString(seriesString);
                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        }

        // //XYSIZE
        function _createBubbleTooltipXYSizeLine(data, identifier, style, formatter){
            var content = '';
            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1) {
                var text = _getXYSizeString(data, formatter, identifier);
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + text + '</span>';
            }

            return content;
        }

        function treeMapTooltipContent(point, tooltip){
            var style = tooltip.style, formatter = tooltip.formatter, identifier = formatter.identifier;

            var content = '';

            if (tooltip.shared) {
                if (identifier.indexOf(NAME) != -1) {
                    var p, d = point, points = [point.name];
                    while ((p = d.parent) && p.depth) {
                        d = p;
                        points.unshift(p.name);
                    }
                    content += (style ? '<span>' : TOOLTIP_CATEGORY_STYLE) + points.join(' / ') + '</span><br>';
                }
                content += _createSeriesLine(point, identifier, style, formatter);
            } else {

                content += _createCategoryLine(point, identifier, style, formatter);

                content += _createSeriesLine(point, identifier, style, formatter);
            }

            return content;
        }

        function ganttTooltipContent (point, tooltip) {
            var style = tooltip.style, formatter = tooltip.formatter, identifier = formatter.identifier;
            var series = point.series;

            var names = [PROCESSES, SERIES, STARTTIME, FINISHTIME, DURATION, PROGRESS];

            var content = '';

            function fmtStr(item) {
                if (identifier.indexOf(item) !== -1) {
                    var propKey = propMap[item][0];
                    var fmtKey = propMap[item][1];
                    var value = series._formatValue ? series._formatValue(point, propKey) : point[propKey];
                    var fmt = formatter[fmtKey] || series._getTooltipFormatFn && series._getTooltipFormatFn(propKey);

                    var str = BaseUtils.format(value, fmt);

                    return series._postTooltip ? series._postTooltip(str, propKey) : str;

                }
                return null
            }

            names.map(function (item) {
                var str = fmtStr(item);
                if (str != null) {
                    content += (style ? '<span>' : TOOLTIP_SERIES_STYLE) + str + '</span><br>';
                }
            });

            return content
        }


        function defaultTooltipContent(point, tooltip){
            var series = point.series, vanchart = series.vanchart, points = point.points;

            var formatter = tooltip.formatter, identifier = formatter.identifier, style = tooltip.style;

            var content = '';

            if(tooltip.shared && points && points.length){
                //,
                var hasMap = vanchart.isMap(), hasRangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

                content += _createCategoryLine(point, identifier, style, formatter);

                //todo points
                points
                    .filter(shareValid)
                    .forEach(function(p){
                        var dotColor = (hasMap && hasRangeLegend) ? points[0].color : p.color;

                        var tooltip = p.options.tooltip;

                        content += '<span style="font-size:' + (isSupportSVG ? '0.75rem' : '12px') + ';font-style:normal; color: ' + dotColor + ';opacity:' + p.opacity + '">'+'&#9679  '+'</span>';

                        // CHART-867
                        // formatter
                        // 
                        content += _createSeriesLine(p, identifier, style, tooltip.formatter);

                        content += '<br />';
                    });

            }else{

                content += _createCategoryLine(point, identifier, style, formatter);
                content += _createSeriesLine(point, identifier, style, formatter);

            }

            return content;
        }

        function _createCategoryLine(point, label, style, formatter){
            var content = '', type = point.series.type;


            if (type === Constants.MULTIPIE_CHART) {
                if (label.indexOf(SERIES) != -1) {
                    content = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                }
            }else{
                if (label.indexOf(CATEGORY) != -1) {
                    content = BaseUtils.format(point.category, formatter.categoryFormat);
                }

                if (label.indexOf(NAME) != -1 && type !== Constants.WORD_CLOUD_CHART) {
                    content = BaseUtils.format(point.name, formatter.nameFormat);
                }
            }

            if(content){
                content = _escapeString(content);
                content = (style ? '<span>' : TOOLTIP_CATEGORY_STYLE) + content +'</span>';
                content += '<br />';
            }

            return content;
        }
        
        function _escapeString(string) {
            if(string){
                return string.replace(/</g,"&lt").replace(/>/g, "&gt");
            }
            return string;
        }

        function _createSeriesLine(point, label, style, formatter){
            var content = '', type = point.series.type;

            var pointValue = point.isNull ? "" : point.value,
                pointPercent = point.isNull ? "" : point.percentage;  //@chart-1091:Nullvaluepercent""

            if(type === Constants.STRUCTURE_CHART && pointValue === "-"){
                pointValue = ""; // @CHART-1379
            }

            var valueString = BaseUtils.format(pointValue, formatter.valueFormat);
            var percentString = BaseUtils.format(pointPercent, formatter.percentFormat);
            var levelString = BaseUtils.format(point.level, formatter.levelFormat);
            var textString;

            var valuesMap = {};
            valuesMap[SIZE] = valueString;
            valuesMap[VALUE] = valueString;
            valuesMap[PERCENT] = percentString;
            valuesMap[LEVEL] = levelString;

            if (type === Constants.MULTIPIE_CHART || type === Constants.WORD_CLOUD_CHART) {
                if (label.indexOf(NAME) != -1) {
                    textString = BaseUtils.format(point.name, formatter.nameFormat);
                }
            }else {
                if (label.indexOf(SERIES) != -1) {
                    textString = BaseUtils.format(point.seriesName, formatter.seriesFormat);
                }
            }

            var valueArray = [VALUE, PERCENT, LEVEL];

            if(type == Constants.BUBBLE_CHART || type == Constants.SCATTER_CHART){
                valueArray = [SIZE, PERCENT, LEVEL];
            }

            var valuesString = valueArray
                .filter(function (k) { return label.indexOf(k) !== -1 && !BaseUtils.isEmpty(valuesMap[k])})
                .map(function (k) { return valuesMap[k] })
                .join('  ');

            if (textString && valuesString) {
                textString += ':';
            }

            textString = _escapeString(textString);
            if (textString) {
                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + textString +'</span>';
            }
            if (valuesString) {
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + valuesString +'</span>';
            }

            return content;
        }

        function lineMapTooltipContent (point, tooltip){
            if(!tooltip || !tooltip.enabled){
                return;
            }
            var formatter = tooltip.formatter, content = '';
            if(typeof formatter == 'object'){
                var style = tooltip.style, label = formatter.identifier;

                content += _lineMapCreateCategoryLine(point, label, style, formatter);
                content += _lineMapCreateSeriesLine(point, label, style, formatter);

            }else{
                content = BaseUtils.getFormatterFunction(formatter).call(point);
            }

            return content;
        }

        function _lineMapCreateCategoryLine (point, label, style, formatter) {
            var content = '';

            if(label.indexOf(SERIES) != -1){

                var seriesString = BaseUtils.format(point.seriesName, formatter.seriesFormat);

                content += (style ? '<span >' : TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        }

        function _lineMapCreateSeriesLine (point, label, style, formatter){
            var content = '';

            var hasTag = function (tag) {
                return label.indexOf(tag) !== -1
            };

            var names = [];
            var options = point.options;
            if (hasTag(FROM)) {
                options.from.name && names.push(options.from.name);
            }
            if (hasTag(TO)) {
                options.to.name && names.push(options.to.name);
            }
            if (names.length) {
                content += (style ? '<span>' : TOOLTIP_SERIES_STYLE) + names.join('') + '</span>&nbsp;';
            }

            var values = [];
            if (hasTag(VALUE)) {
                var valueString = BaseUtils.format(point[point.series.getTargetKey()], formatter.valueFormat);
                valueString && values.push(valueString);
            }
            if (hasTag(PERCENT)) {
                var percentString = BaseUtils.format(point.percentage, formatter.percentFormat);
                percentString && values.push(percentString);
            }
            if (values.length) {
                content += (style ? '<span>' : TOOLTIP_VALUE_STYLE) + values.join('&nbsp;&nbsp;') + '</span>';
            }

            return content;
        }

        return calculateTooltipContent;
    }


    return {
        calculateSingleLineLabelContent:calculateSingleLineLabelContent,
        createMultiLineLabelContent:createMultiLineLabelContent,
        calculateTextDim:calculateTextDim,
        dataLabelGenerator:dataLabelGenerator(),
        tooltipGenerator:tooltipGenerator()
    }

});
/**
 * Created by eason on 16/2/19.
 * 
 */
define('chart/Series',['require','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../Constants','./Point','../dom/Evented','../utils/BezierEasing','../utils/PathGenerator','../ComponentLibrary','../vector/CanvasRenderer','../component/FormattedText','../utils/Timer'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');
    var BezierEasing = require('../utils/BezierEasing');
    var PathGenerator = require('../utils/PathGenerator');
    var ComponentLibrary = require('../ComponentLibrary');
    var CanvasRenderer = require('../vector/CanvasRenderer');
    var FormattedText = require('../component/FormattedText');
    var Timer = require('../utils/Timer');

    var ANIMATION_TIME = 600;
    var EASE_TYPE = 'quad-out';

    var Series = Evented.extend({

        initialize:function(options, vanchart, index){

            this.vanchart = vanchart;

            this.points = [];

            this.refresh(options, index);
        },

        refresh:function(options, index){

            var vanchart = this.vanchart, type = options.type || vanchart.options.chartType;
            var plotOptions = vanchart.options.plotOptions;
            var queryList = [options, plotOptions[type], plotOptions];

            this.minSize = QueryUtils.queryList(queryList, 'minSize');
            this.maxSize = QueryUtils.queryList(queryList, 'maxSize');

            //
            this.originalColor = options.color;this.originalMarkerFillColor = options.marker && options.marker.fillColor;

            this.interpolate = this._getSeriesInterpolate(queryList);

            options = this.options = BaseUtils.createOptions(options, [plotOptions[type], plotOptions]);

            this.type = type;//prototypepointMapheatMapareaMapseries
            this.stack = options.stack;
            this.index = index; this.className = 'vancharts-series-' + index;
            this.name = BaseUtils.pick(options.name, Constants.BLANK_VALUE_PERCENTAGE);
            this.visible = BaseUtils.pick(options.visible, true);  // truevisible
            this.state = this.visible ? Constants.STATE_SHOW : Constants.STATE_DROPPED;

            var hexAlpha;
            if (!this.isSeriesAccumulated() && this.type != Constants.STRUCTURE_CHART) {
                var color = this.options.color || vanchart.getDefaultSeriesColor(this.name);
                var opacity = options.opacity;
                hexAlpha = ColorUtils.getStandardColorAndOpacity(color, opacity);

                color = hexAlpha.hex;
                opacity = hexAlpha.alpha;

                var fillColor = this.options.fillColor;
                fillColor = fillColor === true ? color : fillColor;
                var fillColorOpacity = +options.fillColorOpacity;
                fillColorOpacity = isNaN(fillColorOpacity) ? this._getDefaultFillColorOpacity() : fillColorOpacity;

                hexAlpha = ColorUtils.getStandardColorAndOpacity(fillColor, fillColorOpacity);
                fillColor = hexAlpha.hex;
                fillColorOpacity = hexAlpha.alpha;

                //shine:clone
                // 1.clonesymbol
                // 2.markercoloralpha
                var marker = options.marker = BaseUtils.clone(options.marker);
                if (BaseUtils.hasDefined(marker)) {
                    var colorAlpha = this._getMarkerColorAlpha();
                    marker.fillColor = colorAlpha.markerColor;
                    marker.fillColorOpacity = colorAlpha.markerOpacity;

                    if(this.type == Constants.SCATTER_CHART && BaseUtils.isNullMarker(marker)){
                        options.marker.symbol = BaseUtils.getDefaultMarkerSymbol(index);
                    }
                }


                this.color = color; this.opacity = opacity;
                this.fillColor = fillColor; this.fillColorOpacity = fillColorOpacity;
                this.marker = marker;
            }

            if(BaseUtils.hasDefined(this.options.startAngle)){
                var startAngle = this.options.startAngle,
                    endAngle = this.options.endAngle;
                if(startAngle > endAngle){
                    startAngle -= 360;
                }else if(startAngle === endAngle){
                    endAngle = startAngle + 360;
                }
                this.startAngle = BaseUtils.toRadian(startAngle);
                this.endAngle = BaseUtils.toRadian(endAngle);
            }

            //bind Axis
            this._bindAxis();

            if (this._loadData) {
                var data = this._loadData(options.data);
            } else {
                var data = options.data || [];
            }

            // so dirty...
            if (!this.isTreeSeries()) {
                this._dealData(data);
            }

            return this;
        },

        _dealData: function (data) {
            var newPoints = [], series = this, pointsMap = {};
            var vanchart = this.vanchart, type = this.type;
            this.points.forEach(function(point){
                // todo
                // _getPointKey: point here, data[i] below?
                var key = series._getPointKey(point);
                pointsMap[key] = pointsMap[key] || [];
                pointsMap[key].push(point);
            });

            for(var i = 0, len = data.length; i < len; i++){
                var key = series._getPointKey(data[i]), pointArray = pointsMap[key];
                var point = null;
                if(pointArray){

                    for(var j = 0, count = pointArray.length; j < count; j++){
                        if((point = pointArray[j])){
                            pointArray[j] = null;
                            break;
                        }
                    }

                    if(point){
                        //clear states
                        point._lastValue = point.options[series.getTargetKey()];
                        point._lastPercent = point.percentage;
                        point._lastArrivalRate = point.arrivalRate;
                        point.drillSeries = null;
                        point.geo = null;
                        //set new data
                        point.refresh(data[i]);
                    }
                }

                if(!point){
                    point = new Point(data[i], this);
                }

                newPoints.push(point);
            }

            for(var key in pointsMap){
                pointsMap[key] && pointsMap[key].forEach(function(p){
                    vanchart.removePointGraphics(p, type);
                });
            }

            if(this.options.sort){
                //
                newPoints= newPoints.filter(function (point) {return !point.isNull;})
                    .sort(function (pointA, pointB) {
                        return Math.abs(pointB.getTargetValue()) - Math.abs(pointA.getTargetValue());
                    })
            }

            this.points = newPoints;
        },

        _getPointKey: function (point) {
            // categoryArray
            if(this.isMultiCategoryAxisBased()){
                return BaseUtils.encodeCategoryArray(point.categoryArray);
            }

            return point.x;
        },

        /**
         * @Cmen::
         * vanchart.isMultiCategoryBased()
         * baseAxis
         * @returns {boolean}
         */
        isMultiCategoryAxisBased: function (){
            var baseAxisType = this.getBaseAxisType();
            var axis = this.vanchart[baseAxisType](this.options[baseAxisType]);

            return axis && axis.isMultiCateAxis && axis.isMultiCateAxis();
        },

        //optionsradarcolumnRadar
        _getDefaultFillColorOpacity: function () {
            return 1;
        },

        getStackAxis:function(){
            return this[this.getTargetKey() + 'Axis'];
        },

        isNullValue:function(point){
            var originValue = point.options[point.series.getTargetKey()];
            return  originValue == '-' || BaseUtils.hasNotDefined(originValue);
        },

        _getMarkerColorAlpha: function () {

            var vanchart = this.vanchart, options = this.options;
            var plotOptions = vanchart.options.plotOptions, _options = plotOptions[this.type];
            var plotOptionsMarker = (_options && _options.marker) || plotOptions.marker;
            var opacity = options.opacity, seriesMarker = options.marker;

            var _markerColor = (seriesMarker && seriesMarker.fillColor) ||
                this.options.color ||
                (plotOptionsMarker && plotOptionsMarker.fillColor) ||
                vanchart.getDefaultSeriesColor(this.name);

            var _markerOpacity = opacity;

            if(BaseUtils.hasDefined(_markerColor)){
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, opacity);
                _markerColor = hexAlpha.hex;
                _markerOpacity = hexAlpha.alpha;
            }

            return{
                markerColor:_markerColor,
                markerOpacity:_markerOpacity
            }
        },

        _bindAxis:function(){
            var series = this,
                seriesOptions = series.options,
                vanchart = series.vanchart;

            series._getAxisTypes().forEach(function(axisType){

                if(vanchart[axisType]){
                    var targetAxis = vanchart[axisType](seriesOptions[axisType]);
                    if(targetAxis){
                        targetAxis.series.push(series);
                        series[axisType] = targetAxis;
                    }
                }

            });
        },

        supportTooltipShared:function(){
            return this.xAxis || this.yAxis || this.angleAxis;
        },

        _getAxisTypes:function(){
            return ['xAxis', 'yAxis'];
        },

        //,value
        getTargetKey:function(){
            return 'y';
        },

        //key
        getBaseAxisType: function () {
            return 'xAxis';
        },

        _calculateAutoLabelPos:function(point, pos, isVertical, manager, rightBottom){

            var step = 3; //3px
            //
            var labelDim = point.labelDim, plotBounds = this.vanchart.bounds;

            function verticalPosFix(start, end, step, labelDim){
                for(var y = start; (step < 0 ? y > end : y < end); y += step){
                    var labelPos = {x: pos.x, y: y};
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim))){
                        return labelPos;
                    }
                }
            }

            function horizontalFix(start, end, step, labelDim){
                for(var x = start; (step < 0 ? x > end : x < end); x += step){
                    var labelPos = {x:x, y: pos.y};
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim))){
                        return labelPos;
                    }
                }
            }

            var testPos;
            if(isVertical){
                var startY, endY;

                if(BaseUtils.hasDefined(rightBottom)){
                    if(rightBottom){
                        //
                        startY = Math.max(0, pos.y);
                        endY = plotBounds.height - labelDim.height;
                        testPos = verticalPosFix(startY, endY, step, labelDim);
                    }else{
                        endY = 0;
                        startY = Math.min(pos.y, plotBounds.height - labelDim.height);
                        testPos = verticalPosFix(startY, endY, -step, labelDim);
                    }
                }else{
                    //
                    startY = Math.max(0, pos.y);
                    endY = plotBounds.height - labelDim.height;
                    testPos = verticalPosFix(startY, endY, step, labelDim);

                    //
                    if(!testPos){
                        endY = 0;
                        startY = Math.min(pos.y, plotBounds.height - labelDim.height);
                        testPos = verticalPosFix(startY, endY, -step, labelDim);
                    }
                }

            }else{
                var startX, endX;

                if(BaseUtils.hasDefined(rightBottom)){
                    if(rightBottom){
                        //
                        startX = Math.max(0, pos.x);
                        endX = plotBounds.width - labelDim.width;
                        testPos = horizontalFix(startX, endX, step, labelDim);
                    }else{
                        endX = 0;
                        startX = Math.min(pos.x, plotBounds.width - labelDim.width);
                        testPos = horizontalFix(startX, endX, -step, labelDim);
                    }
                }else{

                    //
                    startX = Math.max(0, pos.x);
                    endX = plotBounds.width - labelDim.width;
                    testPos = horizontalFix(startX, endX, step, labelDim);

                    //
                    if(!testPos){
                        endX = 0;
                        startX = Math.min(pos.x, plotBounds.width - labelDim.width);
                        testPos = horizontalFix(startX, endX, -step, labelDim);
                    }

                }
            }

            return testPos ? testPos : pos;
        },

        _getArcPoint:function(r, radian){
            return [this._dealWithFloat(r * Math.sin(radian)), this._dealWithFloat(-r * Math.cos(radian))]
        },

        _getNormalTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];
            var key = this.vanchart.isInverted() ? 'posY' : 'posX';
            var location = this.vanchart.isInverted() ? Constants.LEFT : Constants.BOTTOM;

            sery.points.sort(function(p1, p2){
                return p1[key] - p2[key];
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.posX);
                    yValues.push(point.posY);
                }

            });

            return [xValues, yValues, location];
        },

        _getSeriesInterpolate: function(queryList){
            var step = QueryUtils.queryList(queryList, 'step');
            var curve = QueryUtils.queryList(queryList, 'curve');
            var options = queryList[0];

            var interpolate = 'linear';
            if(options.step || (step && !options.curve)){
                interpolate = 'step-after'
            }else if(options.curve || (curve && !options.step)){
                interpolate = 'cardinal';
            }
            return interpolate;
        },

        _getAngle:function(current, center){

            center = center || {x:0, y:0};

            return Math.atan2(current.y - center.y, current.x - center.x) / (Math.PI / 180);
        },

        _getBackgroundColor:function(){

            var opt = this.vanchart.options;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        getSeryTotalValue:function(){
            var total = 0;

            this.points.forEach(function(point){
                total += point.getTargetValue();
            });

            return total;
        },

        getLegendKey:function(point){
            return this.isSeriesAccumulated() ? point.name : this.name;
        },

        calculateLabelInfo:function(point){
            FormattedText.dataLabelGenerator(point);
        },

        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        isSupportLegendHighlight:function(){
            return true;
        },

        isSeriesAccumulated:function(){
            return false;
        },

        isTreeSeries:function(){
            return false
        },

        /**
         * point
         * @param {[type]} options [description]
         * @param {[type]} redraw  [description]
         */
        addPoint: function (options, redraw){
            var data = this._getOriginSerData();
            var vanchart = this.vanchart;

            // todo dataDomain
            data.push(options);
            redraw && vanchart.update();
        },

        /**
         * point
         * @param  {[type]} index  [description]
         * @param  {[type]} redraw [description]
         * @return {[type]}        [description]
         */
        removePoint: function(index ,redraw){
            if (index < 0) { return; }
            var series = this, vanchart = this.vanchart, data = this._getOriginSerData();
            var serIndex = vanchart.series.indexOf(series);

            data.splice(index, 1);
            series.options.data.splice(index, 1);

            if(data.length === 0) {
                series.remove();
                vanchart.series.splice(serIndex, 1);
                vanchart.options.series.splice(serIndex, 1);
            }

            redraw && vanchart.update();
        },

        /**
         * point
         * @param  {[type]} index  [description]
         * @param  {[type]} option [description]
         * @param  {[type]} redraw [description]
         * @return {[type]}        [description]
         */
        updatePoint: function (index, option, redraw) {
            if(index < 0) { 
                return; 
            } 
            var vanchart = this.vanchart, data = this._getOriginSerData();
            data[index] = option;

            redraw && vanchart.update();
        },

        /**
         * optionvanchart.seriesseries
         * 
         * @param option
         * @returns {number}
         */
        calculatePointIndex: function (option){
            var series = this, vanchart = this.vanchart, pos = -1,index = 0;
            var data = this._getOriginSerData();

            var clone = BaseUtils.clone;

            // 
            var toLnglatPoint = function (option){
                if(option.lnglat) {
                    return option;
                }
                var Geo = vanchart.getCurrentGeo();
                var lnglat = Geo.getFeaturesByName(option.name, series.type);
                var newOption = clone(option);   // 
                newOption.lnglat = lnglat;
                return lnglat && newOption;
            };

            var isLineMap = series.type === Constants.LINE_MAP;

            // name
            if(isLineMap && (!toLnglatPoint(option.from) || !toLnglatPoint(option.to))){
                return -1;
            }

            // option_getPointKey
            var reBuildOption = function(option){
                if(isLineMap) {
                    var newOption = clone(option);
                    newOption.from = toLnglatPoint(option.from);
                    newOption.to = toLnglatPoint(option.to);
                    return newOption.from && newOption.to && newOption;
                }
                return option;
            };

            var op1, op2;
            while(index < data.length) {
                op1 = reBuildOption(option);
                op2 = reBuildOption(data[index]);
                if(!op1 || !op2){
                    index++;   // while
                    continue;
                }
                var key = series._getPointKey(op1);
                var pointKey = series._getPointKey(op2);
                if(key === pointKey) { 
                    pos = index; 
                    break; 
                } 
                index++; 
            } 
 
            return pos; 
        },

        /**
         * @Cmen:
         * OriginOptionOriginOptionseries()
         * OriginOption.seriesseries
         * markerFillColor,
         * series
         */
        _getOriginSerData: function (){
            var series = this, vanchart = this.vanchart, originSeriesData = vanchart.options.series;
            var serIndex = vanchart.series.indexOf(series);
            return serIndex < 0 ? [] : originSeriesData[serIndex].data;
        }
    });


    //view related
    Series.include({

        getClosestPoint:function(){
            return null;
        },

        getTooltipPos:function(point, divDim, event){
            var leftTopPos;
            if(point.options.tooltip.follow){
                var pos = event.containerPoint;
                leftTopPos = [pos.x + 10, pos.y + 10];
            }else{
                leftTopPos = this._getFixedPos(point, divDim);
            }

            if(!leftTopPos){
                return;
            }

            //
            var chartBounds = this.vanchart.getChartBounds();
            var top = chartBounds.y, left = chartBounds.x;
            var bottom = chartBounds.y + chartBounds.height;
            var right = chartBounds.x + chartBounds.width;
            var x = leftTopPos[0], y = leftTopPos[1];

            if(x < left){
                x += (left - x);
            }else if(x + divDim.width > right){
                x -= (x + divDim.width - right);
            }

            if(y < top){
                y += (top - y);
            }else if(y + divDim.height > bottom){
                y -= (y + divDim.height - bottom);
            }

            return [x, y];
        },

        //,,,
        getFillFilter:function(color){
            return color;
        },

        filterRender: function () {
            this.useCanvas() ? this._canvasRender() : this._svgFilterRender();
        },

        render:function(){
            this.useCanvas() ? this._canvasRender() : this._svgRender();
        },

        useCanvas: BaseUtils.falseFn,

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.clipSeriesGroup);
        },

        _svgRender:function(){

            //todo 
            this.initialAnimationMoving = !this.group;

            var vanchart = this.vanchart, renderer = vanchart.renderer;
            if(!this.group){
                this.group = this._createGroup(renderer, vanchart).style('cursor', this._pointerStyle())
                    .attr('transform', BaseUtils.makeTranslate(this._getTranslate()))
                    .attr('class', this.className + ' ' + this.type);
            }

            //,translate
            if(this.type == Constants.GAUGE_CHART){
                this.group.animate({
                    duration:ANIMATION_TIME, ease:EASE_TYPE, attr:{transform:BaseUtils.makeTranslate(this._getTranslate())}
                });
            }else{
                this.group.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            this.drawSeries && this.drawSeries();

            this.drawPoints();
        },

        _svgFilterRender:function(){
            var series = this;

            //todo@eason filtervisible==falseremove

            series.getDataToDraw().forEach(function(point){
                if (point.isVisible()) {
                    point.graphic && point.graphic.style({'display': 'inline'});

                    if(!point.textGraphic){
                        series._createTextGraphic(point);
                    }

                    if(!point.effectGraphic){
                        series.drawPointEffect(point);
                    }
                } else {
                    point.graphic && point.graphic.style({'display': 'none'});
                    point.textGraphic && point.textGraphic.remove();
                    point.textGraphic = null;

                    point.clearPointEffect();
                }
            });
        },

        _canvasRender:function(){
            if(!this._canvas){
                this._canvas = new CanvasRenderer(this.vanchart.dom, this.vanchart);
                this._canvas.onAdd();
            }
            this._canvas.clearAll();
            this._canvas.addSeries(this);
        },

        _pointerStyle:function(){

            // pointnullhyperlinkonClick
            var validPoints = this.points.filter(function (p){
                return !p.isNull;
            });

            return validPoints[0] && validPoints[0].options.onClick ? 'pointer' : '';
        },

        getDataToDraw: function () {
            return this.points;
        },

        getTextDataToDraw: function () {
            return this.getDataToDraw();
        },

        updatePointGraphic:function(point){

        },

        _updateMarkerPointGraphic:function(point){
            var group = point.graphic, marker = point.options.marker, markerType = marker.symbol;

            if(!group){
                return;
            }
            // 
            group.strokePath && group.strokePath.remove();
            group.fillPath && group.fillPath.remove();
            group.markerPath && group.markerPath.remove();
            group.image && group.image.remove();

            group.strokePath = group.fillPath = group.markerPath = group.image = null;

            this._createMarker(marker, group);
        },

        // 
        drawPoints:function(){
            var series = this, vanchart = series.vanchart;
            var graphicGroup = this._getPointGraphicGroup();

            graphicGroup && vanchart.registerInteractiveTarget(this, graphicGroup);

            if (this.initialAnimationMoving && this.initialAnimation) {
                this.initialAnimation();
            }

            var delay = this._calculateAnimationDelay();
            var points = series.getDataToDraw();
            for(var i = 0, len = points.length; i < len; i++){
                series.drawPoint(points[i], delay);
            }

        },

        _drawEffectPoints:function () {
            var series = this;
            series.getTextDataToDraw()
                .forEach(function(point){
                    series.drawPointEffect(point);
                });
        },

        drawPointEffect:function (point) {
            var series = point.series;

            point.clearPointEffect();

            var time = point.getEffectTime();
            if(time) {//shine:0effect
                series.effectAnimation(point);
                point.effectInterval = setInterval(function () {
                    series.effectAnimation(point)
                }, time);
            }
        },

        effectAnimation:function () {
        },

        _drawUpdatePoints: function (point, delay) {
            this._updatePointGraphicStyle(point);   // 

            // attr
            if(this.vanchart.isZoomingWithLargeModel()) {
                point.graphic.attr(this.getPointUpdateAnimationAttr(point, delay).attr);
            } else {
                point.graphic.animate(this.getPointUpdateAnimationAttr(point, delay));
            }

            this.vanchart.registerInteractiveTarget(point, point.graphic);  // 
        },

        _drawEnterPoints: function (point) {
            var series = this, group = series._getPointGraphicGroup();

            var graphic = point.graphic = this._createPointGraphic(point);

            series._updatePointGraphicStyle(point);

            var reShow = series.reShowPoint(point);

            var attrFun = reShow && series.getPointReShowAttr ? series.getPointReShowAttr : series.getPointInitAttr;
            var styleFun = reShow && series.getPointReShowStyle ? series.getPointReShowStyle : series.getPointInitStyle;
            var animateFun = reShow && series.getPointReShowAnimationAttr ? series.getPointReShowAnimationAttr : series.getPointInitAnimationAttr;
	
			// todo 
            point.hasEffect() ? graphic.addTo(group) : graphic.addToBack(group);

            graphic.attr(attrFun ? attrFun.call(series, point) : {})
                .style(styleFun ? styleFun.call(series, point) : {})
                .animate(animateFun ? animateFun.call(series, point) : {});

            series.vanchart.registerInteractiveTarget(point, graphic);
        },

        _drawExitPoints: function (point) {
            var series = point.series;
            if(series.getPointDropAnimationAttr){
                point.graphic.animate(series.getPointDropAnimationAttr(point)).remove();
            } else {
                point.graphic.remove();
            }
        },

        // todo
        // 
        // TreeSeries 
        //   
        drawPoint:function (point, delay) {

            delay = delay || 0;

            var shouldBeVisible = point.isVisible();
            var currentVisibleState = point.graphic && point.graphic.isVisible();

            if (shouldBeVisible === currentVisibleState){

                point.graphic && this._drawUpdatePoints(point, delay);

            } else if (shouldBeVisible && !currentVisibleState) {

                if(point.graphic && !point.graphic.removed()){
                    point.graphic.style('display','inline');
                    this._drawUpdatePoints(point, delay)
                }else{
                    this._drawEnterPoints(point);
                }

            } else if (!shouldBeVisible && currentVisibleState){

                this._drawExitPoints(point);

            }
        },

        _getEffectTime:function (point) {
            return isNaN(point.options.effect.period) ? point.series.getDefaultEffectTime() : point.options.effect.period;
        },

        _getPointEffectGroup:function (point) {
            var series = point.series, renderer = series.vanchart.renderer;
            return point.effectGraphic = point.effectGraphic || renderer.group().addTo(series._getPointGraphicGroup()).style('pointer-events', 'none');
        },

        _createPointGraphic:function(point){
            var graphicKey = this.getPointGraphicKey(point), renderer = this.vanchart.renderer;
            return renderer[graphicKey]();
        },

        getStyle:function(p){
            var options = p.options, series = p.series;
            return {
                'fill':series.getFillFilter(p.color, p),
                'fill-opacity':options.image ? 1 : p.opacity,
                'stroke':p.borderColor,
                'stroke-opacity':p.borderOpacity,
                'stroke-width':options.borderWidth,
                'filter':'none'
            };
        },

        _getDynamicStyle: function (point) {
            var style = this.getStyle(point);

            var target = this.vanchart.highlightTarget;
            if(target != null && this.isSupportLegendHighlight()){     // ""
                var key = this.getLegendKey(point);
                var opacity = (key == target || point._rangeItem == target) ? 1 : 0.3;
                style['fill-opacity'] = style['stroke-opacity'] = opacity;
            }
            return style
        },

        _updatePointGraphicStyle:function(point, style){
            style = style || point.series._getDynamicStyle(point);
            point.graphic && point.graphic.style(style);//update style
        },

        _createMarker:function(marker, group){
            var markerType = marker.symbol, renderer = this.vanchart.renderer;
            group = group || renderer.group();

            if(BaseUtils.isImageMarker(markerType)){
                var w = marker.width, h = marker.height;
                group.image = renderer.image({
                    'preserveAspectRatio':'none', 'x':-w/2, 'y':-h/2, 'width':w, 'height':h
                }).imageContent(markerType).addTo(group);
            }else{
                //,
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath = renderer.path().addTo(group);
                    group.fillPath = renderer.path().addTo(group);
                }else{
                    group.markerPath = renderer.path().addTo(group);
                }
            }

            return group;
        },

        //.attr(d)symbol
        _updateMarker:function(point, group, marker){
            group = group || point.graphic;
            marker = marker || point.options.marker;

            var opacity = marker.fillColorOpacity;

            var target = this.vanchart.highlightTarget;
            if(target){
                var key = this.getLegendKey(point);
                opacity = (key == target || point._rangeItem == target) ? 1 : 0.3;
            }

            var markerType = marker.symbol, backgroundColor = this._getBackgroundColor();

            if(BaseUtils.isImageMarker(markerType)){

            }else{
                //,
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius + 2)})
                        .style({'fill':marker.fillColor, 'fill-opacity':opacity,'stroke':backgroundColor, 'stroke-width':2});
                    group.fillPath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius - 1)})
                        .style({'fill':backgroundColor});
                }else if(isHollow){
                    group.markerPath
                        .attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius)})
                        .style({'stroke':marker.fillColor,'stroke-opacity':opacity,'stroke-width':2, 'fill':backgroundColor})
                }else{
                    group.markerPath.attr({'d':PathGenerator.getMarkerPath(markerType, marker.radius)});
                    isLine ? group.markerPath.style({'fill':marker.fillColor,'fill-opacity':opacity, 'stroke-width':2, 'stroke':backgroundColor})
                        : group.markerPath.style({'fill':marker.fillColor, 'fill-opacity':opacity});
                }
            }
        },

        _onMarkerPressed:function(point){
            if(point.graphic){
                var marker = point.options.marker, markerType = marker.symbol, series = point.series;
                var style = {'fill':point.clickColor, 'fill-opacity': point.clickOpacity};
                if(!BaseUtils.isImageMarker(markerType)){
                    //,
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        point.graphic.strokePath.style(style);
                    }else{
                        point.graphic.markerPath.style(style);
                    }
                }
            }
        },

        _onMarkerState:function (point, isChosen) {
            var marker = point.options.marker, markerType = marker.symbol, gap = 5;

            if(point.graphic){
                gap = 2;
                if(BaseUtils.isImageMarker(markerType)){
                    var w = marker.width + (isChosen ? 4 : 0), h = marker.height+ (isChosen ? 4 : 0);
                    point.graphic.image.attr({
                        'x':-w/2, 'y':-h/2, 'width':w, 'height':h
                    });
                }else{
                    var radius = marker.radius + (isChosen ? 2 : 0);

                    function pathAnimate(path, r) {
                        path
                            .interrupt(Constants.SELECT_ANIMATION)
                            .transition(Constants.SELECT_ANIMATION)
                            .animate({
                            duration:300,
                            ease:BezierEasing.custom["ease-out-back"],
                            attr:{'d':PathGenerator.getMarkerPath(markerType, r)}
                        })
                    }

                    //,
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        pathAnimate(point.graphic.strokePath, radius + 2);
                        pathAnimate(point.graphic.fillPath, radius - 1);
                    }else{
                        pathAnimate(point.graphic.markerPath, radius);
                    }
                }
            }

            var series = point.series, diffX = 0, diffY = 0;
            if(series.type == Constants.RADAR_CHART){
                var pos = series._getArcPoint(gap, point.radian);
                diffX = pos[0]; diffY = pos[1];
            } else {
                diffY = -gap;
                var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
                if (align == Constants.BOTTOM) {
                    diffY = gap;
                }
            }
            series._labelTransformState(point,diffX,diffY,isChosen,300,BezierEasing.custom["ease-out-back"]);
        },

        removeDefaultMarker:function () {
            var series = this;
            series.defaultMarker && series.defaultMarker.remove();
            series.defaultMarker = null;
        },

        _onMarkerMouseOver:function(point){
            var series = point.series, vanchart = series.vanchart;

            series._onMarkerState(point, true);

           if(!point.graphic){
                var marker = this._getDefaultMarker(point);
                series.defaultMarker = series.defaultMarker || this._createMarker(marker).addTo(this.group);

               series.defaultMarker.attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(0.01)');

                this._updateMarker(point, series.defaultMarker, marker);

               series.defaultMarker
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .animate({
                    duration:300,
                    ease:'ease',
                    attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(1.5)'}
                })
            }
        },

        _onMarkerMouseOut:function(point){
            var series = point.series, vanchart = series.vanchart;

            series._onMarkerState(point, false);

            if(!point.graphic && series.defaultMarker) {
                series.defaultMarker.animate({
                    duration:300,
                    ease:'ease',
                    attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'}
                }).remove();
                series.defaultMarker = null;
            }
        },

        //markermarker
        _getDefaultMarker:function(point){
            return {
                'symbol':Constants.CIRCLE,
                'fillColor': point.options.marker.fillColor,
                'fillColorOpacity':point.options.marker.fillColorOpacity,
                "radius": 4.5,
                "enabled": true
            }
        },

        _calculateAnimationDelay:function(){
            return 0;
        },

        _isHollowMarker:function(markerType) {
            return markerType && markerType.indexOf('hollow') != -1;
        },

        _animateEnd: function () {
            this._showLabels();
            this._drawEffectPoints();
        },

        _showLabels: function () {
            var series = this, vanchart = series.vanchart;

            series._updateDataLabels();  // MoreLabel

            if(vanchart._needShowMoreLabel()){
                series.getTextDataToDraw().forEach(function(point){
                    if(point.visible && series.visible) {
                        series._showMoreLabel(point);
                    }
                });
            }

            vanchart._removeChangeDataState(series);
        },

        /**
         * MoreLabel:
         * @param  {[type]} point           [point]
         * @param  {[type]} startX     [moreLabelX](, series.calcMoreLabelPosition)
         * @param  {[type]} startY     [moreLabelY]()
         */
        _showMoreLabel: function(point, startX, startY){
            if(point.depth === 0){//
                return;
            }

            var series = this, vanchart = series.vanchart, points = point.points;
            var moreLabel = vanchart.getComponent(ComponentLibrary.MORELABEL_COMPONENT);

            if(series.type === Constants.GANTT_CHART) {
                return;  // MoreLabel 
            } 

            var lastValue = point._lastValue || 0,
                lastArrivalRate = point._lastArrivalRate || 0;

            // 
            var morePointsOneTip = function (series){ 
                var seriesType = series.type, gaugeType = series.gaugeType;
                if(gaugeType === "pointer_semi" || gaugeType === "pointer" || seriesType === Constants.AREA_MAP || seriesType === Constants.POINT_MAP){
                    return true; 
                }
                return false; 
            }; 

            // ,moreLabel
            var changedValue = BaseUtils.accAdd(point.options[series.getTargetKey()], -lastValue);

            //  
            // pointsundefined
            if (changedValue === 0 || isNaN(changedValue)){
                if(points && point === points[points.length - 1] && morePointsOneTip(series)){ 
                    moreLabel.showWithPoint(point, startX, startY);
                } 
                return;
            }

            point.changedValue = changedValue;
           var changedPercent = changedValue / lastValue;

            point.changedPercent = isFinite(changedPercent) ? changedPercent : (changedPercent < 0 ? "-" : "");
            // -
            if(series.type === Constants.FUNNEL_CHART){
                point.changedArrivalRate = BaseUtils.accAdd(point.arrivalRate, lastArrivalRate);
            }


            // 
            // MoreLabelHelper.collectPoint(point)
            // changedValue
            if(morePointsOneTip(series)){ 
                moreLabel.collectPoint(point); 
                if(point === points[points.length - 1]){
                   moreLabel.showWithPoint(point, startX, startY); 
                }
                return;
            }
            // 
            moreLabel.collectPoint(point); 
            moreLabel.showWithPoint(point, startX, startY); 
        },

        /**
         * MoreLabel:
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [moreLabel]
         * @return {[type]}              [moreLabelPosition]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            return { 
                startX: point.x + point.width/2, 
                centerY: point.y - moreLabelDim.height/2, 
                direction : "top" 
            } 
        }, 

        /**
         * 
         * @return {Boolean} [description]
         */
        hasChangedPoint: function () { 
            var validPoints = this.points.filter(function(point){
                return !point.isNull;
            }); 
            var pointChanged = false, index = 0; 
            
            while(index < validPoints.length) { 
                var point = validPoints[index]; 
                if(point.value != point._lastValue){ 
                    pointChanged = true;
                    break; 
                } 
                index++; 
            }
            //  _changeDataStatehasChangedPointresizepointvalue_lastValuepointChangedtrue
            return pointChanged && this.vanchart._changeDataState;
        }, 

        _updateDataLabels:function(){
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                series._createTextGraphic(point);
            });
        },

        _removeDataLabels: function () {
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                if(point.textGraphic){
                    point.textGraphic.remove();
                    point.textGraphic = null;
                }
                if (point.leadLine) {
                    point.leadLine.remove();
                    point.leadLine = null;
                }

                point.newMoreLabelG && point.newMoreLabelG.remove();
                point.newMoreLabelG = null;
            });
        },

        //labelPos
        //text.tans(x+width/2, y+height/2).dx(dx-width/2).dy(dy-height/2)trans
        _createTextGraphic:function(point){
            var series = this;

            if(point.hasValidDataLabel()){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var labelContent = point.labelContent, dataLabels = point.options.dataLabels, useHtml = dataLabels.useHtml;

                var textLabelGroup = this._getPointTextLabelGroup();

                var text = renderer.vtext(useHtml).attr('transform', BaseUtils.makeTranslate(series._labelTrans(point))).style({'pointer-events': 'none'});
                var startY = 0, halfWidth = point.labelDim.width/2, halfHeight = point.labelDim.height/2;
                text.tspans = [];
                for (var i = 0, count = labelContent.length; i < count; i++) {
                    var label = labelContent[i], labelDim = label.dim, labelText = label.text, labelStyle = label.style, dx;

                    switch (point.options.dataLabels._align) {
                        case Constants.LEFT:
                            dx = 0;
                            break;
                        case Constants.RIGHT:
                            dx = point.labelDim.width - labelDim.width;
                            break;
                        case Constants.CENTER:
                        default:
                            dx = (point.labelDim.width - labelDim.width)/2;
                    }
                    text.tspans.push(
                        renderer.vtspan(useHtml)
                        .style({'width': dataLabels.labelWidth + 'px', height:dataLabels.labelHeight + 'px', 'margin-top':-halfHeight + 'px'})
                        .attr('y', startY)
                        .attr('x', 0)
                        .attr('dy', labelDim.height * .85 - halfHeight)
                        .attr('dx', dx - halfWidth)
                        .textContent(labelText).style(labelStyle)
                        .addTo(text)
                    );

                    startY += (labelDim.height + 2);
                }

                point.textGraphic = textLabelGroup.append(text);

                if (point.labelPos.startPos) {//leadLine
                    point.leadLine = textLabelGroup.append(this._getLeadLine(point));
                }
            }
        },

        _labelTrans:function (point) {
            return {x:point.labelPos.x + point.labelDim.width/2, y:point.labelPos.y + point.labelDim.height/2}
        },

        _labelFontSizeState:function (point, isChosen, duration, ease) {
            if(point.labelPos) {
                var pos = point.series._labelTrans(point), scale = isChosen ? 1.1 : 1;

                if(point.textGraphic){

                    var paras = point.textGraphic.type === 'div' ? {duration: duration, ease: ease,
                            style: {'transform': 'translate(' + pos.x + 'px,' + pos.y + 'px)scale('+  scale + ')'}} : {duration: duration, ease: ease,
                            attr: {'transform': 'translate(' + pos.x + ',' + pos.y + ')scale('+  scale + ')'}};

                    point.textGraphic && point.textGraphic
                        .interrupt(Constants.SELECT_ANIMATION)
                        .transition(Constants.SELECT_ANIMATION)
                        .animate(paras)
                }

            }
        },

        _labelTransformState:function (point, diffX, diffY, isChosen, duration, ease) {
            if(point.labelPos) {
                var trans = point.series._labelTrans(point);
                if(isChosen){
                    trans = {x:trans.x + diffX, y:trans.y + diffY}
                }

                point.textGraphic && point.textGraphic.animate({
                    duration: duration,
                    ease: ease,
                    attr: {'transform': BaseUtils.makeTranslate(trans)},
                    style: {'transform': 'translate(' + trans.x + 'px,' + trans.y + 'px)'}
                })
            }
        },

        _outSideLabelColorState:function (point, isChosen, duration, ease) {
            var labelContent = point.labelContent, len = labelContent.length;
            if (point.textGraphic && point.textGraphic.tspans) {

                point.textGraphic.tspans.forEach(function (span, i) {
                    if (i < len) {
                        var style = labelContent[i].style;
                        span.animate({
                            duration: duration,
                            ease: ease,
                            style: {'color':isChosen ? point.mouseOverColor : style.color}
                        });
                    }
                })
            }
        },

        _leadLineState:function (point, diffX, diffY, isChosen, duration, ease) {
            var series = point.series, labelPos = point.labelPos,
                options = point.options, dataLabels = options.dataLabels;

            if(!labelPos || !labelPos.startPos){
                return;
            }

            function addDiff(pos) {
                return {x:pos.x + diffX, y:pos.y + diffY};
            }

            var leadLinePos = labelPos, leadLineColor = dataLabels.connectorColor || point.color;
            if(isChosen){
                leadLinePos = {startPos:addDiff(labelPos.startPos), midPos:addDiff(labelPos.midPos), endPos:addDiff(labelPos.endPos)}
                leadLineColor = point.mouseOverColor;
            }

            point.leadLine && point.leadLine.animate({
                duration: duration || 100,
                ease: ease || 'ease',
                attr: {'d': series._getLeadLinePathWithPos(leadLinePos)},
                style: {'stroke': leadLineColor}
            });
        },

        _getLeadLine:function(point){
            return this.vanchart.renderer.path().attr('d', this._getLeadLinePath(point))
                .style({
                    'fill':'none', 'stroke': point.options.dataLabels.connectorColor || point.color,
                    'stroke-width':point.options.dataLabels.connectorWidth || 0
                })
        },

        _getLeadLinePath:function (point) {
            return this._getLeadLinePathWithPos(point.labelPos);
        },

        _getLeadLinePathWithPos:function (labelPos) {
            var startPos = labelPos.startPos, midPos = labelPos.midPos, endPos = labelPos.endPos;
            var F = this._dealWithFloat;
            return  'M' + F(startPos.x) + ',' + F(startPos.y) + 'L' + F(midPos.x) + ',' + F(midPos.y) + 'L' + F(endPos.x) + ',' + F(endPos.y);
        },

        _dealWithFloat:function(v){
            return Math.abs(v) < 1e-6 ? 0 : v;
        },

        _getPointGraphicGroup:function(){
            return this.group;
        },

        _getPointTextLabelGroup:function(){
            if(!this.textGraphicGroup){
                var vanchart = this.vanchart,
                    textRenderGroup = vanchart.seriesTextRenderGroup,
                    textDivGroup = vanchart.seriesTextDivGroup;

                this.textGraphicGroup = vanchart.renderer.vgroup();
                textRenderGroup.append(this.textGraphicGroup.renderG);
                textDivGroup.append(this.textGraphicGroup.divG);

                this.textGraphicGroup.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }else{
                this.textGraphicGroup.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            return this.textGraphicGroup;
        },

        _getTranslate:function(){
            return this.vanchart.bounds;
        },

        //seriesUnChosen:series.fire; mouseout:dom event
        //mouseoutseriesUnChosen
        getEvents:function(){
            return {
                'mouseover':this._onSeriesMouseOver,
                'mouseout':this._onSeriesMouseOut,
                'seriesUnChosen':this._seriesUnChosen,
                'pointMouseOver':this._onPointMouseOver,
                'pointMouseOut':this._onPointMouseOut,
                'tap':this._onSeriesTap
            }
        },
        // 
        _onPointMouseOver: function(point){
            if(point.graphic) {
                point.graphic.style('cursor', point.onClick ? 'pointer' : '');
            }
        },

        _seriesUnChosen:function (ev) {
            this._onSeriesMouseOut && this._onSeriesMouseOut(ev);
        },

        _onSeriesMouseOver:function(ev){

            var series = this, vanchart = series.vanchart, hoverSeries = vanchart.hoverSeries;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverSeries != series){
                hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                vanchart.hoverSeries = series;
            }

            var closestPoint = series.getClosestPoint(ev.containerPoint);

            if(closestPoint && closestPoint != hoverPoint){
                hoverPoint && hoverPoint.fire('mouseout', ev);

                vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
                closestPoint.fire('mouseover', ev);
                vanchart.registerInteractiveTarget(closestPoint, closestPoint.series.defaultMarker);
            }
        },

        // tap
        _onSeriesTap : function (ev) {
            BaseUtils.hasTouch() && this.fire('mouseover', ev);
        },

        getPressedStyle:function(){
            return null;
        },

        onPointPress:function(){
            var point = this, series = point.series, style = series.getPressedStyle(point);
            if(style && point.graphic){
                point.graphic.style(style);
            }
        },

        onPointPressUp:function(){
            var point = this, series = point.series, style = series.getHighLightStyle && series.getHighLightStyle(point);
            if(style && point.graphic){
                point.graphic.style(style);
            }
        },

        remove:function(){

            var series = this, vanchart = series.vanchart;
            this.points.forEach(function(point){
                vanchart.removePointGraphics(point, series.type, false);
            });

            this._canvas && this._canvas.remove();
            this.textGraphicGroup && this.textGraphicGroup.remove();
            this.group && this.group.remove();
            this.textGraphicGroup = this._canvas = this.group = null;
        },

        reShowPoint:function (point) {
            var series = point.series, vanchart = series.vanchart, legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            return legend && legend.items && legend.reShowPoint(point);
        },

        //
        updateDelay:function (delay) {
            var series = this, vanchart = series.vanchart, legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            if(legend && legend.showSeries(series)) {
                var chartSeries = vanchart.seriesOfType(series.type);
                for (var i = 0, len = chartSeries.length; i < len; i++) {
                    if (legend.toDropSeries(chartSeries[i])) {
                        return delay || 150;
                    }
                }
            }
            return 0;
        }
    });

    return Series;
});
/**
 * Created by Yuqian on 2017/1/11.
 */

define('chart/gantt/GanttSeries',['require','../Series','../../utils/BaseUtils','../../Constants','../../utils/BezierEasing','../../locale/localeText','../../ChartLibrary'],function (require) {

    var Series = require('../Series');
    var BaseUtils = require('../../utils/BaseUtils');
    var Constants = require('../../Constants');
    var BezierEasing = require('../../utils/BezierEasing');
    var localeText = require('../../locale/localeText');

    var BORDER_RADIUS = 2;
    var GAP_PCT = 0.1;
    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;

    var INIT_ANIMATION_TIME = 1200;//
    var INIT_EASE = BezierEasing.css["ease-out-cubic"];
    var EXIT_ANIMATION_TIME = 150;//
    var EXIT_EASE = BezierEasing.css["ease-in-back"];
    var UPDATE_ANIMATION_TIME = 250;//
    var UPDATE_EASE = BezierEasing.custom["ease-out"];
    var RE_SHOW_ANIMATION_TIME = 900;//
    var RE_SHOW_EASE = BezierEasing.custom["ease-out-quint"];

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';


    var LEVEL_DIVIDE = 7; // 0-6 is low, 7-12 is high

    function fmtYYYYMMdd (d) {
        return d.format('YYYY-MM-dd')
    }

    function fmtYYYYMMddHHmm (d) {
        return d.format('YYYY-MM-dd HH:mm')
    }

    function fmtProgress (v) {
        return v * 100 + '%'
    }

    function fmtProcesses (ps) {
        return ps.map(function (obj) { return obj.name}).join(' ')
    }

    var fmtFns = {};

    function genTimeFormatter (prefix, dateFmtStr) {
        var str = prefix + dateFmtStr;
        if (!fmtFns[str]) {
            fmtFns[str] = function (d) {
                return prefix + d.format(dateFmtStr);
            }
        }
        return fmtFns[str]
    }

    var isSupportSVG = BaseUtils.isSupportSVG();

    var Gantt = Series.extend({
        
        doLayout: function () {

            var series = this, vanchart = series.vanchart;

            var timeAxis = vanchart.getTimeAxis();
            var scale = timeAxis.scale;
            var processes = vanchart.getProcesses();
            var procMap = processes.procMap;
            var cateMap = processes.cateMap;
            var rowHeight = processes.tableDims.rowHeight;

            var newLine = vanchart.options.plotOptions.newLine;
            var oh = this._getSeriesOffsetAndHeight(rowHeight, newLine);

            this.getDataToDraw().forEach(function(point){
                var options = point.options, borderWidth = options.borderWidth;
                var pId = options.processesId;

                var x1 = scale(+point.startTime);
                var x2 = scale(+point.finishTime);

                var rect = {};
                rect.x = x1;
                rect.y = cateMap[pId] * rowHeight + oh.offset;
                rect.width = x2 - x1;
                rect.height = oh.height;

                rect = BaseUtils.rectSubPixelOpt(rect, borderWidth);
                rect.rx = rect.ry = BORDER_RADIUS;

                point.rect = rect;
                point.initRect = {
                    x: rect.x,
                    y: rect.y,
                    width: 0,
                    height: rect.height
                };

                // VML
                point.leftRect = {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width * point.progress,
                    height: rect.height
                };

                point.rightRect = {
                    x: rect.x + point.leftRect.width,
                    y: rect.y,
                    width: rect.width * (1 - point.progress),
                    height: rect.height
                };
            });
        },

        _getSeriesOffsetAndHeight: function (rowHeight, newLine) {

            var height = 0;
            var offset = rowHeight * GAP_PCT;

            var visibles = this._getVisibles();
            var total = newLine ? visibles.length : 1;
            var index = newLine ? visibles.indexOf(this.index) : 0;

            height = rowHeight * (1 - GAP_PCT * (total + 1)) / total; // what does 25% mean? F**k
            offset += index * (height + rowHeight * GAP_PCT);

            return {
                height: height,
                offset: offset
            }
        },

        _getVisibles: function () {
            return this.vanchart.seriesOfType(this.type)
                .filter(function (s) {
                    return s.visible
                })
                .map(function (s) {
                    return s.index
                })
        },

        getDataToDraw: function () {
            var procMap = this.vanchart.getProcesses().procMap;
            return this.points.filter(function (p) { return procMap[p.options.processesId] && !p.isNull });
        },

        // gantt's points are so different from others
        isNullValue: BaseUtils.falseFn,

        _getTranslate: function () {
            return [0, 0]
        },

        _calculateLabelPos: function () {
            this.getDataToDraw().forEach(function(point){
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    var rect = point.rect, labelDim = point.labelDim;
                    // pct bar width
                    var width = rect.width * point.progress;

                    var pos = {y: rect.y + rect.height / 2 - labelDim.height / 2};
                    if (dataLabels.align === Constants.RIGHT) {
                        pos.x = rect.x + width - labelDim.width - LABEL_GAP;
                    } else {
                        pos.x = rect.x + width / 2 - labelDim.width / 2;
                    }

                    point.labelPos = pos;
                }
            });
        },

        getFillFilter: function (color, p) {
            var R = this.vanchart.renderer;
            var attrs = {'x1': 0, 'y1': 0, 'x2': 1, 'y2': 0};

            var pct = p.progress;

            var stops = [
                {'offset':  pct, 'stop-color': color},
                {'offset':  pct, 'stop-color': color, 'stop-opacity': '0.5'}
            ];

            if(p.colorGradient){
                R.updateColorGradient(p.colorGradient, attrs, stops);
            }else{
                p.colorGradient = R.colorGradient(attrs, stops);
            }

            return "url(#" + BaseUtils.stamp(p.colorGradient) + ")";
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        getPointInitAttr:function(point){
            return point.initRect;
        },

        _calculateAnimationDelay:function(){
            return this.updateDelay(EXIT_ANIMATION_TIME);
        },

        getPointInitAnimationAttr:function(point){
            return {
                ease:INIT_EASE,
                duration:INIT_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:RE_SHOW_EASE,
                duration:RE_SHOW_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointUpdateAnimationAttr:function(point, delay){
            return {
                delay:delay || 0,
                ease:UPDATE_EASE,
                duration:UPDATE_ANIMATION_TIME,
                attr:point.rect
            }
        },

        getPointDropAnimationAttr:function(point){
            return {
                ease:EXIT_EASE,
                duration:EXIT_ANIMATION_TIME,
                attr:point.initRect
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, style, true);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);
            series._onState(point, style, false);
        },

        _onState:function (point, style, isChosen) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, BezierEasing.css["ease"]);
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor ,
                'fill':p.series.getFillFilter(p.mouseOverColor, p),
                'fill-opacity': p.opacity,
                'stroke-width':6,
                'stroke-opacity':  p.opacity === 0 ? 0 : 0.35
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity
            }
        },

        _formatFn: function (key) {
            switch (key) {
                case 'processes':
                    return fmtProcesses;
                case 'startTime':
                case 'finishTime':
                    return this.vanchart.getTimeAxis().initLevel < LEVEL_DIVIDE
                        ? fmtYYYYMMdd
                        : fmtYYYYMMddHHmm;
                case 'progress':
                    return fmtProgress;
                default:
                    return null
            }
        },

        _postLabel: function (str, key) {
            switch (key) {
                case 'duration':
                case 'progress':
                case 'startTime':
                case 'finishTime':
                    return localeText(key) + str;
                default:
                    return str
            }
        },

        _postTooltip: function (str, key) {
            switch (key) {
                case 'duration':
                case 'progress':
                case 'startTime':
                case 'finishTime':
                    return localeText(key).trim() + ': ' + str;
                default:
                    return str
            }
        }

    });

    Gantt.prototype._getLabelFormatFn = Gantt.prototype._formatFn;
    Gantt.prototype._getTooltipFormatFn = Gantt.prototype._formatFn;

    //
    // VML patch
    //
    if (!isSupportSVG) {
        Gantt.include({

            getFillFilter: function (color) {
                return color
            },

            _drawUpdatePoints: function (point) {
                this._updatePointGraphicStyle(point);   // 
                this._updateAttr(point);
                this.vanchart.registerInteractiveTarget(point, point.graphic);  // 
            },

            _drawEnterPoints: function (point) {
                var series = this, group = series._getPointGraphicGroup();

                var R = this.vanchart.renderer;
                var graphic = point.graphic = R.group();

                graphic.outerRect = R.rect();
                graphic.leftRect = R.rect();
                graphic.rightRect = R.rect();

                this._updateAttr(point);

                var s = series.getStyle(point);
                this._updatePointGraphicStyle(point, s);

                graphic.append(graphic.outerRect);
                graphic.append(graphic.leftRect);
                graphic.append(graphic.rightRect);

                group.append(graphic);

                series.vanchart.registerInteractiveTarget(point, graphic);
            },

            _updateAttr: function (point) {
                var graphic = point.graphic;
                graphic.outerRect.attr(point.rect);
                graphic.leftRect.attr(point.leftRect);
                graphic.rightRect.attr(point.rightRect);
            },

            _drawExitPoints: function (point) {
                point.graphic.remove();
            },

            _updatePointGraphicStyle:function(point, style){
                var s = style || point.series._getDynamicStyle(point);
                point.graphic.outerRect.style({
                    'stroke-width': (s['stroke-width'] || 0) + 1,
                    'stroke': s['stroke']
                });
                s['stroke-width'] = 0;
                point.graphic.leftRect.style(BaseUtils.clone(s));
                s['fill-opacity'] = s['fill-opacity'] || 1;
                s['fill-opacity'] *= 0.5;
                point.graphic.rightRect.style(s);
            },

            _onPointMouseOver:function(point){
                var series = point.series, style = series.getHighLightStyle(point);
                series._updatePointGraphicStyle(point, style);
            },

            _onPointMouseOut:function(point){
                var series = point.series,style = series.getStyle(point);
                series._updatePointGraphicStyle(point, style);
            }
        })
    }


    require('../../ChartLibrary').register(Constants.GANTT_CHART, Gantt);

    return Gantt;
});

/**
 * Created by eason on 15/8/17.
 */

define('component/LegendIconFactory',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var LegendPath = {};
    var LegendSize = {};

    LegendPath[Constants.PIE_ICON] = 'M15.795,7.943L7.909,12.5L0.205,8.052C1.756,5.333,4.68,3.5,8.032,3.5C11.338,3.5,14.23,5.287,15.795,7.943z';
    LegendSize[Constants.PIE_ICON] = {
        width:16,
        height:16
    };

    LegendPath[Constants.TREEMAP_ICON] = 'M9,12H3c-1.6,0-3-1.4-3-3l0-6c0-1.6,1.3-3,3-3l6,0c1.7,0,3,1.4,3,3v6C12,10.6,10.6,12,9,12z';
    LegendSize[Constants.TREEMAP_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.DONUT_ICON] = 'M8.945,11.107c1.671,0,3.181,0.684,4.269,1.786l4.271-4.271c-4.686-4.686-12.284-4.686-16.971,0l4.216,4.216C5.815,11.768,7.302,11.107,8.945,11.107z';
    LegendSize[Constants.DONUT_ICON] = {
        width:18,
        height:18
    };

    LegendPath[Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.BUBBLE_ICON] = "M6,11.5c-1.47,0-2.851-0.572-3.889-1.611C1.072,8.851,0.5,7.47,0.5,6s0.572-2.851,1.611-3.889C3.149,1.072,4.53,0.5,6,0.5s2.851,0.572,3.889,1.611C10.928,3.149,11.5,4.53,11.5,6s-0.572,2.851-1.611,3.889C8.851,10.928,7.47,11.5,6,11.5z";
    LegendSize[Constants.BUBBLE_ICON] = {
        width:11,
        height:11
    };

    LegendPath[Constants.NULL_MARKER] = 'M1,8L1,8c0-0.552,0.448-1,1-1h12c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1H2C1.448,9,1,8.552,1,8z';
    LegendSize[Constants.NULL_MARKER] = {
        width:16,
        height:16
    };

    LegendPath[Constants.CIRCLE] = 'M11,8c0,1.657-1.343,3-3,3S5,9.657,5,8s1.343-3,3-3S11,6.343,11,8z M14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,8c0-0.347,0.058-0.678,0.142-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.142C4.058,8.678,4,8.347,4,8z';
    LegendSize[Constants.CIRCLE] = {
        width:16,
        height:16
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NULL_MARKER] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NULL_MARKER] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE] = "M4,8C2.897,8,1.897,7.551,1.173,6.827S0,5.103,0,4s0.449-2.103,1.173-2.827S2.897,0,4,0s2.103,0.449,2.827,1.173S8,2.897,8,4S7.551,6.103,6.827,6.827S5.103,8,4,8";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE] = 'M11,11H5V5h6V11z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2V7z';
    LegendSize[Constants.SQUARE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE] = "M0,0h8c0,0,0,3.889,0,8C4,8,0,8,0,8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND] = 'M8,11L5,8l3-3l3,3L8,11z M14,7h-2.586l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M3.586,8l1-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.586L3.586,8z';
    LegendSize[Constants.DIAMOND] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND] = "M0,4.5L4.502,0l4.5,4.5c0,0,0,0-4.5,4.5C0,4.5,0,4.5,0,4.5z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND] = {
        width:9,
        height:9
    };

    LegendPath[Constants.TRIANGLE] = 'M5,10l3-5.196L11,10H5z M14,7h-3.577l1.155,2H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M5.577,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.423L5.577,7z';
    LegendSize[Constants.TRIANGLE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE] = "M4.5,0L9,8c0,0-4.617,0-9,0L4.5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE] = {
        width:9,
        height:8
    };

    LegendPath[Constants.CIRCLE_HOLLOW] = 'M4.142,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.142C4.058,7.322,4,7.653,4,8S4.058,8.678,4.142,9zM14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,7C7.449,7,7,7.449,7,8s0.449,1,1,1s1-0.449,1-1S8.551,7,8,7 M8,5c1.657,0,3,1.343,3,3s-1.343,3-3,3S5,9.657,5,8S6.343,5,8,5L8,5z';
    LegendSize[Constants.CIRCLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = "M4,2c1.102,0,2,0.898,2,2S5.102,6,4,6S2,5.102,2,4S2.898,2,4,2 M4,0C1.791,0,0,1.791,0,4s1.791,4,4,4s4-1.791,4-4S6.209,0,4,0";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE_HOLLOW] = 'M4,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2V9z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M9,7H7v2h2V7 M11,5v6H5V5H11L11,5z';
    LegendSize[Constants.SQUARE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = "M6,6H2V2h4V6z M8,0H0v8h8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND_HOLLOW] = 'M4.157,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.157l-1,1L4.157,9z M14,7h-2.157l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,5.986L5.986,8L8,10.014L10.014,8L8,5.986 M8,4.571L11.429,8L8,11.429L4.571,8L8,4.571L8,4.571z';
    LegendSize[Constants.DIAMOND_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = "M2.121,4.999L5,2.121l2.878,2.878L5,7.879L2.121,4.999z M5,0L0,4.999L5,10l4.999-5.001L5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = {
        width:10,
        height:10
    };

    LegendPath[Constants.TRIANGLE_HOLLOW] = 'M4.5,9H2C1.448,9,1,8.552,1,8s0.448-1,1-1h3.655L4.5,9z M14,7h-3.655L11.5,9H14c0.552,0,1-0.448,1-1S14.552,7,14,7z M8,6.938L6.232,10h3.536L8,6.938 M8,4.938L11.5,11h-7L8,4.938L8,4.938z';
    LegendSize[Constants.TRIANGLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = "M5.001,3.34L7.402,7.5H2.598L5.001,3.34z M5.001,0.34L0,9h10L5.001,0.34z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = {
        width:10,
        height:9
    };

    function getLegendIconPath(name){
        return LegendPath[name];
    }

    function getLegendIconSize(name){
        return LegendSize[name] ? LegendSize[name] : LegendSize[Constants.NORMAL_ICON];
    }

    function hasIcon(name){
        return LegendPath[name];
    }
    
    return {
        getLegendIconPath:getLegendIconPath,
        getLegendIconSize:getLegendIconSize,
        hasIcon:hasIcon
    }
});
/**
 * Created by eason on 15/5/4.
 * 
 */
define('component/Base',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../dom/Evented','../utils/QueryUtils','./LegendIconFactory','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Evented = require('../dom/Evented');
    var QueryUtils = require('../utils/QueryUtils');
    var LegendIconFactory = require('./LegendIconFactory');

    var Class = require('../utils/Class');

    var DEFAULT_MARKER_RADIUS = 4.5;

    var Base = Evented.extend({

        initialize:function(options, componentType, vanchart){

            this.componentType = componentType;
            this.vanchart = vanchart;

            this.refresh(options);
        },

        refresh:function(options){

            this.options = options || this.options;
            
            options = this.options;

            BaseUtils.extend(this, {
                isFloat:options.floating,
                _floatX:this._getPercentValue(options.x, this.vanchart.width),
                _floatY:this._getPercentValue(options.y, this.vanchart.height)
            });

            BaseUtils.calculateFontSizeWithScale(options.style);

            this._refresh && this._refresh(options);
        },

        createComponentGroup:function(){
            return this.vanchart.renderer.group().addTo(this.getComponentParentGroup());
        },
        
        getComponentParentGroup:function(){
            return this.isFloat ? this.vanchart.frontGroup : this.vanchart.backGroup;
        },

        useHtmlLabel:function(){
            return this.options.useHtml || !BaseUtils.isSupportSVG();
        },

        _getLegendType:function(sery){

            var marker = sery.options.marker;

            var icon = '';

            switch (sery.type) {
                case Constants.MULTIPIE_CHART:
                case Constants.PIE_CHART:
                    var innerRadius = sery.options.innerRadius;
                    if (innerRadius && parseFloat(innerRadius) > 0) {
                        return Constants.DONUT_ICON;
                    }else{
                        return Constants.PIE_ICON;
                    }
                case Constants.RADAR_CHART:
                    if (sery.options.columnType) {
                        return Constants.NORMAL_ICON;
                    }
                    break;
                case Constants.FORCE_BUBBLE_CHART:
                case Constants.BUBBLE_CHART:
                    return Constants.BUBBLE_ICON;
                case Constants.TREEMAP_CHART:
                    return Constants.TREEMAP_ICON;
                case Constants.LINE_MAP:
                    return Constants.NULL_MARKER;
                default:
                    icon = Constants.NORMAL_ICON;
            }

            if(sery.type == Constants.POINT_MAP && sery.options.icon){
                return sery.options.icon.iconUrl;
            }

            //marker,marker,
            //image
            if(sery.options.image && BaseUtils.isSupportSVG()){
                //
                icon = sery.options.image;
            }else if(marker){
                icon = marker.symbol;
                if(sery.type == Constants.SCATTER_CHART && !BaseUtils.isImageMarker(icon)){
                    icon = Constants.SCATTER_ICON + marker.symbol;
                }
            }

            return icon;
        },

        //
        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        _setComponentBounds:function(position, usedSize){
            if(this.isFloat || (this.options && this.options.onZero)){
                this._updateFloatBounds(position, usedSize);
            }else{
                this._updateComponentBounds(position, usedSize);
            }
        },

        isHorizontal:function(){
            var position = this.getPosition();
            return position == Constants.TOP || position == Constants.BOTTOM;
        },

        isVertical:function(){
            return !this.isHorizontal();
        },

        getPosition:function(){
            return this.options.position;
        },

        _updateFloatBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;

            var x = this._floatX;
            var y = this._floatY;

            var width = originBounds.x + originBounds.width - x;
            var height = originBounds.y + originBounds.height - y;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break
            }

            /**
             * 0bounds
             * 0
             * bounds
             */
            this.options && this.options.onZero && this._clipPlotBounds(position, usedSize);
        },

        /**
         * 
         * @param position{string} 
         * @para usedSize 
         * @private
         */
        _updateComponentBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y+height-usedSize, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    this.bounds = {x:x+width-usedSize, y:y, width:usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);

            this._clipPlotBounds(position, usedSize);
        },

        _clipPlotBounds:function(position, usedSize){

            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.bounds;
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    originBounds = {x:x, y:y+usedSize, width:width, height:height - usedSize};
                    break;
                case Constants.BOTTOM:
                    originBounds = {x:x, y:y, width:width, height:height - usedSize};
                    break;
                case Constants.LEFT:
                    originBounds = {x:x+usedSize, y:y, width:width-usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT_BOTTOM:
                case Constants.RIGHT:
                    originBounds = {x:x, y:y, width:width-usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);
        },

        // cannot decide how to clip now
        // clip them in the end
        _recordForPlotBounds: function (position, usedSize) {
            usedSize = Math.ceil(usedSize);

            (position === Constants.RIGHT_TOP) && (position = Constants.RIGHT);
            (position === Constants.RIGHT_BOTTOM) && (position = Constants.RIGHT);

            this.vanchart.clipPool[position] = Math.max(this.vanchart.clipPool[position] || 0, usedSize);
        },

        _getBackgroundColor:function(){

            var opt = this.option;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        _maxHeight:function(max){
            var maxHeight = this.vanchart.height;

            if(max || this.options.maxHeight){
                return this._getPercentValue(this.options.maxHeight, maxHeight);
            }

            return maxHeight;
        },

        _maxWidth:function(max){
            var maxWidth = this.vanchart.width;

            if(max || this.options.maxWidth){
                return this._getPercentValue(this.options.maxWidth, maxWidth);
            }

            return maxWidth;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter){
                return tick;
            }

            return BaseUtils.format(tick, formatter);
        },

        getDefaultMarkerRadius:function(){
            return DEFAULT_MARKER_RADIUS;
        },

        getPlotBounds:function(){
            return this.vanchart.bounds;
        },

        getChartBounds:function(){
            return this.vanchart.getChartBounds();
        },

        getParentDom:function(){
            return this.vanchart.getParentDom();
        },

        getDivParentDom:function(){
            return this.vanchart.getDivParentDom();
        },

        getTooltipComponent:function(){
            return this.vanchart.components.tooltip;
        },

        remove:function(){

        },

        _bindData: BaseUtils.bindData,

        invisible:function(){
            return BaseUtils.hasDefined(this.options.visible) && (this.options.visible === false);
        },

        _innerClip: function (group) {
            var comp = this, bounds = comp.bounds, vanchart = comp.vanchart, renderer = vanchart.renderer;
            var innerBounds = BaseUtils.makeBounds(0, 0, bounds.width, bounds.height);

            if(!this._clip){
                this._clip = renderer.createClip(innerBounds);
            }else{
                renderer.updateClip(this._clip, innerBounds);
            }

            if (group.type === 'vgroup') {
                var top = 0, left = 0, right = left + innerBounds.width, bottom = top + innerBounds.height;
                group.divG.style({'clip': 'rect(' + top + 'px '+ right +'px '+ bottom +'px ' + left + 'px)'});
                renderer.clip(group.renderG, this._clip);
            } else {
                renderer.clip(group, this._clip);
            }

        }
    });

    return Base;
});
/**
 * Created by Yuqian on 2017/2/7.
 */

define('chart/gantt/defaultValues',['require'],function (require) {
    return {
        PADDING: '0.25rem',
        WEEKEND_COLOR: 'rgba(169, 195, 200, 0.1)',
        OUTLINE: {'fill':'none', 'stroke': 'rgba(207, 207, 207, 1)', 'stroke-width': 1},
        TWEENLINE: {'fill':'none',
            'stroke': 'rgba(207, 207, 207, 0.6)',
            // 'stroke': 'red',
            'stroke-width': 1},
        INNERLINE: {'fill':'none',
            'stroke': 'rgba(207, 207, 207, 0.6)',
            // 'stroke': 'green',
            'stroke-width': 0.5},

        MINUS_PATH: {
            size: [7.5, 7.5],
            graphics: [
                {fill: '#F2F2F2', d: 'M0,12.7c2,0,3.6,1.6,3.6,3.6S2,19.9,0,19.9s-3.6-1.6-3.6-3.6S-2,12.7,0,12.7z'},
                {fill: '#727171', d: 'M0,20c-2.1,0-3.8-1.7-3.8-3.8s1.7-3.7,3.8-3.7s3.8,1.7,3.8,3.8S2.1,20,0,20z M0,12.8c-1.9,0-3.4,1.5-3.4,3.4  s1.5,3.4,3.4,3.4s3.4-1.5,3.4-3.4S1.9,12.8,0,12.8z M2.1,16h-4.3v0.3h4.3V16z'}
            ]
        },

        PLUS_PATH: {
            size: [7.5, 7.5],
            graphics: [
                {fill: '#F2F2F2', d: 'M0,12.7c2,0,3.6,1.6,3.6,3.6S2,19.9,0,19.9s-3.6-1.6-3.6-3.6S-2,12.7,0,12.7z'},
                {fill: '#727171', d: 'M0,20c-2.1,0-3.8-1.7-3.8-3.8s1.7-3.7,3.8-3.7s3.8,1.7,3.8,3.8S2.1,20,0,20z M0,12.8c-1.9,0-3.4,1.5-3.4,3.4  s1.5,3.4,3.4,3.4s3.4-1.5,3.4-3.4S1.9,12.8,0,12.8z M2.1,16H0.2v-1.9h-0.3V16h-2v0.3h2v2h0.3v-2h1.9C2.1,16.3,2.1,16,2.1,16z'}
            ]
        },

        THUMB_PATH: {
            size: [4.6, 7.1],
            graphics: [
                {fill: '#F2F2F2', d: 'M-0.008,13.717h-2.1v4.5l2.2,2.2l0,0l2.1-2.2v-4.5H-0.008'},
                {fill: '#727171', d: 'M-0.008,20.617l-2.3-2.4v-4.7h4.6v4.7L-0.008,20.617z M-2.008,18.117l2,2l2-2v-4.3h-4V18.117z'}
            ]
        }

    }
});

/**
 * Created by Yuqian on 2017/2/6.
 */

define('chart/gantt/levelDomain',['require'],function (require) {

    var SECOND = 1000,
        MINUTE = 60 * SECOND,
        HOUR = 60 * MINUTE,
        DAY = 24 * HOUR,

        WEEK = 7 * DAY,

        MIN_HALF_YEAR = 181 * DAY,

        // not accurate
        YEAR = 365 * DAY,
        MONTH = YEAR / 12,
        QUARTER = YEAR / 4,
        HALF_YEAR = YEAR / 2;

    var units = [
        // 0
        ['year', 'halfYear'],
        // 1
        ['year', 'halfYear'],
        // 2
        ['year', 'quarter'],
        // 3
        ['halfYear', 'month'],
        // 4
        ['quarter', 'month'],
        // 5
        ['quarter', 'month'],
        // 6
        ['month', 'week'],
        // 7
        ['week', 'day'],
        // 8
        ['month', 'date'],
        // 9
        ['month', 'date'],
        // 10
        ['date', 'meridiem'],
        // 11
        ['date', 'qDay'],
        // 12
        ['date', 'hour']
    ];

    var r0 = 3 / MIN_HALF_YEAR;// R0 = 1emWidth * 3 / halfYear

    function upUnit (level) {
        return units[level][0]
    }

    function subUnit (level) {
        return units[level][1]
    }

    /***
     * @returns {number}
     */
    function Ratio (em, level) {
        return r0 * em * Math.pow(2, level)
    }

    return {
        r0: r0,
        LEN: units.length,
        Ratio: Ratio,
        upUnit: upUnit,
        subUnit: subUnit
    }

});

/**
 * Created by Yuqian on 2017/1/22.
 */

define('chart/gantt/helper',[],function () {

    function lineH (R, G, styles, x1, x2, y, old) {
        if (!old) {
            old = G.append(R.line().style(styles));
        }
        return old.attr({
            x1: x1,
            y1: y,
            x2: x2,
            y2: y
        });
    }

    function lineV (R, G, styles, y1, y2, x, old) {
        if (!old) {
            old = G.append(R.line().style(styles));
        }
        return old.attr({
            x1: x,
            y1: y1,
            x2: x,
            y2: y2
        });
    }

    function rect(R, G, styles, x, y, width, height, old) {
        if (!old) {
            old = G.append(R.rect().style(styles));
        }
        return old.attr({
            x: x,
            y: y,
            width: width,
            height: height
        });
    }

    function traverse (root, childName, before, after) {

        function dfs (node, depth, len, i, parent) {
            before && before(node, depth, len, i, parent);
            var c = node[childName], n;
            if (c && (n = c.length)) {
                c.map(function (d, i) {
                    dfs(d, depth + 1, n, i, node)
                });
            }
            after && after(node, depth, len, i, parent);
        }

        dfs(root, 0, 0, 0, null);
    }

    function sum (arr) {
        return arr.reduce(function (a, b) { return a + b }, 0)
    }

    // calc new values according to old proportions
    function distribValues (oldValues, newValue) {
        var old = sum(oldValues);
        return oldValues.map(function (v) {
            return v / old * newValue
        });
    }

    function getValidProgress(progress) {
        var v = progress;
        if (0 <= v && v <= 1) {
            return v
        }
        return 1
    }

    return {
        lineH: lineH,
        lineV: lineV,
        rect: rect,
        traverse: traverse,
        sum: sum,
        distribValues: distribValues,
        getValidProgress: getValidProgress
    }
});

/**
 * Created by Yuqian on 2017/3/2.
 */

define('chart/gantt/LevelBar',['require','../../component/Base','../../Constants','../../utils/BaseUtils','../../ComponentLibrary','./defaultValues','../../dom/EventObject','./levelDomain','./helper'],function (require) {
    var Base = require('../../component/Base');
    var Constants = require('../../Constants');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var defaultValues = require('./defaultValues');
    var EventObject = require('../../dom/EventObject');

    var LEN = require('./levelDomain').LEN;

    var helper = require('./helper');
    var LineV = helper.lineV;
    var LineH = helper.lineH;

    var MINUS_PATH = defaultValues.MINUS_PATH;
    var PLUS_PATH = defaultValues.PLUS_PATH;
    var THUMB_PATH = defaultValues.THUMB_PATH;

    var THUMB_WIDTH = THUMB_PATH.size[0];

    var HEIGHT = 12;
    var GAP = 12;
    var SLIDER_WIDTH = 64;

    var MOVE_WIDTH = SLIDER_WIDTH - THUMB_WIDTH; // width thumb can move
    var STEP = MOVE_WIDTH / (LEN - 1);

    var LevelBar = Base.extend({

        doLayout: function () {
            this._setComponentBounds(Constants.BOTTOM, HEIGHT);

            var chartBounds = this.vanchart.bounds;
            this.bounds = {
                x: chartBounds.x,
                y: chartBounds.y + chartBounds.height,
                height: HEIGHT,
                width: chartBounds.width
            }
        },
        
        render: function () {
            // render once
            if (!this.group) {
                var R = this.vanchart.renderer;
                this.group = R.group().add();
                this.group
                    .attr('transform', BaseUtils.makeTranslate(this.bounds))
                    .attr('class', 'level-bar');

                this._bar(R);
                this._slider(R);
            }

            // debug icon reference
            // this.group.append(R.rect()
            //     .attr({
            //         x: this._getLineStartX() + SLIDER_WIDTH / 4 * 3,
            //         y: HEIGHT / 2 - 1,
            //         width: 2,
            //         height: 2,
            //         fill: 'red'
            //     }));
        },

        // in case of empty data
        isEnabled: function () {
            return this.enabled && this.vanchart.getTimeAxis().isZoomEnabled();
        },

        setLevel: function (level) {
            if (level == null) {
                return
            }
            // invalid if never set the level
            this.enabled = true;
            this._setThumbLevel(level);
        },

        _setThumbLevel: function (level) {
            var x = THUMB_WIDTH / 2 + STEP * level;
            this.thumbG.attr('transform', BaseUtils.makeTranslate({
                x: x,
                y: -17
            }));
        },

        _bar: function (R) {
            this.group.append(R.rect()
                .attr({
                    x: 0,
                    y: 0,
                    width: this.bounds.width,
                    height: this.bounds.height
                })
                .style({
                    stroke: 'none',
                    fill: this._gradient(R)
                })
            );
        },

        _gradient: function (R) {
            if (!BaseUtils.isSupportSVG()) {
                return 'rgb(220, 220, 220)'
            }

            var attrs = {'x1': 0, 'y1': 0, 'x2': 0, 'y2': 1};

            var stops = [
                {'offset':   '0%', 'stop-color': 'rgb(220, 220, 220)'},
                {'offset':  '75%', 'stop-color': 'rgb(181, 181, 181)'},
                {'offset': '100%', 'stop-color': 'rgb(137, 137, 137)'}
            ];

            var gradient = R.colorGradient(attrs, stops);
            return "url(#" + BaseUtils.stamp(gradient) + ")";
        },

        _slider: function (R) {

            var g = this.group.append(R.group());
            g.attr('transform', BaseUtils.makeTranslate({
                x: this._getLineStartX(),
                y: HEIGHT / 2
            }));

            LineH(R, g,
                {'fill':'none', 'stroke': '#727171', 'stroke-width': 0.5},
                0,
                SLIDER_WIDTH,
                0
            );

            this.minusG = this._getIconGroup(R, MINUS_PATH, -MINUS_PATH.size[0] / 2);
            this.plusG = this._getIconGroup(R, PLUS_PATH, SLIDER_WIDTH + PLUS_PATH.size[0] / 2);
            this.thumbG = this._getIconGroup(R, THUMB_PATH, SLIDER_WIDTH / 2);

            ['minus', 'plus', 'thumb'].map(function (name) {
                var graphic = this[name + 'G'];
                g.append(graphic);
                var evObj = new EventObject(this.iconEvents(name));
                evObj.control = this;
                this.vanchart.registerInteractiveTarget(evObj, graphic);
            }, this);

        },

        // relative to bounds
        _getLineStartX: function () {
            return this.bounds.width - SLIDER_WIDTH - GAP
        },

        eventsMap: {
            minus: ['tap'],
            plus: ['tap'],
            thumb: ['panstart', 'panmove', 'panend']
        },

        iconEvents: function (name) {
            var types = this.eventsMap[name];
            var events = {};
            types.map(function (type) {
                events[type] = this['on' + name + type];
            }, this);
            return events
        },

        onminustap: function (ev) {
            this.control._changeLevel(-1);
        },

        onplustap: function (ev) {
            this.control._changeLevel(1);
        },

        onthumbpanstart: function (ev) {
        },

        onthumbpanmove: function (ev) {
            var bar = this.control;
            var bounds = bar.bounds;
            var pos = ev.containerPoint;

            // adjust to [0, MOVE_WIDTH]
            var v = pos.x - bounds.x - bar._getLineStartX() - THUMB_WIDTH / 2;
            v = Math.min(Math.max(0, v), MOVE_WIDTH);

            var level = Math.round(v / STEP);
            bar._changeToLevel(level);
        },

        onthumbpanend: function (ev) {
        },

        _changeToLevel: function (level) {

            if (!this.isEnabled()) {
                return
            }

            this.vanchart.changeToLevel(level);
            this._setThumbLevel(this.vanchart.getTimeAxis().getLevel());
        },

        _changeLevel: function (c) {
            var level = this.vanchart.getTimeAxis().getLevel() + c;
            this._changeToLevel(level);
        },

        _getIconGroup: function (R, paths, x) {
            var g = R.group();
            g.attr('transform', BaseUtils.makeTranslate({
                x: x,
                y: -17
            }));
            g.append(R.path().attr(paths.graphics[0]));
            g.append(R.path().attr(paths.graphics[1]));
            return g
        }

    });

    ComponentLibrary.register(ComponentLibrary.LEVELBAR, LevelBar);

    return LevelBar

});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/Table',['require','../../component/Base'],function (require) {
    var Base = require('../../component/Base');

    return Base.extend({

        _getHeader: function () {
            return this.options.header;
        },

        _getBody: function () {
            return this.options.body;
        }
    });

});

/**
 * Created by Yuqian on 2017/2/27.
 */

define('chart/gantt/ScrollbarItem',['require','../../dom/Evented','../../utils/BaseUtils'],function (require) {

    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var isSupportSVG = BaseUtils.isSupportSVG();

    // todo, need a transform util
    var transReg = /translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i;

    var BG_SIZE = 12;
    var BG_COLOR = 'rgba(233, 233, 233, 0.6)';
    var BG_STROKE = 'rgba(207, 207, 207, 0.6)';
    var BG_STROKE_WIDTH = 0.5;
    var BAR_SIZE = 6;
    var BAR_COLOR = 'rgba(160, 160, 160, 0.6)';
    var BAR_HOVER_COLOR = 'rgba(88, 88, 88, 0.6)';
    var BAR_ROUND = BAR_SIZE / 2;

    var ScrollbarItem = Evented.extend({

        initialize: function (opt) {
            this.opt = opt;

            this.pos = {
                x: 0,
                y: 0
            };
            var vanchart = opt.manager.vanchart,
                R = opt.manager.renderer;

            this.group = opt.group.append(R.group());
            this.group.style('transition', 'opacity 0.3s');
            this.group.attr('transform', BaseUtils.makeTranslate([opt.x, opt.y]));

            var width, height, barWidth, barHeight, offsetDir;
            if (opt.dir === 'x') {
                width = this.opt.length;
                height = BG_SIZE;
                barWidth = this.opt.barLength;
                barHeight = BAR_SIZE;
                offsetDir = 'y';
            } else {
                width = BG_SIZE;
                height = this.opt.length;
                barWidth = BAR_SIZE;
                barHeight = this.opt.barLength;
                offsetDir = 'x';
            }

            this.background = this.group.append(R.rect().attr({
                'width': width,
                'height': height
            }).style({
                'fill': BG_COLOR,
                'stroke': BG_STROKE,
                'stroke-width': BG_STROKE_WIDTH
            }));

            var barAttrs = {
                'rx': BAR_ROUND,
                'ry': BAR_ROUND,
                'width': barWidth,
                'height': barHeight
            };
            barAttrs[offsetDir] = (BG_SIZE - BAR_SIZE) / 2;

            this.bar = this.group.append(R.rect().attr(barAttrs).style('fill', BAR_COLOR));

            vanchart.registerInteractiveTarget(this, this.bar);
        },

        show: function (d) {
            d = this._over || d;
            if (d !== this._showed) {
                this._showed = d;
                if (BaseUtils.isSupportSVG()) {
                    this.group.style('opacity', d ? '1' : '0');
                } else {
                    this.group.style('display', d ? '' : 'none');
                }
            }
        },

        remove: function () {
            this.group.remove();
        },

        setPos: function (x, y) {
            if (x !== this.opt.x || y !== this.opt.y) {
                this.group.attr('transform', BaseUtils.makeTranslate([x, y]));
                this.opt.x = x;
                this.opt.y = y;
            }
        },

        setSize: function (length, barLength) {
            if (length !== this.opt.length || barLength !== this.opt.barLength) {

                if (length < barLength || length < 0 || barLength < 0) {
                    length = barLength = 0;
                }

                var key = this.opt.dir === 'x' ? 'width' : 'height';
                this.background.attr(key, length);
                this.bar.attr(key, barLength);
                this.opt.length = length;
                this.opt.barLength = barLength;
            }
        },

        setPct: function (pct) {
            this.setBarPos(this._getRemainLength() * pct);
        },

        getBarPos: function () {
            return this.pos[this.opt.dir]
        },

        setBarPos: function (value) {
            value = Math.max(0, Math.min(value, this._getRemainLength()));
            if (this.getBarPos() !== value) {
                this.pos[this.opt.dir] = value;
                this.bar.attr('transform', BaseUtils.makeTranslate(this.pos));
            }
        },

        _getRemainLength: function () {
            return this.opt.length - this.opt.barLength
        },

        // _getBarPos: function () {
        //     var translate;
        //     if (isSupportSVG) {
        //         translate = this.bar.attr('transform').match(transReg);
        //         translate && translate.shift();
        //
        //     } else {
        //         var style = this.bar.node().style;
        //         translate = [parseFloat(style.left), parseFloat(style.top)];
        //     }
        // },

        getEvents: function () {
            return {
                'mouseover': this.onMouseOver,
                'mouseout': this.onMouseOut,
                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        onMouseOver: function () {
            this._over = true;
            this.bar.style({ fill: BAR_HOVER_COLOR });
        },

        onMouseOut: function () {
            this._over = false;
            this.bar.style({ fill: BAR_COLOR });
        },

        onPanStart:function(ev){
            this.initPos = this.getBarPos();
            this.initPointPos = ev.containerPoint;
        },

        onPanMove:function(ev){
            var delta = ev.containerPoint[this.opt.dir] - this.initPointPos[this.opt.dir];

            // this.setBarPos(this.initPos + delta); // , 

            this.opt.manager['on' + this.opt.dir]((this.initPos + delta) / this._getRemainLength());
        },

        onPanEnd:function(){
            this.opt.manager.vanchart.handler.panTarget = null;
        }
    });

    ScrollbarItem.SIZE = BG_SIZE;

    return ScrollbarItem

});

/**
 * Created by Yuqian on 2017/2/27.
 */

define('chart/gantt/Scrollbar',['require','../../dom/Evented','../../utils/BaseUtils','./ScrollbarItem'],function (require) {

    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var Bar = require('./ScrollbarItem');

    var MIN_BAR_LENGTH = 20;

    function toFixed (value) {
        return +value.toFixed(3);
    }

    /**
     * usage:
     *
     // view
     var view = this;
     view.scrollbar = new Scrollbar({
         view: view, // view
         group: g, // svg group
         width: this.bounds.width,
         height: this.bounds.height,
         innerWidth: this.innerWidth,
         innerHeight: this.innerBodyHeight
     })

     // listen on:
     view.scrollbar
         .on('scrollX', this.onScrollX, view) // data: {x: Number}
         .on('scrollY', this.onScrollY, view) // data: {y: Number}

     // fire:
     view.fire('innerChange', pos) // give it a pos object {x: Number, y: Number}
     view.fire('resize', options) // new width, height, innerWidth, innerHeight
     view.fire('mouseover') // display
     view.fire('mouseout') // hide

     */

    return Evented.extend({

        /**
         *
         * @param options
         * {
         *   view: object, // the view this bar built on
         *   group: object, // the dom g this manager appended
         *   onChangeName: string, | 'innerChange' // listen on eventName
         *   onResizeName: string, | 'resize'
         *   onOverName: string, | 'mouseover'
         *   onOutName: string, | 'mouseout'
         *   width: 0, // visible area
         *   height: 0,
         *   innerWidth: 0, // inner real size
         *   innerHeight: 0,
         *   scrollX: true,
         *   scrollY: true,
         *   autoHide: true
         * }
         */
        initialize: function (options) {
            // for convenient
            this.view = options.view;
            this.vanchart = options.view.vanchart;
            this.renderer = options.view.renderer || this.vanchart.renderer;
            this.group = options.group;
            this.options = options;

            this.options.autoHide = options.autoHide !== false;

            this.x = this.y = 0; // inner bounds translation

            if (this._isScrollX(options)) {
                this.barX = this._barBottom();
            }
            if (this._isScrollY(options)) {
                this.barY = this._barRight();
            }

            var changeName = options.onChangeName || 'innerChange';
            var resizeName = options.onResizeName || 'resize';
            var overName = options.onOverName || 'mouseover';
            var outName = options.onOutName || 'mouseout';
            this.view
                .on(changeName, this.setPos, this)
                .on(resizeName, this.setSize, this);

            if (options.autoHide) {
                this.barX && this.barX.show(false);
                this.barY && this.barY.show(false);
                this.view.on(overName, this.onover, this);
                this.view.on(outName, this.onout, this);
            }
        },

        onover: function () {
            this.show(true);
        },

        onout: function () {
            this.show(false);
        },

        show: function (d) {
            this.barX && this.barX.show(d);
            this.barY && this.barY.show(d);
        },

        setPos: function (pos) {
            // if (pos.initiator === this) {
            //     return
            // }
            if (this.barX && pos.x != null) {
                var pctX = pos.x / (this.options.width - this.options.innerWidth);
                this.barX.setPct(pctX);
            }
            if (this.barY && pos.y != null) {
                var pctY = pos.y / (this.options.height - this.options.innerHeight);
                this.barY.setPct(pctY);
            }
        },

        // resize, bar group pos and bar size
        setSize: function (options) {
            options.scrollX = this.options.scrollX;
            options.scrollY = this.options.scrollY;

            if (this.options.scrollX) {
                var shouldX = this._isScrollX(options);

                if (shouldX && !this.barX) {
                    this.barX = this._barBottom();
                }
                if (!shouldX && this.barX) {
                    this.barX.remove();
                    this.barX = null;
                }
                if (shouldX && this.barX) {
                    var lengths = this._getLengths(options, 'width');
                    this.barX.setPos(0, options.height - Bar.SIZE);
                    this.barX.setSize(lengths.length, lengths.barLength);
                }
            }
            if (this.options.scrollY) {
                var shouldY = this._isScrollY(options);

                if (shouldY && !this.barY) {
                    this.barY = this._barBottom();
                }
                if (!shouldY && this.barY) {
                    this.barY.remove();
                    this.barX = null;
                }
                if (shouldY && this.barY) {
                    var lengths = this._getLengths(options, 'height');
                    this.barY.setPos(options.width - Bar.SIZE, 0);
                    this.barY.setSize(lengths.length, lengths.barLength);
                }
            }
            BaseUtils.extend(this.options, options);
        },

        _barBottom: function () {
            var lengths = this._getLengths(this.options, 'width');
            return this._bar(
                'x',
                0,
                this.options.height - Bar.SIZE,
                lengths.length,
                lengths.barLength
            );
        },

        _barRight: function () {
            var lengths = this._getLengths(this.options, 'height');
            return this._bar(
                'y',
                this.options.width - Bar.SIZE,
                0,
                lengths.length,
                lengths.barLength
            );
        },

        _getLengths: function (options, prop) {
            var outer = options[prop];
            var inner = prop === 'width' ? options.innerWidth : options.innerHeight;
            var length = outer - (this._isScrollBoth(options) ? Bar.SIZE : 0);
            return {
                length: length,
                barLength: Math.max(outer / inner * length, MIN_BAR_LENGTH)
            }
        },

        /**
         *
         * @param dir 'x'/'y'
         * @param x translate x
         * @param y translate y
         * @param length background length
         * @param barLength
         * @private
         */
        _bar: function (dir, x, y, length, barLength) {
            return new Bar({
                manager: this,
                group: this.group,
                x: x,
                y: y,
                length: length,
                barLength: barLength,
                dir: dir
            });
        },

        onx: function (pct) {
            this.fire('scrollX', {
                initiator: this,
                x: pct * (this.options.width - this.options.innerWidth)
            });
        },

        ony: function (pct) {
            this.fire('scrollY', {
                initiator: this,
                y: pct * (this.options.height - this.options.innerHeight)
            });
        },

        _isScrollX: function (options) {
            return options.scrollX && (toFixed(options.width) < toFixed(options.innerWidth))
        },

        _isScrollY: function (options) {
            return options.scrollY && (toFixed(options.height) < toFixed(options.innerHeight))
        },

        _isScrollBoth: function (options) {
            return this._isScrollX(options) && this._isScrollY(options)
        },

        remove:function () {
            this.barX && this.barX.remove();
            this.barY && this.barY.remove();
            this.barX = this.barY = null;
        }
    });
});

/**
 * Created by Yuqian on 2017/2/24.
 */

define('chart/gantt/TableView',['require','../../dom/Evented','../../utils/BaseUtils','../../utils/ColorUtils','../../dom/DomUtils','../../Constants','./Scrollbar','./helper'],function (require) {
    var Evented = require('../../dom/Evented');
    var BaseUtils = require('../../utils/BaseUtils');
    var ColorUtils = require('../../utils/ColorUtils');
    var toBack = require('../../dom/DomUtils').toBack;
    var Constants = require('../../Constants');
    var Scrollbar = require('./Scrollbar');
    var helper = require('./helper');
    var sum = helper.sum;

    var makeTranslate = BaseUtils.makeTranslate;
    var isEmpty = BaseUtils.isEmpty;
    var mixColorWithAlpha = ColorUtils.mixColorWithAlpha;
    var min = Math.min;
    var max = Math.max;

    return Evented.extend({

        _parts: ['header', 'body', 'outline', 'scrollbar'],

        _eventNames: ['wheelMove', 'resizeStart', 'resizeMove', 'over', 'pan'],

        initialize: function (model, vanchart) {
            this.model = model;
            this.vanchart = vanchart;
            this.renderer = vanchart.renderer;
            var G = this.G = {};
            var cn = this.className;

            // todo, &vanchart.render, group init seq
            ['', 'body', 'inner-body'].map(function (name) {
                G[name || cn] = vanchart[name ? cn + '-' + name : cn];
            });

            this.innerPosX = this.innerPosY = 0;

            var innerBodyHeight = this.model.tableDims.rowHeight * this.model.tableDims.rowNum;
            this.visibleBodyHeight = this.model.bounds.height - this.model.tableDims.headerHeight;
            this.innerBodyHeight = max(innerBodyHeight, this.visibleBodyHeight);
        },

        _getInnerWidth: function () {
            return this.model.innerWidth
        },

        render: function () {

            var renderer = this.renderer, bounds = this.model.bounds;
            this.clip = renderer.createClip({width: bounds.width, height: bounds.height});
            var group = this._getGroup().attr('transform', makeTranslate(bounds));
            renderer.clip(group, this.clip);

            this._parts.map(function (key) {
                this['_' + key]();
            }, this);

            this._eventNames.map(function (key) {
                this.vanchart.handler.on(key, this['on' + key], this);
            }, this);

        },

        _prepareBody: function () {
            var R = this.renderer;

            var bodyG = this._getGroup('body'),
                G = this._getGroup('inner-body');

            var backGroup = this._addGroup('inner-body-back', G);
            toBack(backGroup.node());

            bodyG.attr('transform', BaseUtils.makeTranslate({x: 0,y: this.model.tableDims.headerHeight}));
            // make it exceed any bounds, so needn't to update
            this.bodyClip = R.createClip({
                width: this.vanchart.bounds.width,
                height: this.vanchart.bounds.height
            });
            R.clip(bodyG, this.bodyClip);

            this._bodyEles = {
                hLines: [],
                vLines: [],
                rects: []
            };
            this._bodyEles.gs = [];
        },

        _buildScrollbar: function (opt) {
            this.scrollbar = new Scrollbar(
                BaseUtils.extend({
                    view: this,
                    group: this._getGroup('body'),
                    width: this.model.bounds.width,
                    height: this.visibleBodyHeight,
                    innerWidth: this._getInnerWidth(),
                    innerHeight: this.innerBodyHeight
                }, opt)
            );

            this.scrollbar
                .on('scrollX', this.onScrollX, this)
                .on('scrollY', this.vanchart.onScrollY, this.vanchart); // sync with another

            this.vanchart.on('moveY', this.onScrollY, this); // sync with another
        },

        _addGroup: function (name, parentG) {
            var newGroup = this.renderer.group();
            var className = name ? this.className + '-' + name : this.className;
            newGroup.attr('class', className);

            this.G[name || this.className] = newGroup;

            if (parentG) {
                parentG.append(newGroup);
            }

            return newGroup
        },

        _getGroup: function (name) {
            return this.G[name || this.className];
        },

        _getOptionsColor: function (obj) {
            if (isEmpty(obj.opacity)) {
                return obj.backgroundColor
            } else {
                return mixColorWithAlpha(obj.backgroundColor, obj.opacity);
            }
        },

        changeInner: function (pos) {
            this._setInnerPos(pos);
        },

        onwheelMove: function (ev) {
            var pos = {x: null, y: null};

            if (this._shouldYMove(ev.containerPoint)) {
                pos.y = this.innerPosY - ev.wheel.pixelY;
            }

            if (this._shouldXMove(ev.containerPoint)) {
                pos.x = this.innerPosX - ev.wheel.pixelX;
            }

            this.changeInner(pos);
        },

        onpan: function (ev) {
            switch (ev.type) {
                case 'panstart':
                    this._initInnerPos = {x: this.innerPosX, y: this.innerPosY};
                    this._initPoint = ev.containerPoint;
                    break;
                case 'panmove':
                    var pos = {x: null, y: null};
                    if (this._shouldYMove(this._initPoint)) {
                        pos.y = this._initInnerPos.y + ev.deltaY;
                    }
                    if (this._shouldXMove(this._initPoint)) {
                        pos.x = this._initInnerPos.x + ev.deltaX;
                    }
                    this._setInnerPos(pos);
                    break;
                case 'panend':
            }
        },

        // not strict since y is within bounds
        _shouldYMove: function (p) {
            return p.y > (this.model.bounds.y + this.model.tableDims.headerHeight)
        },

        _shouldXMove: function (p) {
            return BaseUtils.containsPoint(this.model.bounds, p)
        },

        onScrollX: function (data) {
            this._setInnerPos(data);
        },

        onScrollY: function (data) {
            this._setInnerPos(data);
        },

        /**
         * check and set inner group position
         * @param {Object} pos = {
         *     x: {Number}
         *     y: {Number}
         * }
         * @returns {Object} pos // valid pos
         * @private
         */
        _setInnerPos: function (pos) {
            var x, y;
            if (pos) {
                if (pos.x != null) {
                    x = pos.x;
                }
                if (pos.y != null) {
                    y = pos.y;
                }
            }

            if (x == null) {
                x = this.innerPosX;
            }
            if (y == null) {
                y = this.innerPosY;
            }

            x = min(max(this.model.bounds.width - this._getInnerWidth(), x), 0);
            y = min(max(this.visibleBodyHeight - this.innerBodyHeight, y), 0);

            if (x !== this.innerPosX || y !== this.innerPosY) {
                this._showShadow && this._showShadow(x !== 0);

                this._getGroup('header').attr('transform', BaseUtils.makeTranslate([x, 0]));
                this._getGroup('inner-body').attr('transform', BaseUtils.makeTranslate([x, y]));
                this.innerPosX = x;
                this.innerPosY = y;

                this.fire('innerChange', { x: x, y: y});
            }
        },

        onresizeStart: function (ev) {
            this._initX = this.model.bounds.x;
            this._initWidth = this.model.bounds.width;
            this._initPointX = ev.containerPoint.x;
        },

        onresizeMove: function () {
            this.update();
            this._fireResize();
        },

        _fireResize: function () {
            this.fire('resize', {
                width: this.model.bounds.width,
                height: this.visibleBodyHeight,
                innerWidth: this._getInnerWidth(),
                innerHeight: this.innerBodyHeight
            });
            this._setInnerPos(); // bounds checking
        },

        onover: function (ev) {
            if (BaseUtils.containsPoint(this.model.bounds, ev.containerPoint)) {
                this.fire('mouseover');
            } else {
                this.fire('mouseout');
            }
        }

    });

});

/**
 * Created by Yuqian on 2017/2/3.
 */

define('chart/gantt/ProcessesView',['require','./TableView','../../utils/BaseUtils','./Scrollbar','../../dom/DomUtils','./helper','./defaultValues'],function (require) {
    var TableView = require('./TableView');
    var BaseUtils = require('../../utils/BaseUtils');
    var Scrollbar = require('./Scrollbar');
    var toBack = require('../../dom/DomUtils').toBack;
    var helper = require('./helper');
    var DEFAULT = require('./defaultValues');
    var LineV = helper.lineV;
    var LineH = helper.lineH;
    var Rect = helper.rect;
    var traverse = helper.traverse;
    var sum = helper.sum;

    var OUTLINE = DEFAULT.OUTLINE,
        INNERLINE = DEFAULT.INNERLINE,
        TWEENLINE = DEFAULT.TWEENLINE;

    return TableView.extend({

        className: 'processesGroup',

        update: function () {
            var renderer = this.renderer, bounds = this.model.bounds;
            renderer.updateClip(this.clip, {width: bounds.width, height: bounds.height});
            this._header();
            this._body();
            this._outline();
        },

        _getInnerWidth: function () {
            return sum(this.model.tableDims.widths)
        },

        _header: function () {
            var R = this.renderer, group = this._getGroup();
            var widths = this.model.tableDims.widths,
                height = this.model.tableDims.headerHeight;

            var header = this.model._getHeader();

            var G = this._getGroup('header');

            if (!G) {
                G = this._addGroup('header', group);
                this._headerEles = {};
                this._headerEles.gs = [];
            }

            var lineV = LineV.bind(null, R, G);
            var lineH = LineH.bind(null, R, G);
            var rect = Rect.bind(null, R, G);

            var gs = this._headerEles.gs, _p = -1;

            var width = 0;
            widths.map(function (w, i) {

                gs[++_p] = rect(
                    {fill: this._getOptionsColor(header[i])},
                    width, 0, w, height,
                    gs[_p]
                );

                if (i) {
                    gs[++_p] = lineV(TWEENLINE, 0, height, width, gs[_p]);
                }

                gs[++_p] = this._drawText(G, header[i].style, height / 2, width + w / 2, header[i].text, gs[_p]);

                width += w;
            }, this);

            var lineAdj = TWEENLINE['stroke-width'] / 2;
            gs[++_p] = lineH(TWEENLINE, 0, width, height - lineAdj, gs[_p]);
        },

        _body: function () {

            if (!this._bodyEles) {
                this._prepareBody();
            }

            var R = this.renderer;
            var G = this._getGroup('inner-body-back');

            var gs = this._bodyEles.gs, _p = -1;

            var lineV = LineV.bind(null, R, G);
            var lineH = LineH.bind(null, R, G);
            var rect = Rect.bind(null, R, G);

            var body = this.model._getBody();

            var widths = this.model.tableDims.widths,
                accWidths = [],
                width = widths.reduce(function (acc, w, i) {
                    accWidths[i] = acc;
                    return acc + w
                }, 0),
                rowNum = this.model.tableDims.rowNum,
                rowHeight = this.model.tableDims.rowHeight;

            var lineIdx = 0,
                colsIdxes = widths.map(function () { return 0 });

            var _drawText = this._drawText.bind(this);

            traverse(
                this.model._getCateRoot(),
                'categories',
                null,
                function (node, depth, len, i) {
                    if (!depth) { return }

                    var col = depth - 1, // col no.
                        lastColIdx = colsIdxes[col], // save up bound
                        nextLineIdx = lineIdx + 1; // down bound

                    // skip merged cell's last child
                    // needn't to draw every single cell outline
                    if (i < len - 1) {
                        ++lineIdx;
                        var style = depth === 1 ? TWEENLINE : INNERLINE;
                        gs[++_p] = lineH(style, accWidths[col], width, rowHeight * lineIdx, gs[_p]);

                        // when a line is drawn,
                        // the cell's last child drawn as well.
                        var n = colsIdxes.length;
                        while (--n >= col) {
                            colsIdxes[n] = lineIdx;
                        }
                    }

                    var text = node.name;
                    if (text == null || text === '') { return }

                    gs[++_p] = _drawText(
                        G,
                        body[col].style,
                        rowHeight * (lastColIdx + nextLineIdx) / 2,
                        accWidths[col] + widths[col] / 2,
                        text,
                        gs[_p]
                    );
            });

            ++lineIdx; // last line height
            var additionIdx = lineIdx;
            while (additionIdx <= rowNum) {
                var style = additionIdx === lineIdx ? TWEENLINE : INNERLINE;
                gs[++_p] = lineH(style, 0, width, rowHeight * additionIdx, gs[_p]);
                ++additionIdx;
            }

            // vertical line
            var acc = 0;
            var height = this.innerBodyHeight;
            widths.map(function (w, i) {
                if (body[i]) {
                    ++_p;
                    if (!gs[_p]) {
                        gs[_p] = G.append(R.rect());
                        gs[_p].style({fill: this._getOptionsColor(body[i])});
                        toBack(gs[_p].node());
                    }

                    rect(null,
                        acc, 0, w, height,
                        gs[_p]
                    );
                }

                if (i) {
                    gs[++_p] = lineV(TWEENLINE, 0, height, acc, gs[_p]);
                }

                acc += w;
            }, this);
        },

        _outline: function () {
            var R = this.renderer, G = this._getGroup();
            var bounds = this.model.bounds;

            if (!this._outlineEles) {
                var lineAdj = OUTLINE['stroke-width'] / 2;

                var lineV = LineV.bind(null, R, G, OUTLINE);
                var lineH = LineH.bind(null, R, G, OUTLINE);

                lineV(0, bounds.height, lineAdj); // left
                lineH(0, this.vanchart.bounds.width, lineAdj); // top
                lineH(0, this.vanchart.bounds.width, bounds.height - lineAdj);// bottom
            }

            this._outlineEles = LineV(R, G, INNERLINE, 0, bounds.height, bounds.width - INNERLINE['stroke-width'] / 2, this._outlineEles); // right
        },

        _scrollbar: function () {
            this._buildScrollbar({
                scrollX: true,
                scrollY: false
            })
        },

        _drawText: function (G, style, y, x, content, old) {
            if (!old) {
                old = G.append(this.renderer
                    .text()
                    .style(style)
                    .textContent(content)
                );
            }
            old.attr({
                x: x,
                y: y,
                dy: '.35em',
                'margin-top': '-0.5em'
            }).vMiddle();
            return old;
        },

        onresizeMove: function (ev) {
            var bounds = this.model.bounds;

            var delta = ev.containerPoint.x - this._initPointX;
            bounds.width = this._initWidth + delta || 0;

            this.model.expandPanelWidth(bounds.width);

            TableView.prototype.onresizeMove.call(this);
        }
    });
});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/Processes',['require','./Table','../../utils/BaseUtils','../../ComponentLibrary','./ProcessesView','./helper','./defaultValues'],function (require) {
    var Table = require('./Table');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var ProcessesView = require('./ProcessesView');
    var helper = require('./helper');
    var traverse = helper.traverse;
    var sum = helper.sum;
    var distribValues = helper.distribValues;

    var _PADDING = require('./defaultValues').PADDING;
    var PADDING = 0; // get from font-size
    var LINE_HEIGHT = 3;

    var getTextDimension = BaseUtils.getTextDimension;
    var Max = Math.max;

    var Processes = Table.extend({

        _refresh: function () {
            PADDING = BaseUtils.paddingConvertWithScale(_PADDING);
        },

        doLayout: function () {

        },

        // get the outline dim
        getInitPanelDims: function () {
            this.tableDims = this._calcTableDims();
            return {
                width: this._calcPanelWidth(),
                headerHeight: this.tableDims.headerHeight, // may change
                rowHeight: this.tableDims.rowHeight,
                rowNum: this.tableDims.rowNum
            }
        },

        setPanelDims: function (panelDims) {
            // set the real dim for render
            this.tableDims.headerHeight = panelDims.headerHeight;
            this.tableDims.rowNum = panelDims.rowNum;

            this.bounds = {
                x: panelDims.x,
                y: panelDims.y,
                width: panelDims.pWidth,
                height: panelDims.height
            }
        },

        _calcPanelWidth: function () {
            var ratio, width;
            var originWidth = sum(this.tableDims.widths);
            if (ratio = this.options.width) {
                var bounds = this.vanchart.bounds;
                width = bounds.width * ratio;

                // may have to expand table width
                if (width > originWidth) {
                    this.expandPanelWidth(width);
                }


            } else {
                width = originWidth;
            }

            // visible width
            return width;
        },

        expandPanelWidth: function (width) {
            if (width <= sum(this.tightWidths)) {
                return
            }

            this.tableDims.widths = distribValues(this.tableDims.widths, width)
        },

        _calcTableDims: function () {
            var header = this._getHeader();
            var body = this._getBody();
            var root = this._getCateRoot();

            var headerDim = this._calcHeaderDim(header);
            var rowDim = this._calcRowDim(headerDim.widths, body, root);

            return {
                headerHeight: headerDim.height,
                rowHeight: rowDim.height,
                widths: rowDim.widths,
                rowNum: rowDim.num
            }
        },

        _calcHeaderDim: function (header) {
            if (!header || !header.length) {
                return {
                    height: 0,
                    widths: []
                }
            }
            var height = 0;

            var widths = header.map(function (h) {
                var dim = getTextDimension(h.text, h.style, false);
                height = Max(height, dim.height * LINE_HEIGHT);
                return dim.width + PADDING * 2;
            });

            return {
                height: height,
                widths: widths
            }
        },

        _calcRowDim: function (widths, body, root) {

            var procMap = this.procMap = {}; // store node & parent
            var cateMap = this.cateMap = {}; // for row

            var height = 0, num = 0;

            traverse(root, 'categories',
            function (node, depth, len, i, parent) {
                if (!depth) { return }
                var col = depth - 1;
                var dim = getTextDimension(node.name, body[col].style, false);
                widths[col] = Max(widths[col], dim.width);

                var c = node.categories;
                if (!(c && c.length > 1)) {
                    // check node has 1/no child's height (:= 1 line height)
                    height = Max(height, dim.height * LINE_HEIGHT);
                    cateMap[node.processesId] = num;
                }

                if (!(c && c.length)) { // leaf
                    ++num;
                }

                procMap[node.processesId] = {
                    options: node,
                    parent: procMap[parent.processesId]
                }
            });

            widths = widths.map(function (w) {
                return w + PADDING * 2
            });

            this.tightWidths = widths.slice();

            return {
                num: num,
                height: height,
                widths: widths
            }
        },

        _getCateRoot: function () {
            return this.options;
        },

        // move view to xxxView
        render: function () {

            if (!Object.keys(this.procMap).length) {
                return
            }

            if (!this.view) {
                this.view = new ProcessesView(this, this.vanchart);
            }

            this.view.render();

        }
    });

    ComponentLibrary.register(ComponentLibrary.PROCESSES, Processes);

    return Processes;
});

/**
 * Created by Yuqian on 2017/2/3.
 */

define('chart/gantt/TimeAxisView',['require','./TableView','../../utils/BaseUtils','./levelDomain','../../dateUnits/dateUnits','./helper','./defaultValues'],function (require) {
    var TableView = require('./TableView');
    var BaseUtils = require('../../utils/BaseUtils');

    var levelDomain = require('./levelDomain');
    var dateUnits = require('../../dateUnits/dateUnits');

    var helper = require('./helper');
    var LineV = helper.lineV;
    var LineH = helper.lineH;
    var Rect = helper.rect;
    var sum = helper.sum;
    var DEFAULT = require('./defaultValues');

    var OUTLINE = DEFAULT.OUTLINE,
        INNERLINE = DEFAULT.INNERLINE,
        TWEENLINE = DEFAULT.TWEENLINE,

        getTextDimension = BaseUtils.getTextDimension,
        bindData = BaseUtils.bindData;

    function findIndex (array, fn) {
        var i = -1, len = array.length;
        while (++i < len) {
            if (fn(array[i])) {
                return i
            }
        }
    }

    return TableView.extend({

        className: 'timeaxisGroup',

        initialize: function () {
            TableView.prototype.initialize.apply(this, arguments);

            var vanchart = this.vanchart;
            this.on('innerChange', function (v) {
                vanchart.fire('moveSeriesTextDivGroup', v);
            });
            this.on('resize', function () {
                vanchart.fire('updateSeriesTextDivGroup');
            })
        },

        update: function () {
            var renderer = this.renderer, bounds = this.model.bounds;
            this._getGroup().attr('transform', BaseUtils.makeTranslate(bounds));
            renderer.updateClip(this.clip, {width: bounds.width, height: bounds.height});
            this._header();
            this._body();
            this._outline();
        },

        updateContent: function () {
            this._header();
            this._body();
            this.leftUp = null;
            this._fireResize();
        },

        _setInnerPos: function (pos) {

            pos = TableView.prototype._setInnerPos.call(this, pos);

            // so, bad, smell...
            var headerData = this.model._headerData;
            if (!this.leftUp) {
                var l = this.l.bind(null, -this.innerPosX);
                var r = this.r.bind(null, -this.innerPosX + this.model.bounds.width);
                this.leftUp = {
                    i: findIndex(headerData.upTexts, l),
                    data: headerData.upTexts
                };
                this.leftSub = {
                    i: findIndex(headerData.subTexts, l),
                    data: headerData.subTexts
                };
                this.rightUp = {
                    i: findIndex(headerData.upTexts, r),
                    data: headerData.upTexts
                };
                this.rightSub = {
                    i: findIndex(headerData.subTexts, r),
                    data: headerData.subTexts
                };
            }
            this._checkTextBounds('left', this.leftUp);
            this._checkTextBounds('left', this.leftSub);
            this._checkTextBounds('right', this.rightUp);
            this._checkTextBounds('right', this.rightSub);

            return pos;
        },

        l: function (px, d) {
            return px >= d.left
        },

        r: function (px, d) {
            return px <= d.right
        },

        _checkTextBounds: function (side, t) {
            t.i = t.i || 0;
            t.i = Math.min(t.i, t.data.length - 1);
            var d = t.data[t.i]; // text data
            var px, left, right;
            var leftBound = -this.innerPosX;
            var rightBound = -this.innerPosX + this.model.bounds.width;
            if (side === 'left') {
                px = leftBound;
                left = px;
                right = Math.min(d.right, rightBound);
            } else {
                px = rightBound;
                left = Math.max(d.left, leftBound);
                right = px;
            }
            var l = this.l(px, d);
            var r = this.r(px, d);
            if (l && r) {
                // adjust label pos
                if (!d.width) { // text width
                    d.width = getTextDimension(d.content, d.style).width;
                }
                if (right - left >= d.width) {
                    // cell wider than text
                    d.ele.attr('x', (left + right) / 2).vMiddle();
                } else {
                    // hide this text
                    d.ele.attr('x', -100);
                }
            } else {
                d.ele.attr('x', d.x).vMiddle(); // recover
                if (!l) { // adjust last text
                    --t.i;
                } else if (!r) { // adjust next text
                    ++t.i;
                }
            }
        },

        _header: function () {
            var R = this.renderer, group = this._getGroup();

            var model = this.model;
            var tWidth = model.bounds.width;
            var heights = model.tableDims.heights;
            var height = sum(heights);

            var header = model._getHeader();

            if (!this._headerEles) {
                this._headerEles = {
                    upLines: [],
                    upTexts: [],
                    subLines: [],
                    subTexts: []
                };
                this._headerEles.gs = [];
            }

            var gs = this._headerEles.gs, _p = -1;
            var eles = this._headerEles;
            var data = this.model._headerData;

            // add the background on the parent group
            // so, unrelated with innerWidth
            gs[++_p] = Rect(R, group,
                {fill: this._getOptionsColor(header[0])},
                0, 0, tWidth, heights[0],
                gs[_p]
            );

            gs[++_p] = Rect(R, group,
                {fill: this._getOptionsColor(header[1])},
                0, heights[0], tWidth, heights[1],
                gs[_p]
            );

            var lineAdj = TWEENLINE['stroke-width'] / 2;
            gs[++_p] = LineH(R, group, TWEENLINE, 0, tWidth, heights[0] - lineAdj, gs[_p]);
            gs[++_p] = LineH(R, group, TWEENLINE, 0, tWidth, height - lineAdj, gs[_p]);

            var G = this._getGroup('header') || this._addGroup('header', group);

            ['upLines', 'subLines'].map(function (type) {
                var selection = bindData(eles[type], data[type]);

                selection.exit.map(function (d) {
                    d.remove();
                });

                var enter = selection.enter.map(function (d) {
                    return G.append(R.line().datum(d).style(INNERLINE));
                });

                eles[type] = enter.concat(selection.update)
                    .map(function (ele) {
                        return ele.attr(ele.datum())
                    });
            });

            ['upTexts', 'subTexts'].map(function (type) {
                var selection = bindData(eles[type], data[type]);

                selection.exit.map(function (d) {
                    d.remove();
                });

                var enter = selection.enter.map(function (d) {
                    return G.append(R.text().datum(d).style(d.style));
                });

                eles[type] = enter.concat(selection.update)
                    .map(function (ele) {
                        var d = ele.datum();

                        d.ele = ele;

                        ele
                        .textContent(d.content)
                        .attr({
                            x: d.x,
                            y: d.y,
                            dy: '.35em',
                            'margin-top': '-0.5em'
                        }).vMiddle();
                        return ele
                    });
            });
        },

        _body: function () {

            if (!this._bodyEles) {
                this._prepareBody();
                this._shadow();
            }

            this._bodyData = {
                hLines: [],
                vLines: [],
                rects: [] // weekend bg
            };

            var eles = this._bodyEles, data = this._bodyData;

            var R = this.renderer;
            var G = this._getGroup('inner-body-back');

            var rowHeight = this.model.tableDims.rowHeight;
            var rowNum = this.model.tableDims.rowNum;
            var height = this.innerBodyHeight;

            // maybe need another back group
            data.rects = this.model._weekendsWidths;

            var selection = bindData(eles.rects, data.rects);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.rect().datum(d).style({fill: DEFAULT.WEEKEND_COLOR}));
            });

            eles.rects = enter.concat(selection.update)
                .map(function (ele) {
                    var d = ele.datum();
                    return ele.attr({
                        x: d.from,
                        y: 0,
                        width: d.to - d.from,
                        height: height
                    })
                });

            // vertical lines
            data.vLines = this.model._headerData.subLines;

            var selection = bindData(eles.vLines, data.vLines);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.line().datum(d).style(INNERLINE));
            });


            eles.vLines = enter.concat(selection.update)
                .map(function (ele) {
                    var d = ele.datum();
                    return ele.attr({
                        x1: d.x1,
                        y1: 0,
                        x2: d.x2,
                        y2: height
                    })
                });

            // horizontal lines
            var i = 0;
            while (++i <= rowNum) {
                data.hLines.push({
                    x1: 0,
                    y1: i * rowHeight,
                    x2: this._getInnerWidth(),
                    y2: i * rowHeight
                })
            }

            var selection = bindData(eles.hLines, data.hLines);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return G.append(R.line().datum(d).style(INNERLINE));
            });

            eles.hLines = enter.concat(selection.update)
                .map(function (ele) {
                    return ele.attr(ele.datum())
                });

        },

        _outline: function () {
            var R = this.renderer, G = this._getGroup();
            var bounds = this.model.bounds;

            var lineV = LineV.bind(null, R, G, OUTLINE);
            var lineAdj = OUTLINE['stroke-width'] / 2;

            if (!this._outlineEles) {
                var lineH = LineH.bind(null, R, G, OUTLINE);

                lineH(0, this.vanchart.bounds.width, lineAdj); // top
                lineH(0, this.vanchart.bounds.width, bounds.height - lineAdj); // bottom
            }

            // VML bug
            var right = bounds.width - lineAdj;
            if (!BaseUtils.isSupportSVG()) {
                right = Math.floor(right);
            }

            this._outlineEles = lineV(0, bounds.height, right, this._outlineEles); // right
        },

        _scrollbar: function () {
            this._buildScrollbar({
                scrollX: true,
                scrollY: true
            })
        },

        _shadow: function () {
            var attrs = {'x1': 0, 'y1': 0, 'x2': 1, 'y2': 0};

            var stops = [
                {'offset':   '0%', 'stop-color': 'rgb(62, 62, 62)', 'stop-opacity': '0.2'},
                {'offset':  '75%', 'stop-color': 'rgb(62, 62, 62)', 'stop-opacity': '0'}
            ];

            var gradient = this.renderer.colorGradient(attrs, stops);
            var url = "url(#" + BaseUtils.stamp(gradient) + ")";

            this._shadowRect = this._getGroup('body')
                .append(this.renderer.rect())
                .style('transition', 'opacity 0.2s')
                .attr({
                    x: 0,
                    y: 0,
                    width: 10,
                    height: this.model.bounds.height,
                    fill: url
                });

            this._showShadow(false);
        },

        _showShadow: function (d) {
            if (d !== this._shadowShowed) {
                this._shadowShowed = d;
                this._shadowRect.style('opacity', d ? '1' : '0');
            }
        },

        onresizeMove: function (ev) {
            var bounds = this.model.bounds;

            var delta = this._initPointX - ev.containerPoint.x;
            bounds.x = this._initX - delta;
            bounds.width = this._initWidth + delta || 0;

            TableView.prototype.onresizeMove.call(this);
        }

    });
});
/**
 * Created by Yuqian on 2017/2/6.
 */

define('chart/gantt/levelText',['require','../../locale/localeText'],function (require) {

    var localeText = require('../../locale/localeText');

    // wow, such work
    // so dirty...
    var keys = [
        // 0
        // 2017 | ____
        ['yyyy', 'N'],
        // 1
        // 2017 | 
        ['yyyy', 'N'],
        // 2
        // 2017 | 
        ['yyyy', 'QQQ'],
        // 3
        // 2017, | 01
        ['N[,]yyyy', 'MMM'],
        // 4
        // 2017, | 1
        ['QQQ[,]yyyy', 'MMM'],
        // 5
        // 2017, | 1
        ['QQQ[,]yyyy', 'MMM'],
        // 6
        // 20171 | 01
        ['MMM[,]yyyy', 'www'],
        // 7
        // 201712 | ...
        ['d[,]MMM[,]yyyy', 'eee'],
        // 8
        // 20171 | 1...30
        ['MMM[,]yyyy', 'd'],
        // 9
        // 1 | 1...30
        ['MMM', 'd'],
        // 10
        // 11 | 
        ['d[,]MMM', 'a'],
        // 11
        // 11 | 0~6
        ['d[,]MMM', 'I'],
        // 12
        // 11 | 1...24
        ['d[,]MMM', 'HHH']
    ];

    function getKeys () {
        return localeText.getTextMap()['ganttLevels'] || keys
    }

    function getUpText(date, level) {
        return date.format(getKeys()[level][0])
    }

    function getSubText(date, level) {
        return date.format(getKeys()[level][1])
    }

    return {
        getUpText: getUpText,
        getSubText: getSubText
    }


});
/**
 * Created by Yuqian on 2017/1/12.
 */

define('chart/gantt/TimeAxis',['require','./Table','../../utils/BaseUtils','../../ComponentLibrary','./TimeAxisView','./levelDomain','../../dateUnits/dateUnits','../../utils/Scale','./helper','./levelText','./levelText','./defaultValues'],function (require) {
    var Table = require('./Table');
    var BaseUtils = require('../../utils/BaseUtils');
    var ComponentLibrary = require('../../ComponentLibrary');
    var TimeAxisView = require('./TimeAxisView');
    var levelDomain = require('./levelDomain');
    var dateUnits = require('../../dateUnits/dateUnits');
    var Scale = require('../../utils/Scale');
    var helper = require('./helper');
    var sum = helper.sum;
    var distribValues = helper.distribValues;
    var getUpText = require('./levelText').getUpText;
    var getSubText = require('./levelText').getSubText;

    var _PADDING = require('./defaultValues').PADDING,
        PADDING = 0,
        LINE_HEIGHT = 3;

    var upUnit = levelDomain.upUnit,
        subUnit = levelDomain.subUnit,
        LEVEL_LEN = levelDomain.LEN,
        Ratio = levelDomain.Ratio;

    var getTextDimension = BaseUtils.getTextDimension,
        getTextHeight = BaseUtils.getTextHeight;
    var object2date = BaseUtils.object2date;
    var isEmpty = BaseUtils.isEmpty;
    var Max = Math.max;
    var Min = Math.min;

    function moveToNext (datetime, unit, ref, ratio, acc) {
        datetime.add(1, unit);
        var pos = (datetime - ref) * ratio;
        acc.push(pos);
        return pos;
    }

    var TimeAxis = Table.extend({

        _refresh: function () {
            PADDING = BaseUtils.paddingConvertWithScale(_PADDING);

            this.lastScale = this.scale;
            this.scale = Scale.linear();
        },

        doLayout: function () {

        },

        // get the outline dim
        getInitPanelDims: function () {
            this.tableDims = this._calcTableDims();
            return {
                headerHeight: sum(this.tableDims.heights)
                // , rowHeight: this.tableDims.rowHeight
            }
        },

        // tablesDims.heights are header heights
        setPanelDims: function (panelDims) {
            // set the real dim for render
            var headerHeight = panelDims.headerHeight;
            this.tableDims.headerHeight = headerHeight; // distribute to two
            this.tableDims.rowHeight = panelDims.rowHeight;
            this.tableDims.rowNum = panelDims.rowNum;

            var heightNow = sum(this.tableDims.heights);
            if (headerHeight > heightNow) {
                this.tableDims.heights =
                    distribValues(this.tableDims.heights, headerHeight);
            }

            this.bounds = {
                x: panelDims.x + panelDims.pWidth,
                y: panelDims.y,
                width: panelDims.tWidth,
                height: panelDims.height
            }
        },

        _calcTableDims: function () {

            var heights = this._getHeaderHeights();

            return {
                heights: heights
                // , rowHeight: 0 // according to P
            }
        },

        _getHeaderHeights: function () {
            return this._getHeader().map(function (h) {
                return getTextHeight(h.style) * LINE_HEIGHT;
            });
        },

        calcSeries: function (series, procMap, cateMap) {

            // get time range
            var min = Number.MAX_VALUE, max = 0;
            var domainMap = {};
            var idMap = {};
            var rowMap = {};
            var markArray = [];
            series.map(function (item) {

                item.points.map(function (p) {
                    var options = p.options;
                    var st = object2date(options.startTime),
                        ft = object2date(options.finishTime),
                        mt = object2date(options.markTime);

                    if (isNaN(st.getTime()) || isNaN(ft.getTime())) {
                        p.isNull = true;
                        return
                    }

                    var pid = p.options.processesId;

                    if (procMap[pid] != null) {

                        var rowNum = cateMap[pid];
                        rowMap[rowNum] = rowMap[rowNum] || [];
                        rowMap[rowNum].push(p);
                        p.rowNum = rowNum;

                        // wonder about where to deal default value
                        // debug first...
                        p.progress = helper.getValidProgress(options.progress);
                        options.tooltip.follow = true;

                        // problem: [A, B, C, D]; pId -> C
                        if (!p.processes) {
                            var id = pid, node = procMap[id];
                            p.processes = [node.options];
                            while (node = node.parent) {
                                p.processes.unshift(node.options);
                            }
                        }

                        if (!isEmpty(p.options.id)) {
                            idMap[options.id] = p;
                        }

                        var thisMap =
                            domainMap[pid] = domainMap[pid] ||
                                {min: Number.MAX_VALUE, max: 0};

                        if (mt && !isNaN(mt.getTime())) {
                            markArray.push(p);
                            thisMap.min = Min(thisMap.min, mt);
                            thisMap.max = Max(thisMap.max, mt);
                        }

                        thisMap.min = Min(thisMap.min, st, ft);
                        thisMap.max = Max(thisMap.max, st, ft);
                        min = Min(thisMap.min, min);
                        max = Max(thisMap.max, max);

                        p.startTime = dateUnits(st);
                        p.finishTime = dateUnits(ft);
                        p.markTime = dateUnits(mt);
                        p.duration = dateUnits.duration(ft - st);
                    }
                })
            });

            this.domainMap = domainMap; // seems useless _
            this.dateDomain = [min, max];
            this.idMap = idMap;
            this.rowMap = rowMap;
            this.markArray = markArray;

            if (min > max) {
                this.dateDomain = []
            }
        },

        render: function () {

            if (!this.dateDomain.length) {
                return
            }

            if (!this.view) {
                this.view = new TimeAxisView(this, this.vanchart);
                this.view.render();
                var m = this._calcFirstViewMovement();
                this.view.changeInner({x: m});
            } else {
                this.view.render();
            }
        },

        _calcFirstViewMovement: function () {
            var oFrom = dateUnits(this.dateDomain[0]);
            var su = subUnit(this.level);
            var barFrom = +oFrom.startOf(su);
            var from = +oFrom.add(-1, su);
            return this.scale(from) - this.scale(barFrom);
        },

        // level change
        renderContent: function () {
            if (!this.dateDomain.length) {
                return
            }
            this.view.updateContent();
        },

        calcScale: function () {
            if (!this.dateDomain.length) {
                return
            }

            var data = this._headerData = {
                upLines: [],
                upTexts: [],
                subLines: [],
                subTexts: []
            };

            var heights = this.tableDims.heights;
            var height = sum(heights);
            var header = this._getHeader();

            var dateDomain = this.dateDomain;
            var em = this._getEm();

            var level = this.getLevel();
            var ratio = Ratio(em, level);
            var shouldCheckWeekends = this.shouldShowWeekends();

            // prepare date stuff

            // get units
            var uu = upUnit(level),
                su = subUnit(level);

            // dateUnits Objects
            var oFrom = dateUnits(dateDomain[0]),
                oTo = dateUnits(dateDomain[1]);

            // round the date
            var sFrom = dateUnits(oFrom).startOf(su).add(-1, su),
                sTo = dateUnits(oTo).endOf(su).add(1, su);
            var uFrom = dateUnits(sFrom).startOf(uu); // according to sub

            // accumulators
            var upDatetime = dateUnits(uFrom);
            var subDatetime = dateUnits(sFrom);
            var upW = (upDatetime - sFrom) * ratio; // first cell
            var subW = (subDatetime - sFrom) * ratio; // first cell

            // step record
            var upWidths = [upW];
            var subWidths = [subW];

            var moveToNextUp = moveToNext.bind(null, upDatetime, uu, sFrom, ratio, upWidths);
            var moveToNextSub = moveToNext.bind(null, subDatetime, su, sFrom, ratio, subWidths);

            // store weekend background (width from, to)
            var ww = this._weekendsWidths = [];

            var timeRangeWidth = (sTo - sFrom) * ratio;
            this.scale.domain([sFrom, sTo]).range([0, timeRangeWidth]);

            // time range width < bounds.width
            this.innerWidth = Math.max(timeRangeWidth, this.bounds.width);

            while (subW < this.innerWidth) {

                checkWeekend();

                var content, pos;

                if (upDatetime <= subDatetime) { // should draw up

                    data.upLines.push({
                        x1: upW,
                        y1: 0,
                        x2: upW,
                        y2: heights[0]
                    });
                    data.subLines.push({
                        x1: subW,
                        y1: heights[0],
                        x2: subW,
                        y2: height
                    });

                    // text means left bound date, save it now
                    content = getUpText(upDatetime, level);

                    pos = moveToNextUp();

                    data.upTexts.push({
                        style: header[0].style,
                        left: upW, // left & right bounds for adjust
                        right: pos,
                        x: (pos + upW) / 2,
                        y: heights[0] / 2,
                        content: content
                    });

                    upW = pos;

                } else {
                    data.subLines.push({
                        x1: subW,
                        y1: heights[0],
                        x2: subW,
                        y2: height
                    });
                }

                content = getSubText(subDatetime, level);

                pos = moveToNextSub();

                data.subTexts.push({
                    style: header[1].style,
                    left: subW,
                    right: pos,
                    x: (pos + subW) / 2,
                    y: heights[0] + heights[1] / 2,
                    content: content
                });

                subW = pos;
            }

            checkWeekend(true); // to end up right bounds

            // helper
            function checkWeekend(isEnd) {
                if (!shouldCheckWeekends) {
                    return
                }
                var last = ww[ww.length - 1];
                if (subDatetime.isWeekend() && !isEnd) {
                    if (!last || last && last.finish) {
                        ww.push({
                            from: subW,
                            finish: false
                        });
                    }
                } else {
                    if (last && !last.finish) {
                        last.to = subW;
                        last.finish = true;
                    }
                }
            }
        },

        getLevel: function () {

            if (this.level == null) {
                if (this.dateDomain.length) {
                    // get from options
                    var isLegal = this.setLevel(this.options.zoomLevel);
                    // options' illegal
                    if (!isLegal) {
                        this.setLevel(this._guessLevel());
                    }
                    this.initLevel = this.level;
                } else {
                    return
                }
            }

            return this.level
        },

        setLevel: function (level) {
            if (level == null || level < 0 || level > LEVEL_LEN - 1) {
                return false
            } else {
                this.level = level;
                return true
            }
        },

        _guessLevel: function () {
            var dateDomain = this.dateDomain;
            var em = this._getEm();
            var width = this.bounds.width;

            var ratio = width / (dateDomain[1] - dateDomain[0]);

            var l = LEVEL_LEN;
            while (--l > -1) {
                var r = Ratio(em, l);
                if (r < ratio) {
                    break;
                }
            }

            return Math.max(0, l);
        },

        // the problem here:
        // did not consider the up header width.
        // thus when the up exceed the sub...
        // adjust em. (do not seem as the true font em)
        // em = width / 6;
        _getEm: function () {
            var header = this._getHeader();

            var tmpDate = dateUnits();
            var upWidth = getTextDimension(getUpText(tmpDate, 0), header[0].style).width + 2 * PADDING;
            // seem sub as one char
            var subWidth = 6 * getTextDimension(getSubText(tmpDate, 0), header[1].style).width;

            var sub = subWidth / 6;
            if (upWidth > subWidth) {
                sub = upWidth / 6;
            }

            return sub
        },

        isZoomEnabled: function () {
            return this.options.zoom
        },

        shouldShowWeekends: function () {
            return this.level > 6 && this.options.showWeekends
        }

    });

    ComponentLibrary.register(ComponentLibrary.TIMEAXIS, TimeAxis);

    return TimeAxis;
});

/**
 * Created by Yuqian on 2017/3/8.
 */

define('chart/gantt/Link',['require','../../vans/VanChart','../../utils/PathGenerator','../../Constants'],function (require) {
var VanChart = require('../../vans/VanChart');
var PathGenerator = require('../../utils/PathGenerator');
var Constants = require('../../Constants');

var PathBefore = PathGenerator.line().interpolate('step-before');
var PathAfter = PathGenerator.line().interpolate('step-after');

var SAME_LINE_GAP = 2;
var ARROW_WIDTH = 3;

var TYPES = {};
TYPES.fs = TYPES.ff = TYPES.sf = TYPES.ss = true;

function calcLinks (cfg) {
    var options = cfg.links,
        idMap = cfg.idMap;
    return options
        .filter(function (link) {
            return link.type && TYPES[link.type.toLowerCase()]
                && link.lineWidth
                && idMap[link.from] && idMap[link.from].isVisible()
                && idMap[link.to] && idMap[link.to].isVisible()
        })
        .map(function (link) {
            return buildLink(link, cfg)
        }, this);
}

function buildLink (link, cfg) {

    var paths = getLinkPath(link, cfg);

    var lineAttr = {
        'd': paths.line
    };
    var lineStyle = {
        'fill': 'none',
        'stroke': link.lineColor,
        'stroke-width': link.lineWidth,
        'stroke-dasharray': Constants.DASH_TYPE[link.dashStyle || 'Solid']
    };

    var arrowAttr = {
        'd': paths.arrow
    };
    var arrowStyle = {
        'fill': link.lineColor,
        'stroke': 'none'
    };

    return {
        lineAttr: lineAttr,
        lineStyle: lineStyle,
        arrowAttr: arrowAttr,
        arrowStyle: arrowStyle
    }
}

function getLinkPath (link, cfg) {
    var idMap = cfg.idMap;
    var type = link.type.toLowerCase();
    var from = getLinePoint(type, 0, idMap[link.from]);
    var to = getLinePoint(type, 1, idMap[link.to]);

    var begin = from[1]; // turn point of from
    var end = to[0]; // turn point of to
    var beginx = begin[0];
    var endx = end[0];

    var gen = PathBefore;
    var mp = [null, (begin[1] + end[1]) / 2]; // middle point to adjust line

    if (begin[1] === end[1]) { // same line
        var rowNum = idMap[link.from].rowNum;
        var barFrom = idMap[link.from];
        var barTo = idMap[link.to];
        var fromLeft = barFrom.rect.x;
        var fromRight = barFrom.rect.x + barFrom.rect.width;
        var toLeft = barTo.rect.x;
        var toRight = barTo.rect.x + barTo.rect.width;

        // same line no turn:
        //    1. fs/sf, f < s
        // && 2. no bar is between from,to

        var condition1 = (type === 'fs' && fromRight < toLeft) || (type === 'sf' && toRight < fromLeft);

        function noBetween() {
            var left = Math.min(fromRight, toRight);
            var right = Math.max(fromLeft, toLeft);
            return cfg.rowMap[rowNum].every(function (bar) {
                if (bar === barFrom || bar === barTo) {
                    return true
                }
                var minx = Math.max(left, bar.rect.x);
                var maxx = Math.min(right, bar.rect.x + bar.rect.width);
                return minx > maxx
            });
        }

        if (condition1 && noBetween()) {
            to = [from[0], to[1]];
            from = [];
        } else {
            mp = [begin[0], begin[1] - idMap[link.from].rect.height / 2 - SAME_LINE_GAP];
        }
        gen = PathAfter;
    } else {
        switch (type) {
            case 'fs':
                if (beginx > endx) {
                    mp[0] = endx;
                }
                break;
            case 'ff':
                if (beginx < endx) {
                    gen = PathAfter;
                }
                break;
            case 'ss':
                if (beginx > endx) {
                    gen = PathAfter;
                }
                break;
            case 'sf':
            default:
                if (beginx < endx) {
                    mp[0] = endx
                }
        }
    }

    var points = from;
    if (mp[0] != null) {
        points.push(mp);
    }
    points = points.concat(to);

    return {
        line: gen(points),
        arrow: genArrowPath(to[1], type.charAt(1))
    }
}

// i = 0/1
function getLinePoint (type, i, p) {
    var cmd = type.charAt(i);
    var rect = p.rect;
    var y = rect.y + rect.height / 2;
    var a = Math.max(rect.height / 2, ARROW_WIDTH * 2);

    // point on the rect
    var onPoint = [
        cmd === 's' ? rect.x : rect.x + rect.width,
        y
    ];

    // point off the rect
    var offPoint = [
        onPoint[0] + (cmd === 's' ? -a : a),
        y
    ];

    var points;

    // if 0 (from), on -> off
    // if 1 (to), off -> on

    if (i) { // 1
        points = [offPoint, onPoint];
    } else {
        points = [onPoint, offPoint];
    }
    return points
}

// pos: vertex
// cms: f , s 
// Mx,yl3,3v-6z
// Mx,yl-3,3v-6z
function genArrowPath (pos, cmd) {
    var d = 'M' + pos[0] + ',' + pos[1] + 'l';
    var w = ARROW_WIDTH;
    if (cmd === 's') { // to right
        d += '-';
    }
    d += w + ',' + w + 'v-' + w * 2 + 'z';
    return d
}

VanChart.include({

    renderLinks: function () {
        this._linksGroup && this._linksGroup.remove();
        this._linksGroup = this._links = null;

        var links = this.options.plotOptions.links;
        if (!links || !links.length) { return }

        if (!this._linksGroup) {
            this._linksGroup = this.renderer.group().addTo(this.clipSeriesGroup);
        }
        if (!this._links) {

            var T = this.getTimeAxis();

            this._links = calcLinks({
                links: links,
                idMap: T.idMap,
                rowMap: T.rowMap
            });
            var g = this._linksGroup, R = this.renderer;

            this._links.map(function (link) {
                link._line = g.append(R.path()
                    .attr(link.lineAttr)
                    .style(link.lineStyle)
                );
                link._arrow = g.append(R.path()
                    .attr(link.arrowAttr)
                    .style(link.arrowStyle)
                )
            });
        }
    }
});
});
/**
 * Created by Yuqian on 2017/3/9.
 */

define('chart/gantt/Mark',['require','../../vans/VanChart','../../utils/PathGenerator','../../Constants','../../utils/BaseUtils'],function (require) {
    var VanChart = require('../../vans/VanChart');
    var PathGenerator = require('../../utils/PathGenerator');
    var Constants = require('../../Constants');
    var BaseUtils = require('../../utils/BaseUtils');
    var getMarkerPath = PathGenerator.getMarkerPath;
    var makeTranslate = BaseUtils.makeTranslate;

    function drawMark (R, pos, size, type, color) {
        var g = R.group().attr('transform', makeTranslate(pos));

        if(BaseUtils.isImageMarker(type)) {
            var w = size, h = size;
            g.image = R.image({
                'preserveAspectRatio': 'none', 'x': -w / 2, 'y': -h / 2, 'width': w, 'height': h
            });
            g.image.imageContent(type);
            g.append(g.image);

        } else {
            var d = getMarkerPath(type, size / 2);
            g.append(R.path()
                .attr('d', d)
                .style({
                    stroke: 'none',
                    fill: color
                })
            );
        }

        return g
    }

    VanChart.include({
        renderMarks: function () {
            this._marksGroup && this._marksGroup.remove();
            this._marksGroup = this._marks = null;
            if (!this._marksGroup) {
                this._marksGroup = this.renderer.group().addTo(this.clipSeriesGroup);
            }
            if (!this._marks) {
                var timeAxis = this.getTimeAxis();
                var markArray = timeAxis.markArray;
                var scale = timeAxis.scale;
                var g = this._marksGroup, R = this.renderer;

                markArray.map(function (p) {
                    if (!(p.visible && p.series.visible)) { return }
                    var height = p.rect.height;
                    var x = scale(p.markTime);
                    var y = p.rect.y + 0.5 * height;
                    g.append(
                        drawMark(R, [x, y], height, p.options.markType, p.options.markColor)
                    );
                });
            }
        }
    });
});

/**
 * Created by Yuqian on 2017/3/1.
 */

define('dateUnits/locale/zh-cn',[],function () {
    return {

        _locale: 'zh-cn',

        // duration[units] can be a function
        // duration.year = function(duration) { return 'string' }
        duration: {
            year: '',
            month: '',
            day: '',
            hour: '',
            minute: '',
            second: ''
        },

        halfYears: ['', ''],
        quarters: '___'.split('_'),
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem: ['', ''],
        qDay: '0~6_6~12_12~18_18~24'.split('_'),

        base: function (add, names) {
            // format according to
            // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
            //
            // custom:
            // half year = N
            // 1/4 day = I

            // week of year
            add('www', 0, 0, function () {
                return this.week() + '';
            });
        }
    }
});

/**
 * Created by Yuqian on 2017/6/7.
 */

define('dateUnits/locale/ja-jp',[],function () {
    return {

        _locale: 'ja-jp',

        // duration[units] can be a function
        // duration.year = function(duration) { return 'string' }
        duration: {
            year: '',
            month: '',
            day: '',
            hour: '',
            minute: '',
            second: ''
        },

        halfYears: ['', ''],
        quarters: '1_2_3_4'.split('_'),
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem: ['', ''],
        qDay: '0~6_6~12_12~18_18~24'.split('_'),

        base: function (add, names) {
            // format according to
            // http://www.unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times
            //
            // custom:
            // half year = N
            // 1/4 day = I

            // week of year
            add('www', 0, 0, function () {
                return '' + this.week() + '';
            });
        }
    }
});

/**
 * Created by Yuqian on 2017/6/7.
 */

define('locale/ja-jp',['require'],function (require) {
    return {

        _locale: 'ja-jp',

        'startTime': '',
        'finishTime': '',
        'duration': '',
        'progress': '',

        ganttLevels: [
            // 0
            ['yyyy[]', 'N'],
            // 1
            ['yyyy[]', 'N'],
            // 2
            ['yyyy[]', 'QQQ'],
            // 3
            ['yyyy[]N', 'MMM'],
            // 4
            ['yyyy[]QQQ', 'MMM'],
            // 5
            ['yyyy[]QQQ', 'MMM'],
            // 6
            ['yyyy[]MM[]', 'www'],
            // 7
            ['yyyy[]MM[]dd[]', 'eeeeee'],
            // 8
            ['yyyy[]MM[]', 'd'],
            // 9
            ['MMM', 'd'],
            // 10
            ['MM[]dd[]', 'a'],
            // 11
            ['MM[]dd[]', 'I'],
            // 12
            ['MM[]dd[]', 'H']
        ]
    }
});

/**
 * Created by Yuqian on 2017/1/11.
 */

define('chart/gantt/Gantt',['require','../../Constants','../../vans/VanChart','../../vans/VanChartLayout','../../ComponentLibrary','../../utils/BaseUtils','../../locale/localeText','../../dateUnits/dateUnits','./GanttSeries','./LevelBar','./Processes','./TimeAxis','./Link','./Mark','../../dateUnits/locale/zh-cn','../../dateUnits/locale/ja-jp','../../locale/ja-jp','../../vans/VanChartLibrary'],function (require) {

    var Constants = require('../../Constants');
    var VanChart = require('../../vans/VanChart');
    var VanChartLayout = require('../../vans/VanChartLayout');
    var ComponentLibrary = require('../../ComponentLibrary');
    var BaseUtils = require('../../utils/BaseUtils');
    var localeText = require('../../locale/localeText');
    var dateUnits = require('../../dateUnits/dateUnits');

    // require for build
    require('./GanttSeries');
    require('./LevelBar');
    require('./Processes');
    require('./TimeAxis');
    require('./Link');
    require('./Mark');

    require('../../dateUnits/locale/zh-cn');

    require('../../dateUnits/locale/ja-jp');
    require('../../locale/ja-jp');

    var PROCESSES = ComponentLibrary.PROCESSES;
    var TIMEAXIS = ComponentLibrary.TIMEAXIS;
    var LEVELBAR = ComponentLibrary.LEVELBAR;

    var Max = Math.max;

    var RESZIE_TOLERANCE = 10;

    var Gantt =  VanChart.extend({
        vanChartType: Constants.GANTT_CHART,

        initialize: function (option) {

            var lan = localeText.normalizeLocale(option.language);
            if (lan && !/^en/.test(lan)) { // default
                var dateLocale = require('../../dateUnits/locale/' + lan);
                dateUnits.setLocale(dateLocale);
            }

            VanChart.prototype.initialize.apply(this, arguments);
            this.handler && this.handler.on('resizeEnd', this.onResizeEnd, this);

            // _
            this.on('moveSeriesTextDivGroup', this.moveSeriesTextDivGroup);
            this.on('updateSeriesTextDivGroup', this.updateSeriesTextDivGroup)
        },

        refresh: function (options) {
            // @CmenCHART-1130:initialize
            if(!this.width || !this.height) { return; }

            if (this.getTimeAxis()) {
                this.remove();
                var vanchart = this;
                vanchart.panBounds = vanchart.backGroup = vanchart.processesGroup
                    = vanchart.timeaxisGroup = vanchart.frontGroup
                    = vanchart.seriesTextDivGroupWrapper = null;
                ComponentLibrary.ComponentsOrder.map(function (c) {
                    if (c in vanchart.components) {
                        vanchart.components[c].remove();
                        vanchart.components[c] = null;
                    }
                });
                vanchart.components = {};
                var oldFullScreenChart = this.fullScreenChart;

                this.initialize(options, this.wrapDom, this.vancharts);   // fullScreenChartnull

                if(oldFullScreenChart){
                    this.fullScreenChart = oldFullScreenChart;
                    this.fullScreenChart.setData(this.options);
                }
            } else {
                VanChart.prototype.refresh.call(this, options);
            }
        },

        resize: function () {
            this._sizeChanged = true;
            this.refresh(this.options);
        },

        layoutComponentsAndCharts: function () {
            var vanchart = this;
            vanchart.bounds = vanchart._getDefaultBounds();
            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in vanchart.components) {
                    vanchart.components[c].doLayout();
                }
            });

            var P = this.getProcesses();
            var T = this.getTimeAxis();

            if (!this.panBounds) {
                var panelDims = this._calcDims(P, T);
                this.panBounds = this._calcPanBounds(panelDims);

                // re-calc after resize
                this.resizeBounds = this._calcResizeBounds(panelDims);

                P.setPanelDims(panelDims);
                T.setPanelDims(panelDims);
            }

            // todo calcSeries -> vcLayout.calcS...
            T.calcSeries(this.series, P.procMap, P.cateMap);
            T.calcScale();

            VanChartLayout.calculateSeries(this); // calculateLabelInfo
            VanChartLayout.calculateSeriesShapes(this);

            this.render();
        },

        render:function(){

            this.vancharts.endLoading();

            var vanchart = this, renderer = this.renderer;

            // 
            if (this._isEmptyDataChart()) {
                this._showEmptyDataTip();
                window.console && console.log('done');
                return;
            } else {
                this.emptyDataGroup && this.emptyDataGroup.remove();
            }

            // var clipBounds = this.getPlotClipBounds();
            // if(!this.plotClip){
            //     this.plotClip = renderer.createClip(clipBounds);
            // }else{
            //     renderer.updateClip(this.plotClip, clipBounds);
            // }

            // gantt
            // series' inside timeAxis [inner-body] group
            // so...

            ['backGroup', 'processesGroup', 'timeaxisGroup' ,'frontGroup']
                .forEach(function (groupName) {
                    if (!vanchart[groupName]) {
                        var g = vanchart[groupName] = renderer.group().addClass(groupName).add();

                        // so ugly
                        if (groupName === 'processesGroup'
                            || groupName === 'timeaxisGroup') {
                            var name = groupName + '-body';
                            g = vanchart[name] = g.append(renderer.group().addClass(name));
                            name = groupName + '-inner-body';
                            vanchart[name] = g.append(renderer.group().addClass(name));
                        }
                    }
                });

            var mainGroup = vanchart['timeaxisGroup-inner-body'];

            ['clipSeriesGroup', 'seriesGroup', 'seriesTextRenderGroup']
                .forEach(function (groupName) {
                    if (!vanchart[groupName]) {
                        vanchart[groupName] = mainGroup.append(
                            renderer.group().addClass(groupName)
                        );
                    }
                });

            this._addSeriesTextDivGroup();

            this._renderBackground();

            this.renderSeries();

            // series related
            this.renderLinks();
            this.renderMarks();

            this.renderComponents();

            // layout levelbar before P&T,
            // but render it last
            var levelBar = this.getComponent(LEVELBAR);
            if (levelBar) {
                levelBar.setLevel(this.getTimeAxis().getLevel());
            }

            this._consoleDone();

        },

        // no clip, but overflow: hidden
        _addSeriesTextDivGroup: function () {
            var vanchart = this;
            if (!vanchart.seriesTextDivGroupWrapper) {
                vanchart.seriesTextDivGroupWrapper = this.renderer.div().add();
                vanchart.seriesTextDivGroup = this.renderer.div();
                vanchart.seriesTextDivGroupWrapper.append(vanchart.seriesTextDivGroup);
            }
            this.updateSeriesTextDivGroup();
        },

        updateSeriesTextDivGroup: function () {
            // contract div to TimeAxis's inner
            var T = this.getTimeAxis();
            var clipBounds = {
                x: T.bounds.x,
                y: T.bounds.y + T.tableDims.headerHeight,
                width: T.bounds.width,
                height: T.bounds.height - T.tableDims.headerHeight
            };

            // CHART-1353
            // divIE8 event
            this.seriesTextDivGroupWrapper.style({
                left: clipBounds.x + 'px',
                top: clipBounds.y + 'px',
                // clip: rect(<top>, <right>, <bottom>, <left>);
                clip: 'rect(' + [
                    0,
                    clipBounds.width,
                    clipBounds.height,
                    0
                ].join('px ') + 'px)'
            });
        },

        moveSeriesTextDivGroup: function (pos) {
            this.seriesTextDivGroup.style('transform', 'translate(' + pos.x + 'px,' + pos.y + 'px)');
        },

        changeToLevel: function (level) {
            var timeAxis = this.getTimeAxis();
            var levelNow = timeAxis.getLevel();

            if (level === levelNow) {
                return
            }

            timeAxis.setLevel(level);

            timeAxis.calcScale();

            timeAxis.renderContent();
            this.reRenderWholePlot();
        },

        reRenderWholePlot: function () {
            VanChartLayout.calculateSeriesShapes(this);

            this.renderSeries();
            this.renderLinks();
            this.renderMarks();
            this.getComponent(ComponentLibrary.LEGEND_COMPONENT).render();
        },

        _calcDims: function (P, T) {
            var bounds = this.bounds;
            var wholeWidth = bounds.width;

            var pDim = P.getInitPanelDims();
            var pWidth = pDim.width;
            var headerHeight = pDim.headerHeight;

            var tDim = T.getInitPanelDims();
            var tWidth = wholeWidth - pWidth;
            headerHeight = Max(headerHeight, tDim.headerHeight);

            var calcHeight = pDim.rowHeight * pDim.rowNum;
            var bodyViewHeight = bounds.height - headerHeight;

            var rowNum = pDim.rowNum;
            if (calcHeight < bodyViewHeight && pDim.rowHeight > 0) {
                rowNum = Math.floor(bodyViewHeight / pDim.rowHeight);
            }

            return {
                x: bounds.x,
                y: bounds.y,
                pWidth: pWidth, // visible width
                tWidth: tWidth,
                height: bounds.height,
                headerHeight: headerHeight,
                rowHeight: pDim.rowHeight,
                rowNum: rowNum
            };
        },

        getProcesses: function () {
            return this.getComponent(PROCESSES)
        },

        getTimeAxis: function () {
            return this.getComponent(TIMEAXIS)
        },

        isResizeEnabled: function () {
            return this.getComponent(PROCESSES).options.resize;
        },

        // bounds to determine wheel/scroll
        _calcPanBounds: function (dims) {
            return {
                x: dims.x,
                y: dims.y,
                width: dims.pWidth + dims.tWidth,
                height: dims.height
            }
        },

        _calcResizeBounds: function (dims) {
            return {
                x: dims.x + dims.pWidth - RESZIE_TOLERANCE / 2,
                y: dims.y,
                width: RESZIE_TOLERANCE,
                height: dims.height
            }
        },

        onResizeEnd: function () {
            this.resizeBounds.x = this.getTimeAxis().bounds.x - RESZIE_TOLERANCE / 2;
        },

        onScrollY: function (data) {
            this.fire('moveY', data);
        }

    });

    require('../../vans/VanChartLibrary').register(Constants.GANTT_CHART, Gantt);

    return Gantt;
});
/**
 * Created by Mitisky on 16/7/28.
 */
define('utils/LoadingUtils',[],function(){
    var loadingMap = {};

    function startLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';
        if(loadingMap[id] || document.getElementById(id)){
            return;
        }

        var background_div = document.createElement('div');
        var inner_div = document.createElement('div');

        background_div.id = id;
        background_div.style.backgroundColor = 'white';
        background_div.style.opacity = 0.75;
        background_div.style.filter = 'alpha(opacity=75)';
        background_div.style.position = 'absolute';
        background_div.style.width = '100%';
        background_div.style.height = '100%';
        background_div.style.left = 0;
        background_div.style.top = 0;
        background_div.style.zIndex = 9999;

        if(inner_div.style.animation != undefined || inner_div.style.webkitAnimation != undefined) {
            inner_div.style.left = '50%';
            inner_div.style.top = '50%';
            inner_div.className = 'loader-inner ball-scale-ripple-multiple';
            inner_div.innerHTML = '<div></div><div></div><div></div>';
        }

        background_div.appendChild(inner_div);
        dom.appendChild(background_div);
        loadingMap[id] = background_div;
    }

    function endLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';

        if(loadingMap[id]) {
            dom.removeChild(loadingMap[id]);
            loadingMap[id] = null;
        } else {
            var loadingDiv = document.getElementById(id);
            if(loadingDiv) {
                dom.removeChild(loadingDiv);
            }
        }
    }

    return {
        startLoading:startLoading,
        endLoading:endLoading
    };
});

/**
 * Created by eason on 15/7/3.
 * reused and modified tooltip component from echarts
 */
//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('component/Tooltip',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary','./FormattedText'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var FormattedText = require('./FormattedText');

    var DEFAULT_DURATION = 0.4;

    var Tooltip = Base.extend({

        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:2000;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;pointer-events:none;',

        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.animation && !opt.follow) {
                var transitionText = 'left ' + DEFAULT_DURATION + 's,'
                    + 'top ' + DEFAULT_DURATION + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if(opt.style){
                var fontStyle = BaseUtils.cssNormalization(opt.style);

                for(var styleName in fontStyle){
                    if(styleName == 'color'){
                        cssText.push(styleName + ':' + ColorUtils.colorToHex(fontStyle[styleName]));
                    }else{
                        cssText.push(styleName + ':' + fontStyle[styleName]);
                    }
                }
            }

            if (opt.backgroundColor) {
                if(typeof opt.backgroundColor == 'string'){
                    if(BaseUtils.isSupportSVG()){
                        cssText.push('background-Color:' + opt.backgroundColor);
                    }else{
                        var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                        // ms: #alpha+hex
                        var msColor = '#' + ('0' + (hexAlpha.alpha * 255 | 0).toString(16)).slice(-2) + hexAlpha.hex.replace('#', '');
                        cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=' + msColor + ', endColorstr=' + msColor + ', GradientType=0)');
                    }
                }else if(typeof opt.backgroundColor == 'object'){

                    var color = opt.backgroundColor;
                    var startColor = ColorUtils.colorToHex(color.startColor);
                    var endColor = ColorUtils.colorToHex(color.endColor);

                    var start = 'left';

                    var startPos = 'left top';
                    var endPos = 'right top';
                    var type = 1;

                    if(color.x1 == color.x2){
                        start = 'top';

                        startPos = 'left top';
                        endPos = 'left bottom';

                        type = 0;
                    }

                    cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                    cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
                }
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            if(opt.shadow){
                cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
            }

            var padding = opt.padding;
            if (padding != null && padding != undefined) {
                padding = BaseUtils.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                    + padding[1] + 'px '
                    + padding[2] + 'px '
                    + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },

        doLayout:function(dom){
            if(!this._tDom){
                dom = dom || this.vanchart.getDivParentDom();

                this._tDom = document.createElement('div');

                this._hiddenDom = document.createElement('div');

                this._tDom.onselectstart = function() {
                    return false;
                };

                this._tDom.style.position = 'absolute';

                this._hiddenDom.style.visibility = 'hidden';

                dom.appendChild(this._tDom);

                dom.appendChild(this._hiddenDom);

                this._tooltipHideTick = null;
            }
        },

        remove:function(){
            if(this._tDom){
                var dom = this.vanchart.getDivParentDom();
                dom.removeChild(this._tDom);
                dom.removeChild(this._hiddenDom);
            }
        },
        /**
         * toolbarIcon
         * @param  {Obejct} icon mouseovertoolbarIcon
         * @param  {String} text 
         */
        showWithToolbarIcon:function (icon, text) {
            var toolbar = icon.toolbar, opt = toolbar.options.tooltip;
            var tooltipDim  = this.calculateTooltipDivDim(opt, text);
            var pos = icon.toolbar.calcToolbarTipPos(icon, tooltipDim);
            this._show(pos, opt, text);
        },

        showWithPoint:function(point, event, formatPoint){
            if(point && point.options.tooltip && point.series.vanchart.renderer){
                var fmtPoint = formatPoint || point,
                    opt = fmtPoint.options.tooltip, // use formatPoint's style
                    seriesChart = point.series;
                var tooltipText = FormattedText.tooltipGenerator(fmtPoint);
                var tooltipDim  = this.calculateTooltipDivDim(opt, tooltipText);
                //
                var pos = seriesChart.getTooltipPos(point, tooltipDim, event);

                if(pos){
                    this._show(pos, opt, tooltipText);
                    //for bi
                    this._tooltipRect = BaseUtils.makeBounds(pos, tooltipDim);
                }

            }
        },

        // replace '-' with '&#150;' in ie 10, 11, edge;
        // innerHTML '-' will lead to repaint
        _getTooltipText: (function () {
            // todo
            // browser detail version function
            // ie 10, 11, edge
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf('MSIE ');
            if (ua.indexOf('Trident/7.0') > 0 ||
                ua.indexOf('Edge/') > 0 ||
                msie > 0 && parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10) === 10
            ) {
                return function (text) {
                    text += '';
                    var replaced = '';
                    var isContent = true;
                    var i = -1;
                    var len = text.length;
                    var t;
                    while (++i < len) {
                        t = text.charAt(i);
                        if (isContent && t === '-') {
                            t = '&#150;';
                        } else if (t === '<') {
                            isContent = false;
                        } else if (t === '>') {
                            isContent = true
                        }
                        replaced += t;
                    }
                    return replaced;
                }
            } else {
                return function (text) {
                    return text;
                }
            }
        })(),

        _show:function(pos, opt, tooltipText){

            if(pos && opt && tooltipText && !this.vanchart.isMouseDown){
                clearTimeout(this._tooltipHideTick);

                this._tDom.innerHTML = this._getTooltipText(tooltipText);

                this._tDom.style.cssText = this._gCssText
                    + this._style(opt)
                    + 'left:' + pos[0] + 'px;top:' + pos[1] + 'px;';

            }
        },

        hide:function(){

            clearTimeout(this._tooltipHideTick);

            this._tooltipHideTick = setTimeout(function(){
                this._tDom.style.display = 'none';
            }.bind(this), 400);

        },

        immediateHide:function(){
            this._tDom.style.display = 'none';
        },

        calculateTooltipDivDim:function(opt, tooltipText){
            opt = opt || '';
            var testDiv = this._hiddenDom;
            testDiv.innerHTML = tooltipText;
            testDiv.style.cssText = this._gCssText + this._style(opt) + 'visibility:hidden;';
            var width = testDiv.offsetWidth;
            var height = testDiv.offsetHeight;
            return {
                width:width,
                height:height
            };
        },

        render:function(){
            //do nothing
        }

    });

    ComponentLibrary.register(ComponentLibrary.TOOLTIP_COMPONENT, Tooltip);
    return Tooltip;
});
/**
 * Created by Yuqian on 16/9/27.
 */
define('Carousel',['require','./utils/BaseUtils','./utils/QueryUtils','./dom/DomUtils','./utils/ColorUtils','./utils/PathUtils','./Constants','./utils/BezierEasing','./vector/SvgRenderer','./vector/VmlRenderer','./component/Tooltip'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var QueryUtils = require('./utils/QueryUtils');
    var DomUtils = require('./dom/DomUtils');
    var ColorUtils = require('./utils/ColorUtils');
    var PathUtils = require('./utils/PathUtils');
    var Constants = require('./Constants');
    var BezierEasing = require('./utils/BezierEasing');
    var SvgRenderer = require('./vector/SvgRenderer');
    var VmlRenderer = require('./vector/VmlRenderer');
    var Tooltip = require('./component/Tooltip');

    var SWITCH_BUTTON_HEIGHT_RATIO = 3.4375;

    var defaultOpt = {
        type: Constants.BUTTON,
        color: "#7f7f7f",
        interval: 1000,
        style: {
            "fontSize": '16px',
            "color": '#ffffff'
        }
    };

    // button 'text...' hint
    var TOOLTIP_STYLE = {
        borderWidth: 1,
        borderColor: '#000000',
        borderRadius: 2,
        backgroundColor: 'rgba(255, 255, 255, 0.5)',
        padding: 5,
        shadow: true,
        animation: true,
        style: {
            'fontSize': '12px',
            'fontFamily': 'MicrosoftYaHei, sans-serif',
            'color': '#515151'
        }
    };

    /*
     * first and last chart has a wrap inside 'vanchart-chart' dom.
     * move this wrap to the empty wrap, or move back,
     * to make an infinity loop

                 dom
                 menu(button)
                 menuButton                                      
                                                                 
                 
container
(in container)  chartDoms[0]                                     chartDoms[1]                
frontEmptyWrap  firstChartWrap[svg...](no wrap)           
{margin-left:-x}                                                                           
                 [svg, divLabelDom, calculateDom...]                                       
                                                                                           
                                                                                           
                                                                                           
                                                                                           
                                                                                           
                                            

                        menu(carousel)       
                                    o o o o o o                   
                               
                 

    */

    var CarouselFun = function (vanCharts) {
        var type = null,
            outerDom = null,
            menu = null,
            menuButtons = [],
            arrowWrapLeft = null,
            arrowWrapRight = null,
            container = null,
            frontEmptyWrap = null,
            lastChartWrap = null,
            rearEmptyWrap = null,
            firstChartWrap = null,
            chartDoms = [],
            onIndex = 0,
            optLength = 0,
            intervalID = null,
            animationID = null,
            fontSize = 0;

        var evented = {
            left: null,
            right: null,
            dom: null
        };

        var tooltip = new Tooltip({}, Constants.TOOLBAR_COMPONENT, {});

        var isCssAni = 'transition' in document.getElementsByTagName('body')[0].style;

        // IE7 in IE11
        var isIE7 = /MSIE 7/.test(navigator.userAgent);

        function refresh (option, i) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (btnDom.mText) {
                if (btnDom.mText.textContent) {
                    btnDom.mText.textContent = titleText;
                } else {
                    btnDom.mText.innerText = titleText;
                }
                checkBtnTextSpace(btnDom);
            }

            btnDom._title = titleText;

            return setupChart(option, vanCharts.charts[i], chartDoms[i], i);
        }

        /**
         * setup carousel container and button
         * return initialized or refreshed charts Array
         * @param {Object} [option]
         * @param {Array} [charts]
         * @param {Object} [dom]
         * @returns {Array} [charts]
         */
        function init (option, charts, dom) {

            if (!option || !option.switchStyle) {
                setInterval();
            }

            var options = option.options;
            var switchStyle = QueryUtils.merge(defaultOpt, option.switchStyle, true);

            if (!BaseUtils.isSupportSVG()) {
                if (switchStyle.style.color) {
                    switchStyle.style.color = ColorUtils.colorToHex(switchStyle.style.color);
                }
            }

            outerDom = dom;
            type = switchStyle.type;
            optLength = options.length;

            menu = menu || DomUtils.create('div', 'vanchart-menu', dom);
            container = container || DomUtils.create('div', 'vanchart-cc', dom);

            dom.style.overflow = 'hidden';

            tooltip.doLayout(dom);

            var color = switchStyle.color;

            charts.splice(optLength)
                .map(function (c) { c.remove(); });

            menuButtons.splice(optLength)
                .map(function (d) { DomUtils.remove(d); });

            chartDoms.splice(optLength)
                .map(function (d) { DomUtils.remove(d); });

            addClass(container, 'van-ani');

            onIndex = (onIndex >= optLength) ? 0 : onIndex;

            switch (type) {
                case Constants.CAROUSEL:
                    menu.style.bottom = 0;
                    menu.style.height = "18px";
                    menu.style.width = "100%";
                    menu.mWrap = menu.mWrap || DomUtils.create('div', 'vanchart-menu-wrap', menu);
                    container.style.cssText = "top:0;" +
                        "bottom: 18px;" +
                        "left:" + -onIndex * 100 + '%;' +
                        "width:" + optLength * 100 + "%";

                    // ie < 8 no resize
                    if (!BaseUtils.isSupportSVG()) {
                        container.style.height = outerDom.clientHeight - 18 + 'px';
                    }

                    arrowWrapLeft = arrowWrapLeft || DomUtils.create('div', 'vanchart-arrow-wrap', dom);
                    arrowWrapRight = arrowWrapRight || DomUtils.create('div', 'vanchart-arrow-wrap', dom);
                    arrowWrapRight.style.right = 0;
                    var left = arrowWrapLeft.arrowLeft = arrowWrapLeft.arrowLeft || DomUtils.create('div', 'vanchart-arrow vanchart-arrow-left', arrowWrapLeft);
                    var right = arrowWrapRight.arrowRight = arrowWrapRight.arrowRight || DomUtils.create('div', 'vanchart-arrow vanchart-arrow-right', arrowWrapRight);
                    setArrow(left, color);
                    setArrow(right, color);

                    var interval  = switchStyle.interval;

                    evented.left && evented.left.off('tap');
                    evented.left = evented.left || new VanHammer(left);
                    evented.left.on('tap', function (e) {
                        e.preventDefault();
                        setInterval(interval);
                        var index = (optLength + onIndex - 1) % optLength;
                        prepareCarouselDom(index, Constants.LEFT);
                        showIndex(index);
                    });

                    evented.right && evented.right.off('tap');
                    evented.right = evented.right || new VanHammer(right);
                    evented.right.on('tap', function (e) {
                        e.preventDefault();
                        setInterval(interval);
                        var index = (onIndex + 1) % optLength;
                        prepareCarouselDom(index, Constants.RIGHT);
                        showIndex(index);
                    });

                    evented.dom && evented.dom.off(dom, 'mouseover mouseout');
                    evented.dom = VanHammer
                        .on(dom, 'mouseover', function () {
                            setInterval();
                        })
                        .on(dom, 'mouseout', function () {
                            setInterval(interval);
                        });

                    setInterval(interval);

                    return carousel(options, charts);

                case Constants.BUTTON:
                default:
                    var startColor = gradualColor(color);
                    var cssText = 'width:100%;top:0;' +
                        'background-color:' + color + ';' +
                        'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=' +
                            startColor + ', endColorstr=' + ColorUtils.colorToHex(color) + ', GradientType=0);';

                    cssText += 'background-image: -webkit-gradient(linear, left top, left bottom, from(' + startColor + '), to(' + color + '));';
                    cssText += 'background-image: -moz-linear-gradient(top' + startColor +', '+ color +');';
                    cssText += 'background-image: -webkit-linear-gradient(top' + startColor +', '+ color +');';
                    cssText += 'background-image: linear-gradient(to bottom' + startColor +', '+ color +');';

                    menu.style.cssText = cssText;
                    setTextStyle(menu, switchStyle.style);

                    fontSize = BaseUtils.getTextHeight(switchStyle.style);
                    var btnH = fontSize * SWITCH_BUTTON_HEIGHT_RATIO;
                    container.style.cssText =
                        "left:" + -onIndex * 100 + '%;' +
                        "top:" + btnH + "px;" +
                        "bottom: 0;" +
                        "width:" + optLength * 100 + "%";

                    if (!BaseUtils.isSupportSVG()) {
                        container.style.height = outerDom.clientHeight - btnH + 'px';
                    }

                    return button(options, charts, switchStyle.style.color, hoverColor(color));
            }
        }

        function carousel(options, oldCharts) {
            // prepare two empty doms in front and end;
            // use these doms to imitate infinity loop.
            frontEmptyWrap = frontEmptyWrap || DomUtils.create('div', 'vanchart-chart', container);
            frontEmptyWrap.style.width = 100 / optLength + "%";
            frontEmptyWrap.style.marginLeft = -100 / optLength + "%";

            if (isIE7) {
                frontEmptyWrap.style.width = outerDom.clientWidth + 'px';
                frontEmptyWrap.style.marginLeft = -outerDom.clientWidth + 'px';
            }

            var cs = options.map(function (option, i) {
                setupCarouselDoms(option, i);
                return setupChart(option, oldCharts[i], chartDoms[i], i);
            });

            rearEmptyWrap = rearEmptyWrap || DomUtils.create('div', 'vanchart-chart', container);
            rearEmptyWrap.style.width = 100 / optLength + "%";
            rearEmptyWrap.style.marginRight = -100 / optLength + "%";

            if (isIE7) {
                rearEmptyWrap.style.width = outerDom.clientWidth + 'px';
                rearEmptyWrap.style.marginLeft = -outerDom.clientWidth + 'px';
            }

            return cs;
        }
        function setupCarouselDoms (option, i) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (!chartDoms[i]) {
                chartDoms[i] = DomUtils.create('div', 'vanchart-chart', container);
                menuButtons[i] = btnDom = DomUtils.create('div', 'vanchart-menu-dot', menu.mWrap);

                if (!BaseUtils.isSupportSVG()) {
                    btnDom.style.background = 'none';
                    var ieDom = DomUtils.create('div', 'vanchart-menu-dot-ie', btnDom);
                    setDot(ieDom);
                }

                if (!i) {
                    addClass(btnDom, 'van-on');
                }
            }

            btnDom._title = titleText;
            btnDom.i = i;

            VanHammer.on(btnDom, 'mouseover', function () {
                showCarouselTooltip(btnDom);
            });

            VanHammer.on(btnDom,'mouseout', function () {
                tooltip.immediateHide();
            });

            new VanHammer(btnDom)
                .on('tap',function (e) {
                    e.preventDefault();
                    prepareCarouselDom(i);
                    showIndex(i);
                });
        }

        function showCarouselTooltip(btnDom) {
            var tooltipDim = tooltip.calculateTooltipDivDim(TOOLTIP_STYLE, btnDom._title);
            var pos = [
                outerDom.clientWidth / 2 - (optLength - 1) / 2 * 16 + btnDom.i * 16 - tooltipDim.width / 2,
                outerDom.clientHeight - 18 - tooltipDim.height
            ];
            pos[0] = Math.min(Math.max(pos[0], 0), outerDom.clientWidth - tooltipDim.width);
            tooltip._show(pos, TOOLTIP_STYLE, btnDom._title);
        }

        function button(options, oldCharts, textColor, hoverColor) {
            return options.map(function (option, i) {
                setupButtonDoms(option, i, textColor, hoverColor);
                return setupChart(option, oldCharts[i], chartDoms[i], i);
            });
        }

        function setupButtonDoms (option, i, textColor, hoverColor) {
            var titleText = getTitleText(option);
            var btnDom = menuButtons[i];

            if (!chartDoms[i]) {
                chartDoms[i] = DomUtils.create('div', 'vanchart-chart', container);
                menuButtons[i] = btnDom = DomUtils.create('div', 'vanchart-menu-btn', menu);
                btnDom.mIcon = DomUtils.create('span', 'vanchart-menu-icon', btnDom);
                btnDom.mText = DomUtils.create('span', 'vanchart-menu-text', btnDom);

                if (!BaseUtils.isSupportSVG()) {
                    btnDom.insertAdjacentHTML('afterBegin','<span class="vanchart-menu-btn_before"></span>');
                }

                if (!i) {
                    btnDom.style.background = hoverColor;
                }
            }

            setIcon(btnDom.mIcon, option.chartType, textColor);
            btnDom.style.width = 100 / optLength + "%";

            if (!BaseUtils.isSupportSVG()) {
                var width = outerDom.clientWidth / optLength;
                if (isIE7) {
                    // IE11 quirks IE7 is ... different from IE7
                    width -= 2 * fontSize + 1;
                }

                btnDom.style.width = width + 'px';

                if (btnDom.offsetTop !== 0) {
                    btnDom.style.width = width - 1 + 'px';
                }
            }

            /**
             * CHART-1364
             * 
             * textContentinnerText
             * textContent
             * else
             * 
             */
            btnDom.mText.textContent = titleText;
            btnDom.mText.innerText = titleText;

            btnDom._title = titleText;
            btnDom.i = i;

            checkBtnTextSpace(btnDom);

            VanHammer.on(btnDom, 'mouseover', function () {
                btnDom.style.background = hoverColor;
                showButtonTooltip(btnDom);
            });

            VanHammer.on(btnDom, 'mouseout', function () {
                (onIndex !== i) && (btnDom.style.background = '');
                tooltip.immediateHide();
            });

            new VanHammer(btnDom)
                .on('tap', function (e) {
                    e.preventDefault();
                    menuButtons[onIndex].style.background = '';
                    menuButtons[i].style.background = hoverColor;
                    showIndex(i);
                });
        }

        function showButtonTooltip(btnDom) {
            var ellipsis = false;
            if (BaseUtils.isSupportSVG()) {
                ellipsis = btnDom.scrollWidth > btnDom.clientWidth;
            } else {
                ellipsis = btnDom.scrollWidth >= btnDom.clientWidth;
            }

            if (ellipsis || btnDom.mText.innerHTML === '') {
                var tooltipDim = tooltip.calculateTooltipDivDim(TOOLTIP_STYLE, btnDom._title);
                var pos = [
                    outerDom.clientWidth * (btnDom.i + 0.5) / optLength - tooltipDim.width / 2,
                    btnDom.offsetHeight
                ];

                pos[0] = Math.min(Math.max(pos[0], 0), outerDom.clientWidth - tooltipDim.width);

                tooltip._show(pos, TOOLTIP_STYLE, btnDom._title);
            }
        }

        function setupChart(option, oldChart, chartDom, i) {
            chartDom.style.width = 100 / optLength + "%";

            // CHART-1077
            //
            // if (!BaseUtils.isSupportSVG() || chartDom.offsetLeft < outerDom.clientWidth * i) {
            //     var det = outerDom.clientWidth * i - chartDom.offsetLeft;
            //     chartDom.style.width = outerDom.clientWidth + det + 'px';
            // }

            var c, targetDom = chartDom;

            if (i === optLength - 1) {
                if (!lastChartWrap) {
                    lastChartWrap = newWrap(chartDom);
                }
                targetDom = lastChartWrap;
            } else if (i === 0) {
                if (!firstChartWrap) {
                    firstChartWrap = newWrap(chartDom)
                }
                targetDom = firstChartWrap;
            }

            c = vanCharts._initSingle(option, oldChart, targetDom);
            if (i !== onIndex) {
                c.set({enable: false});
            }

            return c;
        }

        function newWrap(chartDom) {
            var wrapDom = DomUtils.create('div', 'vanchart-chart-wrap', chartDom);
            wrapDom.style.cssText = 'width:100%;height:100%';
            return wrapDom;
        }

        function prepareCarouselDom(index, direction) {
            var tmp;
            // last -> first
            if (direction === Constants.RIGHT &&
                onIndex === optLength - 1 && index === 0) {
                chartDoms[0].appendChild(firstChartWrap);
                frontEmptyWrap.appendChild(lastChartWrap);
                removeClass(container, 'van-ani');
                container.style.left = '100%';
                tmp = container.clientWidth; // update css
            } else

            // first -> last
            if (direction === Constants.LEFT &&
                onIndex === 0 && index === optLength - 1) {
                chartDoms[optLength - 1].appendChild(lastChartWrap);
                rearEmptyWrap.appendChild(firstChartWrap);
                removeClass(container, 'van-ani');
                container.style.left = -optLength * 100 + '%';
                tmp = container.clientWidth;
            } else {

            // recover
                chartDoms[0].appendChild(firstChartWrap);
                chartDoms[optLength - 1].appendChild(lastChartWrap);
            }

            addClass(container, 'van-ani');
        }

        function showIndex(index) {
            removeClass(menuButtons[onIndex], 'van-on');
            vanCharts.charts[onIndex].set({enable:false});
            addClass(menuButtons[index], 'van-on');
            vanCharts.charts[index].set({enable:true});

            if (isCssAni) {
                container.style.left = -index * 100 + '%';
            } else {
                var easing = BezierEasing.css['swing'];
                animation(container, 'left', -index * 100 + '%', 500, easing);
            }
            onIndex = index;
        }

        function animation(dom, attr, endValue, duration, easing) {
            window.clearTimeout(animationID);
            var from = parseFloat(dom.style[attr]) || 0,
                tmp = endValue.match(/([\d.E-]+)(.*)/i),
                to = +tmp[1], unit = tmp[2],
                here = from, now = 0, STEP = 17;

            move();

            // 0 -> duration, from -> to;
            function move() {
                if (now >= duration) {
                    here = to;
                    dom.style[attr] = here + unit;
                } else {
                    here = from + (to - from) * easing(now / duration);
                    dom.style[attr] = here + unit;
                    now += STEP;
                    animationID = window.setTimeout(move, STEP);
                }
            }
        }

        // start interval or cancel
        function setInterval(interval) {
            window.clearInterval(intervalID);
            if (interval) {
                intervalID = window.setInterval(function () {
                    var index = (onIndex + 1) % optLength;
                    prepareCarouselDom(index, Constants.RIGHT);
                    showIndex(index);
                }, interval);
            }
        }

        // width < padding * 2 + icon + 1em
        // remove padding to prevent wrap
        function checkBtnTextSpace(btnDom) {
            if (btnDom.clientWidth <= 22 + 3 * fontSize) {
                btnDom.mText.innerHTML = '';
                btnDom.mText.style.marginLeft = 0;
                if (!isIE7) {
                    btnDom.style.padding = 0;
                }
            }
        }

        return {
            init: init,
            refresh: refresh
        }
    };

    function getTitleText(option) {
        var title = option.title;

        if (title.text && title.useHtml) {
            return BaseUtils.getPlainText(title.text);
        }

        return title.text || '';
    }

    function setTextStyle(dom, styleObj) {
        Object.keys(styleObj).map(function (name) {
            if (typeof styleObj[name] !== 'string') {
                return
            }
            dom.style[name] = styleObj[name];
        });
    }
    
    function gradualColor(color) {
        var rgba = ColorUtils.getRGBAColorArray(color);
        var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
        return ColorUtils.toColor(ColorUtils.hsb2rgb(hsb[0], hsb[1] * 0.85, (hsb[2] + 0.15) * 100 / 115), 'hex');
    }

    function hoverColor(color) {
        var rgba = ColorUtils.getRGBAColorArray(color);
        var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
        return ColorUtils.toColor(ColorUtils.hsb2rgb(hsb[0], hsb[1] * 0.75, (hsb[2] + 0.25) * 100 / 125), 'hex');
    }


    function addClass(ele, name) {
        var names = ele.className.split(' ');
        if (names.indexOf(name) === -1) {
            ele.className += ' ' + name;
        }
    }

    function removeClass(ele, name) {
        var names = ele.className.split(' ');
        var i = names.indexOf(name);
        if (i !== -1) {
            names.splice(i, i);
            ele.className = names.join(' ');
        }
    }

    function setIcon(dom, type, color) {
        if (BaseUtils.isSupportSVG()) {
            var svg = '<svg width=22 height=22><g>' + icon[type] +  '</g></svg>';
            dom.innerHTML = svg;
            dom.querySelector('g').setAttribute('fill', color)
            if (type === Constants.RADAR_CHART) {
                dom.querySelector('g').setAttribute('stroke', color);
            }
        } else {
            dom.innerHTML = '<img width="22" height="22" src="data:image/png;base64,' + png[type] + '">';
        }
    }

    var icon = {};
    icon[Constants.PIE_CHART] = '<path d="M12,0.266v10.041l9.519-1.314C20.642,4.339,17,0.742,12,0.266z"/> <path d="M21.744,10.061l-7.309,1.009L11,11.511V11v-0.545V9.651V0.208C5.04,0.208,0.208,5.04,0.208,11 c0,5.96,4.832,10.792,10.792,10.792c0,0,1.214,0,1.602-0.12l0.006-0.012c5.195-0.778,9.183-5.247,9.183-10.659 C21.792,10.683,21.771,10.371,21.744,10.061z"/>'
    icon[Constants.BAR_CHART] = '<rect x="0.937" y="6.794" width="8.112" height="2.704"/> <rect x="0.938" y="12.502" width="13.52" height="2.704"/> <rect x="0.938" y="18.211" width="17.125" height="2.704"/> <rect x="0.937" y="1.086" width="6.309" height="2.704"/>';
    icon[Constants.COLUMN_CHART] = '<rect x="0.625" y="11.943" width="2.83" height="9.432"/> <rect x="6.284" y="8.17" width="2.83" height="13.205"/> <rect x="12.886" y="4.398" width="2.83" height="16.977"/> <rect x="18.545" y="0.625" width="2.83" height="20.75"/>';
    icon[Constants.LINE_CHART] = '<path d="M20.527,2.742c-0.813,0-1.473,0.659-1.473,1.473c0,0.308,0.095,0.593,0.256,0.83l-4.155,7.48 c-0.005,0-0.01-0.002-0.016-0.002c-0.296,0-0.571,0.089-0.802,0.24l-5.74-3.399c0.005-0.05,0.015-0.098,0.015-0.149 c0-0.814-0.66-1.473-1.473-1.473S5.667,8.402,5.667,9.215c0,0.154,0.03,0.299,0.074,0.439L1.987,13.84 c-0.161-0.06-0.333-0.097-0.514-0.097C0.66,13.742,0,14.402,0,15.215s0.66,1.473,1.473,1.473s1.473-0.659,1.473-1.473 c0-0.265-0.076-0.511-0.198-0.726l3.614-4.028c0.227,0.142,0.492,0.227,0.778,0.227c0.399,0,0.76-0.16,1.025-0.418l5.572,3.299 c-0.042,0.136-0.07,0.277-0.07,0.427c0,0.814,0.66,1.473,1.473,1.473s1.473-0.659,1.473-1.473c0-0.445-0.202-0.84-0.514-1.11 l4.033-7.259c0.126,0.035,0.257,0.06,0.395,0.06C21.34,5.688,22,5.029,22,4.215S21.34,2.742,20.527,2.742z"/>';
    icon[Constants.AREA_CHART] = '<path d="M15.255,15.935c0.045,0.075,0.079,0.159,0.079,0.253c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5 c0-0.106,0.041-0.199,0.097-0.28l-7.79-8.953C6.571,6.993,6.493,7.021,6.406,7.021c-0.106,0-0.199-0.04-0.28-0.097L1,12.315V21h21 V9.832L15.255,15.935z"/> <path d="M6.642,6.955C6.797,6.87,6.906,6.711,6.906,6.521c0-0.276-0.224-0.5-0.5-0.5s-0.5,0.224-0.5,0.5 c0,0.17,0.09,0.313,0.22,0.403C6.208,6.981,6.3,7.021,6.406,7.021C6.493,7.021,6.571,6.993,6.642,6.955z"/> <path d="M14.834,16.688c0.276,0,0.5-0.224,0.5-0.5c0-0.094-0.033-0.178-0.079-0.253c-0.087-0.145-0.24-0.247-0.421-0.247 c-0.17,0-0.312,0.09-0.403,0.22c-0.057,0.081-0.097,0.174-0.097,0.28C14.334,16.464,14.558,16.688,14.834,16.688z"/> <polygon points="1,12.315 1,0 0,0 0,22 0.088,22 22,22 22,21 1,21 "/>';
    icon[Constants.GAUGE_CHART] = '<path d="M11,1.149c-6.042,0-10.958,4.916-10.958,10.958c0,2.103,0.597,4.146,1.729,5.908l1.845-1.184 c-0.904-1.408-1.381-3.042-1.381-4.724c0-4.834,3.933-8.766,8.766-8.766s8.766,3.933,8.766,8.766c0,1.682-0.477,3.315-1.38,4.723 l1.845,1.184c1.13-1.762,1.728-3.804,1.728-5.907C21.958,6.065,17.042,1.149,11,1.149z"/> <path d="M11.49,12.11L11,4.273l-0.49,7.837c-0.236,0.16-0.4,0.417-0.4,0.724c0,0.492,0.398,0.89,0.89,0.89s0.89-0.399,0.89-0.89 C11.89,12.527,11.726,12.27,11.49,12.11z"/>';
    icon[Constants.RADAR_CHART] = '<polygon fill="none" stroke-miterlimit="10" points="6.828,20.531 1.417,13.746 3.348,5.286 11.167,1.521 18.985,5.286 20.916,13.746 15.506,20.531 "/> <polyline fill="none" stroke-miterlimit="10" points="3.38,5.38 11.042,10.885 15.506,20.531 "/> <polyline fill="none" stroke-miterlimit="10" points="18.985,5.286 11.057,10.87 1.417,13.746 "/> <line fill="none" stroke-miterlimit="10" x1="11.026" y1="10.885" x2="20.916" y2="13.746"/> <line fill="none" stroke-miterlimit="10" x1="11.167" y1="1.521" x2="11.042" y2="10.901"/> <line fill="none" stroke-miterlimit="10" x1="11.042" y1="10.885" x2="6.835" y2="20.539"/>';
    icon[Constants.SCATTER_CHART] = '<circle cx="14.625" cy="12.158" r="0.916"/> <circle cx="14.625" cy="7.383" r="1.291"/> <circle cx="7.958" cy="12.699" r="0.916"/> <circle cx="21.293" cy="3.702" r="0.707"/> <circle cx="2.041" cy="16.965" r="2.041"/>';
    icon[Constants.BUBBLE_CHART] = icon[Constants.FORCE_BUBBLE_CHART] = '<circle cx="3.521" cy="14.938" r="3.521"/> <circle cx="11.927" cy="5.5" r="1.958"/> <circle cx="20.667" cy="10.219" r="1.333"/>';
    icon[''] = icon[Constants.MULTI_CHARTS] = '<rect x="2" y="12" width="3" height="9"/> <rect x="7" y="8" width="3" height="13"/> <rect x="12" y="9" width="3" height="12"/> <rect x="17" y="5" width="3" height="16"/> <path d="M20.172,0.911c-0.507,0-0.917,0.411-0.917,0.917c0,0.056,0.022,0.105,0.032,0.158l-4.522,3.532 c-0.156-0.121-0.342-0.205-0.554-0.205c-0.404,0-0.737,0.266-0.859,0.629L8.582,5.56C8.425,5.278,8.135,5.079,7.79,5.079 c-0.507,0-0.917,0.411-0.917,0.917c0,0.053,0.021,0.1,0.031,0.151L2.395,9.78C2.238,9.654,2.046,9.567,1.828,9.567 c-0.506,0-0.917,0.411-0.917,0.917s0.411,0.917,0.917,0.917c0.507,0,0.917-0.411,0.917-0.917c0-0.121-0.026-0.236-0.069-0.342 l4.42-3.563c0.168,0.2,0.411,0.335,0.693,0.335c0.495,0,0.893-0.394,0.91-0.884l4.627,0.372c0.082,0.422,0.437,0.747,0.883,0.747 c0.507,0,0.917-0.411,0.917-0.917c0-0.127-0.026-0.248-0.073-0.358l4.428-3.457c0.168,0.197,0.41,0.329,0.689,0.329 c0.506,0,0.917-0.411,0.917-0.917C21.089,1.322,20.678,0.911,20.172,0.911z"/>';
    icon[Constants.MULTIPIE_CHART] = '<path d="M5.267,10.754c0,0.009-0.002,0.018-0.002,0.028c0,2.918,2.276,5.356,5.194,5.356l0.017-0.002 C7.585,16.12,5.291,13.643,5.267,10.754z"/> <path d="M10.499,18.487l0.003,0c2.997,0,5.568-1.763,6.804-4.219C16.071,16.724,13.5,18.486,10.499,18.487z"/> <path d="M2.916,10.745c0,0.012-0.002,0.025-0.002,0.037c0,4.215,3.329,7.705,7.544,7.705 c0.008,0,0.015-0.001,0.022-0.001C6.288,18.474,2.935,14.937,2.916,10.745z"/> <path fill-opacity = "0.2" d="M18.856,10h2.233C20.546,5,16,0.396,11,0.212v2.213C15,2.604,18.326,6,18.856,10z"/> <path fill-opacity = "0.6" d="M16.104,10h2.752C18.326,6,15,2.604,11,2.424v2.724C13,5.318,15.603,8,16.104,10z"/> <path d="M11,5.149V10h5.104C15.603,8,13,5.318,11,5.149z"/> <path fill-opacity = "0.2" d="M17.752,13.176c-0.119,0.376-0.269,0.741-0.445,1.092c-1.236,2.456-3.807,4.219-6.804,4.219l-0.003,0 l-0.004,0c0,0-0.007-0.001-0.015-0.001c-0.008,0-0.015,0.001-0.022,0.001c-4.215,0-7.544-3.49-7.544-7.705 c0-0.012,0.002-0.025,0.002-0.037c0-0.012-0.002-0.024-0.002-0.036C2.914,6.708,6,3.432,10,3.109V1.2 c-5,0.329-8.994,4.454-8.994,9.509c0,5.269,4.227,9.686,9.496,9.686c5.27,0,9.497-4.395,9.497-9.395h-1.908 C18.091,11.75,17.972,12.482,17.752,13.176z"/> <path fill-opacity = "0.6" d="M2.914,10.709c0,0.012,0.002,0.024,0.002,0.036c0.019,4.192,3.372,7.729,7.564,7.741 c0.007,0,0.015,0.001,0.015,0.001l0.004,0c3-0.001,5.572-1.764,6.808-4.219c0.177-0.351,0.326-0.716,0.445-1.092 c0.22-0.694,0.339-1.426,0.339-2.176h-2.349c0,3-2.321,5.138-5.239,5.138c-0.009,0-0.019-0.001-0.028-0.002l-0.017,0.002 c-2.917,0-5.194-2.438-5.194-5.356c0-0.009,0.002-0.018,0.002-0.028c0-0.015-0.002-0.03-0.002-0.045C5.264,8.007,7,5.783,10,5.468 V3.109C6,3.432,2.914,6.708,2.914,10.709z"/> <path d="M5.264,10.709c0,0.015,0.002,0.03,0.002,0.045c0.024,2.889,2.319,5.366,5.208,5.382c0.009,0,0.019,0.002,0.028,0.002 c2.918,0,5.239-2.138,5.239-5.138H10V5.468C7,5.783,5.264,8.007,5.264,10.709z"/>';
    icon[Constants.AREA_MAP] = icon[Constants.HEAT_MAP] = icon[Constants.POINT_MAP] = icon[Constants.LINE_MAP] = '<path d="M28.12 36.6h.03-.05z"/><path d="M19.53 15.7l.04-.02v-.04c0-.08-.1-.16-.2-.13h-.1c-.05 0-.1 0-.12.1 0 0 0 .1-.02.1-.07 0-.14.1-.17.2l-.1.2-.07.1-.1.1-.1.3v.2h-.1v.1h-.1l-.1.1v.5c0 .1 0 .4.1.4l.1-.1v.1h.2v.1h.2v-.2s-.1-.3.1-.5v-.9zM13-8.66h-.05.04zm7.2 16.68L20.18 8h-.1s-.03 0-.04.02h.18zM14.77 18v-.02s-.02.02 0 .02z"/><path d="M21.9 5.6c.05-.05-.02-.12-.05-.17 0 0-.04 0-.03-.02 0 0 .02-.1 0-.1h-.04v-.2c.02-.1 0-.1 0-.1.07 0 .1-.1.1-.1.05-.1 0-.2-.05-.2h.02c.05 0 .04-.1.04-.1l-.1-.1-.2.2h-.1c-.1 0-.1.1-.2.1l-.2.1c-.1 0-.1.1-.2.1l-.1.1c-.1 0-.1.1-.1.1l-.1.2s0 .1-.1.1-.2-.1-.2 0c-.1 0-.3 0-.4-.1V5c0-.1.2-.2.1-.24l.1-.1-.1-.05v.1l-.2-.1h-.4l-.1.1h-.2c.1-.1 0-.1 0-.1V4c0-.15-.1-.24-.2-.26v-.4l-.1-.05V3c0-.1-.1-.1-.1-.1 0-.1 0-.1-.1-.1h-.1c-.1-.1-.2 0-.2 0l-.3-.1-.1-.1v.14h-.5.1c0-.04.1 0 .1-.04L17 3v-.02l-.02-.1v.07-.02V3h-.07.1v.03s-.1 0-.1.02l-.1.04c0 .1-.1.1-.1.1l-.1.1s-.2 0-.2.1h.7-.2v.1l-.1-.1c.1 0 .1.1.1.1v.1h.1v.5c-.1.1-.3.1-.3.2l-.1.1v.2s-.1-.1-.1 0l-.1-.1H16c-.03 0-.1 0-.2.3l-.06.2h-.05c-.1 0-.1.1-.1.1h.1-.1c0 .1 0 .1.1.2 0 0 0 .1.1.1h.4s0 .1.1.1l.2-.2h.1l.1.1h.1l.2.2V6h-.2c-.1 0-.2 0-.2.03-.1 0-.2 0-.2.02l-.1.04c-.1 0-.2.4-.2.5V7H16c-.2 0-.3-.2-.3-.08-.07.1-.17-.04-.2-.02-.2 0-.28-.1-.35 0 0 .06-.03.05-.03.1s-.1.1-.1.1H15s-.04 0 0 0l-.4-.1-.1-.05c-.16 0-.25.2-.27.26-.04.1-.06.2-.05.2.04.2.15.3.2.3h-.06c-.3.2-.36.3-.36.3 0 .1-.1.1-.14.1h-.24s-.03-.1-.2-.1h-.05c-.04 0-.23.2-.3.2l-.1.1h-.03l-.02.1-.43.2-.37.4-.1.3h-.1s0-.2-.02-.2c0 0-.05-.1-.1-.1v-.2.2c-.04 0-.1.2-.16.2h-.1c-.1 0-.25-.3-.3-.4v-.1h-.04c-.2 0-.24-.2-.24-.2v-.1l-.6-.1H9l.03-.1-.08-.1.03.1c-.03-.1-.04 0-.03 0h-.02l.24-.7-.35.5-.06-.1-.04-.1c-.02 0-.03 0-.04-.1 0 0-.04-.2-.07-.2v-.1h-.2L8.3 7c0-.05-.2-.2-.2-.2-.1-.07-.2-.1-.4-.1h-.1l-.1-.04h-.2l-.1-.05s0 .2-.02.2V7H7.1v-.15c0-.02 0-.12-.03-.15v-.1c.05-.05.12-.1.14-.17l.1-.1v-.68l-.1-.1v-.03.3c0-.04 0 .2-.1.2H7c-.04 0-.06-.33-.1-.33s-.06-.2-.1-.2v-.4L6.5 5H6s.2-.05.17-.1l.1-.03c.03-.05.08-.06.08-.08 0-.1-.05-.1-.1-.1l-.12-.1H5.9c-.1 0-.1.1-.1.1V5h-.2c-.1 0-.1 0-.1.04l-.1.06c0 .02-.1.04-.1.07v.36l-.1.03c-.1 0-.1.2-.1.2L5 6s0-.3-.02-.3c0 0 0 .1-.1.1-.03 0-.1.1-.14.1l-.07-.3s0-.2-.05-.2c-.08 0-.1-.1-.1-.1 0-.05-.1-.1-.14-.1s-.1 0-.12.05v.05l-.07.04-.1.13-.1.05-.1.1c-.1 0-.1.03-.1.05v.08s-.1.1-.1.15V6l-.1-.04H3c-.03 0-.1.04-.13.1v.1c.03.07.1.1.14.1v.8s-.5 0-.5.04-.5.15-.5.15v.08l.4.03.1.04c-.1 0 0 .02-.1.03l-.1.03-.1.04H2c-.05 0-.1.03-.1.06-.05 0-.1 0-.1.03h-.1c0-.1-.04-.1-.1-.1h-.3s-.03 0-.05.1c-.04 0-.08.1-.1.1V8v-.2l-.02-.1c0-.04 0-.12-.1-.12 0 0-.1 0-.1.02v.2S1 8 .93 8H.8v-.16c-.03 0-.05-.1-.06-.1-.02 0-.04-.05-.07-.04 0 0 0-.03-.03-.03L.6 7.65H.5c-.06 0-.1.06-.1.07H.3c0 .02-.02.03-.03.04-.05.04-.05.1-.04.12H.15l-.02.02c-.06.04-.06.14-.02.2v.02l.1.02c0 .02-.1.06-.1.12 0 .04 0 .12.1.15v.1c.1.1.1.1.2.1h.1l.1.1.1.1V9s-.1.1 0 .2v-.05H.1c-.02.08 0 .18.06.2l.12.07H.3l.07.03H.4v.16h.1H0h.3c-.02.1.1.1.1.1-.06.1 0 .1 0 .1 0 .1.04.1.1.1 0 .1 0 .1.02.1l.03.1H.7l.04.1s.1.1.17.1H1l.1.1.2.1v.4l.3.1.1.1-.05.1h-.1s-.05 0-.06.1c-.1 0-.1.1-.1.1l-.2.1h-.1.1v.1l-.1.1v.1c-.1.1-.1.1-.1.2-.1 0-.1.1-.1.2v.1s-.1.1 0 .2v.1c-.1 0 0 0 0 .1-.1 0-.1 0-.1.1v.2l.1.1h.2l.1.1.1.1v.1h.1l.1.1h.1s.1 0 .1-.1V13H2v.1c0 .05.06.1.1.1h.1v.1l.1.1c0 .04 0 .04.03.05h.05v.14s.04.1.12.1H3v.1s.03.1.06.1h.05l.1.1h.2c0 .1 0 .1.1.2h.3l.1-.1H4c.05 0 .07.1.1.1 0 0 .03.1.07.1h.15v.3s.2.4.3.4h.05l.1-.3c.1 0 .1-.1.2-.2v-.1l.1-.07.04-.06v.15s0 .1.1.16c0 .1.1.1.2.1h.1c.1 0 .1-.1.1-.1v-.1h.1l.1-.1H6l.1.06h.2l.1.02H6v.1c0 .05.04.1.07.1h.16c-.04 0-.07.06-.07.1v.1c.03.1.17.1.2.1l.22.04H7c.02-.02.08-.03.1-.12l.03-.03.08-.07h.4l.1-.06h.1c.1-.05.1-.1.1-.1l.1-.04h.2l.2.1h.1c.1 0 .2.1.2.1h.2c.1-.05.1-.14.1-.2 0 .04.2.06.2.06v.1H9s-.03.04 0 .1v.2s0 .03.05.05c0 .1.05.1.08.1 0 .1.05.1.05.1v.1h.03v.4H9v.1h-.03c-.03 0-.04.1-.05.1h-.1v.2h-.1l-.1.1v.1l-.02.1v.1l.07.1-.1.1v.1c.04.1.07.1.1.1h.4s.03.1.05.1c0 0 0 .1.03.1-.03.02-.03.04 0 .06V17h.02l.1.28v.06c0 .05 0 .14.04.2H9l.15.03.04.02v.4-.5h.3v.2s0-.1.1-.1v-.2.1s0 .1.1.1h.2s.1 0 .1-.1v-.3l.1-.2v-.1c0 .1.1.1.1.1h.2l.1-.1s0 .3.1.3v.3h.1v-.6l.1-.1.1-.1c.1 0 .1-.1.1-.1h.2v.4l.1.5c.1 0 .2-.4.2-.4s.1 0 .1-.1v.1-.1.1h.1s0 .1.1.1c0 0 0 .1.2.1l.1-.1v-.1h.3v-.05h.4v.1c-.1 0-.2.2-.2.2-.1 0-.1.1-.1.2l-.1.1-.1.04v.1c-.07 0-.07 0-.07.1l.1.2c-.1 0 0 .1 0 .1s0 .1.1.1h.4l.1.02v-.05h.1l.1-.08h.06s.1.03.1 0l.1-.08V18h.1l.1-.2.2-.1-.1-.1c-.1-.1-.1-.1-.2-.14l-.3-.1H13h1v.1-.1h.1v-.14h.2s.1 0 .1-.1c.1.07.1.1.2 0h.1V17s.1-.1.18-.1.1.1.1.1c.1 0 .2-.04.2-.14v.6h.2c.08 0 .1-.4.1-.4V17l.1-.1v-.1l.1-.06c.1 0 .1 0 .1-.1v.4c.1.07.1.5.2.5l.1-.4V17h.1l.04-.03.02-.02c.1 0 .2-.04.2-.12l-.1-.05-.1-.05.2-.02h.2l.3.1-.1-.1h.23s.1 0 .1-.1v-.1h.3l.1-.1V16s.1 0 .1-.05l.1-.02.03-.04v-.1c.1 0 .1-.1.1-.1h.1v-.1c.08-.1.07-.2 0-.2v-.2h.05v-.4l.04-.1h.1l-.1-.1v-.5h.2v-.25c0-.1 0-.1-.03-.1l-.53-.1h.6l.1-.1.06-.08s.08-.1 0-.1l.07-.1V13h-.3c-.1-.06-.1-.07-.2-.07l.1-.1h.1l.1-.07-.1-.1v-.27c-.06-.1-.15-.2-.3-.2l-.06-.1s-.1-.1-.2-.1v-.1c0-.1 0-.1-.1-.2l-.1-.1v-.2c0-.1 0-.1-.03-.1l-.1-.2c-.1-.2-.1-.2-.1-.1-.1 0-.1-.1-.2 0-.1-.1-.4-.1-.5-.1l.3-.1h.2l.1-.1.6-.5-.46.1c0-.1.1-.1.1-.1.07 0 .17-.1.2-.1s.05-.1.04-.1l.1-.1v.2c.03 0 .04.2.05.2l.04-.3.1-.1c.06 0 .1-.1.1-.1l-.7-.1H17h.4l.1.1h.2l.1.1h.6c.1-.08.1-.28.1-.3l.1-.17c.1 0 .1-.1.1-.1v-.1h.1s.1 0 .1-.04l.1-.1c.1 0 .1 0 .1-.1.1 0 .1-.1.1-.1h.4l-.04-.1c-.1-.1 0-.1 0-.1v-.1c.1-.1.1-.1.1-.2.1 0 .17-.1.18-.1l.04-.1.05-.1.1-.1c0-.1.1-.2.1-.2l.06-.1h.3c0-.1.2-.1.2-.1v-.1l.3-.1c.1-.1.3-.2.3-.3s-.1-.1 0-.1v-.1s.1 0 .1-.1v-.3c0-.1 0-.2-.1-.2l-.1-.2c0-.1-.1-.1-.1-.1v-.1c.1-.1.1-.1.1-.2h.5c0-.1.1-.2.1-.3 0-.1-.1-.1-.1-.2zM1.25 11.5zm12.8 6.8h.04-.1z"/><path d="M17.38 10h.04"/><path d="M16 3.5h.23H16zm2.32 6.5l-.04-.02V10h.04zM21 7.34h.05L21 7.3v.03zm-4.4 5.4s-.02-.07-.1-.07h-.02v.15l-.03.14h-.03c-.03 0-.06-.13-.07-.13l-.02-.1c-.05 0-.1.08-.14.1-.1 0-.1.1-.1.1h.3c.1 0 .1.05.1.03v-.18l-.1-.05z"/>';
    icon[Constants.TREEMAP_CHART] = '<polygon fill-opacity = "0.6" points="11,0 11,10 11,13 11,14 11,16 11,22 22,22 22,16 22,14 22,13 22,10 22,0 "/> <rect y="14" fill-opacity = "0.2" width="10" height="8"/> <rect width="10" height="13"/>';
    icon[Constants.FUNNEL_CHART] = '<polygon points="20.06,6.533 1.989,6.533 1.082,1.656 20.966,1.656 "/> <polygon points="17.949,14.412 4.005,14.412 2.051,8.409 19.888,8.409 "/> <polygon points="14.963,20.79 6.944,20.79 4.271,15.912 17.933,15.912 "/>';
    icon[Constants.GANTT_CHART] = '<path d="M8.38.95V4.42h-7A.48.48,0,0,1,.83,4V1.37a.47.47,0,0,1,.5-.43ZM2.67,6.48a.47.47,0,0,0-.5.43V9.53a.47.47,0,0,0,.5.43H13.12V6.48ZM20.49,12H8.58a.47.47,0,0,0-.5.43v2.62a.47.47,0,0,0,.5.43H20.49a.47.47,0,0,0,.5-.43V12.43A.48.48,0,0,0,20.49,12ZM4,17.53a.47.47,0,0,0-.5.43v2.63A.47.47,0,0,0,4,21H14.44V17.53Z"/> <path fill-opacity="0.5" d="M11.58,1.37V4a.48.48,0,0,1-.5.43H8.38V.95h2.7A.47.47,0,0,1,11.58,1.37Zm3,5.1H13.12V10h1.46a.47.47,0,0,0,.5-.43V6.9A.48.48,0,0,0,14.58,6.48Zm4.49,11.06H14.44V21h4.63c.32,0,.6-.19.6-.43V18C19.67,17.73,19.39,17.53,19.07,17.53Z"/>';
    icon[Constants.STRUCTURE_CHART] = '<path d="M20.4,18c-1,1-2.5,1-3.5,0.1c-0.7-0.6-0.9-1.6-0.7-2.4l-4-1.7c-0.1,0.1-0.2,0.2-0.3,0.3c-1.4,1.5-3.6,1.6-5.2,0.4l-1,1  c0.7,1,0.6,2.3-0.2,3.2c-1,1-2.5,1-3.5,0.1c-1-1-1-2.5-0.1-3.5c0.9-0.9,2.4-1,3.4-0.2l1-1c-1.3-1.5-1.3-3.8,0.1-5.3  c0,0,0.1-0.1,0.1-0.1l-1.5-3C4,6.3,2.8,6.2,2,5.4c-1-1-1-2.5-0.1-3.5c1-1,2.5-1,3.5-0.1c1,1,1,2.5,0.1,3.5c0,0,0,0,0,0l1.5,3  c1.4-0.9,3.4-0.8,4.7,0.4l2.1-2.1c-0.6-0.9-0.5-2.2,0.3-3.1c1-1,2.5-1,3.5-0.1s1,2.5,0.1,3.5c-0.9,1-2.4,1-3.4,0.1l-2,2  c0.9,1.2,1.1,2.8,0.4,4.2l3.8,1.6c0.1-0.2,0.2-0.3,0.4-0.5c1-1,2.5-1,3.5-0.1C21.3,15.4,21.4,17,20.4,18z"/>';
    icon[Constants.WORD_CLOUD_CHART] = '<path d="M17.61,12.53H15.85v5h1.86a2.5,2.5,0,0,0,1.83-.62A2.51,2.51,0,0,0,20.16,15,2.31,2.31,0,0,0,17.61,12.53Zm-.53,1.12h.49c.88,0,1.29.45,1.31,1.37s-.4,1.43-1.3,1.43h-.5Zm-8-4.52L5,19.47H7.2l1-2.62h4l1,2.62h2.23L11.25,9.13Zm1.08,2.35,0,.07,0,.12s.16.39,1.33,3.42H8.8c1.09-2.84,1.3-3.37,1.34-3.45Zm-5,1.21c-2-.11-3.08-1.26-3.19-3.42C2.05,7,3.13,5.87,5.15,5.74A2.88,2.88,0,0,1,8,7.77l.1.29-1.5.39-.08-.26A1.37,1.37,0,0,0,5.16,7.11c-.63,0-1.52.32-1.62,2.14.07,1.8,1,2.08,1.63,2.14A1.43,1.43,0,0,0,6.63,10l.06-.3,1.48.43-.06.25A2.72,2.72,0,0,1,5.14,12.7ZM19.47,8.62v0A2.22,2.22,0,0,0,18,6.66a2.06,2.06,0,0,0,1.07-1.89c-.08-.95-.66-2.1-3-2.17H12.43v8.56h3.91C18.93,11.16,19.47,9.78,19.47,8.62Zm-1.89-.08c0,.54-.16,1.17-1.44,1.17H14.2V7.53h1.86C17.37,7.56,17.56,8.13,17.59,8.54ZM15.91,6H14.2V4.1h1.71c1.19,0,1.35.51,1.36.88S17.09,6,15.91,6Z"/>';

    function setArrow(dom, color) {
        if (BaseUtils.isSupportSVG()) {
            dom.style.background = color;
            dom.innerHTML = '<svg width=30 height=30><path fill="none" stroke="#FFFFFF" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="M11.1,21.5L20.9 15 11.1 8.5 M11.1,21.5z"></path></svg>';
        } else {
            var circle = createVml('shape');
            circle.path = PathUtils.circlePath(15, 15, 15);
            circle.stroked = 'False';
            circle.fillcolor = color;
            var fill = createVml('fill');
            fill.color = color;
            fill.opacity = 0.5;
            circle.appendChild(fill);
            dom.appendChild(circle);

            var path = createVml('shape');
            path.path = /vanchart-arrow-left/.test(dom.className) ?
                'm19,22 l9,15 l19,9 e' : 'm11,22 l21,15 l11,9 e';
            path.filled = 'False';
            path.strokecolor = '#ffffff';
            dom.appendChild(path);
            VanHammer.on(dom, 'mouseover', function () {
                fill.opacity = 0.2;
            });
            VanHammer.on(dom, 'mouseout', function () {
                fill.opacity = 0.5;
            })
        }
    }

    function setDot(dom) {
        var circle = createVml('shape');
        circle.style.width = '100%';
        circle.style.height = '100%';
        circle.coordsize = '10 10';
        circle.path = PathUtils.circlePath(5, 5, 5);
        circle.stroked = 'False';
        circle.fillcolor = '#7f7f7f';
        var fill = createVml('fill');
        fill.color = '#7f7f7f';
        fill.opacity = 0.5;
        circle.appendChild(fill);
        dom.appendChild(circle);
    }

    var png = {};
    png[Constants.PIE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAMFBMVEUAAAD///////////////////////////////////////////////////////////87TQQwAAAAD3RSTlMAEM/vv4Bgr59AcFAg348jFhddAAAAjElEQVQY02MAArGSDx6JDGDAav//w//PASAmo/5/IPv/JwEgW/g/mP1fEcjWh7I/AVX/h7L/L2AQhrMvMOTD2b8Z6uHsfwz+ULZK1ByG/2B25smtLfYQ9hewLEQNRACoFwZ+AM2EgW9Au2DAkIEVzg6AuO0/xG1wRYpgv0CEBaB+/A/2I8Tv/zVAfgcA4kmspsM258YAAAAASUVORK5CYII=';
    png[Constants.BAR_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAElBMVEUAAAD///////////////////8+Uq06AAAABXRSTlMAQIAgEDB5ccoAAAA+SURBVBjTY0AGoqGhgTjZBICjoKCgCFw9SAMm20hJSUkZlwFwNWAgANELBgrobEdBMDDAZQZEPRQI4GQjAwAQhxXw9o2YjgAAAABJRU5ErkJggg==';
    png[Constants.COLUMN_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAG1BMVEUAAAD////////////////////////////////rTT7CAAAACHRSTlMAgEC/IGCPMNAZ/cwAAAAuSURBVBjTY4ADRSEEW6KRALvYDMHWaCbAtmgiwHZSgbOBiG5skJcDRRgcRYEMADB5J9shBWGXAAAAAElFTkSuQmCC';
    png[Constants.LINE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMA74C/IM9AEN+vYDCfcFCP7HfXwgAAAG9JREFUGNPNjzsOxDAIRA0Yf+J1du5/2siKIQ1dmlA9PQ2gSa8nHznSBIo0gOgGlAPdm+M4HQuK4Qn8jEU88QdoZw6MZ0+lQ/Li5muDFpYGrokpu9UbJjUmtqaqdQeqAN2aYln7hx41nbwzLDN9Yi4tRQMa2y+S7gAAAABJRU5ErkJggg==';
    png[Constants.AREA_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAgklEQVR42mL4DwQMtACjBg8zg4FCBhRbiMPg+f8hIIFqBiMZCgMGFBuMxVAQeE+q4UD1AnCDgVT/f9zgPlgxcYaC4uc8Ayws/xMG5wkZDjX0Pdix/0kD8/EY6gAzlByDsRqOzcfkGIySDHEFIyMFGWEClC7AJslIqyw9avAQNhggwABVPsGVrLOsUQAAAABJRU5ErkJggg==';
    png[Constants.GAUGE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWBAMAAAA2mnEIAAAAMFBMVEUAAAD///////////////////////////////////////////////////////////87TQQwAAAAD3RSTlMAgL9A3zAQn89wII/vr2A5/8HrAAAAnUlEQVQY02NAA5kq/52mQZjZ/0FgG4jJ6v/fXbDk/5cAIDvmvzJDKIPR/6MMDGz+HxkYjBkY5L8kMLD/FwCzGf8XMKz/xABmM+j/Ytj/GUjPBGL73wz9DUBaEIg5fjAAlYPYIA0M/ydA2ZxA9gMgfQaI+f5D1NyFqOm/AHUh7w+G/b+g7PXfGeK/Q9n1XxmYtKDsRQoMbHAvJTAQAQCj4DRASabatgAAAABJRU5ErkJggg==';
    png[Constants.RADAR_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMAEO+A32DPr7+fQFAwIHCP1A0rdQAAAMpJREFUGNOFUFlyRCEIlEXcfdz/tAHxVSr5mOmyQJu2UdI39Mob/pOjcuOK9KeQmbPJbd3CS3oqblWQVpiqnEx00tYnjlXqemlo+ISqZHhwBN25AOih0aQDGxhNuI2QbmGh16ByKSLT9w/FAw6aar0v89zItKMhqzJan3tf8i4qe3aWvHxLE81LQ5IKZU7nImu2Y3gvhcQjvBGsLHTat9srTZ0n+V8Ap4fuYd+h4rxCMkNp6YIEwhZwNfkdeWG+fxIfxQsQfdHTB/wA4h0GZUKWX6QAAAAASUVORK5CYII=';
    png[Constants.SCATTER_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAgUlEQVR42mJgGAVA8P//fwFaGFoAxP8ZaWCwAZByGHRhCPYuEKyntsH7oQb/x6WGhUyzF0LpCyMnoRtAkw+6uAMQnwdFIrlhfB5Ko6d3BSA2IDuMgS6aD8T9eDICeV6mNBzn/0eA+dQ0GB1QxeVMtExSDTQJCljBDMQKI7t6AggwAFyzgSCZYutPAAAAAElFTkSuQmCC';
    png[Constants.BUBBLE_CHART] = png[Constants.FORCE_BUBBLE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAnUlEQVR42mJgGAVQwEiswv///ysAqQQodwIjI+MHqrgAaPD7/wiwn1qGOvxHA1QLM1JdzEKC2YbIYUz31AANNgFqG9oPDar3TFR2sAGUFoCnUSCeD4oUKG1AposNgHg9ECdgTUpQEEBpuNzHYfB9Sg3GBwzINZdQ5H0YlEFhgJZd/0P5BhQXm9CckgBNfyDvbwAWiw9GaxWqAIAAAwA2evfwKvysMwAAAABJRU5ErkJggg==';
    png[''] = png[Constants.MULTI_CHARTS] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMAQL/PMBBwgCDvn49gUN+vfvzE8AAAAGJJREFUGNPdjUEOgDAIBFkordpW+f9rNdqUQ3mBeyBhMiwURBNFYQu4HsK60E1aUNAlA+7sUgpQmdXMZh/vDORyPs8cJ+l4T7dEjhsPB8DE+bh0LD4IJkRO3K7Agj/xTzjKDUJoCsaJEKt8AAAAAElFTkSuQmCC';
    png[Constants.MULTIPIE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAe1BMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////NgkbwAAAAKHRSTlMAMpkDn0AnIBSz24Dmv4dKOhoQCuzKrJqMLfnyuaZ5dGZaUkIN0pRsCVisMQAAAOZJREFUGNN90dtygyAUhWHWEhA0Gg8xappz0pb3f8LKdkrTXvS/45s9DHtQL8G6TP0qcxYKS3n2gm0UVX9ugblPatFca63IsX4AfdLtB0nF2BbIhHPcNVkV6jBo8Txqj2bkfheCCmG3eA08ZfhC/RYii483GZ9BDkF4qSBLYGE8NDeJw4mUx+DGlU2ssdY9ZeWrFl7bkHcI48gicUHdCFt4+sRHTrCRHcoT33+GL3Cy+wxPVvHlh4Hcfy/fwXi9nL0ntTfo1JqDmSrGqglxxeQw57Iszwbx4lSWYy3/+2td27ad4D99Ae8gE70h03waAAAAAElFTkSuQmCC';
    png[Constants.AREA_MAP] = png[Constants.HEAT_MAP] = png[Constants.POINT_MAP] = png[Constants.LINE_MAP] ='iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAA5ElEQVR42mJgGHHg////AkDsAMQK1DZ4/38IeE/QcJACIDYgwlAHqIH/kQxvAOLz2BTPB0kA8X1CLoC6FtlgOEBXiA76QWGIx1cO/7GDfpCCAqjzcYH76MEC4hNQr8CAyys4QANUIzqAmbEe7kMcCkkF76HxooCeDqkB1mNLMtQAAdhyznkqGHwfawoikDKIBQ64EnwA1Ob9aLFNLFBgIDK7CpAQByDHNMD0s+AymJGR8QDUgngiyqIHQHwQiPlJLcHeIwXRe7QI+w/1mQLOMCZU7iKxQWXIfVoU7uS5blADgAADACOwXahZ5pbvAAAAAElFTkSuQmCC';
    png[Constants.TREEMAP_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAOUlEQVR42mL8DwQMRABGIAAqnclAJGBioBEYNXjU4FGDh5XBLEDMRyuD1YhUe3Y08kYNHqQGAwQYAL9YCMfrIWhGAAAAAElFTkSuQmCC';
    png[Constants.FUNNEL_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABcAAAAXBAMAAAASBMmTAAAAKlBMVEUAAAD///////////////////////////////////////////////////+Gu8ovAAAADXRSTlMAQMCAIGAw0FAQ8HCwS1BQUgAAAHVJREFUGNNjwA2Y78LAZQYGDjjnKgMDC5xzDahuLYxzAcjRhXEKgJxEQShIAHIcYRwHIGcvTFkAkOML40wActih7DsgJ3Aj7ETYehPsuloIRwHT3UlKYNAAZMKMuzUBzGFEGAZxKkJ/LojjAOWwGhsbW2CYCwC1z2uuESf9qgAAAABJRU5ErkJggg==';
    png[Constants.GANTT_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAeFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////GqOSsAAAAJ3RSTlMABOgQCPvZzN3OhMOofnrCZD03jzDs0ryWiXNsXyUjDd9TUkQqHhgfRKpZAAAAmElEQVQY043P2Q6DIBRF0SsiKMrgXKfamf//w1qxQJo0uh73y8kBmEMDYxyA9SI1WrGB310+R9o4ie7mZW1zeXU5bBuaLKhQfQ4HBB7bgKOGbOJuqL45007G8p3MahJvLmVfLcXAjtncE8BEE3NrZXOhfXv5gXxgzaEH/nu2qZQyXUiajUqNavpdQ5wxVuafXEWWJoJzwYo3Z10TfT0w3LEAAAAASUVORK5CYII=';
    png[Constants.STRUCTURE_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAhFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8g2+bRAAAAK3RSTlMAA/v3JXcSB9yNRSycF/Dsu7akmJSCTTMOC9HEwKWIWTof4taqoH1wZ1Ydf35d9gAAAO1JREFUGNNVUAlygzAMlA+wMZAQroTc6d3q///rYkHcahikWe+sdkVSitbhOQ2vOyu4/KUyZj4+0ft+gc9sNJdCnBrmSuCCNfuDkDPMHCIlbzS/k1MoUIzhG+D5s/UlKjr6wp6XHJhsHysVxh8K1b3vxJV4bTfM277LV5fSc88aywqalORZHRiGiW2UTfAFGErP9pVbnhz1wvZxT7rSnhEVS6+WqMzGiE7h8TiBzV1Z+fYTUwHcejan2mZDmCN/MPQ2NVEbu+g5oiPkNLQauaBTEvkKtR2mm/R0/3MR7/n9Nhz+xPifP0GL93SGVL8LLRIgop0Y4gAAAABJRU5ErkJggg==';
    png[Constants.WORD_CLOUD_CHART] = 'iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAACMUlEQVRIS7VUQXLaQBCckcRBXEAXqnY4YP8AvyDJD8IL4rwgzgvivCD2D+AFkBeYvCD4BSEHraq4gE+6UJpUU1plAYkCV3lPQhp6erp7lumNDr8RLl0MnGXZeyJ65wgVRbEIguDZGLP0SV4MnKbpPTN/q5n0q4g8uPevBmbmD8aY+Wq1Gm632xkRDUSkwjsCzrLsKgzDbq/XW9Tp7xg74PV63c3z/DcRJSLSPWJcFkyJCBriLKMoGh02aJLCNToCttaOiegTEY2iKFpiPFVd9/v9G5+5BzxR1SUzg+WtqmoQBDfOxEoKa+2GiOYi8hFAcD8Mw00TY5+h16wy0AdWInoUkTsAQxrHNM9zSITzqKrDMhV3zLwoigJ1SMoQ04oIjPyf4zRNF8zcEZFrfLDWIjpfVPW7i5eqwtCfDXGrSO0BY3RVfYJpRAQASDIpzRwQ0QsRdcCKmSGbO8vD5dgDxo8yk7dEhHHHqgqAqao+E9GsZDoREdTAh6vS8F2KjDEgsjsnF8QlhZk/w1hV/YNm7Xb7OkmSjTflL5AhoicRGZ0ELnO9RlEcxwmArLVz3BNoZIwZO2BsnLUW0k1dbSNjay3S8cPPsHuGici3D+yezwGGiQPoe2AWRu4gx2gEw5n5XlWh+18R2W1uLePSROz/i7//fgyRGAAWRbEzEs3jOB5DskZgb733suklB00r7evkqmUMfVW1GwTBuC6j7nur1Zo13YIX38d17M5mfO6fT9X9A37JPSaAohB+AAAAAElFTkSuQmCC'

    var CSS = "position:absolute;width:1px;height:1px;behavior:url(#default#VML);";

    function createVml (type) {
        var shape = VmlRenderer.prototype.create(type);
        shape.style.cssText = CSS;
        shape.coordsize = '1 1';
        return shape;
    }

    return CarouselFun;
});
/**
 * Created by eason on 15/5/15.
 * 
 */
define('VanCharts',['require','./vans/VanChart','./vans/VanChartMap','./vans/VanChartForceBubble','./vans/VanChartWordCloud','./vans/VanChartStructure','./chart/gantt/Gantt','./utils/BaseUtils','./Constants','./utils/LoadingUtils','./Carousel','./vans/VanChartLibrary'],function(require){

    require('./vans/VanChart');
    require('./vans/VanChartMap');
    require('./vans/VanChartForceBubble');
    require('./vans/VanChartWordCloud');
    require('./vans/VanChartStructure');
    require('./chart/gantt/Gantt');

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var LoadingUtils = require('./utils/LoadingUtils');
    var Carousel = require('./Carousel');
    var VanChartLibrary = require('./vans/VanChartLibrary');

    window.VAN_CANVAS = BaseUtils.isSupportSVG() ? 'canvas' : 'vancanvas';

    var _baseIndex = 0;

    var _instances = Object.create(null);

    function init(dom){
        BaseUtils.initConst();
        var instanceKey = dom.getAttribute(Constants.INSTANCES_KEY);
        if(!instanceKey){
            instanceKey = Constants.INSTANCES_KEY + _baseIndex++;
            dom.setAttribute(Constants.INSTANCES_KEY, instanceKey);
        }

        var vanCharts = _instances[instanceKey] || new VanCharts(dom);
        _instances[instanceKey] = vanCharts;

        return vanCharts;
    }

    function VanCharts(dom){
        this.dom = dom;
        this.charts = [];
        this.carousel = Carousel && Carousel(this);

        this.dom.style.cssText += ';overflow:hidden;-ms-user-select:none;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;';
        this.dom.onselectstart = this.dom.ondrag = function(){
            return false;
        };
    }

    VanCharts.prototype = {
        constructor:VanCharts,

        setOptions:function(options){

            this.options = options || this.options;

            if (options && BaseUtils.isArray(options.options)) {
                this.charts = this.carousel.init(options, this.charts, this.dom);
            }else{
                this.charts = [this._initSingle(options, this.charts[0], this.dom)];
            }
        },

        showLightBox:function(vanchart){
            showLightBox(vanchart);
        },

        hideLightBox:function(container, fullScreenFather){
            hideLightBox(container, fullScreenFather);
        },

        /**
         * return initialized or refreshed chart object
         * @param {Object} [option]
         * @param {Object} [oldChart]
         * @param {Object} [dom]
         * @returns {Object} [chart]
         * @private
         */
        _initSingle: function (option, oldChart, dom) {

            var ChartClass = VanChartLibrary.get(option.chartType);

            if (oldChart && oldChart.vanChartType === ChartClass.prototype.vanChartType) {

                //todo 
                oldChart._changeDataState = true;

                oldChart.refresh(option);

                return oldChart;
            } else {
                oldChart && oldChart.remove();
                return new ChartClass(option, dom, this);
            }
        },

        setData:function(options, i){
            if (i != null) {
                // update a single chart in carousel
                this.charts[i] = this.carousel.refresh(options, i);
            } else {
                this.setOptions(options);
            }
        },

        /**
         * 
         * @param {[type]} options [description]
         * @param {[type]} index   [description]
         */
        setAutoRefreshData: function (options, index){
            index = index || 0;
            this.charts[index].autoRefresh(options, index);  // 
        },

        eachVanChart:function(callBack){
            // each
            this.charts && this.charts.forEach(function(chart){
                callBack.call(null, chart);
            });
        },

        refreshRestore:function(){
            this.eachVanChart(function(chart){
                chart.refreshRestore();
            });
        },

        resize:function(options){

            //
            if(options){
                this.setOptions(options);
            }else{
                this.charts.forEach(function(chart){
                    chart.resize();
                });
            }
        },

        getChart:function(index){
            return this.charts[index];
        },

        clear:function(){
            for(var i = 0, len = this.charts.length; i < len; i++){
                this.charts[i].remove();
                this.charts[i] = null;
            }
        },

        startLoading: function () {
            if(this.dom){
                LoadingUtils.startLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
            }
        },

        endLoading: function () {
            if(this.dom){
                LoadingUtils.endLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
            }
        }
    };

    function initPaddingScale(scale){
        BaseUtils.initPaddingScale(scale);
    }

    function showLightBox(vanchart, zIndex){

        var options = vanchart.options;

        var w, d;

        try {
            d = window.top.document;
            w = window.top;
        } catch (e) {
            w = window;
            d = w.document;
        }

        var body = d.body;

        //todo FRzIndex,3000,8000
        //var currentMaxZ = 7998;  3330
		var currentMaxZ = 3330;

        if (zIndex == null) {
            var el, i = -1,
                len = document.body.children.length;
            while (++i < len) {
                el = document.body.children[i];
                if ((el.style.display || '').toLowerCase() !== 'none') {
                    currentMaxZ = Math.max(currentMaxZ, el.style.zIndex);
                }
            }
        } else {
            currentMaxZ = zIndex - 1;
        }

        var boxDiv = d.createElement('div');
        boxDiv.style.cssText =
            'position: fixed;' +
            'top:0;' +
            'left:0;' +
            'width:100%;' +
            'height:100%;' +
            'z-index:' + (currentMaxZ + 1) + ';';
        if (BaseUtils.isSupportSVG()) {
            boxDiv.style.background = 'rgba(0,0,0,0.3)';
        } else {
            boxDiv.style.background = '#000000';
            boxDiv.style.filter = 'alpha(opacity=30)';
        }

        body.appendChild(boxDiv);

        var container = d.createElement('div');
        container.style.cssText =
            'position: fixed;' +
            'top:5%;' +
            'left:10%;' +
            'width:80%;' +
            'height:90%;' +
            'z-index:' + (currentMaxZ + 2) + ';' +
            'background:#ffffff;' +
            'box-shadow:0px 4px 50px rgba(0,0,0,0.5);';

        // for ie quirks mode
        try {
            container.style.setExpression("top", "( ignoreMe = document.body.scrollTop + this.previousSibling.clientHeight * 0.05) + 'px' ");
            boxDiv.style.setExpression("top", "( ignoreMe = document.body.scrollTop ) + 'px' ");
            container.style.position = 'absolute';
            boxDiv.style.position = 'absolute';
        } catch (e) {

        }
        body.appendChild(container);

        var fullScrVanCharts = init(container);

        // It's a little strange that
        // the VanChart[S] instance's father is a VanChart instance
        // 'cause we have only one chart in full screen mode
        fullScrVanCharts.fullScreenFather = vanchart;
        fullScrVanCharts.setOptions(options);

        vanchart.set({enable: false});
        vanchart.fullScreenChart = fullScrVanCharts;

        container.boxDiv = boxDiv;

        boxDiv.onclick = function(){
            hideLightBox(container, vanchart);
        };

        container.onclick = function(e){
            e = e || w.event;
            if (e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble = true
            }
        };
    }

    function hideLightBox(container, fullScreenFather){
        var parent = container.parentNode;

        if(parent){
            parent.removeChild(container);
            if(container.boxDiv){
                parent.removeChild(container.boxDiv);
            }
        }

        fullScreenFather.set({enable: true});
        fullScreenFather.fullScreenChart = null;
    }

    function acceptPoint (obj) {
        return obj && obj.vanChartType === 'point'
    }

    return window.VanCharts = {
        version: '8.5.0',
        buildTime: '10/19/2017 15:09:16 GMT+0800 (CST)',
        /*v: commit */
        showLightBox:showLightBox,
        hideLightBox:hideLightBox,
        init:init,
        initPaddingScale:initPaddingScale,
        acceptPoint: acceptPoint,
        instances:_instances
    };
});
/**
 * Created by eason on 15/5/4.
 */
define('chart/Bar',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/BezierEasing','./Series','../ComponentLibrary','../dom/Browser','../ChartLibrary','../ChartLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var Series = require('./Series');
    var ComponentLibrary = require('../ComponentLibrary');
    var Browser = require('../dom/Browser');

    var INIT_ANIMATION_TIME = 1200;//
    var INIT_EASE = BezierEasing.css["ease-out-cubic"];
    var EXIT_ANIMATION_TIME = 150;//
    var EXIT_EASE = BezierEasing.css["ease-in-back"];
    var UPDATE_ANIMATION_TIME = 250;//
    var UPDATE_EASE = BezierEasing.custom["ease-out"];
    var RE_SHOW_ANIMATION_TIME = 900;//
    var RE_SHOW_EASE = BezierEasing.custom["ease-out-quint"];
    var STACK_ANIMATION_TIME = 600;//
    var STACK_EASE = BezierEasing.css["ease-out-cubic"];//

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;
    var MIN_BAR_SIZE = 2;

    var Bar = Series.extend({

        doLayout:function(){

            var ow = this.getSeriesOffsetAndWidth();
            var series = this, vanchart = series.vanchart;
            var isColumn = series.type == Constants.COLUMN_CHART, inverted = vanchart.isInverted();
            var startKey = 'x', stackKey = 'y';
            if(!isColumn){
                startKey = 'y'; stackKey = 'x';
            }

            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);

            var baseAxis = series[startKey + 'Axis'];
            var stackAxis = series[stackKey + 'Axis'];


            var basePos = stackAxis.getZeroPos();
            var axisLineWith = 0;
            if (baseAxis.isOnZero()) {
                axisLineWith = baseAxis.options.lineWidth;
            }

            this.points.forEach(function(point){
                var options = point.options;

                var startPos = baseAxis.scale(baseAxis.getAxisValue(options[startKey], point));
                var stackPrePos = stackAxis.scale(options[stackKey + '0']);

                // 8.5.0startPosValue
                var stackCurrentPos = stackAxis.scale(stackAxis.getAxisValue(options[stackKey], point) + options[stackKey + '0']);

                if (stackPrePos === Infinity) {
                    stackPrePos = stackAxis.scale.range()[0];
                }

                var rectX, rectY, rectWidth, rectHeight;
                rectX = startPos + ow.offset - ow.width / 2;
                rectY = Math.min(stackPrePos, stackCurrentPos);
                rectWidth = ow.width;
                rectHeight = Math.abs(stackPrePos - stackCurrentPos);

                if (rectY === basePos) {
                    rectY += axisLineWith / 2;
                    rectHeight -= axisLineWith / 2;
                } else if (rectY + rectHeight === basePos) {
                    rectHeight -= axisLineWith /2;
                }
                rectHeight = Math.max(rectHeight, 0);

                var rect = {};
                if(showAsColumn){
                    rect.x = rectX; rect.y = rectY; rect.width = rectWidth; rect.height = rectHeight;
                }else{
                    rect.x = rectY; rect.y = rectX; rect.width = rectHeight; rect.height = rectWidth;
                }

                point.rect = BaseUtils.rectSubPixelOpt(rect, options.borderWidth);
                point.rect.rx = point.rect.ry = point.options.borderRadius;

                if(!point.isNull){
                    series._calculateAnimationInitRect(point, isColumn, inverted);
                }
            });

        },

        getSeriesOffsetAndWidth:function(){
            var series = this, options = series.options;

            var columnCount = 0, stackedMap = {};
            var columnIndex = 0;//start from 0
            var allPointsCount = 0;

            var chartSeries = this.vanchart.seriesOfType(this.type);

            var baseAxisType = this.getBaseAxisType();

            chartSeries.forEach(function(otherSeries){

                if(otherSeries[baseAxisType] == series[baseAxisType] && otherSeries.visible){

                    if(otherSeries.stack && !stackedMap[otherSeries.stack]){
                        columnCount++;
                        stackedMap[otherSeries.stack] = true;

                        if(series.stack && series.stack == otherSeries.stack){
                            columnIndex = columnCount - 1;
                        }

                    }else if(!otherSeries.stack){
                        columnCount++;
                        if(series == otherSeries){
                            columnIndex = columnCount - 1;
                        }
                    }
                }

                if(otherSeries[baseAxisType] == series[baseAxisType]){
                    allPointsCount += otherSeries.points.length;
                }
            });

            var categoryAxis = series[baseAxisType];

            var width = 0, offset = 0;

            if(categoryAxis.isCategory()) {

                var categoryGap = options.categoryGap, gap = options.gap, tickLength = categoryAxis.getTickLength();

                categoryGap = BaseUtils.getPercentValue(categoryGap, tickLength);

                var seriesGap;
                
                // @Cmen:CHART-889
                var defaultWidth = (tickLength - categoryGap) / columnCount; //  
                var defaultOffset = categoryGap / 2 + defaultWidth * (columnIndex + 0.5);  //  

                if(parseFloat(gap) >= 0) {  // 
                    seriesGap = BaseUtils.getPercentValue(gap, defaultWidth); 
                    offset = defaultOffset; 
                    width = defaultWidth - seriesGap; 
                }else{  // 
                    seriesGap = Math.abs(BaseUtils.getPercentValue(gap, tickLength - categoryGap));
                    width = (tickLength - categoryGap - seriesGap) / columnCount;
                    offset = categoryGap / 2 + width * (columnIndex + 0.5) + seriesGap * 0.5;   // offset
                    width += seriesGap;
                }

            } else {
                var rangeLength = categoryAxis._getRange();
                rangeLength = Math.abs(rangeLength[1] - rangeLength[0]);

                width = rangeLength/allPointsCount/3;
                offset = 0;
            }
            // seriesWidth,Axis.adjustDomain4Radius
            this._seriesWidth = BaseUtils.hasDefined(options.width) ? options.width : Math.max(width, MIN_BAR_SIZE);
            return {
                width: this._seriesWidth,
                offset:offset
            }
        },

        _getPointKey: function (point) {
            if(this.isMultiCategoryAxisBased()){
                return BaseUtils.encodeCategoryArray(point.categoryArray);
            }
            return this.type == Constants.BAR_CHART ? point.y : point.x;
        },

        getTargetKey:function(){
            return this.type == Constants.BAR_CHART  ? 'x' : 'y';
        },

        //key
        getBaseAxisType: function () {
            return this.type == Constants.COLUMN_CHART ? 'xAxis' : 'yAxis';
        },

        getTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            var points = sery.points;
            var valueAxis = sery.type == Constants.COLUMN_CHART ? sery.yAxis : sery.xAxis;
            var baseAxis = sery.type == Constants.COLUMN_CHART ? sery.xAxis : sery.yAxis;
            var isHorizontal = baseAxis.isHorizontal(), isAxisReversed = valueAxis.isAxisReversed();

            var bars = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                if(!point.isNull && point.rect){
                    bars.push(point.rect);
                }
            }

            bars.sort(function(a, b){
                return isHorizontal ? a.x - b.x : a.y - b.y;
            });

            bars.forEach(function(barShape){
                var x, y;

                if(isHorizontal){
                    x = barShape.x + barShape.width / 2;
                    y = isAxisReversed ? barShape.y + barShape.height : barShape.y;
                }else{
                    x = isAxisReversed ? barShape.x : barShape.x + barShape.width;
                    y = barShape.y + barShape.height/2;
                }

                xValues.push(x);
                yValues.push(y);
            });

            return [xValues, yValues, baseAxis.getPosition()];
        },

        _calculateAnimationInitRect:function(point, isColumn, inverted){

            var key = isColumn ? 'y' : 'x', options = point.options;
            var valueAxis = point.series[key + 'Axis'], value = valueAxis.getAxisValue(options[key], point);
            var startPos = valueAxis.getStartPos(), isPositive = value >= 0;
            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);
            var location, initRect;

            if(showAsColumn){
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.BOTTOM_TO_TOP;
                    initRect = {
                        x:point.rect.x,
                        y:startPos,
                        width:point.rect.width,
                        height:0
                    };
                }else{
                    location = Constants.TOP_TO_BOTTOM;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:point.rect.width,
                        height:0
                    };
                }
            }else{
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.LEFT_TO_RIGHT;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }else{
                    location = Constants.RIGHT_TO_LEFT;
                    initRect = {
                        x:point.rect.x + point.rect.width,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }
            }

            point.location = location; point.initRect = initRect;
        },

        //
        _calculateLabelPos:function(){
            var series = this;
            series.points.forEach(function(point) {
                if(point.isVisible()){
                    var dataLabels = point.options.dataLabels;
                    if(dataLabels && dataLabels.enabled){
                        point.labelPos = series._calculateAlignLabelPos(point, dataLabels.align);
                    }
                }
            });
        },

        _calculateAlignLabelPos:function(point, align){

            var labelDim = point.labelDim, rect = point.rect, plotBounds = this.vanchart.bounds;
            var plotWidth = plotBounds.width, plotHeight = plotBounds.height;

            var isVertical = point.location == Constants.TOP_TO_BOTTOM || point.location == Constants.BOTTOM_TO_TOP;
            var isPositive = point.location == Constants.BOTTOM_TO_TOP || point.location == Constants.LEFT_TO_RIGHT;
            var centerX = rect.x + rect.width/2, centerY = rect.y + rect.height/2;

            if (!labelDim) {
                return ;
            }

            var x,y;

            switch (align){
                case Constants.CENTER:

                    x = centerX - labelDim.width/2;
                    y = centerY - labelDim.height/2;

                    break;
                case Constants.INSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y + LABEL_GAP : rect.y + rect.height - LABEL_GAP - labelDim.height;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ?  rect.x + rect.width - LABEL_GAP - labelDim.width : rect.x + LABEL_GAP;
                    }

                    break;
                case Constants.OUTSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y - LABEL_GAP - labelDim.height : rect.y + rect.height + LABEL_GAP;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ? rect.x + rect.width + LABEL_GAP : rect.x - LABEL_GAP - labelDim.width;
                    }

                    break;
            }

            return {
                x:x,
                y:y
            }
        },

        /**
         * MoreLabel@OverRide Series.calcMoreLabelPosition
         * @param  {[type]} point            [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var isColumn = this.type == Constants.COLUMN_CHART, inverted = this.vanchart.isInverted(); 
            var chartBounds = this.vanchart.bounds; 
            var startX = 0, startY = 0, direction = "top"; 
 
            if((isColumn && !inverted) || (!isColumn && inverted)){ 
                startX = point.rect.x + point.rect.width / 2; 
                startY = point.rect.y; 
            } else { 
                startX = point.rect.x + point.rect.width; 
                startY = point.rect.y + point.rect.height / 2; 
                direction = "right"; 
            } 
 
            return { 
                startX: startX + chartBounds.x, 
                startY: startY + chartBounds.y, 
                direction: direction 
            } 
        }
    });


    //view related
    Bar.include({

        _getFixedPos:function(point, divDim){

            var plotBounds = this.vanchart.bounds;
            var x,y, rect = point.rect;
            if(point.initRect.height === 0){
                //
                x = plotBounds.x + rect.x + rect.width + TOOLTIP_GAP;
                if(point.location == Constants.BOTTOM_TO_TOP){
                    y = plotBounds.y + rect.y;
                }else{
                    y = plotBounds.y + rect.y + rect.height;
                }

            }else{
                //
                y = plotBounds.y + rect.y + rect.height + TOOLTIP_GAP;

                if(point.location == Constants.LEFT_TO_RIGHT){
                    x = plotBounds.x + rect.x + rect.width - divDim.width;
                }else{
                    x = plotBounds.x + rect.x - divDim.width;
                }

            }
            return [x, y];
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        getFillFilter:function(color, p){

            if(BaseUtils.isSupportSVG()){
                var series = this, options = p.options, vanchart = series.vanchart, renderer = vanchart.renderer;

                if(options.image){

                    var imageX, imageY, rect = p.rect;
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            imageX = rect.x;
                            imageY = rect.y + rect.height % options.imageHeight;
                            break;

                        case Constants.TOP_TO_BOTTOM:
                        case Constants.LEFT_TO_RIGHT:
                            imageX = rect.x;
                            imageY = rect.y;
                            break;

                        case Constants.RIGHT_TO_LEFT:
                            imageX = rect.x + rect.width % options.imageWidth;
                            imageY = rect.y;
                            break;
                    }

                    var patterAttr = {
                        'x':imageX, 'y':imageY, 'width':options.imageWidth, 'height':options.imageHeight,'patternUnits':'userSpaceOnUse'
                    };

                    var imageAttr = {
                        'x':0, 'y':0, 'width':options.imageWidth, 'height':options.imageHeight
                    };

                    if(!p.imagePattern){
                        p.imagePattern = renderer.imagePattern(patterAttr, imageAttr, p.options.image);
                    }else{
                        renderer.updateImagePattern( p.imagePattern, patterAttr, imageAttr, p.options.image);
                    }

                    return "url(#" + BaseUtils.stamp(p.imagePattern) +")";

                }else if(vanchart.options.style == Constants.STYLE_GRADUAL){
                    var x1, y1, x2, y2;
                    x1 = y1 = x2 = y2 = '0%';
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            y1 = '100%';
                            break;
                        case Constants.TOP_TO_BOTTOM:
                            y2 = '100%';
                            break;
                        case Constants.LEFT_TO_RIGHT:
                            x2 = '100%';
                            break;
                        case Constants.RIGHT_TO_LEFT:
                            x1 = '100%';
                            break;
                    }

                    var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
                    var stop1 = {'offset':'0%', 'stop-color':color};
                    var stop2 = {'offset':'100%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.9)};

                    if(p.colorGradient){
                        renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                    }else{
                        p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                    }

                    return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
                }
            }

            return color;
        },

        _calculateAnimationDelay:function(){
            if(this.stack){
                return 0;
            }

            return this.updateDelay(EXIT_ANIMATION_TIME);
        },

        _getStackExitPointDropRect:function (point) {
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;

            if(!preP && !sufP) {
                return point.initRect;
            }
            var rect = (preP ? preP : sufP).rect;
            switch (point.location){
                case Constants.BOTTOM_TO_TOP:
                    return {x:rect.x, y:(preP ? rect.y : rect.y + rect.height), width:rect.width, height:0};
                case Constants.TOP_TO_BOTTOM:
                    return {x:rect.x, y:(preP ? rect.y + rect.height : rect.y), width:rect.width, height:0};
                case Constants.LEFT_TO_RIGHT:
                    return {x:(preP ? rect.x + rect.width : rect.x), y:rect.y, width:0, height:rect.height};
                case Constants.RIGHT_TO_LEFT:
                    return {x:(preP ? rect.x : rect.x + rect.width), y:rect.y, width:0, height:rect.height};
            }
        },

        _getStackReShowPointInitRect:function (point) {
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;

            if(!preP && !sufP) {
                return point.initRect;
            }
            var element = (preP ? preP : sufP).graphic.node();
            var x = parseFloat(element.getAttribute("x")), y = parseFloat(element.getAttribute("y")),
                width = parseFloat(element.getAttribute("width")), height = parseFloat(element.getAttribute("height"));
            switch (point.location){
                case Constants.BOTTOM_TO_TOP:
                    return {x:x, y:(preP ? y : y + height), width:width, height:0};
                case Constants.TOP_TO_BOTTOM:
                    return {x:x, y:(preP ? y + height : y), width:width, height:0};
                case Constants.LEFT_TO_RIGHT:
                    return {x:preP ? x + width : x, y:y, width:0, height:height};
                case Constants.RIGHT_TO_LEFT:
                    return {x:preP ? x : x + width, y:y, width:0, height:height};
            }
        },

        getPointInitAttr:function(point){
            return point.initRect;
        },

        getPointReShowAttr:function (point) {
            var series = point.series;
            return series.stack ? series._getStackReShowPointInitRect(point) : point.initRect;
        },

        getPointInitAnimationAttr:function(point){
            return {
                ease:INIT_EASE,
                duration:INIT_ANIMATION_TIME,
                attr:point.rect}
        },

        getPointReShowAnimationAttr:function (point) {
            return point.series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:point.rect
                } : {
                    ease:RE_SHOW_EASE,
                    duration:RE_SHOW_ANIMATION_TIME,
                    attr:point.rect}
        },

        getPointUpdateAnimationAttr:function(point, delay){
            return  point.series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:point.rect
                } : {
                    delay:delay,
                    ease:UPDATE_EASE,
                    duration:UPDATE_ANIMATION_TIME,
                    attr:point.rect}
        },

        getPointDropAnimationAttr:function(point){
            var series = point.series;
            return series.stack ? {
                    ease:STACK_EASE,
                    duration:STACK_ANIMATION_TIME,
                    attr:series._getStackExitPointDropRect(point)
                } : {
                    ease:EXIT_EASE,
                    duration:EXIT_ANIMATION_TIME,
                    attr:point.initRect}
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, style, true);
        },

        _onPointMouseOut:function(point){
            var series = point.series,style = series.getStyle(point);

            series._onState(point, style, false);
        },

        _onState:function (point, style, isChosen) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.OUTSIDE){
                var diffX = 0, diffY = 0;
                if(isChosen) {
                    switch (point.location) {
                        case Constants.BOTTOM_TO_TOP:
                            diffY -= 3;
                            break;
                        case Constants.TOP_TO_BOTTOM:
                            diffY += 3;
                            break;
                        case Constants.LEFT_TO_RIGHT:
                            diffX += 3;
                            break;
                        case Constants.RIGHT_TO_LEFT:
                            diffX -= 3;
                            break;
                    }
                }
                series._labelTransformState(point, diffX, diffY, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            } else {
                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, BezierEasing.css["ease"]);
            }
        },

        effectAnimation:function (point) {

            var options = point.options, series = point.series, vanchart = series.vanchart, renderer = vanchart.renderer;

            if(options.image){
                return;
            }

            var group = series._getPointEffectGroup(point), rect = point.rect;
            var style = {'fill':'none', 'stroke':point.color, 'stroke-opacity': 0, 'stroke-width':0};

            var width = (point.location === Constants.BOTTOM_TO_TOP || point.location === Constants.TOP_TO_BOTTOM) ? rect.width : rect.height;

            function createEffectG() {
                return renderer.rect().addTo(group).attr(rect).style(style);
            }

            function borderWidth(t) {
                return 0.5 * width * t;
            }

            function getPositiveNumber(num) {
                return num < 0 ? 0 : num; 
            }

            function ani(graphic, delay, time) {

                graphic.style(style)
                    .effectTransition()
                    .delay(delay)
                    .ease('linear')
                    .duration(time)
                    .styleTween('stroke-opacity', function(){return function (t) {return 0.8 * (1-t);}})
                    .styleTween('stroke-width', function(){return borderWidth})
                    .attrTween('x',function(){return function(t){return rect.x - borderWidth(t)/2 + 1;}})
                    .attrTween('y',function(){return function(t){return rect.y - borderWidth(t)/2 + 1;}})
                    .attrTween('width',function(){return function(t){ return getPositiveNumber(rect.width + borderWidth(t) - 2); }})
                    .attrTween('height',function(){return function(t){ return getPositiveNumber(rect.height + borderWidth(t) - 2) ;}})
                ;
            }

            var firstG = group.firstG = group.firstG || createEffectG(),
                secondG = group.secondG = group.secondG || createEffectG(),
                thirdG = group.thirdG = group.thirdG || createEffectG();

            var period = series._getEffectTime(point), scale = period/series.getDefaultEffectTime();
            ani(firstG, 0, 1600 * scale);
            ani(secondG, 600 * scale, 1600 * scale);
            ani(thirdG, 1200 * scale, 1600 * scale);
        },

        getDefaultEffectTime:function () {
            return 2800;
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor ,
                'fill':p.series.getFillFilter(p.mouseOverColor, p),
                'fill-opacity': p.opacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        }
    });

    require('../ChartLibrary').register(Constants.BAR_CHART, Bar);
    require('../ChartLibrary').register(Constants.COLUMN_CHART, Bar);

    return Bar;
});
/**
 * Created by Yuqian on 2017/3/20.
 */

// todo, separate chart in a folder is better

define('chart/PieSeries',['require','../utils/BaseUtils','./Series','../utils/PathGenerator','../utils/Interpolator','../Constants','../utils/BezierEasing'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Series = require('./Series');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');
    var HOVER_PERCENT = 1.1;
    var Constants = require('../Constants');
    var Bezier = require('../utils/BezierEasing');

    var LABEL_GAP = 2;
    var DECREASE = [0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5];
    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';
    var STEP = Math.PI / 180;

    return {

        // calculate pie/multiPie label position
        // 3 things: outside labels pos,
        //           inside labels pos,
        //           lead lines;
        //
        // outside labels may adjust the chart's radius
        // 3 steps for outside labels:
        // 1. ignore minimal arc labels to content each part's height (4 parts);
        // 2. place labels, no overlap (regardless of part bounds)
        // 3. (when not fixed) test if all labels' bounds are within this chart's bounds.
        //    if not, decrease the radius, return to step 1.

        /**
         * place outside labels, get new radius if needed
         * @param {Array} outPoints
         * @param {object} bounds
         * @param {Array} center
         * @param {number} [radius]
         * @returns {number} radius Original radius or new radius
         */
        calcOutsideLabel: function (outPoints, bounds, center, radius) {
            var series = this;

            var pointsGroups = {};

            outPoints.map(function (p) {
                var loc = series.getLocByArc(series.getCenterAngle(p));
                pointsGroups[loc] = pointsGroups[loc] || [];
                !p.isNull && pointsGroups[loc].push(p);   // @CHART-1369
            });

            if (radius) {
                pointsGroups = series.ignoreMin(pointsGroups, radius);// step 1
                series.placeOutSideLabels(pointsGroups, radius);// step 2
                return radius;

            } else {
                radius = Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    var usedR = radius * DECREASE[i];
                    var usedPointsG = series.ignoreMin(pointsGroups, usedR);// step 1
                    series.placeOutSideLabels(usedPointsG, usedR);// step 2

                    if (series.testWithinBounds(usedPointsG, center, bounds)) {// step 3
                        break;
                    }
                }
                return usedR;
            }
        },

        calculateInsideLabelBounds:function(inPoints){
            var series = this;
            inPoints.map(function (a,i) {
                var node = inPoints[i];
                var center = series.getCenterPoint(node);

                var x = center[0] - node.labelDim.width/2;
                var y = center[1] - node.labelDim.height/2;

                node.labelPos = {x:x, y:y};
            });
        },

        calculateLeadLineStartPos:function(outPoints){
            var series = this;
            outPoints.map(function(arcPoint){
                var radius = series._getOuterRadius(arcPoint);
                var centerArc = series.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x: (radius + 1) * Math.sin(centerArc),
                        y: (radius + 1) * Math.cos(centerArc + Math.PI)
                    }
                }
            });
        },

        getCenterAngle:function(node){
            var rotate = this.chartInfo.rotate || 0;
            var centerAngle = rotate + (this._getStartAngle(node) + this._getEndAngle(node)) / 2 ;
            return BaseUtils.makeValueInRange(0, 2 * Math.PI, centerAngle);
        },

        getCenterRadius:function (node) {
            var innerRadius = this._getInnerRadius(node),
                outerRadius = this._getOuterRadius(node);
            return innerRadius + (outerRadius - innerRadius) / 2;
        },

        getCenterPoint:function (node) {
            var centerAngle = this.getCenterAngle(node),
                centerR = this.getCenterRadius(node);
            return this._getArcPoint(centerR, centerAngle);
        },

        getLocByArc: function (arc) {
            arc = arc % (2 * Math.PI);
            if(arc < Math.PI / 2){
                return RIGHT_TOP;
            }else if(arc < Math.PI){
                return RIGHT_BOTTOM;
            }else if(arc < 3 * Math.PI / 2){
                return LEFT_BOTTOM;
            }else{
                return LEFT_TOP;
            }
        },

        // ignore min for 4 parts
        ignoreMin: function (pointsGroups, radius) {
            var result = {};
            for (var i in pointsGroups) {
                pointsGroups[i].map(function (p) { p.labelPos = null; });
                result[i] = this._ignoreMinArcLabel(radius, pointsGroups[i]);
            }
            return result;
        },

        // ignore 1 part
        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //
            if(radius * 1.2 < totalHeight){

                var det = totalHeight - radius * 1.2;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            var series = this;
            arcs.sort(function(a, b){
                return series.getCenterAngle(a) - series.getCenterAngle(b);
            });

            return arcs;
        },

        placeOutSideLabels: function (pointsGroups, radius) {
            var series = this;
            Object.keys(pointsGroups).map(function (key) {
                series.findNiceBounds(true, pointsGroups[key], radius, key) ||
                series.findNiceBounds(false, pointsGroups[key], radius, key)
            });
            // here MUST be true.
            // for we have ignored min arcs, the problem is how to place them.
            // the solution now is incomplete though.
            // return true;
        },

        findNiceBounds:function(isAngleIncrease, arcPoints, usedR, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var angleRange = this._getStartAndEndAngle(location);

            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;

            var preBounds;
            var preArc;

            arcPoints.map(function (p) {
                p.labelPos = null;
            });

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var compare = isAngleIncrease ? Math.max : Math.min;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerArc = this.getCenterAngle(point);

                centerArc = preArc ? compare(centerArc, preArc) : centerArc;

                var found = false;
                for(var arc = centerArc; (isAngleIncrease ? arc < searchEnd : arc > searchEnd); arc += step){

                    var centerX = outerR * Math.sin(arc);
                    var centerY = outerR * Math.cos(arc + Math.PI);

                    var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);
                    if ((preBounds ? !this._isOverlapOrShadow(preBounds, bounds) : true)
                    ) {
                        found = true;
                        preArc = arc;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }

                var midPos = {x:centerX, y:centerY};
                var endPos;
                if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                    endPos = {x:centerX + hWidth, y:centerY};
                }else{
                    endPos = {x:centerX - hWidth, y:centerY};
                }

                preBounds = bounds;
                point.labelPos = {
                    x:bounds.x,
                    y:bounds.y,

                    midPos:midPos,
                    endPos:endPos
                };
            }

            return true;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LABEL_GAP;
            }else{
                x = centerX - hWidth - LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        // 1. judge overlapped
        // 2. the Y pos should not exceed the previous's half
        _isOverlapOrShadow: function (a, b) {
            var topHalfMinY = Math.max(a.y, b.y);
            var topHalfMaxY = Math.min(a.y + a.height / 2, b.y + b.height / 2);
            var bottomHalfMinY = Math.max(a.y + a.height / 2 , b.y + b.height / 2);
            var bottomHalfMaxY = Math.min(a.y + a.height, b.y + b.height);

            return BaseUtils.rectangleOverlapped(a, b) ||
                topHalfMinY <= topHalfMaxY || bottomHalfMinY <= bottomHalfMaxY;
        },

        testWithinBounds: function (pointsGroups, center, wholeBounds) {
            for (var i in pointsGroups) {
                var bounds, x, y, width, height;
                x = y = 0;
                switch (i) {
                    case RIGHT_TOP:
                    case RIGHT_BOTTOM:
                        y = wholeBounds.y - center[1];
                        width = wholeBounds.width + wholeBounds.x - center[0];
                        height = wholeBounds.height;
                        break;
                    case LEFT_BOTTOM:
                    case LEFT_TOP:
                        x = wholeBounds.x - center[0];
                        y = wholeBounds.y - center[1];
                        width = -x;
                        height = wholeBounds.height;
                        break;
                }
                bounds = {x: x, y: y, width: width, height: height};

                for (var j = 0; j < pointsGroups[i].length; j++) {
                    var p = pointsGroups[i][j];
                    if (!p.labelPos) {
                        continue;
                    }
                    var pBounds = {
                        x: p.labelPos.x,
                        y: p.labelPos.y,
                        width: p.labelDim.width,
                        height: p.labelDim.height
                    };
                    if (!BaseUtils.containsRect(bounds, pBounds)) {
                        return false;
                    }
                }
            }
            return true;
        },

        //
        _changeInnerRadius:function (d) {
            return d.depth > 1 && d.options.tooltip && d.options.tooltip.shared;
        },

        _onPointState:function (d, isChosen, style, attr) {
            var series = this;
            var arc = PathGenerator.arc();
            var startAngle = series._getStartAngle(d), endAngle = series._getEndAngle(d),
                innerRadius = series._getInnerRadius(d), outerRadius = series._getOuterRadius(d);

            var inRadiusScale = series._changeInnerRadius(d) ? HOVER_PERCENT : 1;
            var outStartRadius = outerRadius * HOVER_PERCENT, outEndRadius = outerRadius,
                inStartRadius = innerRadius * inRadiusScale, inEndRadius = innerRadius, duration = 400;
            if(isChosen){
                outStartRadius = outerRadius;outEndRadius = outerRadius * HOVER_PERCENT; duration = 300;
                inStartRadius = innerRadius; inEndRadius = innerRadius * inRadiusScale;
            }
            var outInterpolate = Interpolate(outStartRadius, outEndRadius),
                inInterpolate = Interpolate(inStartRadius, inEndRadius),
                arcData = {startAngle:startAngle, endAngle:endAngle, innerRadius:innerRadius};

            d.graphic.style(style)
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    ease:Bezier.css["ease-out-back"],
                    duration:duration,
                    attr:attr,
                    attrTween:{'d':function(){return function (t) {return arc.outerRadius(outInterpolate(t)).innerRadius(inInterpolate(t))(arcData);};}}
                });
        },

        _onTextState:function (point, isChosen) {
            var series = this;
            if(!point.labelPos){
                return;
            }

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            var trans = series._labelTrans(point);

            var centerAngle = series.getCenterAngle(point);
            if(align == Constants.INSIDE && isChosen) {
                var inRadiusScale = series._changeInnerRadius(point) ? HOVER_PERCENT : 1;//

                var innerR = series._getInnerRadius(point) * inRadiusScale,
                    outerR = series._getOuterRadius(point) * HOVER_PERCENT,
                    centerR = innerR + (outerR - innerR) / 2;
                trans = series._getArcPoint(centerR, centerAngle);
            } else if(align == Constants.OUTSIDE && isChosen){
                var diffR = series._getOuterRadius(point) * (HOVER_PERCENT - 1),
                    diffP = series._getArcPoint(diffR, centerAngle),
                    diffX = diffP[0], diffY = diffP[1];

                trans = {x:trans.x + diffX, y:trans.y + diffY};
            }

            var duration = isChosen ? 300 : 400, ease = Bezier.css["ease-out-back"];
            var paras = point.textGraphic.type === 'div' ? {duration: duration, ease: ease,
                    style: {'transform': 'translate(' + trans.x + 'px,' + trans.y + 'px)'}} : {duration: duration, ease: ease,
                    attr: {'transform': BaseUtils.makeTranslate(trans)}};

            point.textGraphic && point.textGraphic.animate(paras);

            if(align == Constants.OUTSIDE) {
                series._outSideLabelColorState(point, isChosen, duration, ease);
                series._leadLineState(point, diffX, diffY, isChosen, duration, ease);
            }
        },


        _getInnerRadius: function (d) {
            return d.innerRadius;
        },

        _getOuterRadius: function (d) {
            return d.outerRadius;
        },

        _getStartAngle: function (d) {
            return d.startAngle;
        },

        _getEndAngle: function (d) {
            return d.endAngle;
        },

        _getPositionInPie:function(absPos){

            var x = absPos.x - this.chartInfo.centerX;

            var y = absPos.y - this.chartInfo.centerY;

            return {x:x, y:y};
        },

        _isRotatable:function(){
            return BaseUtils.isSupportSVG() && this.options.rotatable;
        },

        onPanStart:function(ev){
            if(!this._isRotatable()){
                return;
            }

            this.initPos = ev.containerPoint;

            this.initRotate = BaseUtils.toDegree(this.chartInfo.rotate);
        },

        onPanMove:function(ev){
            if(!this._isRotatable()){
                return;
            }

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos));

            var newAngle = this._getAngle(this._getPositionInPie(ev.containerPoint));

            var rotate = newAngle - startAngle + this.initRotate;

            this._getPointGraphicGroup().attr("transform", "rotate(" + rotate + ")");

            this.chartInfo.rotate = BaseUtils.toRadian(rotate);

            this._calculateLabelPosWhenRadiusFixed();

            this._rotateLabels();
        },

        onPanEnd:function(ev){
            this.vanchart.handler.panTarget = null;
        },

        getEvents:function(){
            return BaseUtils.extend(Series.prototype.getEvents.call(this),
                {
                    'panstart':this.onPanStart,
                    'panmove':this.onPanMove,
                    'panend':this.onPanEnd
                });
        },

        _rotateLabels:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = this.textLabelGroup;
            series.getDataToDraw().forEach(function(point){

                if(point.textGraphic && !point.labelPos){
                    point.textGraphic.remove();
                    point.leadLine && point.leadLine.remove();
                    point.textGraphic = null, point.leadLine = null;
                }else if(point.textGraphic && point.labelPos){

                    point.textGraphic
                        .interrupt(Constants.SELECT_ANIMATION)
                        .attr('transform', BaseUtils.makeTranslate(series._labelTrans(point)));

                    if(point.labelPos.startPos){
                        if(point.leadLine){
                            point.leadLine.attr('d', series._getLeadLinePath(point));
                        }else{
                            point.leadLine = series._getLeadLine(point);
                        }
                    }
                }else if(!point.textGraphic && point.labelPos){
                    series._createTextGraphic(point);
                }
            });
        }
    }
});

/**
 * Created by shine on 2016/12/19.
 */
define('EffectHelper',['require','./utils/BaseUtils','./utils/PathGenerator','./utils/BezierEasing','./vector/Transition','./vector/shape/Path','./vector/shape/LayerGroup','./dom/Browser'],function(require) {
    var BaseUtils = require('./utils/BaseUtils');
    var PathGenerator = require('./utils/PathGenerator');
    var BezierEasing = require('./utils/BezierEasing');
    var Transition = require('./vector/Transition');
    var Path = require('./vector/shape/Path');
    var LayerGroup = require('./vector/shape/LayerGroup');
    var Browser = require("./dom/Browser");

    var PATH = 'M-56,0a56,16 0 1,0 112,0a56,16 0 1,0 -112,0';

    function pointMapEffectAnimation(layer, d) {
        var series = d.series, vanchart = series.vanchart;

        var period = series._getEffectTime(d);

        var getPosition = function (){
            var latlng = d.getLatLng(), pixels = latlng && vanchart.latLngToLayerPoint(latlng) || {x:0, y:0};
            return {
                x: pixels.x,
                y: pixels.y
            }
        };
        function bottom_to_top() {
            var pos = getPosition();   // 
            return function (t) {
                return BaseUtils.makeTranslate3d({x:pos.x, y:pos.y - 25 * t});
            }
        }

        function top_to_bottom() {
            var pos = getPosition();
            return function (t) {
                return BaseUtils.makeTranslate3d({x:pos.x, y:pos.y - 25 * (1-t)});
            }
        }


        //todo:node element ?
        new Transition({node:function () {return layer._icon;}}, "point-map-effect")
        // .interrupt("point-map-effect")
            .ease(BezierEasing.css["ease-out-quint"])
            .duration(0.25 * period)
            .styleTween('transform', bottom_to_top)
            .transition()
            .ease(BezierEasing.css["ease-in-quint"])
            .duration(0.25 * period)
            .styleTween('transform', top_to_bottom)
            .transition()
            .ease(BezierEasing.css["ease-out-quint"])
            .duration(0.25 * period)
            .styleTween('transform', bottom_to_top)
            .transition()
            .ease(BezierEasing.css["ease-in-quint"])
            .duration(0.25 * period)
            .styleTween('transform', top_to_bottom);

        var initStyle = {'fill-opacity': 0, 'fill': d.color};

        var layerGroup = d.effectGraphic = d.effectGraphic || new LayerGroup().addTo(vanchart.getEffectLayer());

        function createEffectG() {
            return new Path().addTo(layerGroup)._path.style(initStyle).attr('d', PATH);
        }

        var iconSize = d.options.icon.iconSize, initScale = iconSize[0]/90;//90path90

        var pos = getPosition();
        var trans = BaseUtils.makeTranslate({x: pos.x, y: pos.y}),
            initTrans = trans + ' scale(' + initScale + ')';

        function ani(graphic, delay, time) {
            graphic.style(initStyle).attr('transform', initTrans);

            graphic
                .effectTransition()
                .delay(delay)
                .ease('linear')
                .duration(time)
                .attrTween('transform', function () {
                    return function (t) {
                        return trans + 'scale(' + (initScale + initScale*1.4*t) + ')';
                    }
                })
                .styleTween('fill-opacity', function () {
                    return function (t) {
                        return 0.6 * (1-t);
                    }
                })
        }

        var firstG = layerGroup.firstG = layerGroup.firstG || createEffectG(),
            secondG = layerGroup.secondG = layerGroup.secondG || createEffectG(),
            thirdG = layerGroup.thirdG = layerGroup.thirdG || createEffectG();

        var scale = period / series.getDefaultEffectTime();
        ani(firstG, 0, 2000 * scale);
        ani(secondG, 600 * scale, 2000 * scale);
        ani(thirdG, 1200 * scale, 2000 * scale);

    }

    //
    function areaStyleEffectAnimation(d, transX, transY) {
        var paras = _calculateParas(d, transX, transY);

        d.graphic
            .attr('transform-origin', 'center')
            .effectTransition()
            .ease(BezierEasing.css["ease-out-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.firstTweenFun)
            .attr('transform', paras.translate + 'scale(1.05)')
            .transition()
            .ease(BezierEasing.css["ease-in-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.secondTweenFun)
            .attr('transform', paras.translate + 'scale(1)')
    }

    function areaMapEffectAnimation(layer, d) {
        var paras = _calculateParas(d);

        layer._path
            .style("filter", null)  // style['filter']= "none"
            .effectTransition()
            .ease(BezierEasing.css["ease-out-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.firstTweenFun)
            .attr("fill-opacity", 1)   // webkitattr:,chromeoperahttps://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
            .transition()
            .ease(BezierEasing.css["ease-in-quad"])
            .duration(0.5 * paras.period)
            .attrTween('filter', paras.secondTweenFun)
            .attr("fill-opacity", 0)
    }

    function _calculateParas(d, transX, transY) {
        var series = d.series, vanchart = series.vanchart, renderer = vanchart.renderer;

        d.effectShadowFilter = d.effectShadowFilter || renderer.createDropShadowFilter(3, 3, 0.75, 5, 91/255, 91/255, 91/255);
        var filterID = 'url(#' + BaseUtils.stamp(d.effectShadowFilter) + ')';
        var period = series._getEffectTime(d);

        var translate = (isNaN(transX) || isNaN(transY)) ? '' : BaseUtils.makeTranslate({x:transX, y:transY})

        function firstTweenFun() {
            return function (t) {
                renderer.updateDropShadowFilter &&
                renderer.updateDropShadowFilter(d.effectShadowFilter, 3 * t, 3 * t, t * 0.75, t * 5, 91/255, 91/255, 91/255);
                return filterID;
            }
        }

        function secondTweenFun() {
            return function (t) {
                renderer.updateDropShadowFilter &&
                renderer.updateDropShadowFilter(d.effectShadowFilter, 3 * (1-t), 3 * (1-t), (1-t) * 0.75, (1-t) * 5, 91/255, 91/255, 91/255);
                return filterID;
            }
        }

        return {
            period:period,
            translate:translate,
            firstTweenFun:firstTweenFun,
            secondTweenFun:secondTweenFun
        }
    }

    function bubbleEffectAnimation(d, isMap) {
        forceBubbleEffectAnimation(d, null, isMap);
    }

    function forceBubbleEffectAnimation(d, trans, isMap) {
        var style = {'fill-opacity': 0, 'stroke':'none', 'fill': d.color};

        var arc = PathGenerator.arc().innerRadius(d.radius).startAngle(0).endAngle(360);

        function path(t) {
            return arc({outerRadius:d.radius + t * d.radius * 1.5})
        }

        _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style, 'pathFun':path, 'trans':trans});
    }

    function markerEffectAnimation(d, isMap) {
        var marker = d.options.marker;

        if(marker && marker.symbol){
            var markerType = marker.symbol, radius = marker.radius;

            if (BaseUtils.isImageMarker(markerType)){
                return;
            }

            var style = {'fill':'none', 'stroke':marker.fillColor, 'stroke-width':0, 'stroke-opacity':0};

            function borderWidth(t) {
                return t * radius * 2.5;
            }

            function path(t) {
                return PathGenerator.getMarkerPath(markerType, radius + borderWidth(t)/2 - 1);
            }

            _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style,
                'opacityKey':'stroke-opacity', 'pathFun':path, 'borderFun':borderWidth});

        } else {
            _nullMarkerEffectAnimation(d, isMap);
        }
    }

    function _nullMarkerEffectAnimation(d, isMap) {
        var marker = d.options.marker, radius = marker.radius;

        var style = {'fill-opacity': 0, 'stroke':'none', 'fill': marker.fillColor};

        var arc = PathGenerator.arc().innerRadius(0).startAngle(0).endAngle(360);

        function path(t) {
            return arc({outerRadius: t * radius * 3.5})
        }

        _markerStyleAnimation(d, {'isMap':isMap, 'initStyle':style, 'pathFun':path});
    }

    //
    function _markerStyleAnimation(d, options) {
        var series = d.series, vanchart = series.vanchart, renderer = vanchart.renderer;
        var initStyle = options.initStyle, trans = options.trans || {x:d.posX, y:d.posY};

        var group, createEffectGFun;
        if(options.isMap) {
            var latlng = d.getLatLng(), pixels = vanchart.latLngToLayerPoint(latlng);
            trans = pixels;
            group = d.effectGraphic = d.effectGraphic || new LayerGroup().addTo(vanchart.getEffectLayer());

            createEffectGFun = function createEffectG() {
                return new Path().addTo(group)._path.style(initStyle)
                    .attr('transform', BaseUtils.makeTranslate(trans));
            }
        } else {
            group = series._getPointEffectGroup(d)
                .attr('transform', BaseUtils.makeTranslate(trans));
            createEffectGFun = function createEffectG() {
                return renderer.path().addTo(group).style(initStyle);
            }
        }

        function ani(graphic, delay, time) {
            graphic
                .style(initStyle)
                .effectTransition()
                .delay(delay)
                .ease('linear')
                .duration(time)
                .styleTween('stroke-width', function () {
                    return options.borderFun;
                })
                .styleTween(options.opacityKey || 'fill-opacity', function () {
                    return function (t) {
                        return 0.3 * (1-t);
                    }
                })
                .attrTween('d', function () {
                    return options.pathFun;
                })
        }

        var firstG = group.firstG = group.firstG || createEffectGFun(),
            secondG = group.secondG = group.secondG || createEffectGFun(),
            thirdG = group.thirdG = group.thirdG || createEffectGFun();

        var period = series._getEffectTime(d), scale = period / series.getDefaultEffectTime();
        ani(firstG, 0, 1600 * scale);
        ani(secondG, 440 * scale, 1600 * scale);
        ani(thirdG, 880 * scale, 1600 * scale);
    }

    return {
        MARKER_EFFECT_TIME:2560,
        markerEffectAnimation:markerEffectAnimation,
        bubbleEffectAnimation:bubbleEffectAnimation,
        AREA_STYLE_EFFECT_TIME:2000,
        areaStyleEffectAnimation:areaStyleEffectAnimation,
        areaMapEffectAnimation:areaMapEffectAnimation,
        POINT_MAP_EFFECT_TIME:3200,
        pointMapEffectAnimation:pointMapEffectAnimation,
        forceBubbleEffectAnimation:forceBubbleEffectAnimation
    };
});
/**
 * Created by eason on 15/7/13.
 */

define('chart/Pie',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','./Series','./PieSeries','../utils/BoundsManager','../utils/BezierEasing','../EffectHelper','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Series = require('./Series');
    var PieSeries = require('./PieSeries');
    var BoundsManager = require('../utils/BoundsManager');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');

    var CIRCLE = 2 * Math.PI;
    var HOVER_PERCENT = 1.1;
    var MAGIC_DET = 3;//3px
    
    var ANIMATION_TIME = 1000;
    var EASE = 'bounce';

    var SORT_EASE = Bezier.css.swing;
    var SORT_TIME = 400;

    var Pie = Series.extend({

        _getAxisTypes:function(){
            return [];
        },

        doLayout:function(){

            //
            var seriesBounds = this._calculateSeriesBounds(), pie = this;
            if(!seriesBounds && (!this.options.radius && !this.options.center)){
                throw new Error('pie has no bounds');
            }
            var centerX, centerY, radius;
            if(seriesBounds){
                radius = this.options.radius || Math.min(seriesBounds.width/2, seriesBounds.height/2);
                centerX = seriesBounds.x + seriesBounds.width/2;
                centerY = seriesBounds.y + seriesBounds.height/2;
                this.bounds = seriesBounds;
            }else{
                radius = this.options.radius;
                centerX = this._getPercentValue(this.options.center[0], this.vanchart.width);
                centerY = this._getPercentValue(this.options.center[1], this.vanchart.height);
            }
            var rotate = this.chartInfo && this.chartInfo.rotate || 0;
            this.chartInfo = {radius:radius, centerX:centerX, centerY:centerY, rotate:rotate};

            //
            var pieLayout = PieLayout()
                .value(function(d){
                    return pie.options.roseType == Constants.SAME_ARC ? 1 : Math.abs(d.getTargetValue());
                })
                .startAngle(pie.startAngle).endAngle(pie.endAngle);

            var points = this.points.filter(function(p){return p.isVisible()});
            var series = this;

            points.forEach(function(point){
                point.lastShape = series._getArcData(point);
            });

            pieLayout(points);
        },

        _getFixedPos:function(datum, divDim){

            var plotBounds = this.vanchart.bounds;

            var pieConfig = datum.series.chartInfo;

            var translateX = pieConfig.centerX;
            var translateY = pieConfig.centerY;

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.outerRadius * HOVER_PERCENT;

            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },

        // 12345radius
        // chartInfo.radius - 
        // 1. options.radius: radius, 
        //    
        // 2. bounds/2 : radius
        // 3. chartInfo.seriesMinRadius: radius (CHART-947)

        _calculateLabelPos:function(){
            var roseType = this.options.roseType, points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.options.dataLabels;
                if(point.visible && dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            //
            this._calculateOutsideLabelBounds(outPoints);

            if (!this.options.radius) {
                //,
                if ((inPoints.length && !outPoints.length) || (!inPoints.length && !outPoints.length)) {
                    this.chartInfo.radius = this.chartInfo.radius / HOVER_PERCENT - MAGIC_DET;
                }
            }


            //
            var innerRadius = this.options.innerRadius, radius = this.chartInfo.radius;
            if(innerRadius){
                if(typeof innerRadius == 'string' && innerRadius.indexOf('%') != -1){
                    innerRadius = parseFloat(innerRadius) * radius / 100;
                }else{
                    innerRadius = parseFloat(innerRadius);
                }
            }

            this.chartInfo.innerRadius = innerRadius;

            this.points.forEach(function(d){
                d.innerRadius = innerRadius;
            });

            //
            if(roseType){
                var radiusGap = radius - innerRadius;
                var maxValue = 0;
                points.forEach(function(d){
                    maxValue = Math.max(maxValue, Math.abs(d.getTargetValue()));
                });
                var sizePerValue = radiusGap / maxValue;
                //maxValue0
                if(isNaN(sizePerValue) || !isFinite(sizePerValue)){
                    sizePerValue = 0;
                }
                points.forEach(function(d){
                    d.outerRadius = innerRadius + sizePerValue * Math.abs(d.getTargetValue());
                })
            }else{
                this.points.forEach(function(d){d.outerRadius = radius;});//inVisibleout
            }

            this.calculateLeadLineStartPos(outPoints);

            //
            this.calculateInsideLabelBounds(inPoints);
        },

        // in fact, seriesMinRadius is like a flag
        // chartInfo.radius is the value key
        // see _calculateOutsideLabelBounds
        adjustRadius: function (radius) {
            if (this.chartInfo.radius !== radius) {
                this.chartInfo.seriesMinRadius = radius;
                this.chartInfo.radius = radius;
                this._calculateLabelPos();
            }
        },

        _calculateLabelPosWhenRadiusFixed:function(){
            var points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            this._calculateLabelBoundsForFixed([this.chartInfo.centerX, this.chartInfo.centerY], this.chartInfo.radius, outPoints);

            this.calculateLeadLineStartPos(outPoints);

            //
            this.calculateInsideLabelBounds(inPoints);
        },

        _calculateOutsideLabelBounds:function(outPoints){
            if(!outPoints.length){
                return ;
            }

            var configRadius = this.options.radius || this.chartInfo.seriesMinRadius;

            //
            outPoints.forEach(function(arc){arc.labelPos = null;});

            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            if(!configRadius){
                this.chartInfo.radius = this.calcOutsideLabel(outPoints, this.bounds, center);
            }else{
                this.calcOutsideLabel(outPoints, this.bounds, center, radius);
            }

        },

        //,
        _calculateLabelBoundsForFixed:function(center, radius, outPoints){
            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            this.calcOutsideLabel(outPoints, this.bounds, center, radius);
        },

        //,,,,
        //,,
        _calculateSeriesBounds:function(){
            var series = this.vanchart.seriesOfType(Constants.PIE_CHART);
            var plotBounds = this.vanchart.bounds;
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].options.center && series[i].options.radius){
                    fixedSize++;
                }
            }

            //
            var averageSize = plotBounds.width / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.options.center){
                        return {
                            x:plotBounds.x + i * averageSize,
                            y:plotBounds.y,
                            width:averageSize,
                            height:plotBounds.height
                        }
                    }
                }
            }
        },

        _getTranslate:function(){
            return [this.chartInfo.centerX, this.chartInfo.centerY];
        },

        _getArcData:function(d){
            if(BaseUtils.hasDefined(d.startAngle)){
                return {
                    startAngle: d.startAngle,
                    endAngle: d.endAngle,
                    outerRadius:d.outerRadius,
                    innerRadius:d.series.chartInfo.innerRadius
                };
            }
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point  [description]
         * @param  {[type]} divDim [description]
         * @return {[type]}        [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var pieConfig = point.series.chartInfo; 
 
            var translateX = pieConfig.centerX; 
            var translateY = pieConfig.centerY; 
 
            var centerAngle = this.getCenterAngle(point); 
            var tmpR = point.series.chartInfo.innerRadius + (point.outerRadius - point.series.chartInfo.innerRadius) / 2; 
            var pos = this._getArcPoint(tmpR, centerAngle); 
 
            return { 
                startX: translateX + pos[0], 
                startY: translateY + pos[1], 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getHighLightStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.mouseOverColor || p.color, p),
                'fill-opacity': p.opacity,
                'stroke': p.borderColor || p.mouseOverColor || p.color,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity': p.borderOpacity
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke': p.borderColor || p.mouseOverColor || p.color,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity': p.borderOpacity
            }
        },

        getAttrs:function(p){
            var arc = PathGenerator.arc().innerRadius(p.innerRadius);
            return {'d':arc(this._getArcData(p))};
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _calculateAnimationDelay:function(){

            var visiblePoint = 0, graphicCount = 0;
            for(var i = 0, len = this.points.length; i < len; i++){
                var point = this.points[i];
                if(point.visible && point.series.visible){
                    visiblePoint++;
                }

                if(point.graphic){
                    graphicCount++;
                }
            }

            return graphicCount == visiblePoint ? 0 : 1;
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series;

            var arc = PathGenerator.arc();

            return {
                ease:series.initialAnimationMoving ? Bezier.css["ease-out-cubic"] : EASE,
                duration:ANIMATION_TIME,
                attrTween:{'d':function(){
                    var currentArc;

                    if(series.initialAnimationMoving) {
                        currentArc = {startAngle: point.startAngle - CIRCLE, endAngle: point.endAngle - CIRCLE, outerRadius:0, innerRadius:0};
                    } else {
                        var prePoint = series.getPreVisiblePoint(point);
                        if(prePoint == 'first'){
                            currentArc = {startAngle: series.startAngle, endAngle: series.startAngle, outerRadius:point.outerRadius};
                        } else if(prePoint.lastShape){
                            var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                            var sliceStart = point.startAngle + preGap;
                            currentArc = {startAngle: sliceStart, endAngle: sliceStart, outerRadius: point.outerRadius};
                        } else {
                            currentArc = {startAngle: point.startAngle, endAngle: point.endAngle, outerRadius: point.outerRadius, innerRadius: point.innerRadius};
                        }
                    }

                    var interpolate = Interpolate(currentArc, series._getArcData(point));
                    this._current_ = interpolate(1);

                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            }
        },

        getPointUpdateAnimationAttr:function(point, delay){
            var series = point.series, vanchart = series.vanchart;
            var arc = PathGenerator.arc();
            var easeFunc = EASE, animationTime = ANIMATION_TIME;
            if(vanchart.orderType === Constants.DESCENDING || vanchart.orderType == Constants.ASCENDING){//
                easeFunc = SORT_EASE; animationTime = SORT_TIME;
            }
            return {
                ease:easeFunc,
                duration:animationTime,
                attrTween:{'d':function(){
                    var arcData = series._getArcData(point), currentArc = this._current_ || arcData;
                    var interpolate = Interpolate(currentArc, arcData);
                    this._current_ = interpolate(1);
                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            }
        },

        getPointDropAnimationAttr:function(point){
            var series = point.series, options = series.options, startAngle = series.startAngle;
            var arc = PathGenerator.arc();

            return {
                ease:EASE,
                duration:ANIMATION_TIME,
                attrTween:{'d': function(){
                    var current = this._current_;

                    var prePoint = series.getPreVisiblePoint(point);

                    var terminateAngle = startAngle;

                    if(prePoint != 'first' && prePoint.lastShape){
                        var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                        terminateAngle = point.startAngle + preGap;
                    }

                    var end = series._getArcData(point);
                    end.startAngle = end.endAngle = terminateAngle;

                    var interpolate = Interpolate(current , end);
                    this._current_ = interpolate(1);    
                    return function (t) {
                        return arc(interpolate(t));
                    };
                }}
            };
        },

        getPreVisiblePoint:function(point){
            var points = point.series.points, prePoint = 'first';
            for(var i = 0, len = points.length; i < len; i++){
                if(points[i] != point){
                    if(points[i].visible){
                        prePoint = points[i];
                    }
                }else{
                    return prePoint;
                }
            }
            return prePoint;
        },

        getFillFilter:function(color, p){
            var series = this, options = series.vanchart.options;
            if(options.style == Constants.STYLE_GRADUAL && BaseUtils.isSupportSVG()){

                var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

                var attrs = {'cx':"0%", 'cy':"0%", 'r':Math.max(p.outerRadius, 0) + 'px', "gradientUnits":"userSpaceOnUse"};
                var stop1 = {'offset':(p.innerRadius / Math.max(p.outerRadius, 1)) * 100 + '%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.8)};
                var stop2 = {'offset':'100%', 'stop-color':color};

                if(p.colorGradient){
                    renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                }else{
                    p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2], 'radialGradient');
                }

                return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
            }

            return color;
        },

        _onPointMouseOver:function(point){
            this._onState(point, true);
        },

        _onPointMouseOut:function(point){
            this._onState(point, false);
        },

        _onState:function(point, isChosen){
            var series = this;
            var style = isChosen ? series.getHighLightStyle(point) : series.getStyle(point);
            series._onPointState(point, isChosen, style);

            series._onTextState(point, isChosen)
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.vanchart.renderer.group().addTo(this.group);
            }
            return this.pathGroup;
        },

        _getPointTextLabelGroup:function(){

            if(!this.textLabelGroup){
                this.textLabelGroup = this.vanchart.renderer.vgroup().add();
                this.group.append(this.textLabelGroup.renderG);
            }
            this.textLabelGroup.divG.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));

            return this.textLabelGroup;
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    function PieLayout(){
        var value = Number, startAngle = 0, endAngle = 2 * Math.PI, sum = 0;

        function pie(points) {
            var values = points.map(function(point, i) {
                var v = +value.call(pie, point, i);
                sum += v;
                return v;
            });
            var a = startAngle, da = endAngle - a, k = da / sum;
            points.forEach(function(point, i) {
                point.startAngle = isNaN(a) ? 0 : a;
                point.endAngle = (a += isNaN(values[i] * k) ? 0 : values[i] * k);   // kInfinitystartAngleendAngleNaN
            });
        }

        pie.value = function(_) {
            if (!arguments.length) {
                return value;
            }
            value = _;
            return pie;
        };

        pie.startAngle = function(_) {
            if (!arguments.length) {
                return startAngle;
            }
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) {
                return endAngle;
            }
            endAngle = _;
            return pie;
        };

        return pie;
    }

    Pie.include(PieSeries);

    require('../ChartLibrary').register(Constants.PIE_CHART, Pie);

    return Pie;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Line',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Series','../utils/Class','../utils/BezierEasing','../utils/ColorUtils','../dom/DomUtils','../EffectHelper','../utils/PathGenerator','../ChartLibrary','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Series = require('./Series');
    var Class = require('../utils/Class');
    var Bezier = require('../utils/BezierEasing');
    var ColorUtils = require('../utils/ColorUtils');
    var DomUtils = require('../dom/DomUtils');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');

    var LABEL_GAP = 2;

    var LINE_SHOW_TIME = 1200;
    var LINE_SHOW_EASE = Bezier.css['ease-out-cubic'];

    var LINE_UPDATE_TIME = 250;

    var CHOSEN_AREA_ADD_ALPHA = 0.35;

    var UPDATE_EASE = Bezier.css.swing;

    //for ease-out-cubic
    var calculateT = function(point){
        var det = point.indexFromLeft / (point.series.points.length - 1) || 0; //
        return LINE_SHOW_TIME * Bezier.calculateCubicOutT(det);
    };

    var isValidNumber = function (num){
        return isFinite(num) && !isNaN(num);
    };

    var Line = Series.extend({

        doLayout:function(){

            var series = this, vanchart = series.vanchart, options;

            var xAxis = series.xAxis, yAxis = series.yAxis, connectNulls = series.options.connectNulls;
            var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand()/2 : 0;
            var inverted = vanchart.isInverted(), orderKey = inverted ? 'posY' : 'posX';
            var startValue = yAxis.getStartPosValue();

            var validPoints = [];
            if(this.options.large){
                var xMap = {}, yMap = {};
                series.points.forEach(function(point){
                    options = point.options;
                    var x = xAxis.scale(xAxis.getAxisValue(options.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(options.y, point) + options.y0 - startValue), y0 = yAxis.scale(options.y0);
                    
                    // todo 0Infinitypoint
                    if(!isValidNumber(y)) {
                        point.isNull = true;
                    }

                    if (inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posX0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                    if(!xMap[parseInt(point.posX)] || !yMap[parseInt(point.posY)]){
                        xMap[parseInt(point.posX)] = true;
                        yMap[parseInt(point.posY)] = true;
                        validPoints.push(point);
                    }
                }, this);
            }else{
                validPoints = series.points;
            }

            //points
            series.points = validPoints;

            var inOrder = true, points = [];

            //,
            series.y0 = Number.MAX_VALUE;  series.y = -Number.MAX_VALUE;

            validPoints.forEach(function(point, i){

                options = point.options;

                if(this.options.large){
                    x = point.posX; y = point.posY;
                }else{
                    var x = xAxis.scale(xAxis.getAxisValue(options.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(options.y, point) + options.y0  - startValue), y0 = yAxis.scale(options.y0);

                    if(!isValidNumber(y)) {
                        point.isNull = true;
                    }

                    if (inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posX0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                }

                point.indexFromLeft = i;//delay

                if(!connectNulls || (connectNulls && !point.isNull)){
                    if(points.length > 0){
                        inOrder = inOrder && points[points.length - 1][orderKey] <= x;
                    }
                    points.push(point);
                }

                if (Math.abs(options.y0) < Math.abs(series.y0)){
                    series.y0 = Math.abs(options.y0);
                }
                if (Math.abs(options.y + options.y0) > series.y){
                    series.y = Math.abs(options.y + options.y0);
                }

            }, this);

            if(!inOrder){
                points.sort(function(p1, p2){return p1[orderKey] - p2[orderKey];});
                points.forEach(function(point, i){
                    point.indexFromLeft = i;
                });
            }

            var lineGenerator = PathGenerator.line().interpolate(series.interpolate)
                .x(function (d) {return d.posX;}).y(function (d) {return d.posY;})
                .defined(function (d) {return !d.isNull;});

            var areaGenerator =  PathGenerator.area().interpolate(series.interpolate);
            if (inverted) {
                areaGenerator = areaGenerator
                    .y(function (d) { return d.posY })
                    .x0(function (d) {
                        var pre = series._getPreviousStackingPoint(d);
                        return pre ? pre.posX : d.posX0;
                    })
                    .x1(function (d) { return d.posX })
            } else {
                areaGenerator = areaGenerator
                    .x(function (d) { return d.posX })
                    .y0(function (d) {
                        var pre = series._getPreviousStackingPoint(d);
                        return pre ? pre.posY : d.posY0;
                    })
                    .y1(function (d) { return d.posY })
            }

            areaGenerator = areaGenerator.defined(function (d) {return !d.isNull;});

            this.linePath = lineGenerator(points); this.areaPath = areaGenerator(points);

            this.dataBands = this._calculateDataBands();
        },

        _getPreviousStackingPoint:function(point){

            if(BaseUtils.hasDefined(point.series.stack)){
                var points = point.points;
                for(var i = 0, len = points.length; i < len; i++){
                    var preSeries = points[i].series;
                    if(preSeries.stack == point.series.stack && preSeries.visible && points[i + 1] == point){
                        return points[i];
                    }
                }
            }

        },

        _calculateDataBands:function(){
            var plotBounds = this.vanchart.bounds, series = this, bands = this.options.bands || [];
            var dColor = series.color, dOpacity = series.opacity;
            var dFillColor = series.fillColor, dFillColorOpacity = series.fillColorOpacity;
            var yAxis = series.yAxis, domain = yAxis.scale.domain(), isHorizontal = yAxis.isHorizontal();
            var width = plotBounds.width, height = plotBounds.height;

            var resultRanges = [];

            var isLineChart = this.type === Constants.LINE_CHART;
            var isInverted  = this.vanchart.isInverted();
            var left = 0,
                right = width,
                top = 0,
                bottom = height,
                positionPoints,
                len;
            // 
            if(isLineChart){
                // Y
                if(isInverted){
                    positionPoints = series.points.sort(function (p1, p2){
                        return p1.posY - p2.posY;
                    }), len = positionPoints.length;
                    left = 0;
                    right = width;
                    top = positionPoints[0] ? positionPoints[0].posY - 1 : 0;
                    bottom = positionPoints[len - 1] ? positionPoints[len - 1].posY + 1 : width;
                } else {
                    // X
                    positionPoints = series.points.sort(function (p1, p2){
                        return p1.posX - p2.posX;
                    }), len = positionPoints.length;

                    left = positionPoints[0] ? positionPoints[0].posX - 1 : 0;
                    right = positionPoints[len - 1] ? positionPoints[len - 1].posX + 1 : width;
                    top = 0;
                    bottom = height;
                }
            }

            resultRanges.push({
                clipBounds:{x:left, y:top, width:right - left, height:bottom - top},
                color:dColor, fillColor:dFillColor, fillColorOpacity:dFillColorOpacity
            });

            if(!bands || !bands.length){
                return resultRanges;
            }

            for(var i = 0, len = bands.length; i < len; i++){
                var from = Math.max(domain[0], bands[i].from);
                var to = Math.min(domain[1], bands[i].to);

                from = yAxis.scale(from); to = yAxis.scale(to);

                var clipBounds = {x:0, y:Math.min(from, to), width: width, height: Math.abs(from - to)};

                if(isHorizontal){
                    clipBounds = {x:Math.min(from, to), y:0, width:Math.abs(from - to), height:height};
                }

                resultRanges.push({
                    clipBounds:clipBounds,
                    color:bands[i].color || dColor,
                    opacity:bands[i].opacity || dOpacity,
                    fillColor:bands[i].fillColor || dFillColor,
                    fillColorOpacity:bands[i].fillColorOpacity || dFillColorOpacity
                });
            }

            return resultRanges;
        },

        _getFixedPos:function(datum){

            var radius = datum.options.marker.radius || 4.5;

            var plotBounds = this.vanchart.bounds;

            var x = plotBounds.x + datum.posX + radius;
            var y = plotBounds.y + datum.posY + radius;

            return [x, y];
        },

        //
        _calculateLabelPos:function(){

            var series = this, isInverted = this.vanchart.isInverted(), count = series.points.length;
            var plotBounds = this.vanchart.bounds;

            series.points.forEach(function(point, i){
                var dataLabels = point.options.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    var x, y;
                    var alignTop = dataLabels.align == Constants.TOP, labelDim = point.labelDim;
                    var gap = LABEL_GAP;

                    if(!labelDim){
                        return
                    }
                    
                    var marker = point.options.marker;
                    if(marker && marker.symbol){
                        gap += (marker.radius || 4.5);
                    }

                    if(isInverted){
                        x = alignTop ? (point.posX + gap) : (point.posX - gap - labelDim.width);
                        y = point.posY - labelDim.height/2;

                        if(y <= 0){
                            y = point.posY;
                        }else if(y + labelDim.height >= plotBounds.height){
                            y = point.posY - labelDim.height;
                        }

                    }else{
                        x = point.posX - labelDim.width/2;
                        y = alignTop ? (point.posY - gap - labelDim.height) : (point.posY + gap);

                        if(x <= 0){
                            x = point.posX;
                        }else if(x + labelDim.width >= plotBounds.width){
                            x = point.posX - labelDim.width;
                        }
                    }

                    point.labelPos = {x:x, y:y};
                }
            });

        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        getAttrs:function(point){
            return {'transform':BaseUtils.makeTranslate([point.posX, point.posY])};
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            return { 
                startX: point.posX + chartBounds.x, 
                startY: point.posY + chartBounds.y, 
                direction: "top" 
            } 
        }, 
 
        calcMoreLabelStartPosition: function(startX, startY, moreLabelWidth, moreLabelHeight){ 
            var direction = "top"; 
 
            if(startY - moreLabelHeight < 0){ 
                direction = "bottom"; 
            } 
 
            return { 
                startX: startX, 
                startY: startY, 
                direction: direction 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        getHighLightStyle:function(){

        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.options.marker && p.options.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point);
        },

        _onPointMouseOver:function(point){
            point.series._onMarkerMouseOver(point);
        },

        _onPointMouseOut:function(point){
            point.series._onMarkerMouseOut(point);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            }
        },

        getPointInitAnimationAttr:function(point){

            return [{
                delay:calculateT(point),
                ease:'swing',
                duration:150,
                attr:{'transform':'translate('+ point.posX +','+ point.posY +') scale(1.5)'}
            }, {
                duration:150,
                ease:'swing',
                attr:{'transform': 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }];

        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:UPDATE_EASE,
                duration:LINE_UPDATE_TIME,
                attr:{'transform': 'translate(' + point.posX + ',' + point.posY + ')'}
            };
        },

        getClosestPoint:function(pos){
            var isInverted = this.vanchart.isInverted();
            var key = isInverted ? 'y' : 'x', posKey = isInverted ? 'posY' : 'posX';
            var selectedPoint, minDistance = Number.MAX_VALUE;

            var series = this.vanchart.hoverSeries, plotBounds = this.vanchart.bounds;
            var rePos = plotBounds[key] - (isInverted ? pos.y : pos.x);

            series.points.forEach(function(point){
                var dis = Math.abs(point[posKey] + rePos);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        },

        _onSeriesMouseOver:function(ev){

            Series.prototype._onSeriesMouseOver.call(this, ev);

            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesMouseOver();
            });

            BaseUtils.toFront(this.group.node());
        },

        //dom event do nothing
        _onSeriesMouseOut:function(ev){
        },

        //point.series.fire
        _seriesUnChosen:function (ev) {
            //...
            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesMouseOut();
            });
        },

        drawPoints:function(){

            Series.prototype.drawPoints.call(this);

            for(var i = this.dataBandsGraphic.length - 1; i >= 0; i--){
                this.dataBandsGraphic[i].toBack();
            }

        },

        drawSeries:function(){

            var series = this, vanchart = this.vanchart;
            var dataBands = this.dataBands, i, len;

            series.removeDefaultMarker();

            this.dataBandsGraphic = this.dataBandsGraphic || [];

            for(i = dataBands.length, len = this.dataBandsGraphic.length; i < len; i++){
                this.dataBandsGraphic[i].remove();
                this.dataBandsGraphic[i] = null;
            }

            for(i = 0, len = dataBands.length; i < len; i++){
                if(this.dataBandsGraphic[i]){
                    this.dataBandsGraphic[i].refresh(dataBands[i]);
                }else{
                    this.dataBandsGraphic[i] = new DataBand(dataBands[i], series);
                }
            }

            this.dataBandsGraphic.length = dataBands.length;
        }
    });

    //dataBand that draw part of the series
    var DataBand = Class.extend({

        initialize:function(options, series){
            this.series = series;
            this.refresh(options)
        },

        refresh:function(options){
            this.options = options;

            this.render();
        },

        render:function(){

            var options = this.options, series = this.series;
            var group = series.group, vanchart = series.vanchart, renderer = vanchart.renderer;

            var lineStyle = this._getLineStyle(series, options);
            var style = this._getAreaStyle(series, options);
            var isSupportSvg = BaseUtils.isSupportSVG();

            var clipBounds = options.clipBounds, isArea = series.type == Constants.AREA_CHART, isInit = !this.linePath || this.linePath.removed();

            if(!this.clipRect){
                this.clipRect = renderer.createClip({x:clipBounds.x, y:clipBounds.y,width:clipBounds.width, height:clipBounds.height});
            }else {
                renderer.updateClip(this.clipRect, clipBounds);
            }

            if(!series.visible){
                this.linePath && this.linePath.remove();
                this.areaPath && this.areaPath.remove();
                this.linePath = this.areaPath = null;

                return;
            }

            this.linePath = this.linePath || renderer.path().attr('d', series.linePath).addTo(group);
            this.linePath.style(lineStyle);
            this.linePath.isLineChart = true;//todo ie clipbug

            isSupportSvg && renderer.clip(this.linePath, this.clipRect);

            if(isArea){
                this.areaPath = this.areaPath || renderer.path().attr('d', series.areaPath);
                this.areaPath.style(style).addTo(group);
                this.areaPath.isLineChart = true;//todo ie clipbug
                isSupportSvg && renderer.clip(this.areaPath, this.clipRect);
            }

            if(isInit){
                this.linePath.attr('d', series.linePath);
                this.areaPath && this.areaPath.attr('d', series.areaPath);

                isSupportSvg &&
                this.clipRect.rect.attr(vanchart.isInverted() ? 'height' : 'width', 0)
                    .animate({'ease':LINE_SHOW_EASE, 'duration':LINE_SHOW_TIME, 'attr':clipBounds});
            }else{

                this.linePath.animate({
                    'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':{'d':series.linePath}
                });

                if(this.areaPath){
                    this.areaPath.animate({
                        'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':{'d':series.areaPath}
                    });
                }

                isSupportSvg &&
                this.clipRect.rect.animate({
                    'ease':UPDATE_EASE, 'duration':LINE_UPDATE_TIME, 'attr':clipBounds
                });
            }
        },

        toBack:function(){

            DomUtils.toBack(this.linePath && this.linePath.node());

            DomUtils.toBack(this.areaPath && this.areaPath.node());
        },

        _getAreaStyle:function(series, options){
            var target = series.vanchart.highlightTarget;
            var fill, fillOpacity;
            if(target){
                fill = options.fillColor;
                fillOpacity = target == series.name ? 1 : 0.3;
            }else{
                fill = this._getFillFilter(options.fillColor, series);
                fillOpacity = series.vanchart.options.style == Constants.STYLE_GRADUAL ? 1.0 : options.fillColorOpacity;
            }
            return {'fill': fill, 'fill-opacity':fillOpacity};
        },

        _getLineStyle:function(series, options){
            var opacity = options.opacity, target = series.vanchart.highlightTarget;

            if(target){
                opacity = target == series.name ? 1 : 0.3;
            }

            return {'fill':'none','stroke':options.color, 'stroke-width':series.options.lineWidth, 'stroke-opacity':opacity};
        },

        _getFillFilter:function(color, series){

            if(BaseUtils.isSupportSVG()){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var options = series.vanchart.options;

                if(options.style == Constants.STYLE_GRADUAL){
                    //
                    var x1, y1, x2, y2;
                    x1 = y1 = x2 = y2 = '0%';
                    var percent = Math.abs(series.y) / Math.abs(series.y - series.y0) || 0;
                    if (vanchart.isInverted() === true){
                        x1 = (1 - percent)*100 + '%';
                        x2 = '100%';
                    }else {
                        y1 = percent * 100 + '%';
                    }

                    var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
                    var stop1 = {'offset':'0%', 'stop-color':color, 'stop-opacity':0};
                    var stop2 = {'offset': '100%', 'stop-color':color, 'stop-opacity':0.8};

                    if(this.colorGradient){
                        renderer.updateColorGradient(this.colorGradient, attrs, [stop1, stop2])
                    }else{
                        this.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                    }

                    return "url(#" + BaseUtils.stamp(this.colorGradient) +")";
                }
            }

            return color;
        },

        _onSeriesMouseOver:function(){
            this.linePath.style({
                'stroke':ColorUtils.getHighLightColor(this.options.color),
                'stroke-width':this.series.options.lineWidth + 1
            });

            if(this.series.type == Constants.AREA_CHART){
                this.areaPath.animate({
                    duration:200,
                    ease:Bezier.custom["ease-out-back"],
                    style:{
                        'fill':this._getFillFilter(ColorUtils.getHighLightColor(this.options.fillColor), this.series),
                        'fill-opacity': this.options.fillColorOpacity === 0 ? 0 : (this.options.fillColorOpacity + CHOSEN_AREA_ADD_ALPHA)
                    },
                    // zoomthis.areaPathanimatepathseriesmouseOvermouseOverupdate
                    // updatepathhackmouseOverareaPath,
                    // doLayoutareaPathchangedAreaPath
                    // 
                    attr: {
                        "d": this.series.areaPath
                    }
                });
            }
        },

        _onSeriesMouseOut:function(){

            if(this.linePath){
                this.linePath.style(this._getLineStyle(this.series, this.options));
            }

            if(this.areaPath){
                this.areaPath.animate({
                    duration:200,
                    ease:Bezier.custom["ease-out-back"],
                    style:this._getAreaStyle(this.series, this.options)
                });
            }
        },

        remove:function(){
            this.linePath && this.linePath.remove();
            this.areaPath && this.areaPath.remove();
            this.clipRect && this.clipRect.remove();
            this.linePath = this.areaPath = this.clipRect = null;
        }
    });

    require('../ChartLibrary').register(Constants.LINE_CHART, Line);
    require('../ChartLibrary').register(Constants.AREA_CHART, Line);

    return Line;
});
/**
 * Created by eason on 15/12/31.
 */
define('chart/Radar',['require','./Series','../utils/BaseUtils','../utils/QueryUtils','../utils/BoundsManager'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');

    var Radar = Series.extend({

        refresh:function(options, index){

            Series.prototype.refresh.call(this, options, index);

            this.columnType = this.options.columnType;

            this.stack = this.columnType ? 'radar-column' + this.options.stack : this.options.stack;

            return this;
        },

        _getAxisTypes:function(){
            return ['angleAxis', 'radiusAxis', 'polar'];
        },

        getBaseAxisType: function () {
            return 'angleAxis';
        },

        _bindAxis:function(){
            var series = this,
                seriesOptions = series.options,
                vanchart = series.vanchart;

            series._getAxisTypes().forEach(function(axisType){

                if(vanchart[axisType]){
                    var targetAxis = vanchart[axisType](seriesOptions['polar']);
                    if(targetAxis){
                        targetAxis.series.push(series);
                        series[axisType] = targetAxis;
                    }
                }

            });
        },

        _getDefaultFillColorOpacity: function () {
            return this.options.columnType ? 1 : 0.15;
        },

        _getTranslate:function(){
            return this.getCenter();
        },

        getCenter:function(){
            return this.polar && this.polar.center;
        },

        getRadius:function(){
            return this.polar && this.polar.radius;
        },
        
        doLayout:function(){
            var series = this, polar = series.polar, radiusAxis = polar.radiusAxis, angleAxis = polar.angleAxis;
            var center = this.getCenter(), radius = this.getRadius(), piece = angleAxis.piece, valueScale = radiusAxis.scale, cateScale = angleAxis.scale;

            var indicator = radiusAxis.indicator;

            var scaleValueNotNaN = function (num) {
                return isNaN(valueScale(num)) ? 0 : valueScale(num);
            }

            //todo 
            series.points.sort(function(pointA, pointB){
                return cateScale(pointA.category) - cateScale(pointB.category);
            });

            var options;
            series.points.forEach(function(point){

                options = point.options;
                var category = point.category,
                    innerValue = options.y0,
                    outerValue = point.value + options.y0;

                // calc point inner-outer radius for every categroy when use indicastor 
                point.innerRadius = indicator ? series._cateValueScale(category, innerValue) : scaleValueNotNaN(innerValue);    

                point.outerRadius = indicator ? series._cateValueScale(category, outerValue) : scaleValueNotNaN(outerValue);

                point.animateInitRadius = radiusAxis.getStartPos();

                point.radian = cateScale(point.category) * piece;

                var pos = series._getArcPoint(point.outerRadius, point.radian);
                point.posX = pos[0];

                point.posY = pos[1];

                this._calcLabelPos(point);

            }, this);

            series.pathSegment = series._getPathSegment(series.points, series.options.connectNulls);
        },

        _calculateLabelPos:function () {

        },

        getTargetKey: function () {
            return 'y';
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },
        
        _getPathSegment:function(dataPoints, connectNulls){

            var series = this, polar = series.polar, angleAxis = polar.angleAxis, cateScale = angleAxis.scale;

            dataPoints = [].concat(dataPoints);

            dataPoints.sort(function(pointA, pointB){
                return cateScale(pointA.category) - cateScale(pointB.category);
            });

            var pathSeg = [];

            var tmp = [];

            if(connectNulls){

                pathSeg.push(tmp);

                dataPoints.forEach(function(dataPoint){

                    if(!dataPoint.isNull){
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                });
            }else{

                var startIndex = 0;
                var count = dataPoints.length;

                for(var index = count - 1; index > 0; index--){

                    var current = dataPoints[index];
                    var pre = dataPoints[index - 1];

                    if(!current.isNull && pre.isNull){
                        startIndex = index;
                    }
                }

                for(var index = 0; index < count; index++){

                    var dataPoint = dataPoints[(index + startIndex) % count];

                    if(dataPoint.isNull && tmp.length){

                        if(tmp.length > 1){
                            pathSeg.push(tmp)
                        };

                        tmp = [];
                    }else if(!dataPoint.isNull){
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                }

                if(tmp.length){
                    pathSeg.push(tmp);
                }
            }

            return pathSeg;
        },

        _getRadarSeriesPath:function(pathSeg, connectNulls, toCenter){

            var path = '';
            var tmp = [];
            if(pathSeg.length === 1){

                tmp = pathSeg[0];

                var fullShape = tmp.length == this.angleAxis.getCategoryCount() || connectNulls;

                toCenter = (!fullShape && toCenter);

                path = toCenter ? 'M0,0' : '';

                for(var i = 0, count = tmp.length; i < count; i++){

                    var mOrl = (i || toCenter) ? 'L' : 'M';

                    path += (mOrl + BaseUtils.dealFloatPrecision(tmp[i][0]) + "," + BaseUtils.dealFloatPrecision(tmp[i][1]));
                }

                path += (fullShape || toCenter) ? 'Z' : '';

            }else{
                pathSeg.forEach(function(tmp){

                    path += toCenter ? 'M0,0' : '';

                    tmp.forEach(function(pos, i){
                        path += (((i || toCenter) ? 'L' : 'M') + BaseUtils.dealFloatPrecision(pos[0]) + "," + BaseUtils.dealFloatPrecision(pos[1]));
                    });

                    path += toCenter ? 'Z' : '';
                });
            }

            return path;
        },

        _getInitPathSegment:function(pathSeg){
            var init = [];
            pathSeg.forEach(function(seg){
                var tmp = [];
                init.push(tmp);

                seg.forEach(function(){
                    tmp.push([0,0])
                })
            });
            return init;
        },
        // when use indicator, domain of each categroy need to calc one by one
        _cateValueScale : function(cate, value) {
            var series = this, radiusAxis = series.radiusAxis, cateScale = radiusAxis._cateScale;

            var domain;
            // get domain value of specific category
            radiusAxis._cateDomain.forEach(function (d) {
                if(d.name === cate) {
                    domain = d.domain;
                }
            });
            // calc scale value
            cateScale.domain(domain);
            return isNaN(cateScale(value)) ? 0 : cateScale(value);
        }
    });
    
    return Radar;
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/LineRadar',['require','../utils/BaseUtils','../dom/DomUtils','../utils/ColorUtils','../utils/BezierEasing','../EffectHelper','../utils/Interpolator','../Constants','./Radar','../ChartLibrary'],function(require){

    var BaseUtils  = require('../utils/BaseUtils');
    var DomUtils = require('../dom/DomUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var Interpolator = require('../utils/Interpolator');
    var Constants = require('../Constants');
    var Radar = require('./Radar');

    var LINE_SHOW_TIME = 400;
    var LINE_SHOW_EASE = 'back-out';

    var MARKER_INIT_TIME = 200;
    var MARKER_INIT_EASE = 'back-out';

    var EXIT_TIME = 250;
    var EXIT_EASE = 'back-in';

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    var LineRadar = Radar.extend({
        columnType:false,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius + LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        drawPoints:function(){
            Radar.prototype.drawPoints.call(this);

            DomUtils.toBack(this.radarPath && this.radarPath.node());
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

            series.removeDefaultMarker();

            var toCenter = series.fillColor && series.fillColorOpacity;
            var pathStyle = this._getRadarPathStyle();

            if(series.visible && series.pathSegment.length > 0){
                this.radarPath = this.radarPath || renderer.path().addTo(series.group);
                this.radarPath.style(pathStyle);
                this.radarPath.animate({
                    duration:LINE_SHOW_TIME,
                    ease:LINE_SHOW_EASE,
                    attrTween:{'d':function(){
                        var useLastPathSeg = !!this._pathSegment_;
                        if(useLastPathSeg && this._pathSegment_.length == series.pathSegment.length){
                            var last = this._pathSegment_;
                            for(var i = 0, count = last.length; i < count && useLastPathSeg; i++){
                                if(last[i].length != series.pathSegment[i].length){
                                    useLastPathSeg = false;
                                }
                            }
                        }
                        var initPathSeg = useLastPathSeg ? this._pathSegment_ : series._getInitPathSegment(series.pathSegment);
                        var interpolate  = Interpolator.interpolateArray(initPathSeg, series.pathSegment);
                        this._pathSegment_ = series.pathSegment;
                        return function(t){
                            return series._getRadarSeriesPath(interpolate(t), series.options.connectNulls, toCenter);
                        };
                    }}
                });
            }else{
                if(this.radarPath){
                    this.radarPath.animate({
                        duration:EXIT_TIME,
                        ease:EXIT_EASE,
                        attrTween:{'d':function(){
                            var initPathSeg = series._getInitPathSegment(series.pathSegment);
                            var interpolate  = Interpolator.interpolateArray(series.pathSegment, initPathSeg);
                            return function(t){
                                return series._getRadarSeriesPath(interpolate(t), series.options.connectNulls, toCenter);
                            };
                        }}
                    }).remove();
                }

                this.radarPath = null;
            }
        },

        _getRadarPathStyle:function(){
            var series = this, hasFill = series.fillColor && series.fillColorOpacity;
            var fillOpacity = series.fillColorOpacity, strokeOpacity = series.opacity;
            var target = series.vanchart.highlightTarget;

            // target""
            if(BaseUtils.hasDefined(target)){
                fillOpacity = target == series.name ? 1 : 0.3;
                strokeOpacity = target == series.name ? 1 : 0.3;
            }

            return {
                'fill': hasFill ? series.fillColor : 'none',
                'fill-opacity': fillOpacity,
                'stroke': series.color,
                'stroke-width': series.options.lineWidth,
                'stroke-opacity':strokeOpacity
            };
        },

        _getFillHighLightStyle:function(){
            var series = this, hasFill = series.fillColor && series.fillColorOpacity;

            return {
                'fill': hasFill ? ColorUtils.getHighLightColor(series.fillColor) : 'none',
                'fill-opacity': series.fillColorOpacity === 0 ? 0 : (series.fillColorOpacity + 0.35)
            };
        },

        _getStrokeHighLightStyle:function () {
            var series = this;
            return {
                'stroke':ColorUtils.getHighLightColor(series.color),
                'stroke-width': series.options.lineWidth + 1,
                'stroke-opacity':series.opacity
            };
        },

        _getStrokeStyle:function () {
            var series = this;
            return {
                'stroke': series.color,
                'stroke-width': series.options.lineWidth,
                'stroke-opacity':series.opacity
            };
        },

        getStyle:function(){
            return {};
        },

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.options.marker && p.options.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point);
        },

        _calculateLabelPos:function(){

        },

        _getFixedPos:function(datum){
            var radius = isNaN(datum.options.marker.radius) ? 4.5 : datum.options.marker.radius, center = this.getCenter();
            var x, y;
            x = center[0] + datum.posX + radius;
            y = center[1] + datum.posY + radius;

            return [x, y];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition :function(point, moreLabelDim){
            var chartCenter = this.getCenter();
            var startX = point.posX + chartCenter[0],
                startY = point.posY + chartCenter[1];
            return {
                startX: startX,
                startY: startY,
                direction: "top"
            }
        },

        _onSeriesMouseOver:function(ev){
            Radar.prototype._onSeriesMouseOver.call(this, ev);

            var series = this;
            if(series.radarPath){
                series.radarPath
                    .style(series._getStrokeHighLightStyle())
                    .animate({
                        duration:200,
                        ease:Bezier.custom["ease-out-back"],
                        style:series._getFillHighLightStyle()
                    });
            }

            BaseUtils.toFront(series.group.node());
        },

        _onSeriesMouseOut:function(){
            var series = this;

            if(series.radarPath){
                series.radarPath.style(series._getStrokeStyle())
                    .animate({
                        duration:200,
                        ease:Bezier.custom["ease-out-back"],
                        style:series._getRadarPathStyle()
                    });
            }
        },

        _onPointMouseOver:function(point){
            point.series._onMarkerMouseOver(point);
        },

        _onPointMouseOut:function(point){
            point.series._onMarkerMouseOut(point);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            }
        },

        getPointInitAnimationAttr:function(point){

            return {
                delay:LINE_SHOW_TIME,
                duration:MARKER_INIT_TIME,
                ease:MARKER_INIT_EASE,
                attr:{'transform': 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            };

        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:LINE_SHOW_EASE,
                duration:LINE_SHOW_TIME,
                attr:{'transform': 'translate(' + point.posX + ',' + point.posY + ') scale(1)'}
            };
        },

        getPointDropAnimationAttr:function(){
            return {
                ease:EXIT_EASE,
                duration:EXIT_TIME,
                attr:{'transform': 'translate(' + 0 + ',' + 0 + ') scale(0.01)'}
            };
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        getClosestPoint:function(pos){

            var center = this.getCenter(), minDistance = Number.MAX_VALUE;
            var selectedPoint;

            this.points.forEach(function(point){
                var detX = point.posX + center[0] - pos.x;
                var detY = point.posY + center[1] - pos.y;
                var dis = Math.sqrt(detX * detX + detY * detY);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        }
    });

    require('../ChartLibrary').register(Constants.LINE_RADAR, LineRadar);

    return LineRadar;
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/ColumnRadar',['require','../EffectHelper','../utils/Interpolator','../utils/PathGenerator','../Constants','./Radar','../ChartLibrary'],function(require){
    var EffectHelper = require('../EffectHelper');
    var Interpolate = require('../utils/Interpolator');
    var PathGenerator = require('../utils/PathGenerator');
    var Constants = require('../Constants');
    var Radar = require('./Radar');

    var STACK_ANIMATION_TIME = 600;//
    var STACK_EASE = "cubic-out";//

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var CHOSEN_TIME = 100;
    var CHOSEN_EASE = 'ease-out-in';

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    var ColumnRadar = Radar.extend({

        columnType:true,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius - LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getStyle:function(p){
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke':p.borderColor,
                'stroke-width':p.options.borderWidth,
                'stroke-opacity':1
            };
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor || p.color,
                'fill':p.color,
                'fill-opacity': 1,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getRadarColumnPath:function(innerRadius, radius, radian){

            var halfSize = this.polar.angleAxis.piece * 0.375;

            var startRadian = radian - halfSize;

            var endRadian = radian + halfSize;

            var arc = PathGenerator.arc()
                .innerRadius(innerRadius).outerRadius(radius)
                .startAngle(startRadian).endAngle(endRadian);

            return arc();
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series;
            var innerInterpolate = Interpolate(point.animateInitRadius, point.innerRadius);
            var outerInterpolate = Interpolate(point.animateInitRadius, point.outerRadius);

            return series._pointAnimateAttr(EASE, ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointReShowAnimationAttr:function (point) {
            var series = point.series;
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;
            var start = point.animateInitRadius;
            if(preP) {
                start = preP._lastOuterRadius_;
            } else if(sufP) {
                start = sufP._lastInnerRadius_;
            }

            var innerInterpolate = Interpolate(start, point.innerRadius);
            var outerInterpolate = Interpolate(start, point.outerRadius);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointUpdateAnimationAttr:function(point){
            var series = this;
            // initChartinitPaddingScaleinitAnimationupdateAnimation,
            // point._lastInnerRadiusundefined
            var innerInterpolate = Interpolate(point._lastInnerRadius_ || point.animateInitRadius, point.innerRadius);
            var outerInterpolate = Interpolate(point._lastOuterRadius_ || point.animateInitRadius, point.outerRadius);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        getPointDropAnimationAttr:function(point){
            var series = this;
            var points = point.getStackPointPreSufPoint(point), preP = points.pre, sufP = points.suf;
            var end = point.animateInitRadius;

            if(preP){//
                end = preP.outerRadius;
            } else if(sufP){
                end = sufP.innerRadius;
            }

            var innerInterpolate = Interpolate(point.innerRadius, end);
            var outerInterpolate = Interpolate(point.outerRadius, end);

            return series._pointAnimateAttr(STACK_EASE, STACK_ANIMATION_TIME, point, innerInterpolate, outerInterpolate);
        },

        _pointAnimateAttr:function (ease, duration, point, innerInterpolate, outerInterpolate) {
            var series = point.series;
            return {
                ease:ease,
                duration:duration,
                attrTween: {
                    'd': function () {
                        return function (t) {
                            point._lastInnerRadius_ = innerInterpolate(t);
                            point._lastOuterRadius_ = outerInterpolate(t);

                            return series._getRadarColumnPath(point._lastInnerRadius_, point._lastOuterRadius_, point.radian);
                        };
                    }
                }
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series,style = series.getStyle(point);
            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point.graphic.animate({duration:CHOSEN_TIME, ease:CHOSEN_EASE, style:style});
            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
        },

        _getFixedPos:function(datum, divDim){

            var centerAngle = datum.radian, center = this.getCenter();

            var x = datum.posX + center[0];
            var y = datum.posY + center[1];

            if(centerAngle < Math.PI / 2){
                y -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                x -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < Math.PI * 2){
                y -= divDim.height;
                x -= divDim.width;
            }

            return [x, y];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point        [description]
         * @param  {[type]} moreLabelDim [description]
         * @return {[type]}              [description]
         */
        calcMoreLabelPosition :function(point, moreLabelDim){
            var toCenterRadius = point.innerRadius + (point.outerRadius - point.innerRadius) / 2;
            var pointCenter = this._getArcPoint(toCenterRadius, point.radian),
                chartCenter = this.getCenter();

            var startX = pointCenter[0] + chartCenter[0],
                startY = pointCenter[1] + chartCenter[1];
            return {
                startX: startX,
                startY: startY,
                direction: "top"
            }
        }
    });

    require('../ChartLibrary').register(Constants.COLUMN_RADAR, ColumnRadar);

    return ColumnRadar;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('chart/Bubble',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../EffectHelper','../utils/BezierEasing','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var EffectHelper = require('../EffectHelper');
    var BezierEasing = require('../utils/BezierEasing');

    var BUBBLE_INIT_TIME = 500;
    var BUBBLE_UPDATE_TIME = 500;
    var BUBBLE_EXIT_TIME = 300;
    var BUBBLE_RE_SHOW_TIME = 300;

    var CHOSEN_TIME = 200;
    var CHOSEN_EASE = BezierEasing.custom["ease-out-back"];
    var OUT_EASE = BezierEasing.css["ease-out"];

    var Bubble = Series.extend({

        doLayout:function(){
            this._calculateBubblePosition();
        },

        useCanvas:function(){
            return this.options.large
        },

        //,value
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {
            var options = point.options;

            if(this.vanchart.isMap()){
                return options.size == '-' || BaseUtils.hasNotDefined(options.size);
            } else {
                return options.x == '-' || options.y == '-' || options.size == '-' || BaseUtils.hasNotDefined(options.size);
            }
        },

        _getPointKey: function (point) {
            var option = point.options || point;
            return this.vanchart.isMap() ? point.name : ('' + option.x + option.y);
        },

        // 
        _calculateLabelPos:function() {

        },

        //shine:
        _calculateMinMax4Radius:function(){
            var series = this, points = series.points;
            var seriesMinSize = Number.MAX_VALUE, seriesMaxSize = -Number.MAX_VALUE;

            for(var index = 0, len = points.length; index < len; index++){
                var point = points[index];
                var value = point.getTargetValue();

                if(!point.visible || point.isNull){
                    continue;
                }

                //shine:
                // 
                if(value < 0 && !point.options.displayNegative){
                    continue;
                }

                // 
                if(point.options.minSize || point.options.maxSize){
                    continue;
                }

                //todo:0100-2000-200
                seriesMaxSize = Math.max(seriesMaxSize, isNaN(value) ? 0 : Math.abs(value));
                seriesMinSize = Math.min(seriesMinSize, isNaN(value) ? 0 : Math.abs(value));
            }

            series.seriesAbsMinValue = seriesMinSize;
            series.seriesAbsMaxValue = seriesMaxSize;
        },

        _calculateBubbleRadius:function(){
            var series = this, options = series.options;
            //
            var seriesMaxDiameter = Math.max(series.maxSize, series.minSize);
            var seriesMinDiameter = Math.min(series.minSize, series.maxSize);
            var sizeByArea = options.sizeBy == Constants.SIZE_BY_AREA;

            //size
            var max = this.seriesAbsMaxValue, min = this.seriesAbsMinValue;

            if(!this._sizeByCurrentSeries()){//
                var minMax = this._calculateChartMinMax();
                max = BaseUtils.pick(minMax.max, minMax[1]);
                min = BaseUtils.pick(minMax.min, minMax[0]);
            }

            var denominator = max - min;
            var unit = sizeByArea ? (seriesMaxDiameter * seriesMaxDiameter - seriesMinDiameter * seriesMinDiameter) / denominator
                : (seriesMaxDiameter - seriesMinDiameter ) / denominator;
            unit = isFinite(unit) ? unit : 0;

            var scale = BaseUtils.pick(this.vanchart.scale, 1);
            var targetKey = this.getTargetKey();

            this.points.forEach(function(point) {
                var temp = unit * (Math.abs(point.value) - min);
                var diameter = sizeByArea ? Math.sqrt(seriesMinDiameter * seriesMinDiameter + temp) : seriesMinDiameter + temp;
                if(point.options.minSize || point.options.maxSize){
                    //shine:
                    //
                    var _tmp = isNaN(point.options.minSize) ? point.options.maxSize : point.options.minSize;
                    diameter = sizeByArea ? Math.sqrt(_tmp) * 2 : _tmp;
                }
                diameter = (point[targetKey] < 0 && !point.options.displayNegative) ? 0 : diameter;
                point.radius = (diameter/2) * scale;
            });
        },

        //
        _sizeByCurrentSeries: function () {
            return BaseUtils.hasDefined(this.options.minSize) && BaseUtils.hasDefined(this.options.maxSize);
        },

        //&
        _calculateChartMinMax: function () {
            var series = this.vanchart.seriesOfType(this.type);

            var minSize = Number.MAX_VALUE;//
            var maxSize = -minSize;

            series.forEach(function(sery) {
                if(!sery._sizeByCurrentSeries()) {
                    minSize = Math.min(minSize, sery.seriesAbsMinValue);
                    maxSize = Math.max(maxSize, sery.seriesAbsMaxValue);
                }
            });

            return{
                min:minSize,
                max:maxSize
            }
        },

        _calculateBubblePosition:function(){
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;

            this.points.forEach(function(point){
                var options = point.options;

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand() / 2 : 0;
                var t1 = xAxis.scale(xAxis.getAxisValue(options.x)) + det;
                var t2 = yAxis.scale(yAxis.getAxisValue(options.y));

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                var valid = point.labelDim && !point.isNull && !(point.getTargetValue() < 0 && !options.displayNegative);

                if(valid && options.dataLabels && options.dataLabels.enabled){

                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.labelDim.height/2
                    };
                }
            });
        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function(point){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, radius = point.radius || 0;

            var pos;
            if(vanchart.isMap()){
                var latlng = point.getLatLng();

                if(!latlng){
                    return;
                }

                pos = vanchart.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;

            return [pos.x + radius, pos.y + radius];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var chartBounds = this.vanchart.bounds; 
            var startX = point.posX, 
                startY = point.posY;
            
            return { 
                startX: startX + chartBounds.x, 
                startY: startY + chartBounds.y, 
                direction: "top" 
            }
        },

        getPointGraphicKey:function(){
            return 'circle';
        },

        effectAnimation:function (d) {
            EffectHelper.bubbleEffectAnimation(d, this.vanchart.isMap());
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        getPointInitAttr:function(point){
            return {
                'transform':BaseUtils.makeTranslate([point.posX, point.posY]),
                'r':0
            }
        },

        getPointInitAnimationAttr:function(point){
            return {
                delay:point.delayTime || 0,
                ease:'bounce',
                duration:BUBBLE_INIT_TIME,
                attr:{'r': point.radius}
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:'bounce',
                duration:BUBBLE_RE_SHOW_TIME,
                attr:{'r': point.radius}
            }
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:'back-out',
                duration:BUBBLE_UPDATE_TIME,
                attr:{
                    'r':point.radius,
                    'transform': BaseUtils.makeTranslate({x:point.posX, y:point.posY})
                }
            }
        },

        getPointDropAnimationAttr:function(){
            return {
                ease:'back-in',
                duration:BUBBLE_EXIT_TIME,
                attr:{'r':0}
            }
        },

        _getShadowFilter:function () {
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;
            vanchart.bubbleShadowFilter = vanchart.bubbleShadowFilter || renderer.createDropShadowFilter(0, 0, 0.2, 2);
            return 'url(#' + BaseUtils.stamp(vanchart.bubbleShadowFilter) + ')';
        },

        getStyle:function(p){
            var series = p.series;
            var style = {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0,
                'stroke-width':0,
                'fill':p.color,
                'fill-opacity':p.opacity
            };

            //todo ie10
            if(!BaseUtils.isMS) {
                style.filter = p.options.shadow ? series._getShadowFilter() : 'none';
            }

            return style;
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0.35,
                'stroke-width':6,
                'fill':p.mouseOverColor,
                'fill-opacity': p.opacity + 0.35
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'stroke-opacity':0.35,
                'stroke-width':6,
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);
            series._onState(point, true, CHOSEN_EASE, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);
            series._onState(point, false, OUT_EASE, style);
        },

        _onState:function (point, isChosen, ease, style) {
            var series = point.series, vanchart = series.vanchart;
            if(series.vanchart.isLargeMode()){
                return;
            }

            if(vanchart.isMap()){
                point._mapPointOnMouseState(isChosen, CHOSEN_TIME, ease, style);

                point.textLayers && point.textLayers.forEach(function(layer){
                    layer._fontSizeState(isChosen, CHOSEN_TIME, CHOSEN_EASE);
                });
            } else {
                point.graphic
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .animate({
                        ease: ease,
                        duration: CHOSEN_TIME,
                        style: style,
                        attr: {'r': point.radius + (isChosen ? 1 : 0)}
                    });

                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, ease);
            }
        }

    });

    require('../ChartLibrary').register(Constants.BUBBLE_CHART, Bubble);

    return Bubble;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('chart/Scatter',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../EffectHelper','../utils/PathGenerator','../ChartLibrary'],function (require) {

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');

    var SCATTER_INIT_TIME = 300;
    var SCATTER_UPDATE_TIME = 500;
    var LABEL_GAP = 2;

    var Scatter = Series.extend({

        doLayout: function () {
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;
            this.points.forEach(function (point) {

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand() / 2 : 0;
                var t1 = xAxis.scale(xAxis.getAxisValue(point.options.x)) + det;
                var t2 = yAxis.scale(yAxis.getAxisValue(point.options.y));

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                if (point.labelDim) {
                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.options.marker.radius - LABEL_GAP - point.labelDim.height
                    };
                }

            });

            var series = this;

            var lineSvg = PathGenerator.line()
                .interpolate(series.interpolate)
                .x(function (d) {
                    return d.posX;
                })
                .y(function (d) {
                    return d.posY;
                })
                .defined(function (d) {
                    return !d.isNull;
                });

            this.points.sort(function (pointA, pointB) {
                return pointA.posX - pointB.posX;
            });

            this.linePath = lineSvg(this.points);
        },

        useCanvas:function(){
            return this.options.large;
        },

        //,value
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {
            var options = point.options;

            if(this.vanchart.isMap()){
                return options.size == '-' || BaseUtils.hasNotDefined(options.size);
            }else{
                return options.x == '-' || options.y == '-' || BaseUtils.hasNotDefined(options.y);
            }
        },

        _calculateLabelPos: function (point) {

        },

        getTrendLineXYValues: function (sery) {
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function (point) {
            var vanchart = this.vanchart, plotBounds = vanchart.bounds, radius = (point.options.marker &&  point.options.marker.radius) || 0;

            var pos;
            if(vanchart.vanChartType == 'vanChartMap'){
                var latlng = point.getLatLng();

                if(!latlng){
                    return;
                }

                pos = vanchart.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;

            return [pos.x + radius, pos.y + radius];
        },

        _animateEnd: function () {
            this._showLabels();
            this._drawEffectPoints();

            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;
            if(!series.group){
                series.group = series._createGroup(renderer, vanchart)
                    .attr('transform', BaseUtils.makeTranslate(series._getTranslate()))
                    .attr('class', series.className + ' ' + series.type);
            }

            // visibletruelinePathlineGraphic
            if(series.visible && series.linePath) {
                series.lineGraphic = series.lineGraphic || renderer.path({'d':series.linePath})
                    .addTo(series.group)
                    .style({'fill':'none', 'pointer-events': 'none', 'stroke-width': series.options.lineWidth, 'stroke': series.color});
            }
            
        },

        calcMoreLabelPosition: function(point, moreLabelDim) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.posX + chartBounds.x, 
                startY = point.posY + chartBounds.y; 
                
            return { 
                startX: startX, 
                startY: startY, 
                direction:"top" 
            } 
        },

        effectAnimation:function (d) {
            EffectHelper.markerEffectAnimation(d, this.vanchart.isMap());
        },

        getDefaultEffectTime:function () {
            return EffectHelper.MARKER_EFFECT_TIME;
        },

        _getPointKey: function (point) {
            var option = point.options || point;
            return this.vanchart.isMap() ? point.name : ('' + option.x + option.y);
        },

        getAttrs:function(p){
            return {'transform': BaseUtils.makeTranslate({x:p.posX, y:p.posY})};
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point);
        },

        updatePointGraphic:function(point){
            this._updateMarkerPointGraphic(point);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.options.marker);
        },

        getPointInitAttr:function(point){
            return {
                'transform':'translate('+ point.posX +','+ point.posY +') scale(0.01)'
            };
        },

        getPointInitAnimationAttr:function(point){
            return {
                delay:point.delayTime,
                ease:'back-out',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointReShowAnimationAttr:function (point) {
            return {
                ease:'back-out',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                ease:'back-out',
                duration:SCATTER_UPDATE_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(1)'}
            }
        },

        getPointDropAnimationAttr:function(point){
            return {
                ease:'back-in',
                duration:SCATTER_INIT_TIME,
                attr:{'transform' : 'translate('+ point.posX +','+ point.posY +') scale(0)'}
            }
        },

        drawSeries: function () {
            var series = this;

            series.visible && series.lineGraphic && series.lineGraphic.animate({
                duration:SCATTER_UPDATE_TIME, 
                ease:'back-out', 
                attr: {
                    'd': series.linePath
                }
            });

            if(!series.visible){
                series.lineGraphic && series.lineGraphic.remove();
                series.lineGraphic = null;
            }
        },

        getStyle:function(point){
            var marker = point.options.marker;
            var isHollow = this._isHollowMarker(marker.symbol);

            return isHollow ?
            {
                'fill-opacity':0,
                fill:'white',
                stroke:marker.fillColor,
                'stroke-opacity':marker.fillColorOpacity,
                'stroke-width':2
            } :
            {
                fill:marker.fillColor,
                'fill-opacity':marker.fillColorOpacity,
                stroke:'none'
            };
        },

        _onPointMouseOver:function(point){

            var series = point.series;

            if(series.vanchart.isLargeMode()){
                return;
            }

            if(series.vanchart.isMap()){
                series._onMapPointState(point, true);
            }else {
                series._onMarkerMouseOver(point);
            }
        },

        _onPointMouseOut:function(point){
            var series = point.series;

            if(series.vanchart.isLargeMode()){
                return;
            }

            if(series.vanchart.isMap()){
                series._onMapPointState(point, false);
            }else {
                series._onMarkerMouseOut(point);
            }
        },

        _onMapPointState:function (point, isChosen) {
            point._mapPointOnMouseState(isChosen);

            point.textLayers && point.textLayers.forEach(function(layer){
                layer._transformState(isChosen);
            });
        }

    });

    require('../ChartLibrary').register(Constants.SCATTER_CHART, Scatter);
    
    return Scatter;
});

/**
 * Created by eason on 15/12/2.
 */
define('chart/Gauge',['require','../Constants','../utils/BaseUtils','./Series','../utils/QueryUtils','../utils/BoundsManager','../utils/ColorUtils','../component/FormattedText','../utils/BezierEasing'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Series = require('./Series');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var ColorUtils = require('../utils/ColorUtils');
    var FormattedText = require('../component/FormattedText');
    var Bezier = require('../utils/BezierEasing');

    var isSupportSVG = BaseUtils.isSupportSVG()

    var Gauge = Series.extend({

        DEFAULT_PADDING:5,
        LINE_GAP:0.3,
        VERTICAL_GAP:0.3,
        HORIZONTAL_GAP:0.8,

        ANIMATION_TIME:1200,
        EASE_TYPE:'cubic-out',

        CHOSEN_EASE : Bezier.css['ease'],
        CHOSEN_TIME : 200,
        OUT_EASE : Bezier.css['ease-out'],
        OUT_TIME : 900,

        refresh:function(options, index){

            Series.prototype.refresh.call(this, options, index);

            options = this.options;

            this.gaugeType = options.style;

            this.center = null;
            if(options.center){
                this.center = [this._getPercentValue(options.center[0], this.vanchart.width), this._getPercentValue(options.center[1], this.vanchart.height)];
            }

            BaseUtils.calculateFontSizeWithScale(options.seriesLabel && options.seriesLabel.style);
            BaseUtils.calculateFontSizeWithScale(options.valueLabel && options.valueLabel.style);
            BaseUtils.calculateFontSizeWithScale(options.percentageLabel && options.percentageLabel.style);

            return this;
        },

        doLayout:function(){
            var seriesBounds = this._calculateGaugeBounds(), series = this, options = series.options;
            if(!seriesBounds && (!options.radius && !series.center)){
                throw new Error('gauge has no bounds');
            }

            this.bounds = seriesBounds;

            this._calculatePercentage();

            //bandscolordoLayoutdefault bands depend on gauge axis domain.
            series.defaultBands = (options.bands || []).concat(series._getDefaultBands(series.gaugeAxis.scale.domain()));

            series.points.forEach(function (point) {
                var bandsColor = series._getColorFromBands(point.getTargetValue(), series.defaultBands);
                if(bandsColor){
                    bandsColor = ColorUtils.getStandardColorAndOpacity(bandsColor);
                    point.color = bandsColor.hex;
                    point.opacity = bandsColor.alpha;
                }
                point.mouseOverColor = ColorUtils.getHighLightColor(point.color);
                point.clickColor = ColorUtils.getClickColor(point.color);
            });

            this._doLayout();
        },

        _doLayout:function(){
            this._dealPercentLabel();

            this._dealValueLabel();

            this._fixCenterAndRadius();
        },

        calculateLabelInfo:function(point){

        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        _getAxisTypes:function(){
            return ['gaugeAxis'];
        },

        getDataToDraw:function(){
            return [];
        },

        _calculatePercentage:function(){
            if(this.points.length){
                var gaugeAxis = this.gaugeAxis, minMax = gaugeAxis.scale.domain();
                var points = this.points;
                points.forEach(function(point){
                    point.points = points;
                    point.percentage = (point.value - minMax[0]) / (minMax[1] - minMax[0]);
                });
            }
        },

        _calculateLabelPos:function(){

        },

        _getTranslate:function(){
            return [Math.round(this.centerX), Math.round(this.centerY)];
        },

        _validPoint:function () {
            var validPoints = this.points.filter(function (point) {return !point.isNull;});
            return validPoints[0] || this.points[0];
        },

        _dealSeriesLabel:function(){
            var series = this, options = series.options;
            series.seriesLabelContent = ''; series.seriesLabelDim = {width:0, height:0};

            if(options.seriesLabel && options.seriesLabel.enabled){
                var style = options.seriesLabel.style;
                
                var point = series._validPoint();
                FormattedText.dataLabelGenerator(point, options.seriesLabel); // labelContentpoint

                var labelContent = point.labelContent;
                var labelDim = point.labelDim;

                series.seriesLabelContent = labelContent && labelContent[0] ? labelContent[0].text : '';
                series.seriesLabelStyle = style;
                series.seriesLabelDim = labelDim;
            }
        },
        
        _dealPercentLabel:function () {
            var series = this, options = series.options, percentageLabel = options.percentageLabel;
            series.percentageLabelContent = ''; series.percentageLabelDim = {width:0, height:0};
            var point = series.points[0];

            if(!point || point.isNull){
                return;
            }

            if(percentageLabel && percentageLabel.enabled){

                var labelStyle = BaseUtils.clone(percentageLabel.style);

                if(!labelStyle.color){
                    labelStyle.color = point.color;
                }
                FormattedText.dataLabelGenerator(point, percentageLabel);
                
                var labelContent = point.labelContent;
                var labelDim = point.labelDim;
                series.percentageLabelContent = labelContent && labelContent[0] ? labelContent[0].text : '';
                series.percentageLabelStyle = labelStyle;
                series.percentageLabelDim = labelDim;
            }
        },

        _dealValueLabel:function(){
            var series = this, options = series.options, valueLabel = options.valueLabel, style = valueLabel.style, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;

            series.valueLabelContent = ''; series.valueLabelDim = {width:0, height:0};
            
            if(valueLabel && valueLabel.enabled){
                var valueLabelContent = [];
                for(var i = 0, len = series.points.length; i < len; i++){
                    var point = series.points[i];
                    if(point.isNull){
                        continue;
                    }
                    var labelContent = FormattedText.calculateSingleLineLabelContent(formatter, point);
                    var labelDim = BaseUtils.getTextDimension(labelContent, style, useHtml);
                    valueLabelContent.push({
                        labelContent:labelContent,
                        labelDim:labelDim,
                        labelStyle:style
                    });
                }

                series.valueLabelContent = valueLabelContent;
            }
        },

        _getDefaultBands:function(domain){
            var color = this.options.color, bands = [];
            if(color){
                bands.push({
                    from:domain[0],
                    to:domain[1],
                    color:color
                });
            }else{
                var min = domain[0], max = domain[1];
                var band = BaseUtils.accDiv((max - min), 3);
                var fStop = BaseUtils.accAdd(min, band);
                var sStop = BaseUtils.accAdd(fStop, band);
                var colors = this.vanchart.options.colors;

                bands = [
                    {
                        from:min,
                        to:fStop,
                        color:colors[0]
                    },
                    {
                        from:fStop,
                        to:sStop,
                        color:colors[1]
                    },
                    {
                        from:sStop,
                        to:max,
                        color:colors[2]
                    }];
            }

            return bands;
        },

        _getColorFromBands:function(value, bands){
            if(bands && bands.length){

                for(var i = 0, len = bands.length; i < len; i++){
                    var band = bands[i];
                    var min = Math.min(band.from, band.to);
                    var max = Math.max(band.from, band.to);

                    if(value >= min && value <= max){
                        return band.color;
                    }
                }
            }
        },

        //,,,,
        //,,
        _calculateGaugeBounds:function(){
            var series = this.vanchart.seriesOfType(Constants.GAUGE_CHART);
            var plotBounds = this.vanchart.bounds;
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].center && series[i].options.radius){
                    fixedSize++;
                }
            }

            //
            var isHorizontalLayout = this.options.layout == Constants.HORIZONTAL_LAYOUT;
            var divideDimKey =  isHorizontalLayout ? 'width' : 'height';
            var averageSize = plotBounds[divideDimKey] / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.center){
                        if(isHorizontalLayout){
                            return {
                                x:plotBounds.x + i * averageSize,
                                y:plotBounds.y,
                                width:averageSize,
                                height:plotBounds.height
                            }
                        }else{
                            return {
                                x:plotBounds.x,
                                y:plotBounds.y + i * averageSize,
                                width:plotBounds.width,
                                height:averageSize
                            }
                        }
                    }
                }
            }

            return{x:0,y:0,width:0,height:0};
        },

        //
        _getFixedPos:function(datum, divDim){
            var gauge = datum.series, style = gauge.style;
            var x, y;
            if(style == 'pointer_semi'){
                x = gauge.centerX - divDim.width/2;
                y = gauge.centerY + 0.14 * gauge.radius + 10;
            }else{
                x = gauge.centerX + gauge.radius + 10;
                y = gauge.centerY - divDim.height/2;
            }
            return [x, y];
        },

        _animateEnd: function () {
        },

        _getPointTextLabelGroup:function(){

            if(!this.textGraphicGroup){
                var vanchart = this.vanchart, textRenderGroup = vanchart.seriesTextRenderGroup, textDivGroup = vanchart.seriesTextDivGroup;
                this.textGraphicGroup = vanchart.renderer.vgroup();
                this.textGraphicGroup.renderG.addTo(this.group);
                textDivGroup.append(this.textGraphicGroup.divG);
            }

            this.textGraphicGroup.divG.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));

            return this.textGraphicGroup;
        },

        _drawGaugeLabels: function (labelG) {
            var series = this, vanchart = series.vanchart;

            series._removeNormalLabels(labelG);
            series._drawNormalLabels(labelG);

            // Init
            // 
            series.updateLastLabelPos && series.updateLastLabelPos();

            // MoreLabel
            if(vanchart._needShowMoreLabel() && series.visible){
                series._drawDiffMoreLabels(); 
            }

            // vanchart._changeDataState
            vanchart._removeChangeDataState(series)
        },

        //ring and slot 
        _drawDiffMoreLabels: function () {
            var series = this, point = this.points[0];

            if(!point || point.isNull){
                return;
            }

            this._showMoreLabel(point, series.centerX, series.centerY);
        },

        _removeNormalLabels: function (labelG) {
            //,
            var labels = labelG.labels || [];
            for(var i = 0, len =  labels.length; i < len; i++){
                labels[i] && labels[i].remove();
                labels[i] = null;
            }

            this._drawExitValueLabel && this._drawExitValueLabel();  // valueLabel
        },
        
        _drawNormalLabels:function(labelG){
            var series = this, options = series.options, vanchart = series.vanchart, renderer = vanchart.renderer;

            labelG.labels = [];

            if (series.seriesLabelContent) {
                series._drawLabel(labelG, series.seriesLabelContent, series.seriesLabelPos,
                    series.seriesLabelStyle, options.seriesLabel.useHtml);
            }

            if (series.percentageLabelContent) {
                series._drawLabel(labelG, series.percentageLabelContent, series.percentageLabelPos,
                    series.percentageLabelStyle, options.percentageLabel.useHtml, series.animateLabelPara());
            }

            if (series.valueLabelContent && series.valueLabelContent.length) {
                //
                if (series.valueLabelBackground) {
                    var background = BaseUtils.rectSubPixelOpt(series.valueLabelBackground, 0);
                    background.rx = background.rx = series.radius * 0.02;
                    
                    var valueLabelCfg = series.options.valueLabel;

                    // @Cmen:ValueLabelValueLabelbackgroundRect
                    series.valueLabelBackgroundRect = series.valueLabelBackgroundRect || renderer.rect().addTo(labelG);
                    series.valueLabelBackgroundRect
                        .attr(background)
                        .style({
                            'fill':valueLabelCfg.backgroundColor,
                            'fill-opacity':ColorUtils.getColorOpacity(valueLabelCfg.backgroundColor),
                            'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
                        });

                    series.lastValueLabelG = series.valueLabelG; // ,
                    var valueLabelG = series.valueLabelG = renderer.group().addTo(labelG);
                    if(!series.clipRect){
                        series.clipRect = renderer.createClip(series.valueLabelBackground);
                    }else {
                        renderer.updateClip(series.clipRect, series.valueLabelBackground);
                    }
                    renderer.clip(valueLabelG, series.clipRect);
                }

                var isPointerGaugeValueLabel = series.isPointerGauge();

                for (var i = 0, len = series.valueLabelContent.length; i < len; i++) {
                    var valueLabel = series.valueLabelContent[i];

                    series._drawLabel(labelG, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelStyle, options.valueLabel.useHtml, series.animateLabelPara(), valueLabelG, isPointerGaugeValueLabel);
                }
            }
        },

        animateLabelPara:function () {
        },

        _drawLabel:function(labelG, labelContent, labelPos, labelStyle, useHtml, animatePara, parentG, isPointerGaugeValueLabel){
            if(!labelPos){
                return;
            }
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, textHeight = BaseUtils.getTextHeight(labelStyle);

            var textG = renderer
                .vtext(useHtml)
                .attr({'x': labelPos.x, 'y': labelPos.y, 'dy': 0.85 * textHeight})
                .textContent(labelContent)
                .style(labelStyle)
                .addTo(useHtml ? labelG : (parentG || labelG));

            // ValueLabel
            if(isPointerGaugeValueLabel) {
                series.valueLabels = series.valueLabels || [];
                series.valueLabels.push(textG);
            } else {
                labelG.labels.push(textG);
            }

            // IE8
            if(isSupportSVG && animatePara && animatePara.enabled) {
                if(!series.hasChangedPoint()){ return; }  // 
                textG
                    .attr(animatePara.initAttr || {})
                    .style(animatePara.initStyle || {})
                    .animate({
                        ease: series.EASE_TYPE,
                        duration: series.ANIMATION_TIME,
                        style:{'opacity':1},
                        attr:{'transform':BaseUtils.makeTranslate({x:0, y:0})}
                    });
            }

        },

        _onState:function (graphic, isChosen, style) {
            var series = this;
            graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    ease:isChosen ? series.CHOSEN_EASE : series.OUT_EASE,
                    duration:isChosen ? series.CHOSEN_TIME : series.OUT_TIME,
                    style:style
                })
        },

        isPointerGauge: function(){
            return false;
        },

        _onSinglePointerTap:function(ev){
            //
            if(this.points && this.points.length === 1){
                this.points[0].onClick(ev.srcEvent);
            }
        },

        _onSeriesMouseOver:function(ev){
            if(this.points && this.points.length === 1){
                this.vanchart.showTooltip(this.points[0], ev);
            }
        },

        _onSeriesMouseOut:function(){
            this.vanchart.hideTooltip();
        },

        getClosestPoint:function(){
            return this.points.length === 1 ? this.points[0] : null;
        },

        _getStroke:function(gradient){
            return BaseUtils.isSupportSVG() ? "url(#" + BaseUtils.stamp(gradient) + ")" : gradient;
        },

        //
        getEvents:function(){
            return {
                'pointMouseOver':this._onPointMouseOver,
                'pointMouseOut':this._onPointMouseOut,
                'mousemove':this._onSeriesMouseOver,
                'mouseout':this._onSeriesMouseOut,
                'tap':this._onSinglePointerTap,
                'press':this.onSeriesPress,
                'pressup':this.onSeriesPressUp
            }
        },

        isSupportLegendHighlight:function(){
            return false;
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    return Gauge;
});
/**
 * Created by eason on 16/8/9.
 * 
 */


define('chart/PointerGauge',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','../utils/BoundsManager','../utils/PathGenerator','../utils/Interpolator','../utils/Scale','./Gauge','../ChartLibrary','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolator = require('../utils/Interpolator');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');

    var POINTER_ANGLE = 150;
    var POINTER_SEMI_ANGLE = 90;

    var LABEL_EXIT_DURATION = 900; // 1000ms

    var PointerGauge = Gauge.extend({

        gaugeType:Constants.POINTER_GAUGE,

        _doLayout:function(){

            this._dealSeriesLabel();

            this._dealValueLabel();

            this.options.style == 'pointer' ? this._fixPointerCenter() : this._fixPointerSemiCenter();
        },

        //ring and slot 
        _drawDiffMoreLabels: function () {
            var series = this, points = series.points;

            points.forEach(function (point) {
                series._showMoreLabel(point, series.centerX, series.centerY ); 
            });
        },

        getDataToDraw:function(){
            return this.points;
        },

        _fixPointerCenter:function(){
            var gauge = this, options = gauge.options, radius = options.radius, center = gauge.center;
            var align = options.seriesLabel.align || Constants.BOTTOM;
            if (!center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;
                radius = radius || (Math.min(bounds.width, usedHeight) / 2 - gauge.DEFAULT_PADDING);

                if (align == Constants.BOTTOM) {

                    if (centerY + radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    } else {
                        centerY -= labelHeight / 2;   // 
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    } else {
                        centerY += labelHeight / 2;  // 
                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = center[0];
                gauge.centerY = center[1];
                gauge.radius = radius;
            }

            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius+20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                this._dealValueLabelContent(gauge, radius);
            }
        },

        _fixPointerSemiCenter:function(){
            var gauge = this, options = gauge.options, radius = options.radius, align = options.seriesLabel.align;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;
                radius = radius || (Math.min(bounds.width / 2, usedHeight / 1.14) - gauge.DEFAULT_PADDING);

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2 + radius / 2;
                if (align == Constants.BOTTOM) {

                    if (centerY + 0.14 * radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2; // centerY0.14*radius,
                        }
                    } else {
                        centerY -= (labelHeight / 2  + radius * 0.07);  // @Cmen:CHART-798,radius*0.14
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    } else {
                        centerY += (labelHeight / 2 - radius * 0.07); // @Cmen:CHART-798 radius*0.14
                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius * 0.14 + 20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                this._dealSemiValueLabelContent(gauge, radius);
            }
        },

        _dealValueLabelContent:function(gauge, radius){
            var options = gauge.options, gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
            var domain = gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);
            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var startY = 0.16 * radius + tickHeight/2;

            var valueLabelStyle = options.valueLabel.style;
            var useHtml = options.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight),
                heightBoundsManager = boundsManager.heightBoundsManager,
                widthBoundsManager = boundsManager.widthBoundsManager;

            var visibleCount = 0;
            var valueBackgroundY = startY;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0, totalCount = gauge.valueLabelContent.length; i < totalCount; i++){
                var singleLabel = gauge.valueLabelContent[i];

                var tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:startY + valueLabelHeight * (2 + this.LINE_GAP) - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;

                if(!gauge._boundsInCircle(tmpBounds)) {//
                    break;
                } else if(heightBoundsManager.isOverlapped(tmpBounds)){
                    break;
                }

                while(widthBoundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);

                    tmpX = Math.min(-tmpDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:startY + valueLabelHeight * (1 + this.LINE_GAP) - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){//
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);
                }

                singleLabel.labelPos = {
                    x:-singleLabel.labelDim.width/2,
                    y:startY + valueLabelHeight/2
                };

                startY += valueLabelHeight * (1 + this.LINE_GAP);

                valueBackgroundX = tmpX;

                visibleCount++;
            }

            gauge.valueLabelContent.length = visibleCount;

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height: valueLabelHeight * (1 + this.LINE_GAP) * visibleCount + valueLabelHeight
            };
        },

        /**
         * valueLabel
         * @return {[type]} [description]
         */
        _drawExitValueLabel: function(){
            var series = this, vanchart = series.vanchart;

            series.valueLabels = series.valueLabels || [];

            // LastValueLabel
            if(series.hasChangedPoint()){
                var backgroundWidth = BaseUtils.rectSubPixelOpt(series.valueLabelBackground, 0).width;
                series.valueLabels.forEach(function (text){
                    text
                        .animate({
                            ease: series.EASE_TYPE,
                            duration: LABEL_EXIT_DURATION,
                            style:{'opacity':1},
                            attr:{'transform':BaseUtils.makeTranslate({x:backgroundWidth, y:0})}
                            })
                });
                vanchart.setTimeout('pointer_gague_valueLabel_removetimer', function (){
                    removeLastValueLabelGroup(series.lastValueLabelG);
                },LABEL_EXIT_DURATION)
            }
            // 
            else {
                series.valueLabels.forEach(function (text){
                    text.remove();
                });
                removeLastValueLabelGroup(series.lastValueLabelG);
            }
            series.valueLabels = [];

            function removeLastValueLabelGroup(labelG){
                labelG && labelG.remove();
            }
        },

        isPointerGauge: function(){
            return true;
        },


        _dealSemiValueLabelContent:function(gauge, radius){
            var options = gauge.options, gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
            var domain = gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);
            var valueLabelStyle = options.valueLabel.style;
            var useHtml = options.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var endY = -(0.22 * radius + tickHeight/2) - valueLabelHeight;

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight),
                heightBoundsManager = boundsManager.heightBoundsManager,
                widthBoundsManager = boundsManager.widthBoundsManager;

            var visibleCount = 0;
            var valueBackgroundY = endY;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0, totalCount = gauge.valueLabelContent.length; i < totalCount; i++){
                var singleLabel = gauge.valueLabelContent[i];

                valueBackgroundY -= valueLabelHeight * (1 + this.LINE_GAP);

                var tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:endY - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;

                if(!gauge._boundsInCircle(tmpBounds)) {//
                    valueBackgroundY += valueLabelHeight * (1 + this.LINE_GAP);
                    break;
                } else if(heightBoundsManager.isOverlapped(tmpBounds)){
                    valueBackgroundY += valueLabelHeight * (1 + this.LINE_GAP);
                    break;
                }

                while(widthBoundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);

                    tmpX = Math.min(-tmpDim.width/2 - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:endY - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){//
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    tmpX = Math.min(-singleLabel.labelDim.width/2 - valueLabelHeight/4, valueBackgroundX);
                }

                valueBackgroundX = tmpX;

                visibleCount++;
            }

            gauge.valueLabelContent.length = visibleCount;

            for(var i = 0; i < visibleCount;i++){
                var singleLabel = gauge.valueLabelContent[i];
                singleLabel.labelPos = {
                    x:-singleLabel.labelDim.width/2,
                    y:valueBackgroundY + valueLabelHeight/2 + i * valueLabelHeight * (1 + this.LINE_GAP)
                };
            }

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height: valueLabelHeight * (1 + this.LINE_GAP) * visibleCount + valueLabelHeight
            };
        },

        _boundsInCircle: function (bounds) {
            var radius = this.radius, points = [
                {x:bounds.x, y:bounds.y},
                {x:bounds.x + bounds.width, y:bounds.y},
                {x:bounds.x, y:bounds.y + bounds.height},
                {x:bounds.x + bounds.width, y:bounds.y + bounds.height}];

            for(var i = 0; i < 4; i++){
                var point = points[i], diffX = Math.abs(point.x), diffY = Math.abs(point.y);
                if(Math.pow(diffX * diffX + diffY * diffY, 0.5) > radius){
                    return false;
                }
            }

            return true;
        },

        _getPointerTickBoundsManager:function(gaugeAxis, radius, scale, tickHeight){

            var widthBoundsManager = new BoundsManager();
            var heightBoundsManager = new BoundsManager();

            var labelR = (1 - 0.05 - 0.1 - 0.01) * radius;
            var tickData = gaugeAxis.tickData;
            var gauge = this, gap = tickHeight * 0.5;

            tickData.forEach(function(tick){

                var radian = scale(tick.tickValue);

                var center = gauge._getPointerTickCenter(tick, labelR, scale);

                gauge._addToBoundsManager(radian, {
                    x:center.x - tick.tickDim.width/2 - gap,
                    y:center.y - tick.tickDim.height/2 - gap,
                    width:tick.tickDim.width + gap,
                    height:tick.tickDim.height + gap
                }, widthBoundsManager, heightBoundsManager);

            });

            var minorTickData = gaugeAxis.getMinorTickData() || [];

            var minorTickR = (1 - 0.05 - 0.1) * radius;
            var minorTickSize = 0.1 * radius;

            minorTickData.forEach(function(minorTickValue){

                var radian = scale(minorTickValue);

                var point = gauge._getArcPoint(minorTickR, radian);

                var x, y;
                if(radian < Math.PI){
                    //
                    x = point[0];
                    y = point[1];

                }else{
                    //
                    x = point[0] - minorTickSize;
                    y = point[1];
                }

                gauge._addToBoundsManager(radian, {
                    x:x,
                    y:y,
                    width:minorTickSize,
                    height:minorTickSize
                }, widthBoundsManager, heightBoundsManager);
            });

            return {
                widthBoundsManager:widthBoundsManager,
                heightBoundsManager:heightBoundsManager
            };
        },

        //-45to45 -135to-180 135to180 
        _addToBoundsManager: function (radian, bounds, widthBoundsManager, heightBoundsManager) {
            if(radian > -Math.PI/4 && radian < Math.PI/4){
                heightBoundsManager.addBounds(bounds);
            }
            if(radian < -Math.PI * 3/4 || radian > -Math.PI * 3/4){
                heightBoundsManager.addBounds(bounds);
            }
            widthBoundsManager.addBounds(bounds);
        },

        //
        _getPointerTickCenter:function(tick, labelR, scale){

            var radian = scale(tick.tickValue);

            var joinPoint = this._getArcPoint(labelR, radian);
            var x = joinPoint[0];
            var y = joinPoint[1];

            var tickDim = tick.tickDim;

            var angle = Math.atan(tickDim.width / tickDim.height);

            var labelCenterX, labelCenterY;
            if(Math.abs(radian) < angle){

                var gap = tickDim.height/2;
                labelCenterX = x + gap * x / y;
                labelCenterY = y + gap;

            }else if(radian >= angle && radian <= (Math.PI - angle)){//

                var gap = tickDim.width/2;
                labelCenterX = x - gap;
                labelCenterY = y - gap * y / x;

            }else if(radian >= angle - Math.PI && radian <= -angle){//

                var gap = tickDim.width/2;
                labelCenterX = x + gap;
                labelCenterY = y + gap * y / x;

            }else{
                //
                var gap = tickDim.height/2;
                labelCenterX = x - gap * x / y;
                labelCenterY = y - gap;
            }

            return {
                x:labelCenterX,
                y:labelCenterY
            }
        },

        animateLabelPara:function () {
            var series = this;
            return{enabled:true, initAttr:{'transform': BaseUtils.makeTranslate({x:-series.valueLabelBackground.width, y:0})}};
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
                this.hingePath = renderer.path().addTo(group);

                this.labelGroup = this._getPointTextLabelGroup();

                this.axisGroup = this.labelGroup;
                this.needleGroup = renderer.group().addTo(group);
                this.pointerHingePath = renderer.path().addTo(group);
            }

            // seriesevents
            vanchart.registerInteractiveTarget(this, group);

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.dropFilter){
                this.dropFilter =  renderer.createDropShadowFilter(0, 2, 0.1, 2);
                this.innerFilter = renderer.createInnerShadowFilter(0, 2, 0.1, 2);
            }

            this.options.style == 'pointer' ? this._drawPointer(180,0.16,0.07) : this._drawPointer(98,0.11,0.055);
        },

        onSeriesPress:function(){

            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.options.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.options.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius * 1.25);
            this.hingePath.attr('d', circle());

            //
            circle.outerRadius(hinge * this.radius * 1.25);
            this.pointerHingePath.attr('d', circle());
        },

        onSeriesPressUp:function(){

            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.options.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.options.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius);
            this.hingePath.attr('d', circle());

            //
            circle.outerRadius(hinge * this.radius);
            this.pointerHingePath.attr('d', circle());
        },

        _getScale:function(){
            var series = this, style = series.options.style, scaleAngle = style == 'pointer' ? POINTER_ANGLE : POINTER_SEMI_ANGLE;
            var domain = series.gaugeAxis.scale.domain();
            return Scale.linear().domain(domain).range([BaseUtils.toRadian(-scaleAngle), BaseUtils.toRadian(scaleAngle)]);
        },

        getStyle:function(point){
            var options = point.options;
            return {
                'fill':options.needle,
                'fill-opacity':ColorUtils.getColorOpacity(options.needle)
            };
        },

        getHighLightStyle:function(point){
            var options = point.options;
            return {
                'fill':ColorUtils.getHighLightColor(options.needle)
            };
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getPointGraphicGroup:function(){
            return this.needleGroup;
        },

        getPointInitAnimationAttr:function(point){
            var series = point.series, scale = series._getScale();

            return {
                duration:series.ANIMATION_TIME,
                ease:series.EASE_TYPE,
                attrTween:{'d':function(){

                    var lastAngle = this._current_ || scale.domain()[0];
                    this._current_ = BaseUtils.getValueInDomain(point.value, scale.domain());

                    var interpolate = Interpolator(lastAngle, this._current_);

                    return function(t){
                        return series._getArrowPath(interpolate(t));
                    }
                }}
            };
        },

        getPointUpdateAnimationAttr:function(point){
            return this.getPointInitAnimationAttr(point)
        },

        _getArrowPath:function(y){
            var initRadian = this._getScale()(y);
            var radius = this.radius;
            var p0 = this._getArcPoint(0.9 * radius, initRadian);
            var p1 = this._getArcPoint(0.02 * radius, initRadian + Math.PI/2);
            var p2 = this._getArcPoint(0.02 * radius, initRadian - Math.PI/2);
            return 'M' + p0[0] + ',' + p0[1] + 'L' + p1[0] + ',' + p1[1] + 'L' + p2[0] + ',' + p2[1] + 'Z';
        },

        _drawPointer:function(baseAngle, hBackground, hinge){
            var series = this, options = series.options, radius = series.radius;
            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = PathGenerator.arc().startAngle(BaseUtils.toRadian(-baseAngle))
                .endAngle(BaseUtils.toRadian(baseAngle))
                .innerRadius(0).outerRadius(radius).toCenter(false);

            series.backgruondPath.attr('d', arc()).style({
                'fill':options.paneBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.paneBackgroundColor),
                'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });

            //
            circle.outerRadius(hBackground * radius);
            series.hingePath.attr('d', circle()).style({
                'fill' : options.hingeBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.hingeBackgroundColor),
                'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
            });

            this._drawPointerTicks();

            this._drawGaugeLabels(series.labelGroup);
            //
            circle.outerRadius(hinge * radius);
            series.pointerHingePath.attr('d', circle()).style({
                'fill':options.hinge,
                'fill-opacity':ColorUtils.getColorOpacity(options.hinge),
                'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });
        },

        _drawPointerTicks:function(){
            var series = this, bands = series.defaultBands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.axisGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var tickR = (1 - 0.05) * series.radius, labelR = (1 - 0.05 - 0.1 - 0.01) * series.radius;

            var scale = this._getScale();

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function(d){return scale(d.tickValue);});
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (BaseUtils.hasDefined(d.tickContent)) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for(i = 0, len = currentTickLines.length; i < len; i++){

                var tick = currentTickLines[i], tickD = tick.datum();

                var radian = scale(tickD.tickValue);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.1 * series.radius, radian);

                var color = series._getColorFromBands(tickD.tickValue, bands);

                tick.attr('x1', start[0]).attr('y1', start[1]).attr('x2', end[0]).attr('y2', end[1])
                    .style({'stroke':color, 'stroke-width':1});

                var center = series._getPointerTickCenter(tickD, labelR, scale);

                tick.text && tick.text
                    .textContent(tickD.tickContent).style(BaseUtils.clone(labelStyle))
                    .attr({
                        x: center.x - tickD.tickDim.width/2,
                        y: center.y - tickD.tickDim.height/2,
                        dy: '.85em'
                    });
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for(i = 0, len = currentTickLines.length; i < len; i++){
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var radian = scale(value);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.05 * series.radius, radian);
                var color = series._getColorFromBands(value, bands);
                tickLine.attr('x1', start[0]).attr('y1', start[1])
                    .attr('x2', end[0]).attr('y2', end[1]).style({'stroke':color, 'stroke-width':1});
            }
        },

        _onPointMouseOver:function(point) {
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point.graphic, true, style);
        },

        _onPointMouseOut:function(point) {
            var series = point.series, style = series.getStyle(point);

            //arguments[1]ease && duration.over out0.2 easetrue
            series._onState(point.graphic, true, style);
        }

    });

    require('../ChartLibrary').register(Constants.POINTER_GAUGE, PointerGauge);
    require('../ChartLibrary').register(Constants.POINTER_SEMI_GAUGE, PointerGauge);

    return PointerGauge;
});


/**
 * Created by eason on 16/8/9.
 * 
 */

define('chart/SlotGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','../utils/PathGenerator','../utils/Scale','./Gauge','../utils/Interpolator','../component/FormattedText','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var PathGenerator = require('../utils/PathGenerator');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');
    var Interpolator = require('../utils/Interpolator');
    var FormattedText = require('../component/FormattedText');

    var SlotGauge = Gauge.extend({

        gaugeType:Constants.SLOT_GAUGE,

        _getFixedPos:function(datum, divDim){
            var gauge = datum.series;
            var x = gauge.centerX + gauge.radius * 1.08 + 10;
            var y = gauge.centerY - divDim.height/2;
            return [x, y];
        },

        _dealValueLabel:function(){
            var series = this, options = series.options, point = series.points[0];

            var valueLabel = options.valueLabel, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;

            series.valueLabelContent = '';

            if(!point || point.isNull){
                return;
            }

            if(valueLabel && valueLabel.enabled) {
                var labelContent = FormattedText.createMultiLineLabelContent(formatter, point);
                var labelStyle = valueLabel.style;
                var valueLabelContent = [];
                for(var i = 0, len = labelContent.length; i < len; i++){
                    valueLabelContent.push({
                        labelContent:labelContent[i],
                        labelStyle:labelStyle,
                        labelDim:BaseUtils.getTextDimension(labelContent[i], labelStyle, useHtml)
                    });
                }
                series.valueLabelContent = valueLabelContent;
            }
        },

        _fixCenterAndRadius:function(){
            var gauge = this, options = gauge.options, radius = options.radius;
            if (!gauge.center) {
                var bounds = gauge.bounds;

                if(!radius){
                    radius = Math.min(bounds.width / 2, bounds.height / 2);
                    //0.16
                    radius = radius / 1.08 - gauge.DEFAULT_PADDING;
                }

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }else{
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
                gauge.radius = radius;
            }

            if(gauge.percentageLabelContent && gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                };

                var startY = 0;
                for(var i = 0, count = gauge.valueLabelContent.length; i < count; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };

                    startY += (valueLabel.labelDim.height * (1 + gauge.LINE_GAP))
                }

            }else if(gauge.percentageLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height/2
                };

            }else if(gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                var labelHeight = BaseUtils.getTextHeight(options.valueLabel.style);
                var labelCount = gauge.valueLabelContent.length;

                var totalHeight = labelHeight * labelCount + labelHeight * (labelCount - 1) / 2;

                var startY = - totalHeight / 2;

                for(var i = 0; i < labelCount; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };
                    startY += (labelHeight * (1 + gauge.LINE_GAP));
                }
            }
        },

        drawSeries:function(){
            var series = this, options = series.options, point = series.points[0],
                vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
            }

            if (!this.slotBackground) {
                this.slotBackground = renderer.path().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.innderShadow){
                this.innderShadow = renderer.createInnerShadowFilter(0, 2, 0.05, 0);
                this.dropShadow = renderer.createDropShadowFilter(0, 2, 0.05, 0);
            }

            var arc = PathGenerator.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var circle = PathGenerator.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var domain = series.gaugeAxis.scale.domain();
            var scale = Scale.linear().domain(domain).range([BaseUtils.toRadian(-135), BaseUtils.toRadian(135)]);

            series.backgruondPath.attr('d', circle())
                .style({
                    'fill':'none',
                    'stroke': options.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': series.radius * 0.16,
                    'filter':'url(#'+ BaseUtils.stamp(this.innderShadow) +')'
                });

            if(!point || point.isNull){
                if (series.slotBackground) {
                    series.slotBackground.remove();
                    series.needlePath.remove();
                    series.slotBackground = series.needlePath = null;
                }
                series._removeNormalLabels(this.labelGroup);
            } else {

                var initRadian = scale(domain[0]), endRadian = scale(BaseUtils.getValueInDomain(point.value, domain));
                var endDegree = BaseUtils.toDegree(endRadian - initRadian);
                var startStroke = series._getColorFromBands(domain[0], series.defaultBands);
                var endStroke = point.color;

                series.slotBackground.style({
                    'fill': 'none',
                    'stroke': ColorUtils.colorToHex(endStroke),
                    'stroke-linecap': 'round',
                    'stroke-width': series.radius * 0.16
                });

                //
                var cP = this._getArcPoint(series.radius, initRadian);
                series.needlePath.attr('cx', cP[0]).attr('cy', cP[1])
                    .attr('r', 0.048 * series.radius)
                    .style({
                        'fill': options.needle,
                        'fill-opacity': ColorUtils.getColorOpacity(options.needle),
                        'filter': 'url(#' + BaseUtils.stamp(this.dropShadow) + ')'
                    });

                if (series.vanchart.renderer.isAnimation) {

                    series.slotBackground.animate({
                        duration: series.ANIMATION_TIME,
                        ease: series.EASE_TYPE,
                        attrTween: {
                            'd': function () {
                                this._lastRadian_ = this._lastRadian_ || initRadian;
                                var interpolate = Interpolator(this._lastRadian_, endRadian);
                                this._lastRadian_ = endRadian;
                                return function (t) {
                                    return arc.endAngle(interpolate(t))();
                                }
                            }
                        }
                    });

                    series.needlePath.animate({
                        duration: series.ANIMATION_TIME,
                        ease: series.EASE_TYPE,
                        attrTween: {
                            'transform': function () {
                                this._lastRotate_ = this._lastRotate_ || 0;
                                var interpolate = Interpolator(this._lastRotate_, endDegree);
                                this._lastRotate_ = endDegree;
                                return function (t) {
                                    return "rotate(" + interpolate(t) + ")";
                                }
                            }
                        }
                    });

                } else {
                    //todo ie bug
                    var pathStr = arc.endAngle(endRadian)();
                    var pos = series._getArcPoint(series.radius, endRadian);
                    var x = pos[0], y = pos[1], r = series.radius * 0.008;

                    if (Math.abs(endRadian - initRadian) < 1e-6) {
                        var arc = 'a' + r + ',' + r + ' 0 1,0 ';
                        pathStr = 'M' + (x - r) + ',' + y + arc + (r * 2) + ',0 ' + arc + (-r * 2) + ',0 ';
                    }

                    series.slotBackground.attr('d', pathStr);
                    series.needlePath.attr({'cx': pos[0], 'cy': pos[1]});
                }
            }

            this._drawGaugeLabels(this.labelGroup);
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var point = this.points[0];
            if(point){

                var backgroundColor = ColorUtils.getHighLightColor(point.color);
                var needleColor = ColorUtils.getHighLightColor(this.options.needle);

                this._onState(this.slotBackground, true, {'stroke':ColorUtils.colorToHex(backgroundColor)});
                this._onState(this.needlePath, true, {'fill':needleColor});
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.slotBackground, false, {'stroke':point.color});
                this._onState(this.needlePath, false, {'fill':point.options.needle});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                var backgroundColor = ColorUtils.getColorWithDivider(point.color, 1/0.95);
                var needleColor = ColorUtils.getColorWithDivider(this.options.needle, 1/0.95);

                this.slotBackground.style({'stroke':ColorUtils.colorToHex(backgroundColor)});

                this.needlePath.style({'fill':needleColor});
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.SLOT_GAUGE, SlotGauge);

    return SlotGauge;
});

/**
 * Created by eason on 16/8/9.
 * 
 */

define('chart/RingGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','./Gauge','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var Gauge = require('./Gauge');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolator = require('../utils/Interpolator');

    var RingGauge = Gauge.extend({

        gaugeType:Constants.RING_GAUGE,

        _fixCenterAndRadius:function(){
            var gauge = this, options = gauge.options, radius = options.radius, centerX, centerY;
            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
            }else{
                var bounds = gauge.bounds;
                radius = radius || (Math.min(bounds.width/2, bounds.height/2) - gauge.DEFAULT_PADDING);
                centerX = bounds.x + bounds.width/2;
                centerY = bounds.y + bounds.height/2;
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;

            var totalHeight = 0;
            var valueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            if(gauge.percentageLabelContent && valueLabel){
                totalHeight = gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP) + valueLabel.labelDim.height;
            }else if(gauge.percentageLabelContent){
                totalHeight = gauge.percentageLabelDim.height;
            }else if(valueLabel){
                totalHeight = valueLabel.labelDim.height;
            }

            var startY = -totalHeight/2;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos = {
                    x: -gauge.percentageLabelDim.width/2,
                    y:startY
                };

                startY += gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP);
            }

            if(valueLabel){
                valueLabel.labelPos = {
                    x:-valueLabel.labelDim.width/2,
                    y:startY
                };
            }
        },

        drawSeries:function(){
            var series = this, options = series.options,  vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
            }

            if (!this.ringPath) {
                this.ringPath = renderer.path().addTo(group);
            }

            if (!this.innerBackgroundPath) {
                this.innerBackgroundPath = renderer.path().addTo(group);
                this.innerStroke = renderer.path().addTo(group);
                this.outerStroke = renderer.path().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            if(!this.colorGradient){
                var attrs = {'x1':'0%', 'y1':"0%", 'x2':"0%", 'y2':"100%"};
                var stop1 = {'offset':'0%', 'stop-color':'#ffffff'};
                var stop2 = {'offset':'100%', 'stop-color':'#dddddd'};
                this.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);


                stop1['stop-color'] = '#dddddd';
                stop2['stop-color'] = '#ffffff';
                this.clickedGradient = renderer.colorGradient(attrs, [stop1, stop2]);

                if(!BaseUtils.isSupportSVG()){
                    this.colorGradient = '#ffffff';
                    this.clickedGradient = '#dddddd';
                }
            }
            var circle = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0).outerRadius(series.radius);
            var domain = series.gaugeAxis.scale.domain();
            var startFill = series._getColorFromBands(domain[0], series.defaultBands);
            var innerR = series.radius * 0.8;
            var outerStrokeR = innerR + 2, innerStrokeR = innerR - 1.5;

            this.backgruondPath.attr('d', circle()).style({
                'fill':options.paneBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(options.paneBackgroundColor)
            });

            var point = series.points[0];
            if(point) {
                var arc = PathGenerator.arc().startAngle(0).innerRadius(0).outerRadius(series.radius);
                var endFill = point.color, arcPercentage = Math.max(point.percentage, 0);
                var endRadian = 2 * Math.PI * arcPercentage * (options.clockwise ? 1 : -1);
                this.ringPath.style({
                    'fill': ColorUtils.colorToHex(endFill),
                    'fill-opacity': ColorUtils.getColorOpacity(endFill)
                });

                this.ringPath.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attrTween:{'d':function(){
                        this._lastRadian_ = this._lastRadian_ || 0;
                        var interpolate = Interpolator(this._lastRadian_, endRadian);
                        this._lastRadian_ = endRadian;

                        return function (t) {
                            return arc.endAngle(interpolate(t))();
                        }
                    }}
                });
            } else {
                if (this.ringPath) {
                    this.ringPath.remove();
                    this.ringPath = null;
                }
            }

            this.innerBackgroundPath.attr('d', circle.outerRadius(innerR)())
                .style({
                    'fill':options.innerPaneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(options.innerPaneBackgroundColor)
                });

            this.outerStroke.attr('d', circle.outerRadius(outerStrokeR)())
                .style({'fill': 'none', 'stroke':'#000000', 'stroke-opacity':0.05, 'stroke-width':4 });

            this.innerStroke.attr('d', circle.outerRadius(innerStrokeR)())
                .style({
                    'fill': 'none',
                    'stroke':this._getStroke(this.colorGradient),
                    'stroke-width':3
                });


            this._drawGaugeLabels(this.labelGroup);
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.innerStroke, true, {'stroke':this._getStroke(this.colorGradient)});
                this._onState(this.ringPath, true, {'fill': point.mouseOverColor});
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var point = this.points[0];
            if(point){
                this._onState(this.innerStroke, false, {'stroke':this._getStroke(this.colorGradient)});
                this._onState(this.ringPath, false, {'fill': point.color});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.innerStroke.style({'stroke':this._getStroke(this.clickedGradient)});
                this.ringPath.style({'fill': point.clickColor});
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.RING_GAUGE, RingGauge);

    return RingGauge;
});
/**
 * Created by eason on 16/8/9.
 * 
 */

define('chart/ThermometerGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils','../utils/Scale','./Gauge','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var Gauge = require('./Gauge');

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;
    var DEFAULT_RADIUS = 100;
    var MAGIC_DET = 0.001;

    var lastLabelShiftLength;  // 

    var ThermometerGauge = Gauge.extend({

        gaugeType:Constants.THERMOMETER_GAUGE,

        //ring and slot 
        _drawDiffMoreLabels: function () {
            var point = this.points[0];

            if(!point || point.isNull){
                return;
            }

            var domain = this.gaugeAxis.scale.domain();

            var vertical = this.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var scale = Scale.linear().domain(domain).range(
                vertical ? [this.radius , -this.radius] : [ -this.radius , this.radius]);
            var index = scale(point.y);

            var centerX = vertical ? 0 - THERMOMETER_R * 2 + 10 : index;
            var centerY = vertical ? index : 0 - THERMOMETER_R * 2 + 10;

            function f(a, b) {
                return a - b/2;
            }

            var gauge = this; 
            var baseX = gauge.centerX; 
            var baseY = gauge.centerY; 
 
            this._showMoreLabel(point, centerX + baseX, centerY + baseY, f, f); 
        },

        _fixCenterAndRadius:function(){
            var point = this.points[0];
            var gauge = this;
            var para = gauge.options.thermometerLayout == Constants.HORIZONTAL_LAYOUT ?
                this._fixHorizontalThermometerCenter() : this._fixVerticalThermometerCenter();

            var centerX = para.centerX;
            var centerY = para.centerY;
            var radius = para.radius;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos.x -= centerX;
                gauge.percentageLabelPos.y -= centerY;

                //
                gauge.percentageLabelPos.y = Math.min(gauge.percentageLabelPos.y, radius - gauge.percentageLabelDim.height);
            }

            if(showValueLabel){
                showValueLabel.labelPos.x -= centerX;
                showValueLabel.labelPos.y -= centerY;

                var gap = (radius - showValueLabel.labelDim.height) - showValueLabel.labelPos.y;

                //
                if(gap < 0){
                    showValueLabel.labelPos.y += gap;

                    if(gauge.percentageLabelContent){
                        gauge.percentageLabelPos.y += gap;
                    }
                }
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;
        },

        _fixHorizontalThermometerCenter:function(){

            var gauge = this, options = gauge.options, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = options.percentageLabel, valueLabel = options.valueLabel;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var centerX, centerY, radius = gauge.options.radius;

            var totalHeight = this._getThermometerSize();
            var startY;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                startY = centerY;
            } else {
                var bounds = gauge.bounds;
                startY = bounds.y + (bounds.height - totalHeight)/2;
                centerX = bounds.x + bounds.width/2;
                radius = radius || (bounds.width/2 - gaugeAxis.getMaxTickWidth() - gauge.DEFAULT_PADDING);
            }

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.TOP && valueLabel.align == Constants.TOP){

                    if (gauge.center) {
                        startY -= (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));
                        startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                        startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                    }

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));


                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }

                    if(showValueLabel && valueLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }
                }
            }

            if (gauge.center) {
                startY = centerY + 5;
            } else {
                startY += (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R * 2);
                centerY = startY - 5;
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.BOTTOM && valueLabel.align == Constants.BOTTOM){
                    startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.BOTTOM){

                        startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                    }

                    if(showValueLabel && valueLabel.align == Constants.BOTTOM){

                        startY += (showValueLabel.labelDim.height * gauge.HORIZONTAL_GAP);

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                    }
                }

            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixVerticalThermometerCenter:function(){
            var gauge = this, options = gauge.options, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = options.percentageLabel, valueLabel = options.valueLabel;
            var centerX, centerY, radius = options.radius;

            var point = gauge.points[0];
            var domain = gaugeAxis.scale.domain();
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            //
            var totalWidth = this._getThermometerSize();
            var startX;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                startX = centerX - THERMOMETER_R * 2;
            } else {
                var bounds = gauge.bounds;
                startX = bounds.x + (bounds.width - totalWidth)/2;
                centerY = bounds.y + bounds.height/2;
                radius = radius || (bounds.height/2 - gaugeAxis.getTickHeight() - gauge.DEFAULT_PADDING);
            }

            var scale = Scale.linear().domain(domain).range([radius, -radius]);
            var labelY = centerY + scale(BaseUtils.getValueInDomain(point.value, domain));

            if(gauge.percentageLabelDim){
                labelY -= gauge.percentageLabelDim.height/3;//
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.LEFT && valueLabel.align == Constants.LEFT){

                    if (!gauge.center) {
                        startX += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        centerX = startX + THERMOMETER_R;
                    }

                    gauge.percentageLabelPos = {
                        x:startX - gauge.percentageLabelDim.width,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX - showValueLabel.labelDim.width,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                        }

                        gauge.percentageLabelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                    }

                    if(showValueLabel && valueLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                        }

                        showValueLabel.labelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                    }
                }
            }

            if (gauge.center) {
                startX = centerX - THERMOMETER_R;
            } else {
                centerX = startX + THERMOMETER_R;
            }

            startX += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getMaxTickWidth());

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.RIGHT && valueLabel.align == Constants.RIGHT){

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                    gauge.percentageLabelPos = {
                        x:startX,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.RIGHT){
                        gauge.percentageLabelPos = {
                            x:startX + gauge.LINE_GAP * gauge.percentageLabelDim.height,
                            y:labelY
                        };
                    }

                    if(showValueLabel && valueLabel.align == Constants.RIGHT){

                        showValueLabel.labelPos = {
                            x:startX + gauge.LINE_GAP * showValueLabel.labelDim.height,
                            y:labelY
                        };
                    }
                }
            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        //,
        _getThermometerSize:function(){

            var gauge = this, options = gauge.options, valueLabel = options.valueLabel, gaugeAxis = gauge.gaugeAxis;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var percentageLabel = options.percentageLabel;

            if(gauge.options.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                var totalHeight = 0;

                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalHeight += (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                        totalHeight += gauge.LINE_GAP * gauge.percentageLabelDim.height;

                        totalHeight += gauge.HORIZONTAL_GAP * (valueLabel.align == Constants.TOP
                                ? showValueLabel.labelDim.height : gauge.percentageLabelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * gauge.percentageLabelDim.height;
                }else if(showValueLabel){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * showValueLabel.labelDim.height;
                }

                totalHeight += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getTickHeight());

                return totalHeight;

            }else{

                var totalWidth = 0;
                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalWidth += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);
                    }else{
                        totalWidth += (gauge.percentageLabelDim.width + showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalWidth += (gauge.percentageLabelDim.width + gauge.VERTICAL_GAP * gauge.percentageLabelDim.height);
                }else if(showValueLabel){
                    totalWidth += (showValueLabel.labelDim.width + gauge.VERTICAL_GAP * showValueLabel.labelDim.height);
                }

                totalWidth += gaugeAxis.getMaxTickWidth();

                totalWidth += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP);

                return totalWidth;
            }

            return DEFAULT_RADIUS;
        },

        /**
         * 
         * 
         * 
         * 
         * 
         * seriesLabelvalueLabellastShiftLength
         * @returns {{enabled: boolean, initAttr: {transform: *}, initStyle: {opacity: number}}}
         */
        animateLabelPara:function () {
            var series = this, point = series.points[0];
            var gaugeAxis = series.gaugeAxis, domain = gaugeAxis.scale.domain(), isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var valueInDomain = BaseUtils.getValueInDomain(point.value, domain), radius = series.radius;
            var scale = Scale.linear().domain(domain).range([0, 2 * radius]);

            // 
            var shiftLength = isVertical ? scale(valueInDomain) : -radius;
            // lastLabelShiftLength
            lastLabelShiftLength = shiftLength;
            // drawLabelinitAttr
            shiftLength -= this._lastShiftLength || 0;
            // 
            var pos = isVertical ? {x: 0, y: shiftLength} : {x: shiftLength, y: 0};

            return{enabled:true, initAttr:{'transform': BaseUtils.makeTranslate(pos)}, initStyle:{'opacity':0}};
        },

        // lastLabelPos
        updateLastLabelPos: function (){
            this._lastShiftLength = lastLabelShiftLength;
        },

        _fillFilter:function (color, useAlpha) {
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer,
                isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            if(BaseUtils.isSupportSVG()) {
                var endColor = color;
                var startColor = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);
                if(useAlpha) {
                    var alpha = ColorUtils.getStandardColorAndOpacity(endColor).alpha;
                    if (alpha < 1) {
                        startColor = ColorUtils.mixColorWithAlpha(startColor, alpha);
                    }
                }

                var x2 = '0%', y2 = '0%';
                isVertical ? y2 = '100%' : x2 = '100%';
                var stop1 = {'offset': '0%', 'stop-color': isVertical ? endColor : startColor};
                var stop2 = {'offset': '100%', 'stop-color': isVertical ? startColor : endColor};
                var attr = {'x1': '0%', 'y1': '0%', 'x2': x2, 'y2': y2};
                if (this.colorGradient) {
                    renderer.updateColorGradient(this.colorGradient, attr, [stop1, stop2]);
                } else {
                    this.colorGradient = renderer.colorGradient(attr, [stop1, stop2]);
                }

                return "url(#" + BaseUtils.stamp(this.colorGradient) + ")";
            }
            return color;
        },

        _clickEndColor:function (point) {
            return ColorUtils.getColorWithDivider(point.color, 1/0.95);
        },

        _mouseOverEndColor:function (point) {
            return ColorUtils.getColorWithDivider(point.mouseOverColor, 1/0.95);
        },

        drawSeries:function(){
            var series = this, options = series.options, point = series.points[0],
                vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            var gaugeAxis = series.gaugeAxis, domain = gaugeAxis.scale.domain(), isVertical = series.options.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var valueInDomain = BaseUtils.getValueInDomain(point.value, domain), radius = series.radius;

            if(!this.backgruondLine){
                this.backgruondLine = renderer.line().addTo(group);
                this.axisGroup = renderer.group().addTo(group);
            }

            if (!this.thermometerLine) {
                this.thermometerLine = renderer.line().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
            }

            this.labelGroup = this._getPointTextLabelGroup();

            var scale = Scale.linear().domain(domain).range([-radius, radius]);
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', cx = 'cx', cy = 'cy';

            var endX = scale(valueInDomain);
            var initX = -radius;

            if(isVertical){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';cx = 'cy'; cy = 'cx';
                initX = radius;
                endX = scale.range([radius, -radius])(valueInDomain);
            }

            var lastX = BaseUtils.pick(series.thermometerLine.node()._lastX_, initX);
            series.thermometerLine.node()._lastX_ = endX;

            series.backgruondLine.attr(x1, -radius).attr(y1, 0).attr(x2, radius).attr(y2, MAGIC_DET)
                .style({'fill':'none', 'stroke': options.slotBackgroundColor,
                    'stroke-width':THERMOMETER_R * 2, 'stroke-linecap':'round'});

            if (point.isNull) {
                if (this.thermometerLine) {
                    this.thermometerLine.remove();
                    this.needlePath.remove();
                    this.thermometerLine = this.needlePath = null;
                }

            } else {//

                series.thermometerLine.attr(x1, initX).attr(y1, 0).attr(y2, MAGIC_DET).attr(x2, lastX)
                    .style({
                        'stroke':series._fillFilter(point.color, true),
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    });

                series.needlePath.attr('r', THERMOMETER_R * 0.9).attr(cx, lastX).attr(cy, 0)
                    .style({
                        'fill': options.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(options.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke': series._needleStrokeColor(point)
                    });

                var attr = {}; attr[x2] = endX;
                series.thermometerLine.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attr:attr
                });

                attr = {}; attr[cx] = endX;
                series.needlePath.animate({
                    duration:series.ANIMATION_TIME,
                    ease:series.EASE_TYPE,
                    attr:attr
                });
            }

            this._drawGaugeLabels(this.labelGroup);
            this._drawThermometerTicks(scale);
        },

        _needleStrokeColor:function(point){
            //
            return ColorUtils.mixColorWithHSB(point.color, 0, 0.1, -0.1);
        },

        _drawThermometerTicks:function(scale) {
            var series = this, bands = series.options.bands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.labelGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';

            var startY = -9, endY = -15, endMinorY = -13;
            var textY = -19;

            var attrFunc = function (tickD, posX) {
                return {
                    x: posX - tickD.tickDim.width / 2,
                    y: textY - tickD.tickDim.height * 0.85,
                    dy: '0.85em'
                }
            };

            if (series.options.thermometerLayout == Constants.VERTICAL_LAYOUT) {
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                startY = 9; endY = 15; endMinorY = 13;
                textY = 19;
                attrFunc = function (tickD, posX) {
                    return {
                        x: textY,
                        y: posX - tickD.tickDim.height / 2,
                        dy: '.85em'
                    }
                }
            }

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function (d) {
                return scale(d.tickValue);
            });
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (BaseUtils.hasDefined(d.tickContent)) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tick = currentTickLines[i], tickD = tick.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(tickD.tickValue), 1);

                tick.attr(x1, posX).attr(y1, startY).attr(x2, posX).attr(y2, endY)
                    .style({'stroke': axisOption.tickColor, 'stroke-width': axisOption.tickWidth});

                tick.text && tick.text.textContent(tickD.tickContent).style(labelStyle).attr(attrFunc(tickD, posX));
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for (i = 0, len = selection.exit.length; i < len; i++) {
                selection.exit[i].remove();
            }

            for (i = 0, len = selection.enter.length; i < len; i++) {
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(value), 1);
                tickLine.attr(x1, posX).attr(y1, startY)
                    .attr(x2, posX).attr(y2, endMinorY).style({
                    'stroke': axisOption.minorTickColor,
                    'stroke-width': axisOption.minorTickWidth
                });
            }
        },

        _getFixedPos:function(datum, divDim) {
            var gauge = datum.series, options = gauge.options;
            var thermometerLayout = gauge.options.thermometerLayout;
            var percentContent = gauge.percentageLabelContent, valueContent = gauge.valueLabelContent;

            var x, y;

            if(thermometerLayout == Constants.HORIZONTAL_LAYOUT){
                x = gauge.centerX - divDim.width/2;
                var baseY = gauge.centerY;
                y = baseY + THERMOMETER_R + 10;

                if(percentContent && percentContent.length && options.percentageLabel.align == Constants.BOTTOM){
                    y = baseY + gauge.percentageLabelPos.y + gauge.percentageLabelDim.height + 10;
                }

                if(valueContent && valueContent.length && options.valueLabel.align == Constants.BOTTOM){
                    var valueLabel = gauge.valueLabelContent[0];
                    y = baseY + valueLabel.labelPos.y + valueLabel.labelDim.height + 10;
                }

            }else{

                y = gauge.centerY - divDim.height/2;

                var tickWidth = gauge.gaugeAxis.getMaxTickWidth();

                var baseX = gauge.centerX;
                x = baseX + THERMOMETER_R + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + tickWidth + 10;

                if(percentContent && percentContent.length && options.percentageLabel.align == Constants.RIGHT){
                    x = baseX + gauge.percentageLabelPos.x + gauge.percentageLabelDim.width + 10;
                }

                if(valueContent && valueContent.length && options.valueLabel.align == Constants.RIGHT){
                    var valueLabel = gauge.valueLabelContent[0];
                    x = Math.max(x, baseX + valueLabel.labelPos.x + valueLabel.labelDim.width + 10)
                }
            }

            return [x, y];
        },

        _onSeriesMouseOver:function(ev){
            Gauge.prototype._onSeriesMouseOver.call(this, ev);

            var series = this, point = this.points[0];
            if(point){
                series._onState(series.thermometerLine, true, {'stroke':series._fillFilter(series._mouseOverEndColor(point))});
                series._onState(series.needlePath, true, {
                    'stroke':ColorUtils.getHighLightColor(this._needleStrokeColor(point)),
                    'fill': ColorUtils.getHighLightColor(series.options.needle)
                });
            }
        },

        _onSeriesMouseOut:function(ev){
            Gauge.prototype._onSeriesMouseOut.call(this, ev);

            var series = this, point = series.points[0];
            if(point){
                series._onState(series.thermometerLine, false, {'stroke':series._fillFilter(point.color, true)});
                series._onState(series.needlePath, false, {'stroke': this._needleStrokeColor(point), 'fill': this.options.needle});
            }
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.thermometerLine.style('stroke', this._fillFilter(this._clickEndColor(point)));

                this.needlePath
                    .style({
                        'stroke':ColorUtils.getClickColor(point.color),
                        'fill': ColorUtils.getClickColor(this.options.needle)
                    });
            }
        },

        onSeriesPressUp:function(){
            this._onSeriesMouseOver();
        }
    });

    require('../ChartLibrary').register(Constants.THERMOMETER_GAUGE, ThermometerGauge);

    return ThermometerGauge;
});
/**
 * Created by Yuqian on 16/8/9.
 * 
 */

define('chart/TreeSeries',['require','./Series','../utils/BaseUtils','../utils/QueryUtils','../Constants','./Point','../dom/Evented'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');

    var LABEL_GAP = 2;

    var TreeSeries = Series.extend({

        refresh: function (options, index) {

            Series.prototype.refresh.call(this, options, index);

            //chart type specific attributes
            this._refresh();

            this._initChildren();

            return this;
        },

        // Tree data's key of children is varied,
        // so '_initChildren' may be varied;
        // 'visitBefore' is intended for initializing some property like colors;
        // 'visitAfter' for calculating.
        _initChildren: function () {

            this.traverseInitData(this.visitBefore, null);

            // make it as normal series
            this.points = this.root.children;
            this.root.options.tooltip = null;
        },

        _getPointKey: function (point) {
            return point.name;
        },

        //,value
        getTargetKey:function(){
            return 'value';
        },

        _getChildrenKey: function () {
            return 'children';
        },

        traverseData: function (root, visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            function dfsData(node, depth, parent, ancestor) {
                if (!node.children) {
                    node.children = node.options[series._getChildrenKey()];
                }
                var c = node.children;

                node.parent = parent;
                node.depth = depth;
                node.level = depth;
                node.height = 0;
                node.ancestor = ancestor;

                visitBefore && visitBefore.call(series, node);

                if (c && (n = c.length)) {
                    var i = -1, n;
                    while (++i < n) {

                        if ((c[i] instanceof  Point)) {
                            // c[i].refresh();
                        } else {
                            c[i] = new Point(c[i], root.series);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = c[i];
                        }

                        dfsData(c[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, c[i].visible ? c[i].height + 1 : 0);
                    }
                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(root, 0, null, null);
        },

        traverseInitData: function (visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            var rootOptions = {children:this.options.data, name:this.name};
            if(this.root){
                this.root.refresh(rootOptions);
            } else {
                this.root = new Point(rootOptions, series);
            }
            function dfsData(node, nodeOptions, depth, parent, ancestor) {

                var data = nodeOptions[series._getChildrenKey()];

                node.parent = parent;
                node.depth = depth;
                node.level = depth; // level_
                node.height = 0;
                node.ancestor = ancestor;
                node.seriesName = series.name;

                node.children = node.children || [];

                visitBefore && visitBefore.call(series, node);

                // todo, diff algorithm and unit test
                if(BaseUtils.hasDefined(data)) {
                    var newChildrens = [];
                    for (var i = 0, len = data.length; i < len; i++) {

                        var refresh = false;
                        var child;
                        if (node.children.length) {
                            node.children.forEach(function (point) {

                                var pointkey = series._getPointKey(point);

                                if (BaseUtils.hasDefined(pointkey) && (pointkey == series._getPointKey(data[i]))) {
                                    point._lastValue = point.options[series.getTargetKey()];
                                    point.refresh(data[i]);
                                    refresh = true;
                                    child = point;
                                    newChildrens.push(point);
                                }
                            });
                        }

                        if (!refresh) {
                            child = new Point(data[i], series);
                            newChildrens.push(child);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = child;
                        }

                        child.index = i;

                        dfsData(child, data[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, child.visible ? child.height + 1 : 0);
                    }

                    for (var j = 0, size = node.children.length; j < size;) {

                        if (BaseUtils.indexOf(newChildrens, node.children[j]) === -1) {
                            node.children[j].clearChild();
                            // child is removed in clearChild;
                            size--;
                        } else {
                            j++;
                        }
                    }

                    // parent: {value: 123} ----> parent: {children: [1,2,3], value: 123}
                    if (series.type === Constants.TREEMAP_CHART
                    && node.children.length === 0
                    && newChildrens.length) {
                        node.remove();
                        node.visible = true;
                    }

                    /**
                     * TODO
                     * diff
                     *  I. data diff:
                     *     
                     * II. data - dom diff:
                     *     data = domdatadom
                     *     datadom
                     *     diffdom
                     */


                    node.children = newChildrens;

                } else {
                    // parent: {children: [1,2,3], value: 123} ----> parent: {value: 123}
                    
                    var len = node.children.length;
                    while (--len > -1) {
                        node.children[len].clearChild();
                    }

                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(this.root, rootOptions, 0,  null, null);
        },


        visitBefore: function (node) {
            if (node.depth === 1) {
                node.color = this.vanchart.getDefaultSeriesColor(node.name);
            }
        },

        visitAfter: function () {

        },

        drawPoint:function (point, delay) {

            delay = delay || 0;

            var shouldBeVisible = point.isVisible();
            var currentVisibleState = point.graphic && point.graphic.isVisible();

            if (shouldBeVisible === currentVisibleState){

                point.graphic && this._drawUpdatePoints(point, delay);

            } else if (shouldBeVisible && !currentVisibleState) {

                this._drawEnterPoints(point);

            } else if (!shouldBeVisible && currentVisibleState){

                this._drawExitPoints(point);

            }
        },

        _calculatePercentage:function(points, key){
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d[key]);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.percentage = Math.abs(point[key]) / total;
            });
        },

        _onPointMouseOver: function (point) {
            var series = point.series,
                vanchart = series.vanchart, hoverPoint = vanchart.hoverPoint;
            
            if (hoverPoint) {
                this._onPointMouseOut(hoverPoint);
            }

            if (!point.depth) {
                return;
            }
            series.onPointMouseOver(point);
            vanchart.hoverPoint = point;
        },

        _onPointMouseOut: function (point) {
            var series = point.series;
            series.onPointMouseOut(point);
            series.vanchart.hideTooltip();
        },

        isSeriesAccumulated:function(){
            return true;
        },

        getLegendKey:function(point){
            var parent = point.parent;
            while(parent && parent.parent != this.root){
                parent = parent.parent;
            }
            return parent ? parent.name : '';
        },

        isTreeSeries:function(){
            return true;
        }
    });

    return TreeSeries;
});
/**
 * Created by Jeffrey on 16/6/15.
 */

define('chart/MultiPie',['require','../Constants','../utils/BaseUtils','../utils/Scale','./TreeSeries','./PieSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','./Point','../utils/BezierEasing','../EffectHelper','../utils/PathGenerator','../utils/Interpolator','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Scale = require('../utils/Scale');
    var TreeSeries = require('./TreeSeries');
    var PieSeries = require('./PieSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Point = require('./Point');
    var Bezier = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');

    var INNER_RADIUS_PCT = 2 / 3;
    var INNER_RING_RADIUS = 15;
    var INNER_RING_STROKE_WIDTH = 5;

    var CIRCLE = 2 * Math.PI;

    var HOVER_PERCENT = 1.1;

    var VIS_MIN = 1E-10;

    var ANIMATION_TIME = 1000;
    var INNER_HOVER_TIME = 300;
    var SORT_TIME = 400;

    var EASE = 'bounce';
    var INNER_HOVER_EASE = Bezier.css.swing;
    var SORT_EASE = Bezier.css.swing;

    var MultiPie = TreeSeries.extend(PieSeries).extend({

        // prop list
        //
        // nodes: [],
        //
        // root: null,
        //
        // ordered: null,
        //
        // drilldownNow: null,
        //
        // // for convenient
        // center: [],
        // innerRadius: null,
        // radius: null,
        // startAngle: null,
        // endAngle: null,
        // drilldown: null,
        // rotatable: null,
        //
        // chartInfo: {},

        arc: PathGenerator.arc()
            .startAngle(function (d) { return d.x; })
            .endAngle(function (d) { return d.x + d.dx; })
            .innerRadius(function(d) { return d.y;})
            .outerRadius(function(d) { return d.y + d.dy;}),

        _refresh: function () {

            this.chartInfo = {rotate: 0};
            this.sx = Scale.linear();
            this.sy = Scale.linear();

        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                var orderType = this.orderType;

                // #orderData
                c.sort(function(a, b){
                    if (orderType && a.value != null && b.value != null) {
                        return orderType * (Math.abs(a.value) - Math.abs(b.value));
                    } else {
                        return a.index - b.index;
                    }
                });

                node.chSum = Math.max(chSum, Math.abs(_value || 0));
            }

            node.value = _value || node.chSum || 0;

            if (!node.visible) {
                // value is visible size
                // chSum is hold size(include blank)
                node.value = 0;
                node.chSum = 0;
            }
        },

        _visitBefore: function (node) {
            node.isNull = false;
            if (!node.depth) {
                return;
            }

            if (node.depth === 1) {
                node.points = [node];
            } else {
                node.points = node.parent.points.slice();
                node.points.push(node);
            }
        },

        doLayout: function () {

            var series = this;

            var center = [], bounds;
            var plotBounds = this.vanchart.bounds;
            var options = series.options;
            if (!options.center || options.center.length === 0) {
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            } else {
                center[0] = this._getPercentValue(options.center[0], this.vanchart.width);
                center[1] = this._getPercentValue(options.center[1], this.vanchart.height);
            }

            bounds = {x: plotBounds.x, y: plotBounds.y, width: plotBounds.width, height: plotBounds.height};

            series.chartInfo.innerRadius = options.innerRadius;
            series.chartInfo.center = center;
            series.chartInfo.bounds = bounds;

            this.traverseData(this.root, this._visitBefore, this.visitAfter);

            this._initData(series);

            // recover when series dis/hide,
            this.drilldownNow = this.root;

        },

        _initData: function (series) {

            series.nodes = series._bfsTraverseData(series.root);

            // #orderData
            var oldGraphics = series.graphics;
            if (this._isOrderChanged()
                && oldGraphics
                && oldGraphics.length === series.nodes.length) {
                series.nodes.map(function (node, i) {
                    // exchange the displayed graphic
                    node._view = oldGraphics[i];
                });
            }

            var chartInfo = series.chartInfo;
            var options = series.options;

            var radius = chartInfo.radius || options.radius;

            if (radius) {
                series._calcData(series.root);
                series._calculateLabelPos();

            } else {
                // if no radius
                // calculated radius
                // thus calc only once

                var bounds = chartInfo.bounds;
                var center = chartInfo.center;
                chartInfo.radius = Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

                series._calcData(series.root);

                var outPoints = series.nodes.filter(function (node) {
                    return (node.depth &&
                        node.dx &&
                        node.options.dataLabels &&
                        node.options.dataLabels.enabled &&
                        node.options.dataLabels.align === Constants.OUTSIDE)
                });

                if (outPoints.length) {
                    chartInfo.radius = series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center);
                } else {
                    chartInfo.radius = Math.round(chartInfo.radius / HOVER_PERCENT);
                }

                series._calcData(series.root);

                series._calculateLabelPos();
            }

            series.sx = this.sx.range([this.startAngle, this.endAngle]).domain([this.startAngle, this.endAngle]);
            series.sy = this.sy.range([0, this.innerRadius, this.radius]).domain([0, this.innerRadius, this.radius]);

        },

        getDataToDraw: function () {
            return this.nodes;
        },

        orderData: function (para) {
            // #orderData
            // search '#orderData' in this file to get hint
            // some explain:
            // http://www.finedevelop.com/pages/viewpage.action?pageId=11243711
            this.orderType = para === true ?
                1 : para === false ?
                -1 : null;
            this._saveLastView();
        },

        _saveLastView: function () {
            this.graphics = this.nodes.map(function (node) {
                return node._view;
            });
        },

        _bfsTraverseData: function (root) {
            var queue = [];
            var stack = [];
            queue.push(root);

            while (node = queue.shift()) {
                var node;
                stack.push(node);
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        queue.push(children[i]);
                    }
                }
            }
            return stack;
        },

        _calcData: function (root) {
            var series = this;

            if (series.chartInfo.radius && series.options.innerRadius) {
                series.chartInfo.innerRadius = this._getPercentValue(series.options.innerRadius, series.chartInfo.radius);
            }

            var height = root.height;

            var radius = series.chartInfo.radius;
            var innerRadius = series.chartInfo.innerRadius;
            var gradual = series.options.gradual;
            var startAngle = series.startAngle;
            var endAngle = series.endAngle;

            var arc = endAngle - startAngle;

            var dRadius, innerPieR;

            // display !== options value
            // the first ring (depth = 1) radius depends on innerRadius
            if (innerRadius) {
                dRadius = height ? (radius - innerRadius) / height : 0;
                innerPieR = dRadius;
            } else {
                dRadius = (height > 1) ? radius * (1 - INNER_RADIUS_PCT) / (height - 1) : 0;
                innerPieR = (height > 1) ? radius * INNER_RADIUS_PCT : radius;
            }

            // hdx is 'hold dx', hdx >= dx, may leave blank.
            function dfsData(node, x, dx, hdx, dy, ir, iPr) {
                var children = node.children;

                // save last value for enter (dx 0)
                // note: if calculate twice,
                // it has no meaning
                node.x1 = node.x;
                node.y1 = node.y;
                node.dx1 = node.dx;
                node.dy1 = node.dy;

                // going to display
                node.x = x;
                node.y = (node.depth - 2) * dy + ir + iPr;
                node.dx = dx;
                node.hdx = hdx;
                node.dy = dy;

                // adjust values
                if (node.depth) {

                    if (node.depth === 1 && !ir) {
                        node.y = 0;
                        node.dy = iPr;
                    }

                    // outside label may be revised to inside,
                    // otherwise do nothing
                    var options = node.options;
                    if (options.dataLabels && options.dataLabels.enabled) {
                        // clone once only
                        if (!options.dataLabels._align && options.dataLabels.align === Constants.OUTSIDE) {
                            options.dataLabels = BaseUtils.clone(options.dataLabels);
                            options.dataLabels._align = options.dataLabels._align || options.dataLabels.align;
                        }
                        if (options.dataLabels._align === Constants.OUTSIDE) {
                            if (node.depth === height) {
                                options.dataLabels.align = Constants.OUTSIDE;
                            } else {
                                options.dataLabels.align = Constants.INSIDE;
                            }
                        }
                    }

                    series._setColor(node, gradual, height);
                    series.calculateLabelInfo(node);

                } else {
                    // -1 to avoid dy=0, thus invalidate drill down scale
                    node.y = -1;
                    node.dy = ir + 1;
                }

                // save origin for drillDown
                node._x = node.x;
                node._dx = node.dx;
                node._hdx = node.hdx;
                node._y = node.y;
                node._dy = node.dy;

                if (children && (n = children.length)) {
                    var i = -1, n, c, d, hd;
                    dx = node.value ? dx / Math.abs(node.value) : 0;
                    hdx = node.chSum ? hdx / Math.abs(node.chSum) : 0;
                    while (++i < n) {
                        c = children[i];
                        d = Math.abs(c.value) * dx;
                        hd = Math.abs(c.chSum) * hdx;
                        dfsData(c, x, d, hd, dy, ir, iPr);
                        x += hd;
                    }

                }
            }

            dfsData(root, startAngle, arc, arc, dRadius, innerRadius, innerPieR);
        },

        _setColor: function (node, gradual, height) {
            if (!(node && gradual && height)) {
                return;
            }
            if (node.options.color) {
                node.color = node.options.color;
            } else {
                var rgba = ColorUtils.getRGBAColorArray(node.ancestor.color);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var detS, detB;

                var ratio = (node.depth - 1) / height;

                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = -hsb[1] * ratio;
                    detB = (1 - hsb[2]) * ratio;
                } else {
                    detS = (1 - hsb[1]) * ratio;
                    detB = -hsb[2] * ratio;
                }

                node.color = ColorUtils.mixColorWithHSB(node.ancestor.color, 0, detS, detB);
            }


            if (node.options.mouseOverColor) {
                node.mouseOverColor = node.options.mouseOverColor;
            } else {
                var detS, detB;
                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = +0.1;
                    detB = -0.05
                } else {
                    detS = -0.1;
                    detB = +0.05;
                }
                
                node.mouseOverColor = ColorUtils.mixColorWithHSB(
                    (node.options.tooltip && node.options.tooltip.enabled && node.options.tooltip.shared) ?
                        node.ancestor.color :
                        node.color,
                    0, detS, detB);
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
        },

        _calculateLabelPos: function () {
            var series = this;
            var outPoints = [];
            var inPoints = [];

            series.nodes.map(function (node) {
                node.labelPos = null;
                if (node.dx < VIS_MIN) {
                    return;
                }

                if (node.name &&
                    node.depth &&
                    node.dx &&
                    node.dy &&
                    (series.drilldownNow ? node !== series.drilldownNow.parent : true) &&
                    node.options.dataLabels && node.options.dataLabels.enabled) {

                    if (node.options.dataLabels.align === Constants.OUTSIDE) {
                        outPoints.push(node);
                    } else {
                        inPoints.push(node);
                    }
                }
            }, series);

            var chartInfo = series.chartInfo;

            series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center, chartInfo.radius);

            series.calculateLeadLineStartPos(outPoints);

            series.calculateInsideLabelBounds(inPoints);
        },

        _getInnerRadius: function (d) {
            return d.y;
        },

        _getOuterRadius: function (d) {
            return d.y + d.dy;
        },

        _getStartAngle: function (d) {
            return d.x;
        },

        _getEndAngle: function (d) {
            return d.x + d.dx;
        },

        _getPositionInPie: function(absPos){

            var x = absPos.x - this.chartInfo.center[0];

            var y = absPos.y - this.chartInfo.center[1];

            return {x: x, y: y};
        },

        _getFixedPos: function(datum, divDim){

            var translateX = this.chartInfo.center[0];
            var translateY = this.chartInfo.center[1];

            var centerAngle = this.getCenterAngle(datum);
            var radius = (datum.y + datum.dy) * HOVER_PERCENT;



            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },
        
        drillDown: function (d) {
            if (this.drilldownNow === d) {
                return;
            }

            var p, node = d;
            while ((p = node.parent) && p.depth) {
                node = p;
                if (!p.name) {
                    return;
                }
            }

            this.drilldownNow = d;

            var radius = this.chartInfo.radius;
            var innerRadius = this.chartInfo.innerRadius;

            function deepest(node) {
                var children = node.children;
                var dc = node;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        var c = deepest(children[i]);
                        if (c.depth > dc.depth) {
                            dc = c;
                        }
                    }
                }
                return dc;
            }

            var yDomain, yRange;

            if (d.depth) {
                var rootHeight = d.ancestor.parent.height;

                // outer ring
                if (d.height === 0) {
                    yDomain = [d.parent._y, d._y, d._y + d._dy];
                    yRange = [0, INNER_RING_RADIUS, radius];

                } else
                // deepest child is not outer ring
                if (d.height + d.depth !== rootHeight) {
                    var dc = deepest(d);
                    yDomain = [d.parent._y, d._y, d._y + d._dy, dc._y + dc._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius, radius];

                } else {
                    yDomain = [d.parent._y, d._y, d._y + d._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius];
                }

            } else {
                yDomain = [0, innerRadius, radius];
                yRange = [0, innerRadius, radius];
            }

            var h = d.depth + d.height;

            this.sx.domain([d._x, d._x + d._dx]);
            this.sy.domain(yDomain).range(yRange);

            this.nodes.map(function (node) {
                if (node.depth &&
                    node.dataLabels &&
                    node.dataLabels.enabled &&
                    node.dataLabels._align === Constants.OUTSIDE) {
                    if (node.depth === h) {
                        node.dataLabels.align = Constants.OUTSIDE;
                    } else {
                        node.dataLabels.align = Constants.INSIDE;
                    }
                    QueryUtils.merge(node, this.calculateLabelInfo(node), true)
                }
                node.x = this.safeAngle(node._x);
                node.dx = this.safeAngle(node._x + node._dx) - node.x;
                node.y = this.safeRadius(node._y);
                node.dy = this.safeRadius(node._y + node._dy) - node.y;

                if (node === this.drilldownNow.parent) {
                    node.dx = this.safeAngle(7);// to ensure inner pie fill the circle.
                }

            }, this);

            this._calculateLabelPos();
            
            this.drawDrillDown(d);
        },

        safeAngle: function (x) {
            return Math.max(this.startAngle, Math.min(this.endAngle, this.sx(x)));
        },

        safeRadius: function (y) {
            return Math.max(0, this.sy(y));
        },

        _getTranslate:function(){
            return this.chartInfo.center;
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var translateX = this.chartInfo.center[0]; 
            var translateY = this.chartInfo.center[1]; 
 
            var rotate = point.rotate || 0; 
            var angle = rotate + point.x + point.dx / 2 ; 
            var r = point.y + point.dy / 2; 
            var center = this._getArcPoint(r, angle); 
 
            return { 
                startX: center[0] + translateX, 
                startY: center[1] + translateY, 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (dom, d) {
            EffectHelper.areaStyleEffectAnimation(dom, d);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getStyle:function(p){
            return {
                'display': (p.name || p.depth < 2) ? '' : 'none',  // namename
                'fill':p.color,
                'fill-opacity': p.depth ? p.opacity : 0,
                'stroke': p.options.borderColor,
                'stroke-opacity':p.options.borderOpacity,
                'stroke-width':p.options.borderWidth
            }
        },

        getAttrs:function(p){
            return {'d':this.arc(p)};
        },

        getPointGraphicKey:function(){
            return 'path';
        },
        
        getChartNodes: function () {
            return this.nodes;
        },

        getCenter: function () {
            return this.center;
        },

        getRadius: function () {
            return this.radius;
        },
        
        getDrilldown: function () {
            return this.options.drilldown;
        },

        _getPointGraphicGroup:function(){
            if (!this.wrapGroup) {
                this.wrapGroup = this.group.append(this.vanchart.renderer.group());
                this.drawRing();
            }
            return this.wrapGroup;
        },

        // don't know why here ...
        // _getPointTextLabelGroup:function(){
        //     if(!this.textLabelGroup){
        //         this.textLabelGroup = this.group.append(this.vanchart.renderer.group());
        //     }
        //     return this.textLabelGroup;
        // },

        drawRing: function () {
            if (this.ringPath) {
                return;
            }
            this.ringPath = this.group.append(this.vanchart.renderer.path());
            this.ringPath
                .attr({
                    'd':PathGenerator.arc()
                        .startAngle(0)
                        .endAngle(Math.PI * 2)
                        .innerRadius(INNER_RING_RADIUS)
                        .outerRadius(INNER_RING_RADIUS + INNER_RING_STROKE_WIDTH)()
                })
                .style({
                    'display': 'none',
                    'fill': 'rgba(0,0,0,0.1)',
                    'pointer-events': 'none'
                })

        },

        drawDrillDown: function (target) {
            var series = this;
            var supportAnimation = series.vanchart.renderer.isAnimation;

            series._removeDataLabels();

            var arc = series.arc;
            if (supportAnimation) {
                var n = 0;
                series.nodes
                .filter(function (node) {return node.graphic;})
                .map(function (p) {
                    p.graphic
                        .transition()
                        .ease('cubic-in-out')
                        .each('start', function () { ++n; })
                        .duration(ANIMATION_TIME)
                        .style('fill', function(){
                            return p.color;
                        })
                        .attrTween("d", function () {
                            var i = Interpolate(p._view, {x:p.x, y:p.y, dx:p.dx, dy:p.dy});

                            return function (t) {
                                var b = i(t);
                                p._view = b;
                                return arc(b);
                            };
                        })
                        // following handle the small edge things,
                        // doesn't matter to the main animation...
                        .attrTween('opacity', function () {
                            return function (t) {
                                return (p.depth && (p._view.y + p._view.dy) >= INNER_RING_RADIUS) ? 1 : 0
                            }
                        })
                        .each('end', function () {
                            p.graphic.attr('opacity', (p.depth && p.dx && (p.y + p.dy) > INNER_RING_RADIUS) ? 1 : 0);
                            if (!--n) {
                                series._animateEnd();
                                series.ringPath.style('display', (target && target.depth) ? '' : 'none');
                            }
                        });
                });

                if (!target.depth) {
                    series.ringPath
                        .transition()
                        .style('display', 'none');
                }

            } else {

                series.nodes.map(function (d) {
                    d.graphic
                        .attr({
                            'd': arc(d),
                            'opacity': (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0
                        });

                });

                series._animateEnd(target);

                if (!BaseUtils.isSupportSVG()) {
                    series.root.graphic.style({
                        'fill': 'rgba(0,0,0,0)'
                    });
                }

                series.ringPath.style('display', target.depth ? '' : 'none');

            }

        },

        _animateEnd: function () {

            if(!this.vanchart.renderer){
                return; //has been removed
            }

            // for mPie's order animation
            this.ordered = this.orderType;
            this._showLabels();
            this._drawEffectPoints();
        },

        _isOrderChanged: function () {
            return this.ordered !== this.orderType
        },

        // animation
        initialAnimation: function () {

            this.wrapGroup
                .animate({
                    duration:ANIMATION_TIME,
                    ease: Bezier.css["ease-out-cubic"],
                    attrTween: {
                        transform:function () {
                            var i = Interpolate(-360, 0);
                            var j = Interpolate(0, 1);
                            return function (t) {
                                var rotate = i(t), scale = j(t);
                                return 'rotate(' + rotate + ')'+'scale(' + scale + ')';
                            };
                        }
                    }
                });
        },

        getPointUpdateAnimationAttr:function(p){

            var arc = this.arc;

            var isChanged = this._isOrderChanged();
            var ease = isChanged ? SORT_EASE : EASE;
            var aTime = isChanged ? SORT_TIME : ANIMATION_TIME;

            p.graphic
                .attr("opacity", p.depth ? 1 : 0);// hide inner circle

            this.ringPath.style('display', this.drilldownNow.depth ? '' : 'none');

            return {
                ease: ease,
                duration: aTime,
                attrTween: {
                    d: function () {
                        var self = this;
                        var i = Interpolate(p._view, {x:p.x, y:p.y, dx:p.dx, dy:p.dy});
                        return function (t) {
                            var b = i(t);
                            p._view = b;
                            return arc(b);
                        };
                    }
                }
            }
        },

        getPointInitAnimationAttr:function(p){

            var arc, data, series = p.series;

            if (series.initialAnimationMoving) {
                // this.initialAnimation();
                // Interpolator will check every key in b,
                // so give it a simple object is better
                data = {x:p.x, y:p.y, dx:p.dx, dy:p.dy};
            } else {
                data = {x:p.x1, y:p.y1, dx:p.dx1, dy:p.dy1};
            }
            arc = series.arc(data);

            // for animation calc and #orderData
            p._view = data;

            var attr = {
                d: arc,
                opacity: p.depth ? 1 : 0 // hide inner circle
            };

            if (!series.initialAnimationMoving) {
                p.graphic.attr(attr);
                return series.getPointUpdateAnimationAttr(p);
            }

            return {
                attr: attr
            }

        },

        getPointDropAnimationAttr:function(d){
            return this.getPointUpdateAnimationAttr(d);
        },

        // event
        onPointMouseOver:function(point){
            this._onState(point, true);
        },

        onPointMouseOut:function(point){
            this._onState(point, false);
        },

        _onState: function (point, isChosen) {
            if (point.options.tooltip && point.options.tooltip.shared) {
                var p, node = point;
                while ((p = node.parent) && p.depth && p.y+p.dy !== INNER_RING_RADIUS) {
                    node = p;
                    p.series._onSingleState(p, isChosen);
                }
            }
            point.series._onSingleState(point, isChosen);
        },

        _onSingleState:function(point, isChosen){
            var series = point.series, animation = series.options.animation;
            // var pathNode = point.graphic.rawElement;
            var style = {}, attr = {};
            if (point.depth && point._view.y1+point._view.dy1 === INNER_RING_RADIUS) {
                attr = {'opacity': isChosen ? 1 : 0};
            } else {
                style = {
                    'fill-opacity': isChosen ? 1 : point.opacity,
                    'fill': isChosen ? point.mouseOverColor : point.color
                };
            }

            if(animation){
                series._onPointState(point, isChosen, style, attr);
                series._onTextState(point, isChosen);
            }else{
                point.graphic.attr(attr).style(style);
                if (!point.depth && !BaseUtils.isSupportSVG()) {
                    point.graphic.style('fill', 'rgba(0,0,0,0)');
                }
            }
        },

        onPointTap: function (point) {
            if (this.getDrilldown()) {
                this.drillDown(point);
            }
        },

        isSupportLegendHighlight:function(){
            return false;
        }

    });

    MultiPie.prototype._calculateLabelPosWhenRadiusFixed = MultiPie.prototype._calculateLabelPos;
    
    require('../ChartLibrary').register(Constants.MULTIPIE_CHART, MultiPie);

    return MultiPie
});
/**
 * Created by Yuqian on 16/7/19.
 */

define('chart/TreeMap',['require','../Constants','../utils/BaseUtils','./TreeSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','./Point','../EffectHelper','../vans/TreeMapLayout','../utils/Scale','../utils/Interpolator','../dom/DomUtils','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var TreeSeries = require('./TreeSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Point = require('./Point');
    var EffectHelper = require('../EffectHelper');
    var treemapLayout = require('../vans/TreeMapLayout').treemapLayout;
    var Scale = require('../utils/Scale');
    var Interpolator = require('../utils/Interpolator');
    var DomUtils = require('../dom/DomUtils');

    var TOPLABELGAP = 6;

    var ANIMATION_TIME = 800;
    var INIT_EASE = 'out-bounce';

    var CHANGE_TIME = 1000;

    var VANISH_TIME = 800;

    var CHOSEN_TIME = 100;

    var treeMap = TreeSeries.extend({

        nodes: [],

        root: null,

        zoomNow: null,

        sx: null,
        sy: null,

        zoom: null,

        _refresh: function () {
            this.sx = Scale.linear();
            this.sy = Scale.linear();
        },

        visitBefore: function (node) {
            this._setColor(node);
        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                node.chSum = chSum;
            }

            node.value = _value || node.chSum || 0;

            if (node.ancestor && !node.ancestor.visible) {
                node.value = 0;
            }
        },

        doLayout: function () {

            this.traverseData(this.root, null, this.visitAfter);

            var plotBounds = this.vanchart.bounds;

            this.sx.range([0, plotBounds.width]).domain([0, plotBounds.width]);
            this.sy.range([0, plotBounds.height]).domain([0, plotBounds.height]);

            var treeMap = treemapLayout()
                .value(function (d) { return Math.abs(d.value) })
                .size([plotBounds.width, plotBounds.height]);

            this.nodes = treeMap.nodes(this.root)
                .filter(function(d) { return !d.children && d.depth; })
                .map(function (d) {
                    d.value = d.chSum; // for negative value
                    d.visible = d.ancestor.visible;

                    if (d.visible) {
                        this._setVanishPos(d, plotBounds);
                    }

                    this.calculateLabelInfo(d);

                    this._calcLabelPos(d);

                    stash(d);

                    return d;
                }, this);

            function stash (d) {
                d._dx = d.dx;
                d._dy = d.dy;
                d._x = d.x;
                d._y = d.y;
            }
        },

        getDataToDraw: function () {
            return this.nodes;
        },

        _setVanishPos: function (d, plotBounds) {
            d.vanishPos = [
                Math.round((d.ancestor.x + d.ancestor.dx / 2) / plotBounds.width) * plotBounds.width,
                Math.round((d.ancestor.y + d.ancestor.dy / 2) / plotBounds.height) * plotBounds.height
            ];
        },

        _setColor: function (node) {
            if (node.depth === 1) {
                node.color = node.options.color || this.vanchart.getDefaultSeriesColor(node.name);
                node.mouseOverColor = node.options.mouseOverColor || ColorUtils.getHighLightColor(node.color);
                node.clickColor = node.options.clickColor || ColorUtils.getClickColor(node.color);
            }
            if (node.depth > 1 && !node.options.children) {
                if (node.options.color) {
                    node.color = node.options.color;
                } else {
                    node.color = node.ancestor.color;
                }

                if (node.options.mouseOverColor) {
                    node.mouseOverColor = node.options.mouseOverColor;
                } else {
                    if (node.options.color) {
                        node.mouseOverColor = ColorUtils.getHighLightColor(node.options.color);
                    } else {
                        node.mouseOverColor = node.ancestor.mouseOverColor;
                    }
                }

                if (node.options.clickColor) {
                    node.clickColor = node.options.clickColor;
                } else {
                    if (node.options.color) {
                        node.clickColor = ColorUtils.getClickColor(node.options.color);
                    } else {
                        node.clickColor = node.ancestor.clickColor;
                    }
                }
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
            node.borderColor = node.options.borderColor;
            node.borderOpacity = node.options.borderOpacity;
        },

        _calculateLabelPos: function () {

        },

        //
        _calcLabelPos: function (d) {
            var lbl = d.options.dataLabels;
            if (lbl && lbl.enabled) {

                switch (lbl.align) {
                    case Constants.CENTER:
                        lbl._align = Constants.CENTER;
                        d.labelPos = {
                            x: d.x + (d.dx - d.labelDim.width) / 2,
                            y: d.y + (d.dy - d.labelDim.height) / 2
                        };
                        break;
                    case Constants.TOP:
                    default:
                        lbl._align = Constants.LEFT;
                        d.labelPos = {
                            x: d.x + TOPLABELGAP,
                            y: d.y + TOPLABELGAP
                        };
                }

                var rectBound = {x: d.x, y: d.y, width: d.dx, height: d.dy};
                var dataBound = {
                    x: d.labelPos.x,
                    y: d.labelPos.y,
                    width: d.labelDim.width,
                    height: d.labelDim.height
                };
                if (!BaseUtils.containsRect(rectBound, dataBound)) {
                    d.labelPos = null;
                }
            }
        },

        /**
         * @override Series.calcMoreLabelPosition.
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.x + point.dx/2 + chartBounds.x, 
                startY = point.y + point.dy/2 + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d, d.x+d.dx/2, d.y+d.dy/2);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        _getFixedPos:function(datum){

            var plotBounds = this.vanchart.bounds;

            var x = plotBounds.x + datum.x + datum.dx;
            var y = plotBounds.y + datum.y;

            return [x, y];
        },

        zoomTo: function (d) {
            d = this.zoomNow === d.parent ? this.root : d.parent;
            var sx = this.sx.domain([d.x, d.x + d.dx]);
            var sy = this.sy.domain([d.y, d.y + d.dy]);

            var plotBounds = this.vanchart.bounds;
            var kx = plotBounds.width / d.dx, ky = plotBounds.height / d.dy;

            this.nodes.map(function (node) {
                node.dx = kx * node._dx;
                node.dy = ky * node._dy;
                node.x = sx(node._x);
                node.y = sy(node._y);
                this._calcLabelPos(node);
                node.clearPointEffect();
                node.graphic && node.graphic.interrupt();
            }, this);

            // this.render();
            this.vanchart.fire('animationStart');

            this.zoomNow = d;
        },

        getChartNodes: function () {
            return this.nodes;
        },
        
        getZoom: function () {
            return this.options.zoom;
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.group.append(this.vanchart.renderer.group());
            }
            return this.pathGroup;
        },

        // animation
        initialAnimation: function () {

            var series = this;
            var node = this._getPointGraphicGroup();
            var plotBounds = this.vanchart.bounds;
            var cx = plotBounds.width / 2;
            var cy = plotBounds.height / 2;
            node.animate({
                    duration: ANIMATION_TIME,
                    ease: INIT_EASE,
                    attrTween: {
                        transform: function () {
                            var i = Interpolator(0, 1);
                            return function (t) {
                                var inter = i(t);
                                return 'matrix(' +
                                    inter + ',' + 0 + ',' +
                                    0 + ',' + inter + ',' +
                                    (cx - inter * cx) + ',' + (cy - inter * cy) + ')';
                            };
                        }
                    }
                });
        },

        _pointExpandAttr: function (d) {
            return {
                'x': -d.dx/2,
                'y': -d.dy/2,
                'width': d.dx,
                'height': d.dy,
                'transform': "translate(" + (d.x + d.dx/2) + "," + (d.y + d.dy/2) + ")"
            }
        },

        _pointContractAttr: function (d) {
            return {
                'x': 0,
                'y': 0,
                'width': 0,
                'height': 0,
                'transform': "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")"
            }
        },

        getPointInitAttr:function(d){
            return this.initialAnimationMoving
                ? this._pointExpandAttr(d)
                : this._pointContractAttr(d)
        },

        getPointUpdateAnimationAttr: function (d) {
            var series = this;
            if (d.visible) {
                return {
                    ease: 'quad-in-out',
                    duration: CHANGE_TIME,
                    attr: this._pointExpandAttr(d)
                }
            } else {
                return series.getPointDropAnimationAttr(d)
            }
        },

        getPointInitAnimationAttr: function (d) {
            if (this.initialAnimationMoving) {
                return {};
            }
            return this.getPointUpdateAnimationAttr(d);
        },

        getPointDropAnimationAttr:function(d){
            return {
                ease: 'quad-in-out',
                duration: VANISH_TIME,
                attr: {
                    width: 0,
                    height: 0,
                    transform: "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")"
                }
            }
        },

        // event
        onPointMouseOver:function(point){
            point.series._onState.call(point, true);
        },

        onPointMouseOut:function(point){
            point.series._onState.call(point, false);
        },

        _onState:function(isChosen){
            var point = this, series = point.series;
            var style = {
                'fill': isChosen ? point.mouseOverColor : point.color,
                'border-width': point.options.borderWidth + (isChosen ? 1 : 0)
            };

            var attr = series._pointExpandAttr(point);
            if(isChosen){
                attr = {x:attr.x-1, y:attr.y-1, width:attr.width+2, height:attr.height+2}
            }

            DomUtils.toFront(point.graphic.node());

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:CHOSEN_TIME,
                    ease:'ease',
                    style:style,
                    attr:attr
                });

            series._labelFontSizeState(point, isChosen, CHOSEN_TIME, 'ease');
        },

        onPointTap: function (point) {
            if (point.series.getZoom()) {
                point.series.zoomTo(point);
            }
        }

    });

    require('../ChartLibrary').register(Constants.TREEMAP_CHART, treeMap);
});
/**
 * Created by Mitisky on 16/10/10.
 * xy0.030.05
 */
define('chart/Funnel',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BezierEasing','../EffectHelper','../component/FormattedText','../utils/ColorUtils','../ChartLibrary'],function (require) {
    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var FormattedText = require('../component/FormattedText');
    var ColorUtils = require('../utils/ColorUtils');

    var WIDTH_GAP = 0.03;
    var HEIGHT_GAP = 0.05;
    var FUNNEL_CONNECTOR_GAP = 0.03;
    var CONNECTOR_LABEL_GAP = 0.05;
    var FUNNEL_LABEL_GAP = FUNNEL_CONNECTOR_GAP + CONNECTOR_LABEL_GAP;
    var LABEL_MAX_WIDTH = 0.4;

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var FUNNEL_SHOW_TIME = 400;//delay
    var FUNNEL_INIT_TIME = 400;
    var INIT_EASE = BezierEasing.css["ease-out-quart"];
    var FUNNEL_UPDATE_TIME = 500;
    var UPDATE_EASE = BezierEasing.css.swing;
    var FUNNEL_RE_SHOW_TIME = 500;
    var RE_SHOW_EASE = BezierEasing.css.swing;

    var CHOSEN_EASE = BezierEasing.css['ease'];
    var CHOSEN_TIME = 300;

    var Funnel = Series.extend({

        _getAxisTypes:function(){
            return [];
        },

        //,value
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point) {
            return point.name;
        },

        _calculatePercentage: function () {
            var validPoints = this.points.filter(function (point) {
                point._bottomPoint = null;// bottomPointnull
                return !point.isNull && point.visible;});

            var pointCount = validPoints.length;

            var topPoint;

            validPoints
                .forEach(function (point, i) {
                    if(topPoint){
                        topPoint._bottomPoint = point;
                        point.percentage = Math.abs(point.value/(topPoint.value || 1));
                        point.arrivalRate = Math.abs(point.value/(validPoints[0].value || 1));
                    } else {
                        point.percentage = point.arrivalRate = 1;
                    }
                    point.delayTime = FUNNEL_SHOW_TIME * Math.sqrt(i/pointCount);

                    topPoint = point;
                })
        },

        //series dolayoutlabellabelplotBounds
        calculateLabelInfo:function(){

        },

        _outSideSpecialLabel: function (point) {
            var content = point.labelContent;
            return content && (content.nameLabelContent || content.valueLabelContent);
        },

        doLayout:function(){

            var funnel = this;
            funnel.points
                .forEach(function (point) {
                    FormattedText.dataLabelGenerator(point);
                });

            this._calculatePosAndSize();

        },

        _calculateTotalValue: function (filterFun, valueKey) {
            var totalValue = 0;
            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    totalValue += Math.abs(point[valueKey]);
                });
            return totalValue;
        },

        _calculateSeriesMaxValue: function (filterFun, valueKey) {
            var seriesMaxValue = 0;
            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    seriesMaxValue = Math.max(seriesMaxValue, Math.abs(point[valueKey]));
                });
            return seriesMaxValue;
        },

        //
        //inside: 
        //outSide:
        // 
        // posXY
        // 
        _calculatePosAndSize: function () {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds,
                filterFun = function (point) {return !point.isNull && point.visible;};

            var valueKey = funnel.getTargetKey();

            var width = plotBounds.width, height = plotBounds.height,
                totalWidth = width * (1 - 2 * WIDTH_GAP), totalHeight = height * (1 - 2 * HEIGHT_GAP);

            var labelUseSize = funnel._calculateTotalLabelSize();

            totalWidth -= (labelUseSize.useWidth > 0 ? labelUseSize.useWidth + plotBounds.width * FUNNEL_LABEL_GAP : 0);

            //
            funnel.useCurveConnectorLine = false;
            var topPoint;

            var validPoints = funnel.points.filter(filterFun);
            var pointCount = validPoints.length;

            if(pointCount < 1){
                return;
            }

            var firstPoint = validPoints[0], lastPoint = validPoints[pointCount - 1],
                firstLabelHeight = firstPoint.labelDim ? firstPoint.labelDim.height : 0,
                lastLabelHeight = lastPoint.labelDim ? lastPoint.labelDim.height : 0;

            if(funnel.options.useSameSlantAngle){
                var totalValue = funnel._calculateTotalValue(filterFun, valueKey);

                var firstHeight = Math.abs(firstPoint[valueKey]) * totalHeight / totalValue,
                    lastHeight = Math.abs(lastPoint[valueKey]) * totalHeight / totalValue;

                var posY = Math.max(0, firstLabelHeight - firstHeight)/2;
                
                totalHeight -= posY;
                totalHeight -= Math.max(0, lastLabelHeight - lastHeight)/2;

                validPoints
                    .forEach(function (point) {
                        point.posX = Math.round(posY * totalWidth / 2 / totalHeight);
                        point.width = Math.round(totalWidth - point.posX * 2);
                        point.posY = Math.round(posY);
                        point.height = Math.round(Math.abs(point[valueKey]) * totalHeight / totalValue);

                        posY += point.height;

                        funnel._calculateInsideLabelPos(point, topPoint);

                        topPoint = point;
                    })
            } else {
                var seriesMaxValue = funnel._calculateSeriesMaxValue(filterFun, valueKey);
                var unitHeight = totalHeight/pointCount;

                var startY = Math.max(0, firstLabelHeight - unitHeight)/2;

                totalHeight -= startY;
                totalHeight -= Math.max(0, lastLabelHeight - unitHeight)/2;

                validPoints
                    .forEach(function (point, i) {
                        point.width = Math.round(totalWidth * Math.abs(point[valueKey])/seriesMaxValue);
                        point.posX = Math.round((totalWidth - point.width)/2);
                        point.posY = Math.round(startY + i * unitHeight);
                        point.height = Math.round(unitHeight);

                        funnel._calculateInsideLabelPos(point, topPoint);

                        topPoint = point;
                    })
            }

            funnel._calculateOutSideLabelPos(filterFun, labelUseSize.useWidth, labelUseSize.useHeight);
        },

        _calculateInsideLabelPos: function (point, topPoint) {
            var dataLabels = point.options.dataLabels;
            if(dataLabels && dataLabels.enabled){
                if(dataLabels.align == Constants.INSIDE) {
                    point.labelPos = {
                        x: point.posX + point.width / 2 - point.labelDim.width / 2,
                        y: point.posY + point.height / 2 - point.labelDim.height / 2
                    };
                }else if(topPoint){//
                    this.useCurveConnectorLine = this.useCurveConnectorLine || point.height + topPoint.height < point.labelDim.height + topPoint.labelDim.height;
                }
            }
        },

        _calculateOutSideLabelPos: function (filterFun, labelUseWidth, labelUseHeight) {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;
            var gap2 = plotBounds.width * CONNECTOR_LABEL_GAP;
            var totalHeight = plotBounds.height * (1 - 2 * HEIGHT_GAP);

            var pointCount = Math.max(1, this.points.filter(filterFun).length -1);
            var label_label_gap = Math.max(0, (totalHeight - labelUseHeight)/pointCount);

            var startX = plotBounds.width * (1 - 2 * WIDTH_GAP) - labelUseWidth;
            var startY = 0;

            this.points
                .filter(filterFun)
                .forEach(function (point) {
                    var dataLabels = point.options.dataLabels;

                    if(dataLabels && dataLabels.enabled && dataLabels.align == Constants.OUTSIDE && startY < totalHeight) {

                        var content = point.labelContent;

                        var labelDim = point.labelDim, labelHeight = labelDim.height;

                        var labelY = funnel.useCurveConnectorLine ? startY : point.posY + point.height / 2 - labelHeight / 2;

                        var bottomPoint = point._bottomPoint,
                            gapWidth = ((bottomPoint ? bottomPoint.width : 0) - point.width) / 4;

                        var endPos = {x: startX, y: labelY + labelHeight / 2},
                            midPos = {x: startX - gap2, y: labelY + labelHeight / 2},
                            startPos = {x: point.posX + point.width + gapWidth, y: point.posY + point.height / 2};

                        point.labelPos = {
                            x: startX,
                            y: labelY,

                            endPos: endPos,
                            midPos: midPos,
                            startPos: startPos
                        };
                        startY += (point.labelDim.height + label_label_gap);

                        if(funnel._outSideSpecialLabel(point)) {//
                            var nameLabelContent = content.nameLabelContent, valueLabelContent = content.valueLabelContent;
                            //
                            var nameValueGap = labelDim.nameValueGap, valueLabelWidth = Math.min(labelUseWidth, funnel.maxValueLabelWidth);

                            if (nameLabelContent) {
                                var nameLabelDim = nameLabelContent.dim, nameLabelText = nameLabelContent.text;
                                var nameLabelWidth = labelUseWidth - nameValueGap - valueLabelWidth;
                                nameLabelText = funnel._omitLabel(nameLabelText, nameLabelWidth, nameLabelContent.style);

                                nameLabelContent.text = nameLabelText;
                                nameLabelContent.x = 0;
                                nameLabelContent.y = (labelHeight - nameLabelDim.height) / 2;
                            }

                            if (valueLabelContent) {
                                var valueLabelDim = valueLabelContent.dim, valueLabelText = valueLabelContent.text;
                                valueLabelText = funnel._omitLabel(valueLabelText, valueLabelWidth, valueLabelContent.style);

                                valueLabelContent.text = valueLabelText;
                                valueLabelContent.x = labelUseWidth - valueLabelWidth;
                                valueLabelContent.y = (labelHeight - valueLabelDim.height) / 2;
                            }
                        }
                    }
                })
        },

        _omitLabel: function (text, width, style) {

            var tmpDim = BaseUtils.getTextDimension(text, style, false);

            var hasClip = false;

            while(tmpDim.width > width && text.length){
                text = text.substr(0, Math.floor(text.length * 0.9));

                tmpDim = BaseUtils.getTextDimension(text + '...', style, false);

                hasClip = true;
            }

            if(hasClip && text){
                text += '...';
            }

            return text;
        },

        _calculateTotalLabelSize: function () {
            var funnel = this, vanchart = funnel.vanchart, plotBounds = vanchart.bounds;

            var useWidth = 0, useHeight = 0;

            funnel.points
                .filter(function (point) {
                    return !point.isNull && point.visible && point.options.dataLabels && point.options.dataLabels.enabled
                })
                .forEach(function (point) {
                    if(point.options.dataLabels.align == Constants.OUTSIDE){
                        if(+funnel.maxNameLabelWidth || +funnel.maxValueLabelWidth){//
                            useWidth = Math.max(useWidth, (funnel.maxNameLabelWidth || 0) + (funnel.maxValueLabelWidth || 0) + point.labelDim.nameValueGap)
                        } else {//
                            useWidth = Math.max(useWidth, point.labelDim.width);
                        }
                        useHeight += point.labelDim.height;
                    }
            });

            useWidth = Math.min(useWidth, plotBounds.width * LABEL_MAX_WIDTH);

            return {
                useWidth : useWidth,
                useHeight : useHeight
            };
        },

        //dolayout
        _calculateLabelPos:function() {

        },

        _getFixedPos:function(point){
            var translate = point.series._getTranslate();
            return [translate[0] + point.posX + point.width/2, translate[1] + point.posY + point.height/2];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) { 
            var translate = point.series._getTranslate(); 
 
            var startX =point.posX +point.width/2, 
                startY = point.posY + point.height / 2; 
 
            return { 
                startX: translate[0] + startX, 
                startY: translate[1] + startY, 
                direction: "top" 
            }
        },

        getFillFilter:function(color, p){
            var series = p.series, vanchart = series.vanchart, options = vanchart.options;
            if(options.style == Constants.STYLE_GRADUAL && BaseUtils.isSupportSVG()){

                var renderer = vanchart.renderer;

                var attrs = {'x1':'0%', 'y1':'0%', 'x2':'100%', 'y2':'0%'};
                var stop1 = {'offset':'0%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.9)};
                var stop2 = {'offset':'100%', 'stop-color':color};

                if(p.colorGradient){
                    renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                }else{
                    p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                }

                return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
            }

            return color;
        },

        //2px
        _getPointPath: function (p, isChosen) {
            var bottomPoint = p._bottomPoint, diff = isChosen ? 1 : 0;

            var top_left = (-p.width/2 - diff) + ',' + (-p.height/2 - diff);
            var top_right = (p.width/2 + diff) + ',' + (-p.height/2 - diff);
            if(bottomPoint) {
                var bottom_right = (bottomPoint.width/2 + diff) + ',' + (p.height/2 + diff);
                var bottom_left = (-bottomPoint.width/2 - diff) + ',' + (p.height/2 + diff);
                return 'M' + top_left + 'L' + top_right + 'L' + bottom_right + 'L' + bottom_left + 'Z';
            } else {
                var bottom = '0,' + (p.height/2 + diff);
                return 'M' + top_left + 'L' + top_right + 'L' + bottom + 'L' + bottom + 'Z';
            }
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor,
                'fill':p.series.getFillFilter(p.mouseOverColor || p.color, p),
                'fill-opacity': p.opacity,
                'stroke-width': (p.options.borderWidth || 0) + CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : (p.borderOpacity || 0 + CHOSEN_STROKE_OPACITY)
            }
        },

        getPressedStyle:function(p){
            return {
                'stroke':p.clickColor || p.color,
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity === 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        },

        effectAnimation:function (d) {
            EffectHelper.areaStyleEffectAnimation(d, d.posX+d.width/2, d.posY+d.height/2);
        },

        getDefaultEffectTime:function () {
            return EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        getPointInitAttr:function (d) {
            return {
                'transform':'translate(' + (d.posX + d.width/2) + ',' + (d.posY + d.height/2) +') scale(0.01)'
            }
        },

        _pointNormalAttr:function (d) {
            return {
                'd':d.series._getPointPath(d),
                'transform':'translate(' + (d.posX + d.width/2) + ',' + (d.posY + d.height/2) +') scale(1)'
            }
        },

        getPointInitAnimationAttr:function (d) {
            var series = d.series;
            return {
                delay:d.delayTime,
                ease:INIT_EASE,
                duration:FUNNEL_INIT_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        getPointReShowAnimationAttr:function (d) {
            var series = d.series;
            return {
                ease:RE_SHOW_EASE,
                duration:FUNNEL_RE_SHOW_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        getPointUpdateAnimationAttr:function(d){
            var series = d.series;
            return {
                ease:UPDATE_EASE,
                duration:FUNNEL_UPDATE_TIME,
                attr:series._pointNormalAttr(d)
            }
        },

        _onPointMouseOver:function(point){
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({duration:CHOSEN_TIME, ease:CHOSEN_EASE, style:style, attr:{'d':series._getPointPath(point, isChosen)}});

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.INSIDE) {
                series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            } else {
                series._leadLineState(point, 2, 0, isChosen, CHOSEN_TIME, CHOSEN_EASE);
                series._labelTransformState(point, 2, 0, isChosen, CHOSEN_TIME, CHOSEN_EASE);

                series._outSideSpecialLabel(point)
                    ? series._specialLabelColorState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE)
                    : series._outSideLabelColorState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            }
        },

        _getTranslate:function(){
            var plotBounds = this.vanchart.bounds;
            return[plotBounds.x + plotBounds.width * WIDTH_GAP, plotBounds.y + plotBounds.height * HEIGHT_GAP];
        },

        _updateDataLabels:function(){
            var series = this;
            series.getTextDataToDraw().forEach(function(point){

                series._outSideSpecialLabel(point) ? series._createOutSideTextGraphic(point)
                    : series._createTextGraphic(point);
            });
        },

        _createOutSideTextGraphic:function(point){
            var series = point.series, dataLabels = point.options.dataLabels;

            var hasText = function(d){return series.visible && !d.isNull && d.visible && d.labelPos && !isNaN(d.labelPos.x) && !isNaN(d.labelPos.y) && dataLabels && dataLabels.enabled};

            if(hasText(point)){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var labelContent = point.labelContent, useHtml = dataLabels.useHtml;

                var textLabelGroup = this._getPointTextLabelGroup();

                var text = renderer.vtext(useHtml).attr('transform', BaseUtils.makeTranslate(series._labelTrans(point))).style({'pointer-events': 'none'});

                var halfWidth = point.labelDim.width/2, halfHeight = point.labelDim.height/2;

                var createSpanGraphic = function (label) {
                    if(label){
                        var labelDim = label.dim, labelText = label.text, labelStyle = label.style;

                        return renderer.vtspan(useHtml)
                            .style({'width': dataLabels.labelWidth + 'px', height:dataLabels.labelHeight + 'px'})
                            .attr('y', label.y)
                            .attr('x', label.x)
                            .attr('dy', labelDim.height * .85 - halfHeight)
                            .attr('dx', -halfWidth)
                            .textContent(labelText).style(labelStyle)
                            .addTo(text);
                    }
                };

                text.nameSpan = createSpanGraphic(labelContent.nameLabelContent);
                text.valueSpan = createSpanGraphic(labelContent.valueLabelContent);

                point.textGraphic = textLabelGroup.append(text);

                if (point.labelPos.startPos) {//leadLine
                    point.leadLine = textLabelGroup.append(this._getLeadLine(point));
                }
            }
        },

        _specialLabelColorState:function (point, isChosen, duration, ease) {
            var labelContent = point.labelContent;

            function spanColorState(span, label) {
                if(label && span){
                    var style = label.style;

                    span.animate({
                        duration: duration,
                        ease: ease,
                        style: {'color':isChosen ? point.mouseOverColor : style.color}
                    });
                }

            }

            point.textGraphic && spanColorState(point.textGraphic.nameSpan, labelContent.nameLabelContent);
            point.textGraphic && spanColorState(point.textGraphic.valueSpan, labelContent.valueLabelContent);
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    require('../ChartLibrary').register(Constants.FUNNEL_CHART, Funnel);

    return Funnel;

});
/**
 * Created by Mitisky on 16/11/30.
 */
define('chart/WordCloud',['require','./Series','../Constants','../utils/BezierEasing','../EffectHelper','../utils/BaseUtils','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var BaseUtils = require('../utils/BaseUtils');

    var INIT_TIME = 400;
    var INIT_EASE = BezierEasing.css['ease-out-back'];
    var UPDATE_TIME = 600;
    var UPDATE_EASE = BezierEasing.css["ease-out-quart"];
    var DROP_TIME = 1000;
    var DROP_EASE = BezierEasing.css["ease-out-cubic"];
    var RE_SHOW_TIME = 1200;
    var RE_SHOW_EASE = BezierEasing.css["ease-out-cubic"];

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = BezierEasing.css["ease-out-quart"];


    var WordCloud = Series.extend({

        isNullValue: function (point) {
            var targetValue = point.options.value;
            return targetValue == '-' || BaseUtils.hasNotDefined(targetValue) || BaseUtils.hasNotDefined(point.name);
        },

        //,value
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point) {
            return point.name;
        },

        doLayout:function(){

        },

        //
        _calculateLabelPos:function() {

        },

        _getFixedPos:function(point, divDim){
            var word = point.word, dim = point.labelDim;
            var translate = point.series._getTranslate();
            var w = dim.width/2, h = dim.height/2, rotate = BaseUtils.toRadian(word.rotate);

            var ww = rotate === Math.PI/2 ? h : w * Math.cos(rotate) - h * Math.sin(rotate);
            var hh = w * Math.sin(rotate) + h * Math.cos(rotate);
            var dy = dim.height * .35 * Math.cos(rotate);
            var dx = dim.height * .35 * Math.sin(rotate);

            return BaseUtils.isSupportSVG()
                ? [translate[0] + word.x + ww + dx, translate[1] + word.y + hh - dy]
                : [translate[0] + word.x + dim.width, translate[1] + word.y + dim.height];
        },

        _getTranslate:function(){
            var plotBounds = this.vanchart.bounds;
            return[plotBounds.x + plotBounds.width / 2, plotBounds.y + plotBounds.height / 2];
        },

        effectAnimation:function (d) {
            var word = d.word,  series = d.series, period = series._getEffectTime(d);

            d.graphic
                .style('text-shadow','rgba(91,91,91,0.75) 0px 0px 0px')
                .effectTransition()
                .ease(BezierEasing.css["ease-out-quint"])
                .duration(0.5 * period)
                .style('font-size', (1.2 * word.size) + "px")
                .style('text-shadow','rgba(91,91,91,0.75) 3px 3px 5px')
                .transition()
                .ease(BezierEasing.css["ease-in-quint"])
                .duration(0.5 * period)
                .style('font-size',  word.size + "px")
                .style('text-shadow','rgba(91,91,91,0.75) 0px 0px 0px')
        },

        getDefaultEffectTime:function () {
            return 2000;
        },

        // _showLabels: function () {
        // },

        /**
         * @override Series.calcMoreLabelPosition.
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point, moreLabelDim) {
            var translate = point.series._getTranslate();
            var isSupportSVG = BaseUtils.isSupportSVG();
            var word = point.word, textDim = point.labelDim;
            var direction = "top";

            var bestPoints = this._calcNiceMoreLabelPos(point, word.rotate);
            var bestPos = bestPoints.top;
            // 
            if(bestPos.y - moreLabelDim.height < 0){
                bestPos = bestPoints.bottom;
                direction = "bottom";
            }

            // IEDIV
            var ie8PosX = translate[0] + word.x + textDim.width / 2,
                ie8PosY = translate[1] + word.y;
            // IE8 
            if(ie8PosY - moreLabelDim.height < 0){
                ie8PosY = translate[1] + word.y + textDim.height;
                direction = "bottom";
            }

            return {
                startX: isSupportSVG ? bestPos.x : ie8PosX,
                startY: isSupportSVG ? bestPos.y : ie8PosY,
                direction: direction
            }
        },

        /**
         * 
         * 
         * 
         * topPosbottomPostopPostopPosbottomPos
         * topPosrotate0y
         * y20px ?topPos
         * bottomPos
         * @private
         */
        _calcNiceMoreLabelPos: function (point, rotate){
            var translate = point.series._getTranslate();
            var word = point.word, textDim = point.labelDim, height = textDim.height * 0.86,  width = textDim.width;
            var wordX = word.x + translate[0], wordY = word.y  + translate[1];

            var PI = Math.PI, toRadin = function (deg){
                return deg * PI / 180;
            };

            var measure = 20;

            rotate = toRadin(rotate);

            // transform-origin(50%,100%)
            var _angle = Math.atan(height / width * 2);
            var _angles = [ 0, _angle, PI - _angle, PI ];

            var r1 = width / 2,  r2 = Math.sqrt(height * height + width * width / 4);

            var points = _angles.map(function (angle, index){
                var r = index % 3 ? r2 : r1;
                angle -= rotate;
                return {
                    x: Math.round(r * Math.cos(angle)),
                    y: Math.round(r * Math.sin(angle))
                };
            }).sort(function (a,b){
                return b.y - a.y
            });

            var centerPoint = function(p1, p2){
                return {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                }
            };
            var endPos = function (pos){
                return {
                    x: pos.x + wordX,
                    y: wordY - pos.y
                }
            };

            var topPos = (points[0].y - points[1].y > measure) ? points[0] : centerPoint(points[0], points[1]),
                bottomPos = (points[3].y - points[2].y < -measure) ? points[3] : centerPoint(points[3], points[2]);

            return {
                top: endPos(topPos),
                bottom: endPos(bottomPos)
            };
        },

        _getPointGraphicGroup:function(){
            return this.vanchart.group;
        },

        _createPointGraphic:function(point){
            var graphicKey = this.getPointGraphicKey(point), renderer = this.vanchart.renderer;
            point.graphic = renderer[graphicKey]();
            point.graphic.textContent(point.word.text);
            return point.graphic;
        },

        getPointGraphicKey:function(){
            return 'text';
        },

        getStyle:function(p){
            var word = p.word;
            return word ? {
                "font-size": word.size + "px",
                "font-family":word.fontFamily,
                'fill':p.color,
                'text-shadow':'',
                'stroke-width':0,
                'stroke-opacity':1,
                'fill-opacity':p.opacity,
                'filter':''
            } : {};
        },

        getHighLightStyle:function(p){
            var word = p.word, size = parseFloat(word.size)*1.15;

            return {
                "font-size": size + "px",
                'fill':p.mouseOverColor
            };
        },

        _onPointMouseOver:function(point){

            Series.prototype._onPointMouseOver.call(this, point);  // 

            var series = point.series, style = series.getHighLightStyle(point),
                vanchart = series.vanchart, renderer = vanchart.renderer;

            if(point.effectInterval) {
                clearInterval(point.effectInterval);
                point.graphic.interrupt();
            }

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            point.graphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({'duration':CHOSEN_TIME, 'ease':CHOSEN_EASE, 'style':style});

            series.drawPointEffect(point);
        },

        getPointInitAttr:function (p) {
            var word = p.word;
            return word ? {
                'text-anchor': 'middle',
                'transform': "translate(" + [word.x, word.y] + ")rotate(" + word.rotate + ")"
            } : {};
        },

        getPointInitStyle:function () {
            return {
                'font-size':'0.1px',
                'opacity':1
            }
        },

        getPointReShowStyle:function () {
            return {
                'font-size':'0.1px',
                'opacity':0
            }
        },

        getPointInitAnimationAttr:function (d) {
            var word = d.word;

            return {
                delay:d.delayTime || 0,  // worddelayTimeundefinedtransitionend,animateCount0series._animateEnd
                ease:INIT_EASE,
                duration:INIT_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity':1
                }
            }
        },

        getPointReShowAnimationAttr:function (d) {
            var word = d.word;

            return {
                ease:RE_SHOW_EASE,
                duration:RE_SHOW_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity':1
                }
            }
        },

        getPointUpdateAnimationAttr:function (d) {
            var word = d.word;

            return {
                ease:UPDATE_EASE,
                duration:UPDATE_TIME,
                style:{
                    'font-size':word.size + "px",
                    'opacity': 1
                },
                attr:{
                    'transform': "translate(" + [word.x, word.y] + ")rotate(" + word.rotate + ")"
                }
            }
        },

        getPointDropAnimationAttr:function (d) {
            return {
                ease:DROP_EASE,
                duration:DROP_TIME,
                style:{
                    'opacity':0
                }
            }
        },

        isSeriesAccumulated:function(){
            return true;
        }
    });

    require('../ChartLibrary').register(Constants.WORD_CLOUD_CHART, WordCloud);

    return WordCloud;
});
/**
 * Created by shine on 2017/1/10.
 */
define('chart/Structure',['require','./Series','./Point','../Constants','../utils/BezierEasing','../EffectHelper','../utils/BaseUtils','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var Point = require('./Point');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');
    var EffectHelper = require('../EffectHelper');
    var BaseUtils = require('../utils/BaseUtils');

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = BezierEasing.custom["ease-out-back"];

    var Structure = Series.extend({

        //,value
        getTargetKey:function(){
            return 'value';
        },

        _getPointKey: function (point, parent, level) {
            parent = point.parent || parent; level = point.level || level || 0;
            return (parent ? parent.name : "") + point.name + level;
        },

        isNullValue:function(point){
            return false;
        },

        _dealData: function (data) {

            var series = this, vanchart = series.vanchart, ancestorData = data[0], ancestor = vanchart.ancestor;

            vanchart.nodes && vanchart.nodes.forEach(function (node) {
                node._events = null;
                node.graphic && node.graphic.remove();
                node.textGraphic && node.textGraphic.remove();
                node.textGraphic = node.graphic = null;
            });

            vanchart.edges && vanchart.edges.forEach(function (edge) {
                edge.linkGraphic && edge.linkGraphic.remove();
                edge.linkGraphic = null;
            });

            if(ancestorData){

                var nodes = [], edges = [], maxLevel = 0;

                function dealNodesAndEdges(parent, data, level, pointsMap) {
                    var key = series._getPointKey(data, parent, level);
                    var oldPoint = pointsMap[key];
                    var point;
                    if(oldPoint){
                        oldPoint._lastValue = oldPoint[series.getTargetKey()];
                        oldPoint.moreLabelG && oldPoint.moreLabelG.remove();
                        oldPoint.moreLabelG = null;

                        oldPoint.refresh(data);
                        point = oldPoint;

                        pointsMap[key] = null;
                    } else {
                        point = new Point(data, series);
                    }

                    point.level = level;
                    maxLevel = Math.max(level, maxLevel);
                    if(parent) {
                        point.parent = parent;
                        parent.children = parent.children || [];
                        if(BaseUtils.indexOf(parent.children, point) == -1) {
                            parent.children.push(point);
                        }
                    }

                    nodes.push(point);
                    if(parent) {
                        edges.push({source: parent, target: point});
                    }

                    if(data.children){
                        var pointsMap = {};

                        if(point.children){
                            point.children.forEach(function (child) {
                                pointsMap[series._getPointKey(child)] = child;
                            })
                        }

                        data.children.forEach(function (d) {
                            dealNodesAndEdges(point, d, level + 1, pointsMap);
                        });

                        for(var key in pointsMap){
                            pointsMap[key] && pointsMap[key].clearChild();
                        }
                    }

                    return point;
                }

                var map = {};
                if(ancestor) {
                    map[series._getPointKey(ancestor)] = ancestor;
                }
                ancestor = dealNodesAndEdges(null, ancestorData, 0, map);

                for(var key in map){
                    map[key] && map[key].remove();
                }

                vanchart.ancestor = ancestor;
                vanchart.maxLevel = maxLevel;
                vanchart.nodes = nodes;
                vanchart.edges = edges;

                series.points = nodes;
            }
        },


        doLayout:function(){
        },

        _calculateLabelPos:function() {
        },

        _getFixedPos:function(point, divDim){
            var vanchart = this.vanchart, plotBounds = vanchart.bounds;
            var radius = (point.radius + 1)/1.414;
            return [plotBounds.x + point.posX + radius, plotBounds.y + point.posY + radius];
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.posX + chartBounds.x, 
                startY = point.posY + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        getStyle:function(node){
            var options = node.options;
            return {
                'fill':node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke':node.borderColor || node.color,
                'stroke-opacity':node.borderOpacity,
                'stroke-width':options.borderWidth
            };
        },

        getHighLightStyle:function(node){
            var options = node.options;

            return {
                'fill':node.mouseOverColor || node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke-width':options.borderWidth,
                'stroke-opacity':node.borderOpacity,
                'stroke': node.borderColor || node.color
            }
        },

        getPressedStyle:function(node){
            var options = node.options;

            return {
                'fill':node.clickColor || node.color,
                'fill-opacity':options.fillColorOpacity,
                'stroke-width':options.borderWidth,
                'stroke-opacity':node.borderOpacity,
                'stroke':node.borderColor || node.color
            }
        },

        _onPointMouseOver:function(point){
            Series.prototype._onPointMouseOver.call(this, point);  // 
            
            var series = point.series, style = series.getHighLightStyle(point);

            series._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var series = point.series, style = series.getStyle(point);

            series._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var diff = isChosen ? 2 : 0, radius = point.radius, attr = {r:radius + diff};

            if(point.options.image){
                attr = {x:-radius-diff, y:-radius-diff, width:(radius+diff)*2, height:(radius+diff)*2};
            }
            point.graphic.nodeGraphic
                .interrupt(Constants.SELECT_ANIMATION)
                .transition(Constants.SELECT_ANIMATION)
                .animate({
                    duration:CHOSEN_TIME,
                    ease:CHOSEN_EASE,
                    attr:attr,
                    style:style
                });

            var options = point.options, dataLabels = options.dataLabels, align = dataLabels.align;
            if(align == Constants.INSIDE){
                point.series._labelFontSizeState(point, isChosen, CHOSEN_TIME, CHOSEN_EASE);

            } else {
                point.series._labelTransformState(point, 0, -2, isChosen, CHOSEN_TIME, CHOSEN_EASE);
            }
        }
    });

    require('../ChartLibrary').register(Constants.STRUCTURE_CHART, Structure);

    return Structure;
});
/**
 * Created by eason on 16/8/16.
 */
define('chart/ForceBubble',['require','./Bubble','../Constants','../utils/BaseUtils','../EffectHelper','../ChartLibrary'],function(require){

    var Bubble = require('./Bubble');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var EffectHelper = require('../EffectHelper');

    var ForceBubble = Bubble.extend({

        _calculateBubblePosition:function(){

        },

        _getFixedPos:function(datum){
            var radius = datum.radius || 0;
            var plotBounds = this.vanchart.bounds;
            var x = plotBounds.x + datum.x + radius;
            var y = plotBounds.y + datum.y + radius;
            return [x, y];
        },
        
        _getAxisTypes:function(){
            return [];
        },
        
        getTargetKey:function(){
            return 'y';
        },

        /**
         * @override Series.calcMoreLabelPosition
         * @param  {[type]} point [description]
         * @return {[type]}       [description]
         */
        calcMoreLabelPosition: function (point) { 
            var chartBounds = this.vanchart.bounds; 
 
            var startX = point.x + chartBounds.x, 
                startY = point.y + chartBounds.y; 
            return { 
                startX: startX, 
                startY: startY, 
                direction: "top" 
            } 
        }, 

        isNullValue: function (point) {
            var options = point.options;

            return options.x == '-' || options.y == '-';
        },

        _getPointKey: function (point) {
            //point.options ? refreshOptions : init
            return '' + (point.options ? point.options.x : point.x);
        },

        effectAnimation:function (d) {
            EffectHelper.forceBubbleEffectAnimation(d, d);
        },

        getPointInitAttr:function(node){
            return {
                'r': node.radius,
                'transform': BaseUtils.makeTranslate({x:0, y:0})
            };
        },

        getPointInitAnimationAttr:function(point){
            return {
            }
        },
        getPointReShowAnimationAttr:function (point) {
            return{};
        },

        getPointUpdateAnimationAttr:function(point){
            return {
                'r': point.radius,
                'transform': BaseUtils.makeTranslate({x:point.x, y:point.y})
            };
        },

        remove:function(){

            this.points.forEach(function(point){
                if(point.graphic){
                    point.graphic.remove();
                    point.graphic = null;
                }
            });

            this.textGraphicGroup && this.textGraphicGroup.remove();
            this.group && this.group.remove();
            this.textGraphicGroup = this._canvas = this.group = null;
        }

    });

    require('../ChartLibrary').register(Constants.FORCE_BUBBLE_CHART, ForceBubble);
    return ForceBubble;
});
/**
 * Created by eason on 16/5/9.
 */
define('chart/Map',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Series','../EffectHelper','../ChartLibrary','../ChartLibrary','../ChartLibrary'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Series = require('./Series');
    var EffectHelper = require('../EffectHelper');

    var CHOSEN_TIME = 300;
    var CHOSEN_EASE = 'ease';

    var Map = Series.extend({

        initialize:function(options, vanchart, index){

            Series.prototype.initialize.call(this, options, vanchart, index);

            this.on(this.getEvents(), this);
        },

        getTargetKey:function(){
            return 'value';
        },

        _getPointKey:function(point){
            return point.name;
        },

        effectAnimation:function (d) {
            var effectFun = this.type === Constants.POINT_MAP
                ? EffectHelper.pointMapEffectAnimation : EffectHelper.areaMapEffectAnimation;

            d.layers && d.layers.forEach(function(layer){
                effectFun(layer, d);
            });
        },

        getDefaultEffectTime:function () {
            return this.type == Constants.POINT_MAP ?
                EffectHelper.POINT_MAP_EFFECT_TIME :
                EffectHelper.AREA_STYLE_EFFECT_TIME;
        },

        _getFixedPos:function(point){
            var vanchart = point.series.vanchart, type = point.series.type;

            var latlng = point.getLatLng();

            if(!latlng){
                return;
            }

            var pos = vanchart.latLngToContainerPoint(latlng);

            if(type == Constants.AREA_MAP){
                var detX = 0, detY = 0;
                if(point.options.dataLabels && point.labelDim && point.labelPos){
                    detX = point.labelDim.width/2;
                    detY = point.labelDim.height/2;
                }
                return [pos.x + detX, pos.y + detY];
            }

            return [pos.x, pos.y];
        },
        
        getHighLightStyle:function (point) {
            return {
                'stroke':point.borderColor ,
                'fill':point.mouseOverColor,
                'fill-opacity': point.opacity,
                'stroke-width':point.options.borderWidth + 1,
                'stroke-opacity':point.borderOpacity,
                'filter':this._getShadowFilter()
            }
        },

        getStyle:function(point){
            var geo = point.series.vanchart.getCurrentGeo();

            return point.isNull ? geo.defaultAreaStyle() : Series.prototype.getStyle.call(this, point);
        },

        _getShadowFilter:function () {
            var series = this, vanchart = series.vanchart, renderer = vanchart.mapRenderer;
            vanchart.mapShadowFilter = vanchart.mapShadowFilter || renderer.createDropShadowFilter(0, 1, 0.5, 2);
            return 'url(#' + BaseUtils.stamp(vanchart.mapShadowFilter) + ')';
        },

        _onPointMouseOver:function(point){
            var style = this.getHighLightStyle(point);

            this._onState(point, true, style);
        },

        _onPointMouseOut:function(point){
            var style = this.getStyle(point);

            this._onState(point, false, style);
        },

        _onState:function (point, isChosen, style) {
            var series = point.series;
            point._mapPointOnMouseState(isChosen, CHOSEN_TIME, CHOSEN_EASE, style);

            point.textLayers && point.textLayers.forEach(function(layer){
                series.type == Constants.POINT_MAP
                    ? layer._transformState(isChosen)
                    : layer._fontSizeState(isChosen, CHOSEN_TIME, CHOSEN_EASE);
            });
        }

    });

    require('../ChartLibrary').register(Constants.POINT_MAP, Map);
    require('../ChartLibrary').register(Constants.AREA_MAP, Map);
    require('../ChartLibrary').register(Constants.HEAT_MAP, Map);

    return Map;
});
/**
 * Created by Yuqian on 2016/12/23.
 */

define('chart/map/LineMapDataNormalizer',['require','../../utils/BaseUtils'],function (require) {

    var extend = require('../../utils/BaseUtils').extend;

    function normalSingle(p, geo) {
        var name = p.name || p;
        var features = geo.getFeaturesByName(name);
        if (features && features.length) {
            return features.map(function (f) {
                return {
                    name: name,
                    lnglat: f.geometry.coordinates
                }
            })
        }
    }

    function normalDatum(froms, tos, d, normalData) {
        if (!froms || !tos) {
            return;
        }
        var i = 0, f = froms[0] || froms;
        do {
            var j = 0, t = tos[0] || tos;

            do {
                var datum = {};
                extend(datum, d);
                datum.from = f;
                datum.to = t;
                normalData.push(datum)
            } while (t = tos[++j])

        } while (f = froms[++i])
    }
    /*
      1 ->
      from: "place",

      2 ->
      from: {
        name: "place"
      }
      (Get lnglats from geoJson with the same name. Return Points Array or null.)

      3 (correct) ->
      from: {
        name: "place",
        lnglat: [1,0]
      }

    */
    return function (data, geo) {
        geo._loadGeo(); // have to get json first
        var normalData = [];
        var i = -1, d;

        while (d = data[++i]) {
            var froms, tos;
            var isF = d.from && d.from.lnglat;
            var isT = d.to && d.to.lnglat;

            if (isF && isT) {
                normalData.push(d);

            } else {
                froms = isF ? d.from : normalSingle(d.from, geo);
                tos = isT ? d.to : normalSingle(d.to, geo);
                normalDatum(froms, tos, d, normalData)
            }
        }

        return normalData;
    }
});
/**
 * Created by Yuqian on 2016/12/14.
 */
define('chart/LineMap',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../ComponentLibrary','./Series','./map/LineMapDataNormalizer','../ChartLibrary'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var Series = require('./Series');
    var LineMapDataNormalizer = require('./map/LineMapDataNormalizer');

    var TOOLTIP_GAP = 6;

    var PI = Math.PI;

    var LineMap = Series.extend({

        doLayout: BaseUtils.emptyFn,

        _calculateLabelPos: BaseUtils.emptyFn,

        _loadData: function (data) {
            var geo = this.vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            return LineMapDataNormalizer(data, geo);
        },

        // here is obscure...
        // other charts use one canvas per series,
        // lineMap uses only one.
        // it's different...
        useCanvas: BaseUtils.trueFn,

        getTargetKey:function(){
            return 'value';
        },

        _getPointKey:function(point){
            point = point.options || point;
            return point.from.lnglat.join() + point.to.lnglat.join()
        },

        _getFixedPos:function(point, divDim){

            var arc = BaseUtils.computeArc(point.ax, point.ay, point.bx, point.by, point.curveness);

            var th = (arc[3] + arc[4]) / 2;
            th %= 2 * PI;
            var r = arc[2] + TOOLTIP_GAP;
            var x = r * Math.cos(th) + arc[0];
            var y = r * Math.sin(th) + arc[1];

            if (th <= PI / 2) {
                // original
            } else if (th <= PI) {
                x -= divDim.width;
            } else if (th <= 3 / 2 * PI) {
                x -= divDim.width;
                y -= divDim.height;
            } else {
                y -= divDim.height;
            }

            return [x, y];
        },

        remove: function () {
            Series.prototype.remove.call(this);

            this.points = [];
        },

        isSupportLegendHighlight: function () {
            // tmp
            return false
        }
    });

    require('../ChartLibrary').register(Constants.LINE_MAP, LineMap);

    return LineMap;
});
/**
 * Created by eason on 15/6/18.
 */
define('component/BaseAxis',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../ComponentLibrary','../utils/BoundsManager','../utils/Scale','./Base','../utils/BezierEasing'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var BoundsManager = require('../utils/BoundsManager');
    var Scale = require('../utils/Scale');


    var Base = require('./Base');

    var BezierEasing = require('../utils/BezierEasing');
    var TIME = 400;
    var EASE = BezierEasing.css.swing;
    
    var LABEL_LINE_GAP = 4;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };
    
    var TICK_LENGTH = 4;

    var TITLE_LABEL_GAP = 8;
    var TITLE_LABEL_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(TITLE_LABEL_GAP);
    };

    var TICK_COUNT = 5;
    var RADAR_TICK_COUNT = 4;
    var MIN_MAX_GAP = 100;

    var PADDING = 5;

    var MAIN_TICK = 'main';
    var MINOR_TICKS = 'minor';

    var ARROW_SIZE = 15;

    var BaseAxis = Base.extend({

        labelRotation: 0,

        _refresh:function(){
            this.series = [];

            //for category axis
            this.isRangePoints = true;

            this.piece = null;

            this.forecast = [0, 0]; // trendline period

            this._zoomDomain = this._dataDomain = this._domain = this._tickStart = this._step = 0;

            this.initScale();

            var options = this.options, titleOptions = options.title;
            BaseUtils.calculateFontSizeWithScale(options.labelStyle);
            BaseUtils.calculateFontSizeWithScale(titleOptions && titleOptions.style);
            options.tickPadding = isNaN(options.tickPadding) ? 6 : options.tickPadding;
            options.tickLength = options.enableTick ? (isNaN(options.tickLength) ? 4 : options.tickLength) : 0;
            options.minorTickLength = options.enableMinorTick ? (isNaN(options.minorTickLength) ? 2 : options.minorTickLength) : 0;
        },

        //
        _calculateSize:function(tickData){

            var axisOption = this.options;

            this.tickLabelLength = this._getTickLabelLength(tickData);
            var axisTileLength = this.labelLength = this._getAxisTitleLength();
            axisTileLength += (axisTileLength > 0 ? TITLE_LABEL_GAP_FUN() : 0);

            var usedSize = this.tickLabelLength + axisTileLength;
            var isHorizontal = this.isHorizontal();
            var isInverted = this.vanchart.isInverted();

            if(isHorizontal){
                var max = isInverted ? axisOption.maxWidth : axisOption.maxHeight;
                usedSize = max ? Math.min(this._maxHeight(max), usedSize) : usedSize;
            }else{
                var max = isInverted ? axisOption.maxHeight : axisOption.maxWidth;
                usedSize = max ? Math.min(this._maxWidth(max), usedSize) : usedSize;
            }

            this._size = this.series.length === 0 ? 0 : Math.round(usedSize);
        },

        _recordAxisSize:function(){
            if(!this.isOnZero()){
                this.vanchart.axisSize[this.getPosition()] += this._size;
            }
        },

        calculateDomainFromData:function(dataDomain){
            if(!dataDomain){
                //byPercent
                var series = this.series;
                this.byPercent = false;

                if(!this._isBaseAxis()) {
                    for (var i = 0, len = series.length; i < len && !this.byPercent; i++) {
                        this.byPercent = series[i].options.stackByPercent;
                    }
                }

                dataDomain = this._getDomainFromData();
            }
            // doLayout
            if (this.indicator) {
                this._calculateCateDomainData();
            }

            this._dataDomain = dataDomain;

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);

            var zoomDomain = this._zoomDomain || (zoomTool && zoomTool.getZoomInitDomain(this));

            if(this._isBaseAxis() && zoomDomain){
                var min = parseFloat(zoomDomain[0]), max = parseFloat(zoomDomain[1]);
                if(!isNaN(min) && !isNaN(max)){
                    var t = min;
                    min = Math.min(min, max);
                    max = Math.max(t, max);
                }
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], isNaN(min) ? null : min, isNaN(max) ? null : max);
            }else{
                var axisOption = this.options;
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], axisOption.min, axisOption.max);
            }

            //
            this._calculateDateFormat && this._calculateDateFormat();
        },

        _calculateNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options;
            if(axisOption.log){
                return this._calculateLogNiceDomain(minValue, maxValue, fixedMin, fixedMax);
            }else if(this.byPercent){
                return this._calculatePercentValueDomain(minValue, maxValue, fixedMin, fixedMax);
            }else{
                return this._calculateValueNiceDomain(minValue, maxValue, fixedMin, fixedMax);
            }
        },

        calculateDomainFromZoom:function(){
            var zoomDomain = this._zoomDomain, cfg = this.options;
            if(this._isBaseAxis()){
                this._calculateNiceDomain(this._dataDomain[0], this._dataDomain[1], zoomDomain[0], zoomDomain[1]);
            }else{
                var min = BaseUtils.hasDefined(cfg.min) ? Math.max(cfg.min, zoomDomain[0]) : zoomDomain[0];
                var max = BaseUtils.hasDefined(cfg.max) ? Math.min(cfg.max, zoomDomain[1]) : zoomDomain[1];
                if (min > max) {
                    return;
                }

                var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && BaseUtils.hasNotDefined(cfg.min);
                var baseValue = this.isLog() ? 1 : 0;
                min = fromZero ? Math.min(baseValue, min) : min;

                this._calculateNiceDomain(zoomDomain[0], zoomDomain[1], min, max);
            }
        },

        isCategory:function(){
            return this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT;
        },

        zoomRefresh:function(zoom){
            this._zoomDomain = zoom;

            this.calculateDomainFromZoom();
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos, isDateAxis = this.type == ComponentLibrary.DATE_AXIS_COMPONENT, det = isDateAxis ? 1000 : 1e-11;

            var plotBounds = this.vanchart.bounds;

            //
            if(this.isHorizontal()){
                startPos = Math.min(downPos.x, upPos.x) - plotBounds.x;
                endPos = Math.max(downPos.x, upPos.x) - plotBounds.x;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.width);
            }else{
                startPos = Math.min(downPos.y, upPos.y) - plotBounds.y;
                endPos = Math.max(downPos.y, upPos.y) - plotBounds.y;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.height);
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            if(isDateAxis){
                startValue = BaseUtils.date2int(startValue);
                endValue = BaseUtils.date2int(endValue);
            }

            if (Math.abs(startValue - endValue) < det) {
                return;
            }

            this.zoomRefresh([Math.min(startValue, endValue), Math.max(startValue, endValue)])
        },

        getAxisValue: function (value) {
            return value;
        },

        getTrendLineForecast: function (sery) {
            var trendLine = sery.options.trendLine;
            if (trendLine && trendLine.period && trendLine.period.length === 2) {
                var period = trendLine.period;
                this.forecast[0] = Math.min(0, period[0]);
                this.forecast[1] = Math.max(0, period[1]);
            }
        },

        _getStartAndEndTick:function(){
            return this._domain;
        },

        //clip
        updateClipBounds: function (clipBounds) {

            if(this.series.length === 0){
                return;
            }

            var startSize, endSize, t_s, t_e;
            var isHorizontal = this.isHorizontal(), isReversed = this.isAxisReversed(), cfg = this.options;

            if(this.options.showLabel){
                var tick = this._getStartAndEndTick();
                var tick_0 = tick[0];
                var tick_1 = tick[1];
                if(this.isMultiCateAxis && this.isMultiCateAxis()){
                    tick_0 = BaseUtils.decodeCategoryArray(tick_0)[0];
                    tick_1 = BaseUtils.decodeCategoryArray(tick_1)[0];
                }
                var startDim = this._getTickDim(this._getTickContent(tick_0, cfg.formatter));
                var endDim =this._getTickDim(this._getTickContent(tick_1, cfg.formatter));

                if(isReversed){
                    t_s = endDim;
                    t_e = startDim;
                }else{
                    t_s = startDim;
                    t_e = endDim;
                }
                startSize = isHorizontal ? t_s.width : t_s.height;
                endSize = isHorizontal ? t_e.width : t_e.height;

                //
                startSize = Math.round(startSize/2) + PADDING;
                endSize = Math.round(endSize/2) + PADDING;

                if(this.showArrow()){
                    endSize = Math.max(endSize, ARROW_SIZE);
                }

            }else{
                startSize = 0;
                endSize = this.showArrow() ? ARROW_SIZE : 0;
            }

            var plotBounds = this.vanchart.bounds;
            if (isHorizontal){

                var axisSize = this.vanchart.axisSize;
                var leftDis = plotBounds.x + axisSize.left + PADDING;
                var rightDis = axisSize.right + PADDING;

                if(this.isCategory() && !this.isRangePoints){
                    var domain = this._zoomDomain || this._dataDomain;
                    var rangeBand = (plotBounds.width - axisSize.left - axisSize.right)/domain.length;
                    leftDis += (Math.round(rangeBand/2));
                    rightDis += (Math.round(rangeBand/2));
                }

                if(this.options.labelRotation <= -15){
                    startSize = Math.round((startSize - PADDING) * 2);
                }else if(this.options.labelRotation >= 15){
                    endSize = Math.round((endSize - PADDING) * 2);
                }

                startSize = Math.max(startSize - leftDis, 0) + PADDING;
                endSize = Math.max(endSize - rightDis, 0) + PADDING + (this.showArrow() ? ARROW_SIZE : 0);

                clipBounds[Constants.LEFT] = Math.max(clipBounds[Constants.LEFT] || 0, startSize);
                clipBounds[Constants.RIGHT] = Math.max(clipBounds[Constants.RIGHT] || 0, endSize);
            }else{
                clipBounds[Constants.TOP] = Math.max(clipBounds[Constants.TOP] || 0, endSize);
                clipBounds[Constants.BOTTOM] = Math.max(clipBounds[Constants.BOTTOM] || 0, startSize);
            }
        },

        updateAxisSizeAndBounds:function(){
            this._setComponentBounds(this.getPosition(), this._size);
        },

        fixScaleAndTickData:function(){

            // :  rangeRoundzoominvertdomain < 1
            // this.scale.domain(this._domain).rangeRound(this._getRange());
            this.scale.domain(this._domain).range(this._getRange());

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        dealOnZero:function(){

            var cfg = this.options;

            if(cfg.onZero){

                var axisIndex = cfg.onZero === true ? 0 : cfg.onZero;

                var relyOn = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ?
                                    ComponentLibrary.Y_AXIS_COMPONENT : ComponentLibrary.X_AXIS_COMPONENT;

                relyOn = this.vanchart.getComponent(relyOn).getAxis(axisIndex);

                var pos = relyOn.getZeroPos();

                var plotBounds = this.vanchart.bounds;

                var x, y, width, height;
                if(this.isHorizontal()){
                    x = plotBounds.x;
                    y = pos + plotBounds.y - (this.getPosition() == Constants.TOP ? this.bounds.height : 0);
                    width = plotBounds.width;
                    height = this.bounds.height;
                }else{
                    x = pos + plotBounds.x - (this.getPosition() == Constants.LEFT ? this.bounds.width : 0);
                    y = plotBounds.y;
                    width = this.bounds.width;
                    height = plotBounds.height;
                }

                this.bounds = {
                    x:x,
                    y:y,
                    width:width,
                    height:height
                };

            }
        },

        //
        _getTickLabelLength:function(tickData){
            var axisOption = this.options;

            var tickLength = 0, maxLabelLength = 0, isHorizontal = this.isHorizontal();
            if (axisOption.showLabel) {
                tickLength = (isNaN(+axisOption.tickPadding) ? LABEL_LINE_GAP_FUN() : axisOption.tickPadding);
            }

            if(axisOption.enableTick){
                tickLength += (isNaN(+axisOption.tickLength) ? TICK_LENGTH : axisOption.tickLength);
            }

            if(tickData){
                tickData.forEach(function(t){
                    var labelDim = t.tickDim;
                    maxLabelLength = Math.max(maxLabelLength, isHorizontal ? labelDim.height : labelDim.width);
                });
            }else{
                // dim calc duplicated
                var ticks = this._getTickValues();
                for(var i = 0, len = ticks.length; i < len;  i++){
                    var testDim = this._getTickDim(this._getTickContent(ticks[i], axisOption.formatter));
                    maxLabelLength = Math.max(isHorizontal ? testDim.height : testDim.width, maxLabelLength);
                }
            }

            return tickLength + (axisOption.showLabel ? maxLabelLength: 0);
        },

        _getTickDim:function(tickContent){
            var axisOption = this.options, useHtml = axisOption.useHtml, rotation = axisOption.labelRotation || 0;
            var style = axisOption.labelStyle || {};
            return BaseUtils.getTextDimensionWithRotation(tickContent, style, useHtml, rotation);
        },

        //step
        _updateOriginTickData:function(){
            var labels = this._getTickValues(), axis = this;

            this._calculateLabelRotation(labels);
            this.tickData = [];
            
            for(var i = 0, len = labels.length; i < len; i++){
                var tickValue = labels[i], tickContent = tickValue;
                this.tickData.push(axis._calculateSingleTickData(tickValue, tickContent));
            }
        },

        /**
         * 
         * @param  {[type]} labels [description]
         * @return {[type]}        [description]
         */
        _calculateLabelRotation: function (labels) {
            var option = this.options, formatter = option.formatter;

            if (!isNaN(option.labelRotation)) {
                this.labelRotation = option.labelRotation;
            } else if (option.autoRotate) {
                this.labelRotation = this.getLabelAutoRotation(labels, option, formatter);
            } else {
                this.labelRotation = 0;
            }
        },

        /**
         * tickData
         * @return {[type]} [description]
         */
        _calculateSingleTickData: function (value, content, option){
            option = option || {};

            var axisOption = this.options;
            var formatter = axisOption.formatter, useHtml = axisOption.useHtml;

            var style = axisOption.labelStyle || {};
            var tbStyle = BaseUtils.extend(this._getVerticalTextStyle(), style);

            var tickContent = this._getTickContent(content, formatter);
            if (this.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT && tickContent) {
                tickContent = (tickContent + '').trim();
            }
            var rectDim, labelDim, tmpStyle = style;
            var labelRotation = this.labelRotation;

            if (Math.abs(labelRotation) === 90 && BaseUtils.hasChn(tickContent)) {
                labelRotation = 360; // as a log
                tmpStyle = tbStyle;
            }

            rectDim = BaseUtils.getTextDimension(tickContent, tmpStyle, useHtml);
            labelDim = BaseUtils.getTextDimRotated(rectDim, labelRotation);

            if(useHtml){
                labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
            }

            return QueryUtils.merge({
                tickValue:value,
                tickContent:tickContent,
                tickDim:labelDim,
                tickRectDim:rectDim,
                labelRotation: labelRotation
            }, option);
        },

        _isBaseAxis:function(){
            if(this.series.length){
                return this.componentType == this.series[0].getBaseAxisType();
            }
            return false;
        },

        getLabelAutoRotation: function () {
            return 0;
        },

        _getVerticalTextStyle: function (){
            var style = {
                'writingMode': 'tb-rl',
                'writing-mode': 'tb-rl'
            };
            if(!BaseUtils.hasTouch()){style['-webkit-writing-mode'] = 'vertical-rl'; }  // @BI-8541 7.0vertical-rl
            return style;
        },

        _getAxisTitleLength:function(){
            var title = this.options.title;

            if(!title || BaseUtils.isEmpty(title.text)){
                return 0;
            }

            var rectDim, dim;
            this.titleRotation = title.rotation;
            if (BaseUtils.hasChn(title.text) && Math.abs(title.rotation) === 90) {
                this.titleRotation = 360;
                title.style = BaseUtils.extend(this._getVerticalTextStyle(), title.style);
            }

            rectDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);

            dim = BaseUtils.getTextDimRotated(rectDim, this.titleRotation);

            this.titleRectDim = rectDim;
            this.titleDim = dim;

            return this.isHorizontal() ? dim.height : dim.width;
        },

        //
        getAxisTitleBounds:function(){

            var bounds = this.bounds;

            var tickLength = this.tickLabelLength + TITLE_LABEL_GAP_FUN();
            var labelLength = this.labelLength;

            var position = this.getPosition();

            var x = bounds.x;
            var y = bounds.y;
            var width = bounds.width;
            var height = bounds.height;

            switch (position){
                case Constants.LEFT:
                    x += width - tickLength - labelLength;  // 
                    width -= tickLength;
                    break;

                case Constants.BOTTOM:
                    y += tickLength;
                    height -= tickLength;
                    break;

                case Constants.RIGHT:
                    x += tickLength;
                    width -= tickLength;
                    break;

                case Constants.TOP:
                    y += height - tickLength - labelLength;  // Leftx
                    height -= tickLength;
                    break;
            }

            return {
                x:x,
                y:y,
                width: Math.max(width, 0),
                height: Math.max(height, 0)
            }
        },

        getTickLength:function(){
            var range = this.scale.range();
            return Math.abs(range[0] - range[1]) / Math.max(this.tickData.length, 1);
        },

        /**
         * ****
         * dataDomain
         * 
         * 
         * @returns {boolean}
         */
        adjustDomain4Radius: function () {
            if(this.type === ComponentLibrary.VALUE_AXIS_COMPONENT ||
                this.type === ComponentLibrary.DATE_AXIS_COMPONENT){

                var domain = this._domain, isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;
                var range = this._getRange();
                var minMax = this._dataDomain;

                var originLabelWidth = Math.max((domain[0] + '').length, (domain[1] + '').length);

                if(isDate){
                    domain = [BaseUtils.int2date(domain[0]), BaseUtils.int2date(domain[1])];
                }

                var scale = Scale.linear().domain(domain).range(range);

                var axis = this, isBaseAxis = this._isBaseAxis();

                var key = (this.componentType === ComponentLibrary.X_AXIS_COMPONENT) ? 'x' : 'y';

                var downBound = Number.MAX_VALUE, upBound = -Number.MAX_VALUE;

                this.series
                    .map(function(item){
                        if (!item.visible) {  return; }

                        var points = item.points,
                            seriesType = item.type;

                        // 
                        var getPointRadius = function (point){
                            switch(seriesType) {
                                case Constants.BUBBLE_CHART:
                                case Constants.SCATTER_CHART:
                                    return BaseUtils.pick(point.radius, point.options.marker && point.options.marker.radius);
                                case Constants.COLUMN_CHART:
                                case Constants.BAR_CHART:
                                    // BaseAxis

                                    return isBaseAxis ? (item._seriesWidth || item.getSeriesOffsetAndWidth().width) / 2 : 0;
                                case Constants.LINE_CHART:
                                case Constants.AREA_CHART:
                                    return point.options.marker && point.options.marker.radius || item.options.lineWidth;
                                default: return 0;
                            }
                        };

                        points.forEach(function (point){
                           var pos = scale(axis.getAxisValue(point[key], point));
                           if(point.visible && !point.isNull && !isNaN(pos)) {
                               var radius = getPointRadius(point);
                               downBound = Math.min(downBound, pos - radius);
                               upBound = Math.max(upBound, pos + radius);
                           }
                        });
                    });

                if (downBound === Number.MAX_VALUE || upBound === -Number.MAX_VALUE) {
                    return;
                }

                var b1 = scale.invert(downBound), b2 = scale.invert(upBound);

                if(isDate){
                    b1 = BaseUtils.date2int(b1);
                    b2 = BaseUtils.date2int(b2);
                }

                this.calculateDomainFromData([Math.min(Math.min(b1, b2), minMax[0]), Math.max(Math.max(b1, b2), minMax[1])]);

                var labelWidth = Math.max((this._domain[0] + '').length, (this._domain[1] + '').length);

                if (labelWidth > originLabelWidth) {
                    return true;
                }
            }
        },

        _getRange:function(){
            return this.componentType === ComponentLibrary.GAUGE_AXIS_COMPONENT ? this._getGaugeAxisRange() : this._getPlotRange();
        },

        /**
         * 
         * @returns {number}
         */
        limitTickInterval: function (){
            var domain = this._domain, maxValue = domain[1], minValue = domain[0];
            var axisRange = this._getRange();
            if(axisRange){
                var axisPixelSize = Math.abs(axisRange[0] - axisRange[1]),
                    minAllowedTickInterval = Math.floor((maxValue - minValue) / axisPixelSize * 5); // BI,5
                return minAllowedTickInterval;
            }
        },

        /**
         * GaugeAxisTickDataSeries.layout
         * layout
         * TODO 
         * @returns {[number,null]}
         */
        _getGaugeAxisRange: function (){
            if(!this.series.length){return}
            var series = this.series[0], vanchart = this.vanchart, seriesLen = vanchart.series.length;
            var width = vanchart.width, height = vanchart.height;
            var gaugeStyle = series.options.style;

            var axisSize;
            switch(gaugeStyle){
                case Constants.POINTER_SEMI_GAUGE:
                    axisSize = Math.PI * Math.min(width, height) / (2 * seriesLen);
                    break;
                case Constants.THERMOMETER_GAUGE:
                    axisSize = this.options.thermometerLayout === Constants.HORIZONTAL_LAYOUT ? width : height;
                    break;
                default:
                    axisSize = Math.PI * (Math.min(width, height) / (2 * seriesLen)) * 5 / 3;  // 300 / 360 * 2 * PI * R
            }
            return [0, Math.floor(axisSize)];
        },

        _getPlotRange:function(){
            var plotBounds = this.vanchart.bounds;

            if(this.isHorizontal()){
                return this.isAxisReversed() ? [plotBounds.width, 0] : [0, plotBounds.width];
            }else{
                return this.isAxisReversed() ? [0, plotBounds.height] : [plotBounds.height, 0];
            }
        },

        _getPlotBands:function(){

            var plotBands = this.options.plotBands;
            var scale = this.scale;
            var isRangeBand = !!(scale.rangeBand && scale.rangeBand());

            if(typeof plotBands == 'string'){

                var color = plotBands;
                plotBands = [];

                var labels = this._getTickValuesWithEndValue();

                var endIndex = isRangeBand ? -1 : 0;

                for(var index = labels.length - 1; index > endIndex; index -= 2){
                    plotBands.push({
                        color:color,
                        from:isRangeBand ? labels[index] : labels[index - 1],
                        to:labels[index]
                    });
                }

            }else{

                plotBands = plotBands || [];

                var result = [];

                for(var i = 0, count = plotBands.length; i < count; i++){

                    var t_bands = plotBands[i];

                    if(BaseUtils.hasDefined(t_bands.from) && BaseUtils.hasDefined(t_bands.to)){
                        result.push(t_bands);
                    }

                }

                plotBands = result;
            }

            return plotBands;
        },

        _getTickValuesWithEndValue:function(){

            var result = this._getTickValues();

            var max = this._domain[1], isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;

            if(result.length){

                var maxInList = result[result.length - 1];

                if(isDate){
                    if(BaseUtils.date2int(maxInList) < max){
                        result.push(BaseUtils.int2date(max));
                    }
                }else{
                    if(maxInList < max){
                        result.push(max);
                    }
                }
            }

            return result;
        },

        //
        getTickData:function(){
            return this.tickData;
        },

        getMinorTickData:function(){

            var minorTickData = [], cfg = this.options, interval = this._step;

            if(this.options.enableMinorTick && this.tickData.length){

                //
                if(this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT){
                    var minorTickLength = Math.round(this.getTickLength() / 5);
                    var endIndex = this.tickData.length;
                    endIndex = this.isRangePoints ? endIndex - 1 : endIndex;
                    for(var i = 0; i < endIndex; i++){
                        var startPos = this.tickData[i].tickPos;
                        for(var j = 1; j < 5; j++){
                            minorTickData.push(startPos + minorTickLength * j);
                        }
                    }
                }else{

                    var minorInterval = cfg.minorTickInterval ? cfg.minorTickInterval : interval / 5;

                    for(var i = 0, count = this.tickData.length; i < count - 1; i++){

                        var start = this.tickData[i].tickValue;

                        var end = this.tickData[i + 1].tickValue;

                        var isDate = (start instanceof Date && end instanceof Date);

                        start = isDate ? BaseUtils.date2int(start) : start;
                        end = isDate ? BaseUtils.date2int(end) : end;

                        for(var value = BaseUtils.accAdd(start,minorInterval); value < end; value = BaseUtils.accAdd(value, minorInterval)){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }

                    var endValue = this.tickData[this.tickData.length - 1].tickValue;
                    var maxValue = this.scale.domain()[1];

                    var isDate = (endValue instanceof Date) && (maxValue instanceof Date);
                    endValue = isDate ? BaseUtils.date2int(endValue) : endValue;
                    maxValue = isDate ? BaseUtils.date2int(maxValue) : maxValue;

                    if(endValue < maxValue){
                        for(var value = endValue + minorInterval; value <= maxValue; value += minorInterval){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }

                    var startValue = this.tickData[0].tickValue;
                    var minValue = this.scale.domain()[0];

                    isDate = (startValue instanceof Date) && (minValue instanceof Date);
                    startValue = isDate ? BaseUtils.date2int(startValue) : startValue;
                    minValue = isDate ? BaseUtils.date2int(minValue) : minValue;

                    if(startValue > minValue){
                        for(value = startValue - minorInterval; value >= minValue; value -= minorInterval){
                            minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                        }
                    }
                }
            }

            return minorTickData;
        },

        getMaxTickWidth:function(){
            var maxWidth = 0;

            this.tickData.forEach(function(data){
                maxWidth = Math.max(maxWidth, data.tickDim.width);
            });

            return maxWidth;
        },

        getTickHeight:function(){
            if(this.options.labelStyle && this.options.showLabel){
                return BaseUtils.getTextHeight(this.options.labelStyle);
            }
            return 0;
        },

        _calculateTickPosAndStep:function(){

            var axisOption = this.options, scale = this.scale, tickInterval = this.getTickLength();
            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;

            var tickData = this.getTickData();

            tickData.forEach(function(t){
                t.tickPos = scale(t.tickValue);
                t.tickLabelPos = t.tickPos + det;
            });

            if(!axisOption.showLabel){
                tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }else if(axisOption.step){
                var index = 0;
                tickData.forEach(function(t){
                    if(index++ % axisOption.step){
                        t.tickContent = '';
                    }
                });
            }else{
                var isHorizontal = this.isHorizontal(), testStep = 1, longestStep = 1;

                // label rotated [15-90) can as long as it can
                // otherwise check the dim
                var labelRotation = Math.abs(Math.abs(this.labelRotation) - (isHorizontal ? 0 : 90)),
                    isRotated = (labelRotation >= 15 && labelRotation !== 90),
                    labelRadian;
                labelRadian = BaseUtils.toRadian(labelRotation);
                var lastTickPos, lastH = -1, gap, l, h,
                    sin = Math.sin(labelRadian);

                tickData.forEach(function(t){
                    if (t.tickContent === '') {
                        return;
                    }

                    if (isRotated) {
                        h = t.tickRectDim.height;
                        gap = Math.abs(t.tickPos - lastTickPos);
                        l = (h + lastH) / 2;
                        if (l < gap * sin || lastH === -1) {
                            testStep = 1;
                            lastTickPos = t.tickPos;
                            lastH = h;
                        } else {
                            testStep++;
                            longestStep = Math.max(longestStep, testStep);
                        }

                    } else {

                        var testLength = isHorizontal ? t.tickDim.width : t.tickDim.height;

                        if(tickInterval){
                            longestStep = Math.max(longestStep, Math.ceil(testLength/tickInterval));
                        }

                    }
                });

                var index = 0;
                tickData.forEach(function(t){
                    if(index++ % longestStep){
                        t.tickContent = '';
                    }
                });
            }
        },

        _getAxisOriginPoint:function(){
            var axisBounds = this.bounds;
            var position = this.getPosition();
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = axisBounds.x;
                    y = axisBounds.y + axisBounds.height;
                    break;

                case Constants.BOTTOM:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;

                case Constants.LEFT:
                    x = axisBounds.x + axisBounds.width;
                    y = axisBounds.y;
                    break;

                case Constants.RIGHT:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        getPosition:function(){
            var defaultPosition = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'bottom' : 'left';
            var position = this.options.position || defaultPosition;

            if (this.vanchart.isInverted()){
                switch (position) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            } else {
                return position;
            }
        },

        isAxisReversed:function(){
            if (this.componentType === ComponentLibrary.X_AXIS_COMPONENT &&
                this.vanchart.isInverted()) {
                return !this.options.reversed;
            }
            return this.options.reversed;
        },

        isOnZero:function(){
            return this.options.onZero;
        },

        getLineWidth:function(){
            return this.options.lineWidth;
        },

        showArrow:function(){
            return this.options.showArrow;
        },

        getTitleAlign: function () {
            var title = this.options.title;
            if (!title) {
                return null;
            }

            var align = title.align || 'center';

            if (this.vanchart.isInverted()) {
                switch (align) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            }

            return align;
        },

        _calculateLogNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options, logBase = axisOption.log;

            var tickInterval = parseInt(BaseUtils.pick(axisOption.tickInterval, 1));

            minValue = minValue >= 1 ? 1 : minValue;
            minValue = minValue <= 0 ? 1 : minValue;

            minValue = BaseUtils.pick(fixedMin, minValue);
            maxValue = BaseUtils.pick(fixedMax, maxValue);

            minValue = Math.pow(logBase, Math.floor(BaseUtils.log(logBase, minValue)));
            maxValue = Math.pow(logBase, Math.ceil(BaseUtils.log(logBase, maxValue)));

            this._domain = [minValue, maxValue];
            this._tickStart = minValue;
            this._step = tickInterval;
        },

        _calculatePercentValueDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options, min = BaseUtils.pick(fixedMin, 0), max = BaseUtils.pick(fixedMax, 1);
            var interval = BaseUtils.pick(axisOption.tickInterval, 0.25);

            this._domain = [min, max];
            this._tickStart = min;
            this._step = interval;
        },

        //
        _calculateValueNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){

            var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && !this._isBaseAxis();

            var axisOption = this.options;

            if(fromZero){
                if(minValue > 0){
                    minValue = 0;
                }else if(maxValue < 0){
                    maxValue = 0;
                }
            }

            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : minValue;
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : maxValue;

            // if any exceeded min, adjust max to min + 100
            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var tickInterval = axisOption.tickInterval || this._linearTickInterval(minValue, maxValue);

            var domain = this._linearNiceDomain(minValue, maxValue, tickInterval);
            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : domain[0];
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : domain[1];

            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var start = domain[0];

            if(BaseUtils.hasDefined(fixedMin)){

                // ceil( (fixedMin - start) / tickInterval ) * tickInterval
                var diff = BaseUtils.accMul(
                    Math.ceil(
                        BaseUtils.accDiv(BaseUtils.accAdd(fixedMin, -start), tickInterval)
                    ),
                    tickInterval
                );

                start = BaseUtils.accAdd(start, diff);
            }


            this._domain = [minValue, maxValue];
            this._tickStart = start;

            var minAllowedTickInterval = this.limitTickInterval();
            this._step = minAllowedTickInterval ? Math.max(minAllowedTickInterval, tickInterval) : tickInterval;
        },

        _linearTickInterval:function(minValue, maxValue, m){

            m = m || this._getDefaultTickCount();
            var span = maxValue - minValue;
            var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
            var err = m / span * step;

            if (err <= .15) {
                step *= 10;
            } else if (err <= .35) {
                step *= 5;
            } else if (err <= .75) {
                step *= 2;
            }

            if (this.type === ComponentLibrary.DATE_AXIS_COMPONENT) {
                step = Math.max(step, 1000); // min date step = 1 second
            }

            return step;
        },

        _linearNiceDomain:function(minValue, maxValue, tickInterval){

            minValue = BaseUtils.accMul(Math.floor(minValue / tickInterval), tickInterval);

            maxValue = BaseUtils.accMul(Math.ceil(maxValue / tickInterval), tickInterval);

            return [minValue, maxValue];
        },

        _getDefaultTickCount:function(){
            return this.vanchart.options.chartType == Constants.RADAR_CHART ? RADAR_TICK_COUNT : TICK_COUNT;
        },

        getIndexByPosition: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var startX = scale(
                this.isAxisReversed() ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (this.isHorizontal()) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            switch (this.type) {
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    index = BaseUtils.date2int(scale.invert(x));
                    break;
                default:
                    index = scale.invert(x);
            }

            index = Math.round(index);
            return index;
        },

        _valueInDomain: function () {
            return true;
        },

        render:function(){

            this.lastScale = this.scale && this.scale.copy();

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = this.createComponentGroup();
                renderer.clip(this.clipAxisGroup = this.createComponentGroup(), vanchart.plotClip);
            }

            //clip
            var b = this.bounds;
            var clipBounds = {x:b.x, y:b.y, width:b.width, height:b.height};

            if(this.isHorizontal()){
                clipBounds.x = 0; clipBounds.width = vanchart.width;
            }else{
                clipBounds.y = 0; clipBounds.height = vanchart.height;
            }

            if(!this.axisGroupClip){
                this.axisGroupClip = renderer.createClip(clipBounds);
                renderer.clip(this.axisGroup, this.axisGroupClip);
            }else{
                renderer.updateClip(this.axisGroupClip, clipBounds);
            }

            if(!this.axisLineGroup){
                this.axisLineGroup = renderer.group().addTo(vanchart.seriesGroup);
            }
			
			// 
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this._drawPlotBands();

            this._drawGridLine();

            this._drawTickLine();

            this._drawTickLabel();

            this._drawPlotLines();

            this._drawAxisTitle();

            this._drawAxisLine();
        },

        isLog:function(){
            return this.options.log;
        },

        getZeroPos:function(){

            switch (this.type){
                case ComponentLibrary.VALUE_AXIS_COMPONENT:

                    return this.isLog() ? this.scale(1) : this.scale(0);

                case ComponentLibrary.DATE_AXIS_COMPONENT:

                    return this.scale(BaseUtils.int2date(0));

                case ComponentLibrary.CATEGORY_AXIS_COMPONENT:

                    return 0;
            }

        },

        _drawPlotBands:function(){
            var plotBands = this._getPlotBands(), scale = this.scale, isRangeBand = scale.rangeBand;
            var rangeBand = isRangeBand ? scale.rangeBand() : 0;

            var renderer = this.vanchart.renderer;
            var plotBounds = this.vanchart.bounds, axis = this, isHorizontal = axis.isHorizontal();

            var i, len, from, to, rect;
            var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

            if(!this.plotBandsGroup){
                this.plotBandsGroup = renderer.group().addTo(this.clipAxisGroup);
                this.plotBands = [];
            }

            this.plotBandsGroup.attr({'transform': BaseUtils.makeTranslate(plotBounds)});

            for(i = plotBands.length; i < this.plotBands.length; i++){
                this.plotBands[i] && this.plotBands[i].remove();
                this.plotBands[i] = null;
            }

            this.plotBands.length = plotBands.length;

            for(i = 0, len = plotBands.length; i < len; i++){
                var d = plotBands[i];

                var t_f = scale(d.from), t_t = scale(d.to);
                from = Math.min(t_f, t_t); to = Math.max(t_f + rangeBand, t_t + rangeBand);

                from = Math.max(isHorizontal ? x : y, from);
                to = Math.min(isHorizontal ? width : height, to);

                rect = isHorizontal ? {x:from, y:y, width:Math.max(to - from, 0), height:height}
                    :{x:x, y:from, width:width, height:Math.max(to - from, 0)};

                this.plotBands[i] = this.plotBands[i] || renderer.rect(rect).addTo(this.plotBandsGroup);

                this.plotBands[i].style({'fill':d.color}).animate({
                    'duration':TIME, 'ease':EASE, attr:rect
                });
            }
        },

        _drawAxisLine:function(){
            var cfg = this.options, lineWidth = cfg.lineWidth, lineColor = cfg.lineColor;
            var plotBounds = this.getPlotBounds(), axisOrigin = this._getAxisOriginPoint();
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var size = plotBounds.width, renderer = this.vanchart.renderer;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                size = plotBounds.height;
            }
            var det = BaseUtils.lineSubPixelOpt(0, lineWidth);
            if(!this.axisLine){
                this.axisLine = renderer.line().addTo(this.axisLineGroup);
            }
            var attrs = {};attrs[x1] = 0; attrs[x2] = size; attrs[y1] = attrs[y2] = det;
            attrs.transform = BaseUtils.makeTranslate(axisOrigin);
            this.axisLine.attr(attrs).style({stroke:lineColor, 'stroke-width': lineWidth});

            if(this.showArrow()){

                if(!this.arrowGroup){
                    this.arrowGroup = renderer.group().addTo(this.axisLineGroup);
                }

                var line = this.arrowGroup.line || renderer.line().addTo(this.arrowGroup);
                var path = this.arrowGroup.path || renderer.path().addTo(this.arrowGroup);
                this.arrowGroup.line = line; this.arrowGroup.path = path;

                if(this.isHorizontal()){
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y]));
                    line.attr({'x1':0, 'y1':det, 'x2':6, 'y2':det}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M2,-4 L10,0 L2,4 L6,0 L2,-4"}).style({'fill':lineColor});
                }else{
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate(axisOrigin));
                    line.attr({'x1':det, 'y1':0, 'x2':det, 'y2':-6}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M-4,-2 L0,-10 L4,-2 L0,-6 L-4,-2"}).style({'fill':lineColor});
                }
            }else{
                this.arrowGroup && this.arrowGroup.remove();
            }
        },

        _drawGridLine:function(){
            var cfg = this.options, plotBounds = this.getPlotBounds();
            var ticks = this.getTickData(), scale = this.scale, lastScale = this.lastScale || scale;
            var gridLineColor = cfg.gridLineColor, gridLineWidth = cfg.gridLineWidth;

            // phantomjs 1.9, 
            // svg 'stroke-width' has a default value 1
            // 0 is still 1 (_ maybe "value || 1" in apple's webkit...)
            if (gridLineWidth === 0) {
                gridLineColor = '';
            }

            var det = BaseUtils.lineSubPixelOpt(0, gridLineWidth), renderer = this.vanchart.renderer;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', lineSize = plotBounds.height;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';lineSize = plotBounds.width;
            }

            if(!this.gridLinesGroup){
                this.gridLinesGroup = renderer.group().addTo(this.clipAxisGroup);
                this.gridLines = [];
            }
            this.gridLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));

            var pos = this.getPosition(), isBottomOrTop = pos === Constants.TOP || pos === Constants.BOTTOM;
            // 
            var concatArray = this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? [{tickPos: isBottomOrTop ? plotBounds.width : plotBounds.height - 1}] : [];
            var selection = this._bindData(this.gridLines, ticks.concat(concatArray), function(d){return d.tickValue});

            var currentGridLines = [];
            for(var i = 0, len = selection.exit.length; i < len; i++){
                var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                var attr = {}; attr[x1] = pos; attr[x2] = pos;
                selection.exit[i].animate({
                    'duration':TIME, 'ease':EASE, 'attr':attr, 'style':{'opacity':0}
                }).remove();
            }

            for(var i = 0, len = selection.enter.length; i < len; i++){

                var d = selection.enter[i];
                var gridLine = renderer.line().style({'stroke':gridLineColor, 'stroke-width':gridLineWidth}).addTo(this.gridLinesGroup);
                var lastPos = lastScale(d.tickValue) + det;
                var pos = d.tickPos + det;
                lastPos = isNaN(lastPos) ? pos : lastPos;

                gridLine.attr(x1, lastPos).attr(x2, lastPos).attr(y1, 0).attr(y2, lineSize);

                var attr = {}; attr[x1] = pos, attr[x2] = pos, attr[y1] = 0, attr[y2] = lineSize;

                gridLine.animate({'attr':attr, 'duration':TIME, 'ease':EASE});

                gridLine.datum(d);
                currentGridLines.push(gridLine);
            }

            currentGridLines = currentGridLines.concat(selection.update);

            for(var i = 0, len = currentGridLines.length; i < len; i++){
                var gridLine = currentGridLines[i].style({'stroke':gridLineColor, 'stroke-width':gridLineWidth});
                var d = gridLine.datum(), pos = d.tickPos + det;
                var attr = {}; attr[x1] = pos, attr[x2] = pos, attr[y1] = 0, attr[y2] = lineSize;
                gridLine.animate({'attr':attr, 'duration':TIME, 'ease':EASE});
            }

            this.gridLines = currentGridLines;
        },

        //,
        _drawTickLine:function(){
            var renderer = this.vanchart.renderer, cfg = this.options;

            if(!this.tickLinesGroup){
                this.tickLinesGroup = renderer.group().addTo(this.axisGroup);
                this.tickLines = {};
                this.tickLines[MAIN_TICK] = [];
                this.tickLines[MINOR_TICKS] = [];
            }

            var tickLength = cfg.enableTick ? (cfg.tickLength || 0) : 0;
            var tickWidth = cfg.tickWidth || 1,tickColor = cfg.tickColor;
            var detMain = BaseUtils.lineSubPixelOpt(0, tickWidth);

            var minorTickLength = cfg.enableMinorTick ? (cfg.minorTickLength || 0) : 0;
            var minorTickColor = cfg.minorTickColor, minorTickWidth = cfg.minorTickWidth || 1;
            var detMinor = BaseUtils.lineSubPixelOpt(0, minorTickWidth);

            // 
            this._drawMainTickLine({
                det:detMain,
                tickWidth:tickWidth,
                tickLength:tickLength,
                tickColor:tickColor
            });
            // 
            this._drawMinorTickLine({
                det:detMinor,
                tickWidth:
                minorTickWidth,
                tickLength:minorTickLength,
                tickColor:minorTickColor
            });
        },

        /**
         * 
         * @param  {[type]} option [description]
         * @return {[type]}        [description]
         */
        _drawMainTickLine: function (option) {
            var ticks = this.getTickData();
            this.tickLines[MAIN_TICK] = this._drawTickLineWithData(this.tickLines[MAIN_TICK], ticks, option);
        },

        /**
         * 
         * @param  {[type]} option [description]
         * @return {[type]}        [description]
         */
        _drawMinorTickLine: function (option) {
            var minorTickData = this.getMinorTickData();
            this.tickLines[MINOR_TICKS] = this._drawTickLineWithData(this.tickLines[MINOR_TICKS], minorTickData,option );
        },

        /**
         * 
         * @param  {[type]} tickLines [tickLinetickLine]
         * @param  {[type]} tickData  []
         * @param  {[type]} options   []
         * @return {[type]}           [description]
         */
        _drawTickLineWithData: function (tickLines, tickData, options) {
            var axisOrigin = this._getAxisOriginPoint(), orient = this.getPosition();
            var renderer = this.vanchart.renderer, axis = this;

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var selection = axis._bindData(tickLines, tickData, options.keyFunction);
            var currentTickLines = [], i, len;

            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                currentTickLines.push(renderer.line().datum(selection.enter[i]).addTo(axis.tickLinesGroup));
            }

            currentTickLines = currentTickLines.concat(selection.update);

            for(i = 0, len = currentTickLines.length; i < len; i++){
                var datum = currentTickLines[i].datum(), attrs  = {};

                var tickPos;

                if(BaseUtils.hasDefined(datum.tickPos)){
                    tickPos = datum.tickPos;
                }else{
                    tickPos = axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? datum : axis.scale(datum);
                }

                var detX = axisOrigin.x, detY = axisOrigin.y;
                if(!axis.isHorizontal()){
                    detX = axisOrigin.y; detY = axisOrigin.x;
                }

                // categoryKey
                var tickLength = typeof options.tickLengthFuc === "function" ? options.tickLengthFuc(datum) : options.tickLength;

                attrs[x1] = tickPos + options.det + detX; attrs[x2] = attrs[x1];
                attrs[y1] = detY;
                attrs[y2] = (sign * tickLength || 0) + detY;

                currentTickLines[i].attr(attrs).style({
                    'stroke':options.tickColor, 'stroke-width':options.tickWidth
                });
            }

            return currentTickLines;
        },

        _drawPlotLines:function(){
            var plotLines = this.options.plotLines || [], position = this.getPosition();
            var plotBounds = this.vanchart.bounds;
            var scale = this.scale, isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;
            var result = [], axis = this, renderer = this.vanchart.renderer;
            plotLines.forEach(function(d){
                if (BaseUtils.isEmpty(d.value)) {
                    return;
                }

                var originPos = scale(isDate ? BaseUtils.object2date(d.value) : d.value) + (scale.rangeBand ? scale.rangeBand()/2 : 0);
                var pos = BaseUtils.lineSubPixelOpt(originPos, d.width);
                var x1, x2, y1, y2;

                if (axis.isHorizontal()) {
                    if (originPos < 0 || originPos > plotBounds.width) { return }
                    x1 = x2 = pos; y1 = 0; y2 = plotBounds.height;
                } else {
                    if (originPos < 0 || originPos > plotBounds.height) { return }
                    x1 = 0; x2 = plotBounds.width; y1 = y2 = pos;
                }

                var textX, textY, text, style;
                if(d.label && d.label.text && d.label.style){
                    style = d.label.style; text = d.label.text;
                    var align = d.label.align;
                    var textDim = BaseUtils.getTextDimension(text, style, d.label.useHtml);
                    switch (align){
                        case Constants.TOP:
                            textX = x1 - textDim.width; textY = y1;
                            break;
                        case Constants.BOTTOM:
                            textX = x1 - textDim.width; textY = y2 - textDim.height;
                            break;
                        case Constants.LEFT:
                            textX = x1; textY = y1 - textDim.height - LABEL_LINE_GAP_FUN();
                            break;
                        case Constants.RIGHT:
                            textX = x2 - textDim.width; textY = y2 - textDim.height - LABEL_LINE_GAP_FUN();
                            break;
                    }
                }

                result.push({
                    color: d.color,
                    line:{x1:x1, y1:y1, x2:x2, y2:y2},
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],

                    text:text,
                    textDim:textDim,
                    style:style,
                    textX:textX,
                    textY:textY
                });
            });

            function _getPlotLineStyle(datum){
                return {'stroke':datum.color, 'stroke-width':datum.width, 'stroke-dasharray':datum.dataArray};
            }

            function _getLabelGraphic(datum){
                return renderer.text().textContent(datum.text).style(datum.style)
                    .attr({'x':datum.textX, 'y':datum.textY, 'text-anchor':'left', 'dy':datum.textDim.height * .85});
            }

            function _createLabelGraphic(datum, g){
                if(g._textG){
                    g._textG.remove();
                    g._textG = null;
                }
                if(datum.text && datum.textDim) {
                    g._textG = _getLabelGraphic(datum).addTo(g);
                }
            }

            if(!this.plotLinesGroup){
                this.plotLinesGroup = renderer.group().addTo(this.vanchart.backGroup);  // plotLinesclipSeriesGroupSeries
                this.plotLines = [];
            }

            this.plotLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            var selection = this._bindData(this.plotLines, result), i, len;
            this.plotLines = [];

            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var datum = selection.enter[i], g = renderer.group();
                this.plotLines.push(g);

                g._lineG = g.append(renderer.line(datum.line).style(_getPlotLineStyle(datum)));
                _createLabelGraphic(datum, g);
                g.addTo(this.plotLinesGroup);
            }

            for(i = 0, len = selection.update.length; i < len; i++){
                var g = selection.update[i], datum = g.datum();

                g._lineG.attr(datum.line).style(_getPlotLineStyle(datum));

                _createLabelGraphic(datum, g);
                this.plotLines.push(g);
            }
        },

        _drawTickLabel:function(){
            this._drawSvgTickLabel();
        },

        /**
         * SVG
         * @return {[type]} [description]
         */
        _drawSvgTickLabel:function(){
            var vanchart = this.vanchart, renderer = vanchart.renderer;

            var ticks = this.getTickData().filter(function(tick){return tick.tickContent !== ''});

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = renderer.vgroup().add();
                this.axisGroup.append(this.tickLabelsGroup.renderG);
                this.tickLabels = [];
            }

            this.tickLabels = this._drawSvgTickLabelWithData(this.tickLabels, ticks);
        },

        /**
         * svg
         * @param  {[type]} tickLabels [description]
         * @param  {[type]} ticks      [description]
         * @param  {[type]} level      [description]
         * @return {[type]}            [description]
         */
        _drawSvgTickLabelWithData: function (tickLabels, ticks, level) {
            var axis = this, vanchart = this.vanchart, renderer = vanchart.renderer;
            var startPos = level ? this._getLabelStartPos(level) : 0;

            var scale = this.scale, lastScale = this.lastScale || scale;
            var cfg = this.options, labelStyle = cfg.labelStyle,
                useHtml = cfg.useHtml;

            var selection = this._bindData(tickLabels, ticks, function (d) {return d.tickValue}), i, len;

            var currentTickLabels = [], para = {'duration':TIME, 'ease':EASE, 'style':{'opacity':0}};
            for(i = 0, len = selection.exit.length; i < len; i++){
                var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                selection.exit[i].animate(BaseUtils.extend({}, para, axis.isHorizontal() ? {'x': pos} : {'y' : pos})).remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var d = selection.enter[i];
                var transform = this._getLabelAttr(lastScale, d, startPos);

                var tickLabel = this.tickLabelsGroup.append(
                    renderer.vtext(useHtml)
                        .textContent(d.tickContent)
                        .style({'opacity':0})
                );
                var rotateStr = (d.labelRotation % 360) ?
                    tickLabel.vRotate(d.labelRotation, true/* delay */).rotateStr : '';
                transform.transform += rotateStr;
                tickLabel.attr(transform);
                tickLabel.datum(d);
                currentTickLabels.push(tickLabel);
            }

            currentTickLabels = currentTickLabels.concat(selection.update);

            for(i = 0, len = currentTickLabels.length; i < len; i++){
                var tickLabel = currentTickLabels[i], d = tickLabel.datum();
                tickLabel.textContent(d.tickContent).style(labelStyle);

                var transform = this._getLabelAttr(scale, d, startPos);

                var opacity = this._valueInDomain(d.tickValue) ? 1 : 0;

                if(this.useHtmlLabel()){
                    tickLabel.attr(transform).style({'opacity':opacity});
                    tickLabel.vRotate(d.labelRotation);
                }else{
                    var rotateStr = (d.labelRotation % 360) ?
                        tickLabel.vRotate(d.labelRotation, true/* delay */).rotateStr : '';
                    transform.transform += rotateStr;
                    tickLabel.animate({
                        'ease':EASE, 'duration':TIME, 'attr':transform, 'style':{'opacity':opacity}
                    });
                }
            }

            return currentTickLabels;
        },

        /**
         * ,startPos
         * @param  {[type]} scale    [description]
         * @param  {[type]} d        [description]
         * @param  {[type]} startPos [description]
         * @return {[type]}          [description]
         */
        _getLabelAttr:function(scale, d, startPos){
            var origin = this._getAxisOriginPoint();
            var det = scale.rangeBand ? scale.rangeBand()/2 * (d.length || 1) : 0;
            var tickLabelPos = scale(d.tickValue) + det;

            var cfg = this.options, isHorizontal = this.isHorizontal();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0, tickPadding = (cfg.tickPadding + tickLength) || 0;
            var labelRotation = d.labelRotation || 0, labelStyle = cfg.labelStyle, useHtml = cfg.useHtml;
            var position = this.getPosition(), sign = (position == Constants.TOP || position == Constants.LEFT) ? -1 : 1;

            var rectDim = d.tickRectDim, labelDim = d.tickDim;

            // 90 degree has no rotation
            // rotation represents in writing-mode;

            var textX = 0, textY = 0, dx = 0, dy = rectDim.height * 0.85, direction,
                rotationRadian = BaseUtils.toRadian(labelRotation), writingMode;

            if (labelRotation === 360) {
                dx = (useHtml || BaseUtils.isMS) ? 0 : rectDim.width * 0.85 / 2;
                dy = 0;
                writingMode = 'tb-rl';
            }

            if (isHorizontal) {

                direction = Math.abs(labelRotation % 90) < 15 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textY += sign * (labelDim.height - rectDim.height) / 2;
                textX += sign * direction * (labelDim.width - Math.abs(rectDim.height * Math.sin(rotationRadian))) / 2;

                if (position === Constants.TOP) {
                    textY -= rectDim.height;
                    textY -= startPos;
                } else {
                    textY += startPos;
                }

                textY += sign * tickPadding;

                textX += origin.x + tickLabelPos - rectDim.width / 2;
                textY += origin.y;

            } else {

                direction = Math.abs(labelRotation % 90) > 85 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textX += sign * (labelDim.width - rectDim.width) / 2;
                textY += sign * direction * (labelDim.height - rectDim.height * Math.cos(rotationRadian)) / 2;

                if (position === Constants.LEFT) {
                    textX -= rectDim.width;
                    textX  -= startPos;
                } else {
                    textX  += startPos;
                }

                textX += sign * tickPadding;

                textX += origin.x;
                textY += origin.y + tickLabelPos - rectDim.height / 2;
            }

            var px = useHtml ? 'px' : '';
            var transform = 'translate(' + textX + px + ' ' + textY + px + ')';

            var result = {
                transform : transform,
                dy: dy,
                dx: dx,
                'writingMode': writingMode,
                'writing-mode': writingMode
            };

            // phantomjs bug
            if (useHtml && writingMode && !BaseUtils.hasTouch()) {
                result['-webkit-writing-mode'] = 'vertical-rl';
            }

            return result;
        },

        _drawAxisTitle: function () {
            var cfg = this.options, title = cfg.title;
            if (!title || BaseUtils.isEmpty(title.text)) {
                this.titleGroup && this.titleGroup.remove();
                this.titleGroup = null;
                return;
            }
            var R = this.vanchart.renderer, axisGroup = this.axisGroup;
            var useHtml = title.useHtml, rotation = this.titleRotation, align = this.getTitleAlign(),
                text = title.text, style = title.style;

            var textDim = this.titleDim, rectDim = this.titleRectDim;
            var titleBounds = this.getAxisTitleBounds();

            if (!this.titleGroup) {
                this.titleGroup = R.vgroup().add();
                axisGroup.append(this.titleGroup.renderG);
            }

            this.titleGroup.attr({'transform': BaseUtils.makeTranslate(titleBounds)});
            var titleGroup = this.titleGroup;

            //rotate(deg,x,y)
            if (titleGroup.text) {
                titleGroup.text.remove();
            }
            titleGroup.text = titleGroup.append(R.vtext(useHtml));

            var x = 0, y = 0, dx = 0, dy = rectDim.height * 0.85;
            switch (align) {
                case Constants.TOP:
                    y = 0;
                    break;
                case Constants.BOTTOM:
                    y = titleBounds.height - textDim.height;
                    break;
                case Constants.LEFT:
                    x = 0;
                    break;
                case Constants.RIGHT:
                    x = titleBounds.width - textDim.width;
                    break;
                case Constants.CENTER:
                default:
                    if (this.isHorizontal()) {
                        x = (titleBounds.width - textDim.width)/2;
                    } else {
                        y = (titleBounds.height - textDim.height) / 2;
                    }
            }

            if (this.titleRotation === 360) {
                dx = useHtml ? 0 : (BaseUtils.isMS ? '0.2ex' : rectDim.width * 0.85 / 2);  // @CHART-769 IE.
                dy = 0;
            } else {
                x += (textDim.width - rectDim.width) / 2;
                y += (textDim.height - rectDim.height) / 2;
            }

            titleGroup.text
                .textContent(text)
                .attr({
                    x: x,
                    y: y,
                    dy: dy,
                    dx: dx
                }).style(style);

            (rotation % 360) && titleGroup.text.vRotate(rotation);
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.clipAxisGroup && this.clipAxisGroup.remove();
            this.axisGroup = this.clipAxisGroup = null;

            this.axisLineGroup && this.axisLineGroup.remove();
            this.axisLineGroup = null;
            this.axisLine && this.axisLine.remove();
            this.axisLine = null;

            this.gridLinesGroup && this.gridLinesGroup.remove();
            this.gridLinesGroup = null;
            this.gridLines && this.gridLines.forEach(function (gridLine) {
                gridLine && gridLine.remove();
                gridLine = null;
            });
            this.gridLines = null;

            this.plotLinesGroup && this.plotLinesGroup.remove();
            this.plotLinesGroup = null;
            this.plotLines && this.plotLines.forEach(function (plotLine) {
                plotLine && plotLine.remove();
                plotLine = null;
            });
            this.plotLines = null;

            // remove vgroup
            this.tickLabelsGroup && this.tickLabelsGroup.remove();
            this.tickLabelsGroup = null;
            this.tickLabels = null;

            this.cateTickLabelsGroup && this.cateTickLabelsGroup.remove();
            this.cateTickLabelsGroup = null;
            this.cateTickLabels = null;
        }
    });

    return BaseAxis;
});
/**
 * Created by eason on 15/5/18.
 * 
 */
define('component/CategoryAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/BezierEasing'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var BezierEasing = require('../utils/BezierEasing');

    var LABEL_LINE_GAP = 2.5;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };
    
    var CategoryAxis = BaseAxis.extend({

        type:ComponentLibrary.CATEGORY_AXIS_COMPONENT,

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = Scale.ordinal();
        },

        calculateDomainFromData:function(){
            this._dataDomain = this._getDomainFromData();

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);

            this._zoomDomain = this._zoomDomain || (zoomTool && zoomTool.getZoomDomain(this));

            this._domain = this._zoomDomain || this._dataDomain;
        },

        calculateDomainFromZoom:function(){
            this._domain = this._zoomDomain;
        },

        _getStartAndEndTick:function(){
            return [this._domain[0], this._domain[this._domain.length - 1]];
        },

        _getDomainFromData:function(){
            var axisOption = this.options, series = this.series, axis = this, stored = {};
            var categories = axisOption.categories || [];
            categories.forEach(function(category){
                stored[category] = true;
            });

            series.forEach(function(sery){

                this.getTrendLineForecast(sery);

                for(var i = 0, len = sery.points.length; i < len; i++){

                    var tickLabel = sery.points[i].getCategory();

                    if(!stored[tickLabel]){
                        stored[tickLabel] = true;
                        categories.push(tickLabel);
                    }
                }

                // isRangePointsfalse
                if (sery.type !== Constants.AREA_CHART || this.isMultiCateAxis()) {
                    axis.isRangePoints = false;
                }

            }, this);

            // _dataDomain
            if(this.isMultiCateAxis() && categories.length){
                categories = this.resortDataDomain(categories);
            }

            return this.addTrendLineCategories(categories);
        },

        setCategories:function(categories){

            var lastDomain = this._dataDomain;

            this._dataDomain = this.addTrendLineCategories(categories);

            var zoomTool = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(this._isBaseAxis() && zoomTool && zoomTool.zoomToolEnabled()){

                zoomTool.updateRangeLeftAndRight(this, lastDomain, categories);

                var zoomDomain = zoomTool && zoomTool.getZoomDomain(this);

                this._zoomDomain = zoomDomain;

                this.calculateDomainFromZoom()
            }else{
                this._domain = this._dataDomain;
                this._zoomDomain = null;
            }

            this.fixScaleAndTickData();
        },

        addTrendLineCategories: function (categories) {
            if (this.forecast && (this.forecast[0] || this.forecast[1])) {
                var emptyL = 0;
                categories =
                    newArray(-this.forecast[0], function () { return Array(2 + emptyL++).join(' '); })
                        .concat(categories)
                        .concat(newArray(this.forecast[1], function () { return Array(2 + emptyL++).join(' '); }));

                function newArray(length, fillFun) {
                    return Array.apply(null, Array(length)).map(fillFun)
                }
            }

            return categories;
        },

        getOriginalCategories: function () {
            if (this.forecast && (this.forecast[0] || this.forecast[1])) {
                return this._dataDomain.slice(-this.forecast[0], this._dataDomain.length - this.forecast[1]);
            }
            return this._dataDomain;
        },

        //
        updateAxisSizeAndBounds:function(){

            this._updateOriginTickData();

            this._calculateSize(this.tickData);

            this._setComponentBounds(this.getPosition(), this._size);
        },

        _getTickValuesWithEndValue:function(){
            return this._getTickValues();
        },

        fixScaleAndTickData:function(){

            this.scale.domain(this._dataDomain);

            this.isRangePoints ? this.scale.rangePoints(this._getRange()) : this.scale.rangeBands(this._getRange());

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        _getRange:function(){
            var plotRange = this._getPlotRange();

            //
            if(this._dataDomain.length == this._domain.length){
                return plotRange;
            }

            var rangeBands, rangeLength = Math.abs(plotRange[1] - plotRange[0]);
            if (this.isRangePoints) {
                rangeBands = rangeLength / Math.max(this._domain.length - 1, 1);
            } else {
                rangeBands = rangeLength / this._domain.length
            }

            var startIndex = BaseUtils.indexOf(this._dataDomain, this._domain[0]);
            var endIndex = this._dataDomain.length - BaseUtils.indexOf(this._dataDomain, this._domain[this._domain.length - 1]) - 1;

            if(!(this.isAxisReversed() ^ this.isHorizontal())){
                var tmp = startIndex;
                startIndex = endIndex;
                endIndex = tmp;
            }

            var min = -startIndex * rangeBands, max = rangeLength + endIndex * rangeBands;

            if(this.isHorizontal()){
                return this.isAxisReversed() ? [max, min] : [min, max];
            }else{
                return this.isAxisReversed() ? [min, max] : [max, min];
            }
        },

        getLabelAutoRotation: function (labels, axisOption, formatter) {
            if (axisOption.autoRotate &&
                !axisOption.labelRotation) {
                var isInverted = this.vanchart.isInverted();
                var longLabel = labels.reduce(function (a, b) {
                    return BaseUtils.getTextDimension(a).width > BaseUtils.getTextDimension(b).width ? a : b;
                });
                var longContent = this._getTickContent(longLabel, formatter);
                var longDim = BaseUtils.getTextDimensionWithRotation(longContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);
                var gap = Math.max.apply(null, this._getPlotRange()) / this._domain.length - LABEL_LINE_GAP_FUN();

                var w, h;
                if (isInverted) {
                    w = longDim.height;
                    h = longDim.width;
                } else {
                    w = longDim.width;
                    h = longDim.height;
                }
                var l = Math.sqrt(w * w + h * h);

                if (h > gap) {
                    return -90;
                } else if (w > gap) {
                    var alpha = Math.acos(gap/l);
                    var beta = Math.atan(h/w);
                    var theta = alpha + beta;
                    return -BaseUtils.toDegree(theta);
                }
            }
        },

        getCategoryCount:function(){
            return this._dataDomain.length;
        },

        indexOfLabel:function(label){
            return BaseUtils.indexOf(this._dataDomain, label);
        },

        getTickLength:function(){

            var domain = this.scale.domain();

            var range = this.scale.rangeExtent();

            var cateLength = Math.abs(range[1] - range[0]);

            if(this.isRangePoints && domain.length <= 1){
                return cateLength;
            }

            return  this.isRangePoints ? cateLength / (domain.length - 1) : this.scale.rangeBand();
        },

        _getTickValues:function(){
            return this._domain;
        },

        getCategories:function(){
            return this._dataDomain;
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.bounds;

            //
            if(this.isHorizontal()){
                startPos = Math.min(downPos.x, upPos.x) - plotBounds.x;
                endPos = Math.max(downPos.x, upPos.x) - plotBounds.x;
            }else{
                startPos = Math.min(downPos.y, upPos.y) - plotBounds.y;
                endPos = Math.max(downPos.y, upPos.y) - plotBounds.y;
            }

            var domain = this.scale.domain();
            var range = this._getRange();

            var tmpScale = Scale.quantize().domain(range).range(domain);

            var start = BaseUtils.indexOf(this._dataDomain, tmpScale(startPos));
            var end = BaseUtils.indexOf(this._dataDomain, tmpScale(endPos));

            this.zoomRefresh(this._dataDomain.slice(Math.min(start, end), Math.max(start, end) + 1))
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByXYCoordinate(pos);
        },

        _getIndexByXYCoordinate: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var isHorizontal = this.isHorizontal();
            var isReversed = this.isAxisReversed() ^ !isHorizontal;

            var startX = scale(
                isReversed ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (isHorizontal) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = Math.abs(scale(scale.domain()[1]) - scale(scale.domain()[0]));
                index = isReversed ? categories.length - 1 - x / unitLength : x / unitLength;
            } else {
                index = 0;
            }

            if (this.isRangePoints) {
                index = Math.round(index);
            } else {
                index = isReversed ? Math.ceil(index) : Math.floor(index);
            }

            return index;
        },

        getPointsInCategory:function(containerPoint){
            var plotBounds = this.vanchart.bounds;
            var domain = this.scale.domain(), range = this._getRange();
            var tmpScale = Scale.quantize().domain(range).range(domain);
            var category = tmpScale(this.isHorizontal() ? containerPoint.x - plotBounds.x : containerPoint.y - plotBounds.y);
            return this.vanchart.getValidPointsPara(category);
        },

        drawHighlightBackground: function (sharedPoints) {
            var category = sharedPoints[0].getCategory();
            var highlightType = 'line';
            sharedPoints.map(function (point) {
                var series = point.series;
                if (series.type === Constants.BAR_CHART ||
                    series.type === Constants.COLUMN_CHART) {
                    highlightType = 'band';
                }
            });

            var plotBounds = this.getPlotBounds(), isHorizontal = this.isHorizontal();
            var scale = this.scale, rangeBand = scale.rangeBand ? scale.rangeBand() : 0;
            var from = scale(category), to = from + rangeBand, renderer = this.vanchart.renderer;

            var x = 'x', y = 'y', width = 'width', height = 'height', size = plotBounds.height;
            var x1 = 'x1', x2 = 'x2', y1 = 'y1', y2 = 'y2';
            if(!isHorizontal){
                x = 'y'; y = 'x'; width = 'height'; height = 'width'; size = plotBounds.width;
                x1 = 'y1'; x2 = 'y2'; y1 = 'x1'; y2 = 'x2';
            }

            switch (highlightType) {
                case 'band':
                    var bandAttr = {};bandAttr[x] = from;bandAttr[y] = 0;bandAttr[width] = Math.abs(from - to);bandAttr[height] = size;
                    if(!this.highlightBand){
                        this.highlightBand = renderer.rect().attr(bandAttr).style({
                            'fill': 'rgb(98,179,240)',
                            'fill-opacity':0.2
                        }).addTo(this.clipAxisGroup);
                    }
                    this.highlightBand
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .animate({
                            duration:250,
                            ease:BezierEasing.css['ease'],
                            attr:bandAttr
                        });

                    this.highlightLine && this.highlightLine.remove();
                    this.highlightLine = null;

                    break;
                case 'line':
                default:

                    if (rangeBand) {
                        from = (from + to) / 2;
                    }

                    var attr = {};attr[x1] = from;attr[y1] = 0;attr[x2] = from;attr[y2] = size;
                    if(!this.highlightLine){
                        this.highlightLine = renderer.line().attr(attr).style({
                            'stroke': 'rgb(140,140,140)',
                            'stroke-width':1
                        }).addTo(this.clipAxisGroup);
                    }

                    this.highlightLine
                        .attr('transform',BaseUtils.makeTranslate(plotBounds))
                        .animate({
                            duration:250,
                            ease:BezierEasing.css['ease'],
                            attr:attr
                        });

                    this.highlightBand && this.highlightBand.remove();
                    this.highlightBand = null;
            }
        },

        removeHighlightBackground:function(){
            this.highlightBand && this.highlightBand.remove();
            this.highlightLine && this.highlightLine.remove();

            this.highlightBand = null;
            this.highlightLine = null;
        },

        isMultiCateAxis: function (){
            return false;
        }
    });

    ComponentLibrary.register(ComponentLibrary.CATEGORY_AXIS_COMPONENT, CategoryAxis);
    return CategoryAxis;
});
/**
 * Created by eason on 15/5/18.
 * 
 */
define('component/ValueAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../utils/QueryUtils','../Constants','../ComponentLibrary','../utils/Scale'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');

    var ValueAxis = BaseAxis.extend({

        type:ComponentLibrary.VALUE_AXIS_COMPONENT,

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = this.options.log ? Scale.log().base(this.options.log) : Scale.linear();
        },

        getAxisValue: function (value, point) {
            return this.byPercent ? point.percentage : +value;
        },

        _valueInDomain: function (value) {
            var domain = this.scale.domain();
            return value >= Math.min(domain[0], domain[1]) && value <= Math.max(domain[0], domain[1]);
        },

        //
        _getDomainFromData:function(){

            var minValue = Number.MAX_VALUE,maxValue = -minValue, emptyData = true;
            var series = this.series, dataMap = {};

            //check
            var visible = false;
            for(var i = 0, len = series.length; i < len && !visible; i++){
                visible = series[i].visible;
            }

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].visible || !visible){
                    this._getSeriesValue(dataMap, series[i]);
                    this.getTrendLineForecast(series[i]);
                }
            }

            var gap = 0; // for trend line period
            for(var key in dataMap){
                var data = dataMap[key];
                gap = data[1] - data[0] || 0;
                for(var j = 0, dataCount = data.length; j < dataCount; j++){
                    if(!isNaN(data[j]) && !(this.options.log && data[j] <= 0)){
                        minValue = Math.min(minValue, data[j]);
                        maxValue = Math.max(maxValue, data[j]);
                        emptyData = false;
                    }
                }
            }

            if (this._isBaseAxis() && gap && this.forecast) {
                minValue += gap * this.forecast[0];
                maxValue += gap * this.forecast[1];
            }

            if(emptyData){
                minValue = 0;
                maxValue = 100;
            }

            return [minValue, maxValue];
        },

        //
        _getSeriesValue:function(dataMap, sery){

            var seriesName = sery.name || '';

            var key = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            if(BaseUtils.hasNotDefined(sery.stack) || this._isBaseAxis()){
                dataMap[seriesName] = dataMap[seriesName] || [];

                sery.points.forEach(function(point){
                    if(!point.isNull && point.visible) {
                        dataMap[seriesName].push(point.options[key]);
                    }
                });

            }else{
                var PK = sery.stack + sery.type + 'STACK_POSITIVE';
                var NK = sery.stack + sery.type + 'STACK_NEGATIVE';
                dataMap[PK] = dataMap[PK] || [];
                dataMap[NK] = dataMap[NK] || [];

                sery.points.forEach(function(point, i){
                    if(!point.isNull && point.visible){
                        var value = +point.options[key];
                        if(value > 0){
                            if(dataMap[PK][i] != null && dataMap[PK][i] != undefined){
                                dataMap[PK][i] += value;
                            }else{
                                dataMap[PK][i] = value;
                            }
                        }else{
                            if(dataMap[NK][i] != null && dataMap[NK][i] != undefined){
                                dataMap[NK][i] += value;
                            }else{
                                dataMap[NK][i] = value;
                            }
                        }
                    }

                });
            }
        },

        //0
        getStartPos:function(){
            return this.scale(this.getStartPosValue());
        },

        getStartPosValue:function(){

            var axisOption = this.options;

            return axisOption.log && axisOption.log !== 1 ? 1 : 0;
        },

        _getTickValues:function(){

            var valueList = [];

            if(this.options.log){
                var i = 0, tickValue;
                while((tickValue = this._tickStart * Math.pow(this.options.log, i)) <= this._domain[1]){
                    valueList.push(tickValue);
                    i += this._step;
                }
            }else {
                var start = this._tickStart;
                for(; start <= this._domain[1]; start = BaseUtils.accAdd(start, this._step)){
                    valueList.push(start);
                }
            }

            return valueList;
        }
    });

    ComponentLibrary.register(ComponentLibrary.VALUE_AXIS_COMPONENT, ValueAxis);
    return ValueAxis;
});
/**
 * Created by eason on 15/11/2.
 */
define('component/DateAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale'],function(require){

    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale')

    var SECOND = 1000;
    var MINUTE = SECOND * 60;
    var HOUR = MINUTE * 60;
    var DAY = HOUR * 24;
    var MONTH = DAY * 31;
    var YEAR = 12 * MONTH;

    var DateAxis = BaseAxis.extend({

        type:ComponentLibrary.DATE_AXIS_COMPONENT,

        getAxisValue: function (value) {
            return BaseUtils.object2date(value);
        },

        fixScaleAndTickData:function(){

            var domain = [BaseUtils.int2date(this._domain[0]), BaseUtils.int2date(this._domain[1])];

            this.scale.domain(domain).rangeRound(this._getRange());

            //domain
            this._calculateDateFormat();

            this._updateOriginTickData();

            this._calculateTickPosAndStep();
        },

        _calculateDateFormat:function(){
            var tickInterval = this._step;

            var format = 'Dyyyy';

            if(tickInterval <= SECOND){
                format = 'Dss';
            }else if(tickInterval <= MINUTE){
                format = 'Dmm:ss';
            }else if(tickInterval <= HOUR){
                format = 'Dhh:mm';
            }else if(tickInterval <= DAY){
                format = 'Ddd-hh';
            }else if(tickInterval <= MONTH){
                format = 'DMM-dd';
            }else if(tickInterval <= YEAR){
                format = 'Dyyyy-MM';
            }

            this.dateFormat = format;
        },

        _getTickContent:function(tick, formatter){
            var format = this.dateFormat;
            //todo FR
            function formatFunc(cv){
                return (window.FR && window.FR.contentFormat(cv, format)) || cv;
            };

            formatter = formatter || formatFunc;

            return BaseUtils.format(tick, formatter);
        },

        initScale:function(){
            this.lastScale = this.scale;
            this.scale = Scale.linear();
        },

        _getStartAndEndTick:function(){
            return [BaseUtils.int2date(this._domain[0]), BaseUtils.int2date(this._domain[1])];
        },

        _getTickValues:function(){
            var result = [];
            var start = this._tickStart;
            for(; start <= this._domain[1]; start = BaseUtils.accAdd(start, this._step)){
                result.push(BaseUtils.int2date(start));
            }
            return result;
        },

        _valueInDomain: function (value) {
            var domain = this.scale.domain();
            return value >= Math.min(domain[0], domain[1]) && value <= Math.max(domain[0], domain[1]);
        },

        _getDomainFromData:function(){

            var minValue = Math.ceil(Number.MAX_VALUE);
            var maxValue = -minValue;

            var series = this.series;
            var hasData = false;

            var gap = 0;
            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var byAxis = sery[this.componentType];
                if(byAxis == this && sery.visible){
                    this.getTrendLineForecast(series[i]);
                    var data = sery.points;
                    if (data.length > 1) {
                        gap = this.getValueFromData(data[1]) - this.getValueFromData(data[0]) || 0;
                    }
                    for(var i = 0,len = data.length; i < len; i++){
                        var value = this.getValueFromData(data[i]);

                        if(value.getTime){
                            hasData = true;
                            value = BaseUtils.date2int(value);
                            minValue = Math.min(minValue, value);
                            maxValue = Math.max(maxValue, value);
                        }
                    }
                }
            }

            if (this._isBaseAxis() && gap && this.forecast) {
                minValue += gap * this.forecast[0];
                maxValue += gap * this.forecast[1];
            }

            if(!hasData){
                minValue = maxValue = (new Date()).getTime();
            }

            maxValue = minValue >= maxValue ? minValue + 1000 : maxValue;

            return [minValue, maxValue];
        },

        getValueFromData:function(datum){
            var valueIndex = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.object2date(value);
        }
    });

    ComponentLibrary.register(ComponentLibrary.DATE_AXIS_COMPONENT, DateAxis);
    return DateAxis;

});
/**
 * Created by Cmen on 2017/6/29.
 */

define('component/MultiCategoryAxis',['require','../utils/BaseUtils','./CategoryAxis','../Constants','../ComponentLibrary','../utils/BezierEasing'],function (require){
	var BaseUtils = require("../utils/BaseUtils");
    var CategoryAxis = require("./CategoryAxis");
    var Constants = require("../Constants");
    var ComponentLibrary = require("../ComponentLibrary");
    var BezierEasing = require("../utils/BezierEasing");

    var LAST_MAIN_TICK_LINE_KEY = "LAST_MAIN_TICK_LINE";

    var AXIS_GAP = 4,  // 
        AXIS_GAP_FUN = function(){
            return BaseUtils.paddingConvertWithScale(AXIS_GAP);
        };

    var LABEL_LINE_GAP = 4;
    var LABEL_LINE_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(LABEL_LINE_GAP);
    };

    var TICK_LENGTH = 4;

    var MAIN_TICK = "main";

    var decodeArray = BaseUtils.decodeCategoryArray,
        encodeArray = BaseUtils.encodeCategoryArray;


	var MultiCategoryAxis = CategoryAxis.extend({

		/**
		 * Axis.tickDatatickLabeltickData
		 * axis.tickData
		 * @return {[type]} [description]
		 */
		_updateOriginTickData: function (){
			var labelsArray = this._getTickValues();

			this._calculateLabelRotation(labelsArray[0]); // 

			this.tickData = [];

			for (var i = -1; ++i < labelsArray.length;) {
				var labels = labelsArray[i];
				this.tickData[i] = [];

				for(var j = -1; ++j < labels.length;) {
					var tickValue = labels[j].tickValue, tickContent = labels[j].content;

					this.tickData[i].push(
						this._calculateSingleTickData(tickValue, tickContent, { length: labels[j].length})  // length:
					)
				}
			}

			this._updateTickLengthMap(); // Map
		},

		/**
		 * tickValues tick
		 * @return {[type]} [description]
		 */
		_getTickValues: function (){
			var axisArray = [];

			var domain = this._domain;

			domain.forEach(function (cateArrayStr) {
				axisArray.push(decodeArray(cateArrayStr));
			});

			var sortMap = {},sortArr = [];
			var pos = this.getPosition();

			var i, len = axisArray.length;

			var k1 = this.isAxisReversed() ? 1 : 0,
				k2 = (pos == Constants.LEFT || pos == Constants.RIGHT) ? 1 : 0;


			/**
			 * tickValues
			 * 0-len
			 */
			var reverse = (k1 + k2) % 2;

			if(reverse) {
				for(i = len; --i >= 0;) {
					pushCateMap(axisArray[i]);
				}
			} else {
				for(i = -1; ++i < len;) {
					pushCateMap(axisArray[i]);
				}
			}

			function pushCateMap(categoryArray){
				var identifierArray = [];
				categoryArray.forEach(function (cate, index) {
					if(!sortArr[index]) { sortArr[index] = []; } // tickValues

					identifierArray.push(cate);
					var identifier = encodeArray(identifierArray);

					// 
					if(sortMap[identifier]) {
						sortMap[identifier].length++;
					} else {
						sortMap[identifier] = {
							content: cate,
							level: index,
							length: 1, 
							tickValue: encodeArray(categoryArray)
						}
					}
				})
			}

			// maparrie
			for (var identifier in sortMap) {
				var cateInfo = sortMap[identifier],
					index = cateInfo.level;

				sortArr[index].push({
					content: cateInfo.content,
					length: cateInfo.length,
					tickValue: cateInfo.tickValue
				});
			}

			// 
			return sortArr.map(function (lineTicks, index, array) {
				return array[array.length - index - 1];
			})
		},

		/**
		 * Axis.doLayout
		 * @return {[type]} [description]
		 */
		_getTickLabelLength: function (){
			var tickValues = this._getTickValues(), axisGap = AXIS_GAP_FUN();
			var option = this.options, axis = this;

			var totalHeight = 0, // 
				tickLengthArray = [], // 
				labelStartPosArray = []; // 

			var defultTickLength = (isNaN(+option.tickLength) ? TICK_LENGTH : option.tickLength);

			if (option.showLabel) {
                totalHeight += (isNaN(+option.tickPadding) ? LABEL_LINE_GAP_FUN() : option.tickPadding);
            }

            if (option.enableTick) {
                totalHeight += defultTickLength;
            }

            var start_gap = totalHeight;

            var isHorizontal = this.isHorizontal();

            var ticksLen = tickValues.length;

			for(var i = -1; ++i < ticksLen;) {

				labelStartPosArray.push(totalHeight - start_gap);
				var lineHeight = 0, lineTicks = tickValues[i];

				lineTicks.forEach(function (tickInfo) {
					var textDim = axis._getTickDim(tickInfo.content, option.formatter);
					lineHeight = Math.max(lineHeight, (isHorizontal ? textDim.height : textDim.width));
				});

				totalHeight += lineHeight + (i === ticksLen - 1 ? 0 : axisGap);

				tickLengthArray.push(i === 0 ? defultTickLength : totalHeight);
			}

			this._tickLengthArray = tickLengthArray;
			this._tickLabelStartPosArray = labelStartPosArray;

			return option.showLabel ? totalHeight : 0;
		},

		/**
		 * Map
		 * @return {[type]} [description]
		 */
		_updateTickLengthMap: function (){
			var tickValues = this._getTickValues();
			var tickLengthArray = this._tickLengthArray, len = tickLengthArray.length;

			var calcMap = {};

			// 
			for(var i = tickValues.length; --i >= 0;) {
				var lineTicks = tickValues[i];
				for(var j = -1; ++j < lineTicks.length;) {
					var tickValue = lineTicks[j].tickValue;
					if(!calcMap[tickValue]) {
						calcMap[tickValue] = tickLengthArray[i];
					}
				}
			}

			calcMap[LAST_MAIN_TICK_LINE_KEY] = tickLengthArray[len - 1];
			this._tickLengthMap = calcMap;
		},

		/**
		 * tickValue
		 * @param  {[type]} tickValue [description]
		 * @return {[type]}           [description]
		 */
		_getTickLength: function (tickValue) {
			return this._tickLengthMap[tickValue];
		},

		/**
		 * 
		 * @param  {[type]} option [description]
		 * @return {[type]}        [description]
		 */
		_drawMainTickLine: function (option) {
			var ticks = this.getTickData(), axis = this;
			var plotBounds = this.getPlotBounds(), pos = this.getPosition();
			var isBottomOrTop = pos === Constants.BOTTOM || pos === Constants.TOP;
			ticks = ticks.concat([
					{
						tickPos: isBottomOrTop ? plotBounds.width : plotBounds.height - 1,
						tickValue: LAST_MAIN_TICK_LINE_KEY
					}
				]);  // 

			option.keyFunction = function (datum){ return datum.tickValue; };  // identifier
            option.tickLengthFuc = function (datum) {    // key
                return axis._getTickLength(datum.tickValue) || option.tickLength;
            };

            this.tickLines[MAIN_TICK] = this._drawTickLineWithData(this.tickLines[MAIN_TICK], ticks, option);
		},

		/**
		 * scaleKey
		 * @param  {[type]} value [description]
		 * @param  {[type]} point [description]
		 * @return {[type]}       [description]
		 */
		getAxisValue: function (value, point) {
			return point.getCategory();
		},

		/**
		 * tickData
		 * tickDatatickData[0]
		 * @return {[type]} [description]
		 */
		getTickData: function (){
			return this.tickData[0] || [];
		},

		/**
		 * tickData
		 * @return {[type]} [description]
		 */
		getMultiTickData: function (){
			return this.tickData;
		},

        /**
         * dataDomain
         * ["A","B","C"], ["a","b","c"],["A","C","D"]
         * ["A","B","C"],["A","C","D"], ["a","b","c"]--
         * @param categories
         */
        resortDataDomain: function (categories){
            var domainData = categories.map(function (cate){
                return decodeArray(cate);
            });

            var levels = domainData[0].map(function (){return [];});
            var i, j, data, dataStr, storageMap = {} ;

            // categories
            for(i = -1; ++i < levels.length;){
                for(j = -1; ++j < domainData.length;){
                    data = domainData[j].slice(0, i+1);
                    dataStr = encodeArray(data);
                    if(!storageMap[dataStr]){
                        storageMap[dataStr] = true;
                        var identifier = encodeArray(data);  // [""]id[""
                        levels[i].push(identifier.substr(0, identifier.length - 1));
                    }
                }
            }

            var levelsLen = levels.length;

            var lastLevel = levels[levelsLen - 1].map(function (str){
                return str;
            });

            // 
            return sortLevel(levelsLen - 2, lastLevel).map(function (cate){
                return encodeArray(decodeArray(cate+"]"));
            });

            function sortLevel(index, lastLevel){
                // lastLevel
                if(index < 0) {return lastLevel;}
                var newLevel = [];
                var curLevel = levels[index], curLevellen = curLevel.length;

                for(i = -1; ++i < curLevellen;){
                    var curStr = curLevel[i];
                    for(j = -1; ++j < lastLevel.length;){
                        var lastStr = lastLevel[j];
                        if(lastStr.indexOf(curStr) === 0){
                            newLevel.push(lastStr);
                        }
                    }
                }
                // 
                return sortLevel(index - 1, newLevel);
            }
        },

		/**
		 * svg
		 * @return {[type]} [description]
		 */
		_drawSvgTickLabel: function (){
			var axis = this, renderer = this.vanchart.renderer;

			var multiTickData = this.getMultiTickData();

			if(!this.tickLabelsGroup){
                this.tickLabelsGroup = renderer.vgroup().add();
                this.axisGroup.append(this.tickLabelsGroup.renderG);
                this.tickLabels = multiTickData.map(function (){
                    return [];
                });
            }

            multiTickData.forEach(function (tickData, index) {
                axis.tickLabels[index] = axis._drawSvgTickLabelWithData(axis.tickLabels[index], tickData, index);
            })
		},

		/**
		 * 
		 * @param  {[type]} level [description]
		 * @return {[type]}       [description]
		 */
		_getLabelStartPos: function (level) {
			return this._tickLabelStartPosArray[level];
		},

		/**
		 * 
		 * @return {Boolean} [description]
		 */
		isMultiCateAxis: function(){
			return true;
		}

	});

	ComponentLibrary.register(ComponentLibrary.MULTI_CATEGORY_AXIS_COMPONENT, MultiCategoryAxis);
    return MultiCategoryAxis;
});
/**
 * Created by eason on 15/5/15.
 * 
 */
define('component/Axis',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','./CategoryAxis','./ValueAxis','./DateAxis','./MultiCategoryAxis'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var CategoryAxis = require('./CategoryAxis');
    var ValueAxis = require('./ValueAxis');
    var DateAxis = require('./DateAxis');
    var MultiCategoryAxis = require('./MultiCategoryAxis'); 
    
    var Axis = Base.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //option
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else{
                    var AxisClass;

                    var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                    if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                        AxisClass = ValueAxis;
                    } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                        AxisClass = CategoryAxis;
                    } else if (axisType == ComponentLibrary.DATE_AXIS_COMPONENT) {
                        AxisClass = DateAxis;
                    } else if(axisType === ComponentLibrary.MULTI_CATEGORY_AXIS_COMPONENT){ 
                        AxisClass = MultiCategoryAxis; 
                    } 

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }
            }
        },

        doLayout:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].calculateDomainFromData();
                this._axisList[i]._calculateSize();
                this._axisList[i]._recordAxisSize();
            }
        },

        reCalculateSize:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i]._calculateSize();
                this._axisList[i]._recordAxisSize();
            }
        },

        updateAxisClip:function(){
            var clipBounds = {};

            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].updateClipBounds(clipBounds);
            }

            this._recordForPlotBounds(Constants.LEFT, clipBounds[Constants.LEFT] || 0);
            this._recordForPlotBounds(Constants.RIGHT, clipBounds[Constants.RIGHT] || 0);
            this._recordForPlotBounds(Constants.TOP, clipBounds[Constants.TOP] || 0);
            this._recordForPlotBounds(Constants.BOTTOM, clipBounds[Constants.BOTTOM] || 0);
        },

        updateAxisSizeAndBounds:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].updateAxisSizeAndBounds();
            }
        },

        adjustDomain4Radius:function(){
            var adjusted = false;
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                adjusted = this._axisList[i].adjustDomain4Radius() || adjusted;
            }
            return adjusted
        },

        fixBoundsByPlot:function(){
            var plotBounds = this.vanchart.bounds;

            var map = {};

            for(var i = 0, axisCount = this._axisList.length; i < axisCount; i++){

                var axis = this._axisList[i], position = axis.getPosition();

                if(axis.isOnZero()){

                    if(isHorizontal){
                        axis.bounds.width = plotBounds.width;
                    }else{
                        axis.bounds.height = plotBounds.height;
                    }

                    //scaletickData
                    axis.fixScaleAndTickData();

                }else{
                    map[position] = map[position] || [];
                    map[position].push(axis);
                }
            }

            for(var position in map){

                var axisList = map[position];
                var isHorizontal = position == Constants.TOP || position == Constants.BOTTOM;

                for(var i = 0, count = axisList.length; i < count; i++){

                    var axis = axisList[i], axisBounds = axis.bounds;

                    var baseBounds = (axisList[i - 1] && axisList[i - 1].bounds) || plotBounds;

                    if(isHorizontal){
                        var y = position == Constants.TOP ? baseBounds.y - axisBounds.height : baseBounds.y + baseBounds.height;
                        axis.bounds = BaseUtils.makeBounds(baseBounds.x, y, baseBounds.width, axisBounds.height);
                    }else{

                        var x = position == Constants.LEFT ? baseBounds.x - axisBounds.width : baseBounds.x + baseBounds.width;
                        axis.bounds = BaseUtils.makeBounds(x, baseBounds.y, axisBounds.width, baseBounds.height);
                    }

                    //scaletickData
                    axis.fixScaleAndTickData();
                }
            }
        },


        getAxis:function(axisIndex){
            if (axisIndex >= this._axisList.length) {
                axisIndex = 0;
            }
            return this._axisList[axisIndex];
        },

        getAxisCount:function(){
            return this._axisList.length;
        },

        axisZoom:function(downPos, upPos){
            this._axisList.forEach(function(axis){
                axis.axisZoom(downPos, upPos);
            });
        },

        //0
        dealOnZero:function(){
            this._axisList.forEach(function(axis){
                axis.dealOnZero();
            });
        },

        render:function(){
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].render();
            }
        },

        /**
         * Axisaxis
         * @return {[type]} [description]
         */
        remove: function () {
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].remove();
            }
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.X_AXIS_COMPONENT, Axis);
    ComponentLibrary.register(ComponentLibrary.Y_AXIS_COMPONENT, Axis);

    return Axis;
});
/**
 * Created by eason on 15/5/15.
 * 
 */
define('component/GaugeAxis',['require','../Constants','./Axis','../ComponentLibrary'],function(require){
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var ComponentLibrary = require('../ComponentLibrary');

    var GaugeAxis = Axis.extend({

        initAttributesWithSeries:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                var axis = this._axisList[i];
                axis.calculateDomainFromData();
                axis.scale.domain(axis._domain);
                axis._updateOriginTickData();

                if(!axis.options.showLabel){
                    axis.tickData.forEach(function(t){
                        t.tickContent = '';
                    });
                }
            }
        },

        doLayout:function(){

        },

        render:function(){

        }
    });

    ComponentLibrary.register(ComponentLibrary.GAUGE_AXIS_COMPONENT, GaugeAxis);

    return GaugeAxis;
});
/**
 * Created by eason on 16/8/1.
 */

define('component/LegendItem',['require','../dom/Evented','../Constants','../utils/BaseUtils','./LegendIconFactory','../ComponentLibrary'],function(require){

    var Evented = require('../dom/Evented');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var LegendIconFactory = require('./LegendIconFactory');
    var ComponentLibrary = require('../ComponentLibrary');

    // gap between legendIcon and legendText
    var GAP = 8;
    var GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(GAP);
    };

    var WORD_GAP = 0.2;

    var LegendItem = Evented.extend({

        initialize:function(legend, options){
            this.legendX = 0; this.legendY = 0;
            this.legend = legend;
            this.state = Constants.STATE_SHOW;
            this.refresh(options);
        },

        refresh:function(options){
            this.options = options;
            options.renderItem = this;
        },

        render:function(){
            var legend = this.legend, vanchart = legend.vanchart, renderer = vanchart.renderer;
            var textStyle = legend.options.style;

            if (!this.graphic) {
                this.graphic = legend.legendItemsGroup.append(renderer.group());
                if (!this.options.isTrendLine) {
                    this.graphic.style({'cursor': 'pointer'});
                }
            }

            vanchart.registerInteractiveTarget(this, this.graphic);

            var g = this.graphic, d = this.options;
            var markerColor = d.visible ? d.color : d.hiddenColor;
            var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
            var labelDim = BaseUtils.getTextDimension(d.itemName, textStyle, legend.options.useHtml);
            var itemHeight = Math.max(iconSize.height, labelDim.height);

            this.graphic.attr({'transform':BaseUtils.makeTranslate([this.legendX, Math.round(this.legendY + itemHeight/2)])});

            if(LegendIconFactory.hasIcon(d.legendIconType)){
                g.image && g.image.remove();
                g.image = null;

                g.path = g.path || renderer.path().addTo(g);
                g.path.attr('d', LegendIconFactory.getLegendIconPath(d.legendIconType))
                    .attr('transform', BaseUtils.makeTranslate([0, -iconSize.height/2]))
                    .style({
                        'fill':markerColor, 'fill-opacity': d.opacity
                    });
                if(d.series.type == Constants.BUBBLE_CHART){
                    g.path.style('stroke', markerColor).style('stroke-width',1);
                }
            }else{
                g.path && g.path.remove();
                g.path = null;
                
                g.image = g.image || renderer.image().addTo(g);
                g.image.attr({'x':0, 'y':-iconSize.height/2, 'width':12, 'height':12, 'preserveAspectRatio': 'none'})
                    .imageContent(d.legendIconType);
            }

            var svgOffset = !BaseUtils.isSupportSVG() ? {} : {'dy': '0.32em'};

            g.text && g.text.remove(); // @Cmen
            g.text = null;

            g.text = g.append(renderer.vtext());
            g.text
                .style({
                    'cursor': this.options.isTrendLine ? 'default' : 'pointer',
                    'white-space':'nowrap'
                })
                .style({
                    fill:d.visible ? textStyle.color : d.hiddenColor
                });

            var y = 0;
            g.text.spans = this.labels.map(function (text) {
                g.text.append(
                    renderer.vtspan()
                        .attr('y', y)
                        .style('margin-top', '-0.7em') // only apply to div
                        .style(textStyle)
                        .attr(svgOffset)
                        .attr('x', iconSize.width + GAP_FUN())
                        .textContent(text)
                );

                y += (legend.textHeight * (1 + WORD_GAP));
            });
        },

        getEvents:function(){
            if (this.options.isTrendLine) {
                return {};
            }
            return {
                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut,

                'tap':this.onTap
            }
        },

        //for the onXXX functions, this points to the legendItem
        onMouseOver:function(){
            if(this.legend.options.hover){
                BaseUtils.getFormatterFunction(this.legend.options.hover)();
            } else {
                this.graphic && this.graphic.text && this.graphic.text.style({'fill': this.options.hoverColor});

                if (this.legend.options.highlight) {
                    this.legend.highlighted = true;
                    this.legend.vanchart.makeLegendHighlight(this.options.itemName);
                }
            }
           this.legend.fire('mouseover');
        },

        onMouseOut:function(ev){
            var item = this, legend = item.legend, d = item.options;
            var textColor = d.visible ? legend.options.style.color : d.hiddenColor;
            this.graphic && this.graphic.text && this.graphic.text.style({'fill': textColor});
            this.legend.fire('mouseout');
        },

        onTap:function(){
            if(this.legend.options.click){
                BaseUtils.getFormatterFunction(this.legend.options.click)();
                return;
            }

            var item = this, legend = item.legend;
            var name = this.options.bindName, vanchart = this.legend.vanchart, series = vanchart.series;
            var calculatedMap = {};

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                if(sery.isSeriesAccumulated()){
                    sery.points.map(function(point){
                        if(legend._itemBindName(point) == name){
                            point.visible = !point.visible;
                            item.state = point.visible ? Constants.STATE_TO_SHOW : Constants.STATE_TO_DROP;
                        }
                    });
                }else if (sery.name === name){
                    sery.visible = !sery.visible;
                    item.state = sery.visible ? Constants.STATE_TO_SHOW : Constants.STATE_TO_DROP;

                    sery._getAxisTypes().forEach(function(type){
                        var axis = sery[type];
                        // update value/date axis
                        if(axis && !axis._isBaseAxis() && !calculatedMap[BaseUtils.stamp(axis)]){
                            calculatedMap[BaseUtils.stamp(axis)] = true;
                            axis.calculateDomainFromData();
                            if (axis.componentType === ComponentLibrary.X_AXIS_COMPONENT ||
                                axis.componentType === ComponentLibrary.Y_AXIS_COMPONENT) {
                                axis.adjustDomain4Radius();
                            }else{
                                //radiusAxis
                                axis.fixScaleAndTickData();
                            }
                        }
                    })
                }
            }

            this.options.visible = !this.options.visible;

            if (this.options.pairLegendOpt) {
                this.options.pairLegendOpt.visible = this.options.visible;
                this.options.pairLegendOpt.renderItem.render();
                this.options.pairLegendOpt.renderItem.onMouseOut();
            }

            vanchart.reRenderWholePlot();

            item.state = item.state == Constants.STATE_TO_SHOW ? Constants.STATE_SHOW : item.state;
            item.state = item.state == Constants.STATE_TO_DROP ? Constants.STATE_DROPPED : item.state;
        },

        remove: function () {
            this.graphic && this.graphic.remove();
            this.graphic = null;
        }
    });


    return LegendItem;
});
/**
 * Created by eason on 15/5/4.
 * 
 */
define('component/Legend',['require','./Base','../utils/BaseUtils','../Constants','./LegendIconFactory','./LegendItem','../dom/Evented','../utils/BezierEasing','../ComponentLibrary','../chart/gantt/Scrollbar','../dom/DomUtils'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var LegendItem = require('./LegendItem');
    var Evented = require('../dom/Evented');
    var BezierEasing = require('../utils/BezierEasing');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scrollbar = require('../chart/gantt/Scrollbar');
    var DomUtils = require('../dom/DomUtils');


    var PADDING = 4;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };
    
    // Gap between legendItem-icon and legendItem-text
    var GAP = 8;
    var GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(GAP);
    };

    var BUTTON_HEIGHT = 12;

    // Gap between legendItem & next legendItem when legend with horizontal layout
    var HORIZONTAL_GAP = 12;
    var HORIZONTAL_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(HORIZONTAL_GAP);
    };

    // 0.2
    var WORD_GAP = 0.2;
    //vertical layout Gap between legendItem & next legendItem is 0.6
    var PARAGRAPH_GAP = 0.6;

    //icon + icon_text_gap + text
    var MIN_WIDTH = 96;
    var MIN_WIDTH_FUN = function () {
        return BaseUtils.paddingConvertWithScale(MIN_WIDTH);
    };

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var Legend = Base.extend({

        doLayout:function(){
            this.items = this.items || [];

            if(this.invisible()){
                this.remove();
                return ;
            }

            this.yPanEnabled = false;
            this.hasPages = false;

            this._updateLegendItems();
            this._layoutLegendItemBounds();
        },

        _updateLegendItems:function(){
            var series = this.vanchart.series, namedSeries = {}, namedTrendLine = {}, legend = this, vanchart = this.vanchart;
            var legendItemOptions = [], i, len;

            var opacityMap = {};

            // @Cmen-Chart-687
            // 
            // point
            // legendItempointsbindNamepointopacity
            for(i = -1; ++i < series.length;){
                var ser = series[i];
                if(ser.type === Constants.GAUGE_CHART){
                    continue; // no need
                }
                if(ser.isSeriesAccumulated()){
                    ser.points.forEach(function(point){
                        var bindName = legend._itemBindName(point);
                        if(!opacityMap[bindName]){
                            opacityMap[bindName] = {
                                opacity: point.opacity || 1,
                                useSerOpacity : true
                            }
                        } else {
                            if(opacityMap[bindName].opacity != point.opacity){
                                opacityMap[bindName].useSerOpacity = false;
                            }
                        }
                    })
                }
            }

            for(i = 0, len = series.length; i < len; i++){
                var sery = series[i], chartType = sery.type;

                if(chartType == Constants.GAUGE_CHART){
                    continue;
                }

                if(sery.isSeriesAccumulated()){

                    var key = 'name';

                    // BI-7057
                    var ovk = chartType === Constants.PIE_CHART ? 'x' : 'name';
                    var orderMap = {};
                    sery.options.data.forEach(function(datum, i){
                        orderMap[datum[ovk]] = i;
                    });

                    var tmp = sery.points.slice().sort(function (a, b) {
                        return orderMap[a[ovk]] - orderMap[b[ovk]]
                    });

                    tmp.map(function (point) {
                        var bindName = legend._itemBindName(point);
                        if(!(namedSeries[bindName])){
                            var item = {
                                color:vanchart.getDefaultSeriesColor(bindName),
                                opacity: opacityMap[bindName].useSerOpacity ? opacityMap[bindName].opacity : 1,
                                bindName: bindName,
                                itemName: bindName,
                                visible:point.visible
                            };
                            legend._mergeCommonLegendAttr(sery, item);
                            namedSeries[bindName] = true;
                            legendItemOptions.push(item);
                        }
                    });

                }else{
                    if(!(namedSeries[sery.name])) {
                        var item = {color: sery.color, opacity: sery.opacity, bindName: sery.name, itemName: sery.name, visible: sery.visible};

                        legend._mergeCommonLegendAttr(sery, item);

                        namedSeries[sery.name] = item;

                        legendItemOptions.push(item);
                    }
                    if (sery.options.trendLine && !(namedTrendLine[sery.name])) {
                        var item = {isTrendLine: true, color: sery.options.trendLine.color, opacity: sery.opacity, bindName: sery.name, itemName: sery.options.trendLine.name, visible: sery.visible};

                        legend._mergeCommonLegendAttr(sery, item);
                        item.legendIconType = undefined;
                        // log both legends
                        namedSeries[sery.name].pairLegendOpt = item;
                        item.pairLegendOpt = namedSeries[sery.name];

                        namedTrendLine[sery.name] = item;

                        legendItemOptions.push(item);
                    }
                }
            }

            for(i = legendItemOptions.length, len = this.items.length; i < len; i++){
                this.items[i].remove();
                this.items[i] = null;
            }

            for(i = 0, len = legendItemOptions.length; i < len; i++){
                if(this.items[i]){
                    this.items[i].refresh(legendItemOptions[i]);
                }else{
                    this.items[i] = new LegendItem(legend, legendItemOptions[i]);
                }
            }

            this.items.length = legendItemOptions.length;
        },

        _mergeCommonLegendAttr:function(sery, item){
            var cfg = this.options;
            var hiddenColor = cfg.hiddenColor;
            var hoverColor = cfg.hoverColor || cfg.style.color;

            BaseUtils.extend(item, {
                series:sery,
                hiddenColor:hiddenColor,
                hoverColor:hoverColor,
                legendIconType:this._getLegendType(sery),
                lineIndex:0//
            });
        },

        _layoutLegendItemBounds:function(){

            //padding
            var cfg = this.options, position = cfg.position || Constants.RIGHT;

            if (!this.items.length) {
                return
            }

            this.textHeight = BaseUtils.getTextHeight(cfg.style);//

            if(position == Constants.TOP || position == Constants.BOTTOM){

                this._layoutHorizontalLegendItemBounds(position);

            }else {
                //&&
                //:,this.vanchart.bounds.y
                var toolbarHeight = 0;
                if((position == Constants.RIGHT || position == Constants.RIGHT_TOP) && !this.isFloat){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    tools && tools.options.hidden != false && (toolbarHeight = 37 + PADDING_FUN() * 2);
                }

                this._layoutVerticalLegendItemBounds(position, toolbarHeight);
            }
        },

        _layoutVerticalLegendItemBounds:function(position, startY){

            var maxWidth = this._maxWidth(), style = this.options.style;

            var totalUsedWidth = 0, legendY = PADDING_FUN(), borderWidth = this.options.borderWidth || 0;

            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i], options = item.options;
                var iconDim = LegendIconFactory.getLegendIconSize(options.legendIconType);
                var textMaxWidth = maxWidth - GAP_FUN() - iconDim.width - 2 * PADDING_FUN();
                var textUsedWidth = this._getTextUsedWidth(options.itemName, style, textMaxWidth);
                totalUsedWidth = Math.max(textUsedWidth + GAP_FUN() + iconDim.width, totalUsedWidth);

                item.labels = BaseUtils.splitText(options.itemName, style, textMaxWidth, 0, false);
                item.legendX = PADDING_FUN() + borderWidth/2; item.legendY = legendY;

                legendY += (Math.max(this.textHeight * item.labels.length + this.textHeight * WORD_GAP * (item.labels.length - 1), iconDim.height) + PARAGRAPH_GAP * this.textHeight);
            }
            legendY -= PARAGRAPH_GAP * this.textHeight;//

            var legendSize = PADDING_FUN() * 2 + totalUsedWidth, needHeight = legendY + PADDING_FUN();

            var offeredHeight = this.vanchart.bounds.height - (this.isFloat ? 0 : PADDING_FUN() * 2);
            //37tools
            offeredHeight -= Math.max(0, startY - this.vanchart.bounds.y);

            //todo ,256, 255,,
            this.yPanEnabled = this.hasPages = (needHeight - PADDING_FUN()) > offeredHeight;

            if(this.hasPages){
                 this._calculatePagesTransMap(offeredHeight);

                legendSize = Math.max(legendSize, this._getPageButtonWidth(this.pageCount));

                this.maxYPan = this.translateMap[this.translateMap.length - 1];
            }

            // 
            var actualWidth = (legendSize > maxWidth ? maxWidth : legendSize) + (this.isFloat ? 0 : PADDING_FUN() * 2);

            this._setComponentBounds(position, actualWidth);

            var x = this.bounds.x + (this.isFloat ? 0 : PADDING_FUN());
            var y = this.bounds.y + (this.isFloat ? 0 : PADDING_FUN());
            var width = this.bounds.width - (this.isFloat ? 0 : PADDING_FUN() * 2);
            var height = this.bounds.height - (this.isFloat ? 0 : PADDING_FUN() * 2);
            //37tools
            height -= Math.max(0, startY - this.vanchart.bounds.y);

            var usedHeight = Math.min(needHeight, height);
            y = Math.max(startY, y);
            if(!this.isFloat && position == Constants.RIGHT_BOTTOM){
                //
                y = Math.round(this.bounds.y + this.bounds.height - usedHeight - PADDING_FUN());
            } else if (!this.isFloat && (position == Constants.RIGHT || position == Constants.LEFT)) {
                // 
                y += Math.round((height - usedHeight) / 2);
            }

            this.bounds = {x:x, y:y, width:width, height:usedHeight};
        },

        _calculatePagesTransMap:function (offeredHeight) {
            offeredHeight -= (BUTTON_HEIGHT + PADDING_FUN());//

            this.pageIndex = this.pageIndex || 0;

            this.translateMap = [0];//

            var lastStartY = 0;
            for(var itemIndex = 0, itemCount = this.items.length; itemIndex < itemCount; itemIndex++){
                var startY = this.items[itemIndex].legendY;
                if(startY - lastStartY > offeredHeight){
                    lastStartY = startY - PARAGRAPH_GAP * this.textHeight;
                    this.translateMap.push(-startY);
                }
            }

            this.pageCount = this.translateMap.length;
            return offeredHeight;
        },

        _getPageButtonWidth:function(pageCount){
            var style = {'fontFamily':this.options.style.fontFamily || 'Verdana', 'fontSize':'14px'};
            var text = pageCount + '/' + pageCount;
            var textDim = BaseUtils.getTextDimension(text, style, false);
            return BUTTON_HEIGHT * 2 + textDim.width;
        },

        _getTextUsedWidth:function (text, style, maxWidth) {
            var dim = BaseUtils.getTextDimension(text, style, false);
            if(maxWidth && maxWidth < dim.width) {
                return maxWidth;
            }
            return dim.width;
        },

        _layoutHorizontalLegendItemBounds:function(position){
            var plotBounds = this.vanchart.bounds, style = this.options.style;
            //84*n+12(n-1) = offeredWidthitemMaxWidth = icon + icon_text_gap + text + item_item_gap
            var offeredWidth = plotBounds.width - 4 * PADDING_FUN(),
                niceNum = Math.floor((offeredWidth + HORIZONTAL_GAP_FUN())/MIN_WIDTH_FUN());
                niceNum = Math.min(niceNum, this.items.length);

            var itemMaxWidth = Math.round((offeredWidth + HORIZONTAL_GAP_FUN())/niceNum);

            var legendY = PADDING_FUN();

            var currentLineMaxHeight = 0, hasWrap = false, multiLine = this.items.length > niceNum;
            for(var i = 0, len = this.items.length; i < len; i++) {
                var item = this.items[i], options = item.options;

                var iconSize = LegendIconFactory.getLegendIconSize(options.legendIconType);
                var textMaxWidth = itemMaxWidth - GAP_FUN() - iconSize.width - HORIZONTAL_GAP_FUN();
                item.labels = BaseUtils.splitText(options.itemName, style, textMaxWidth, 0, false);
                hasWrap = hasWrap || item.labels.length > 1;

                if (i % niceNum === 0) {//
                    legendY += currentLineMaxHeight;
                    currentLineMaxHeight = 0;
                }
                item.legendX = PADDING_FUN() + i % niceNum * itemMaxWidth;
                item.legendY = legendY;

                currentLineMaxHeight = Math.max(currentLineMaxHeight, (Math.max(this.textHeight * item.labels.length + this.textHeight * WORD_GAP * (item.labels.length - 1), iconSize.height) + PARAGRAPH_GAP * this.textHeight));
            }
            legendY += (currentLineMaxHeight - PARAGRAPH_GAP * this.textHeight);//

            var legendSize = Math.round(legendY) + PADDING_FUN();
            var maxHeight = this._maxHeight();

            this.yPanEnabled = maxHeight && (legendSize > maxHeight);
            this.maxYPan = -legendSize + maxHeight;//yPanEnabled = true

            // 
            var actualHeight = (this.yPanEnabled ? maxHeight : legendSize) +  PADDING_FUN() * 2;

            this._setComponentBounds(position, actualHeight);

            var x = this.bounds.x + PADDING_FUN();
            var y = this.bounds.y + PADDING_FUN();
            var height = this.bounds.height - PADDING_FUN() * 2 + (this.options.borderWidth || 0) * 2;
            var width = this.bounds.width - PADDING_FUN() * 2 + (this.options.borderWidth || 0) * 2;

            var usedWidth = offeredWidth + PADDING_FUN() * 2;
            if(!hasWrap && !multiLine) {
                // 
                usedWidth = this._horizontalCenterLayout(style);
                x += (width - usedWidth) / 2;
            }

            this.bounds = {x:x, y:y, width:usedWidth, height:height};
        },

        // 
        _horizontalCenterLayout:function (style) {
            var legendX = PADDING_FUN();
            for(var i = 0, len = this.items.length; i < len; i++) {
                var item = this.items[i], options = item.options;

                item.legendX = legendX;

                legendX += LegendIconFactory.getLegendIconSize(options.legendIconType).width;
                legendX += GAP_FUN();
                legendX += BaseUtils.getTextDimension(options.itemName, style, false).width;
                legendX += HORIZONTAL_GAP_FUN();
            }

           return legendX + PADDING_FUN()  - HORIZONTAL_GAP_FUN();
        },

        render:function(){

            if(this.invisible() || !this.items.length){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.legendGroup){
                this.legendGroup = this.createComponentGroup();
                this.backgroundGroup = renderer.group().addTo(this.legendGroup);
                this.clipGroup = renderer.group().addTo(this.legendGroup);
                this.legendItemsGroup = renderer.group().addTo(this.clipGroup);

                vanchart.registerInteractiveTarget(this, this.legendGroup);
            }

            this.legendGroup.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, BaseUtils.makeBounds(0,0,bounds.width, bounds.height));

            for(var i = 0, len = this.items.length; i < len; i++){
                this.items[i].render();
            }

            var clip = {x:0, y:0, width:bounds.width, height:bounds.height};
            if(this.hasPages){
                clip.height -= BUTTON_HEIGHT;
                this.pageButton = this.pageButton || new PageButton(legend);
                this.pageButton.refresh();
            }else if(this.pageButton){
                this.pageButton.remove();
                this.pageButton = null;
            }

            //clip
            if(!this.verticalClip){
                this.verticalClip = renderer.createClip(clip);
                renderer.clip(this.clipGroup, this.verticalClip);
            }else{
                renderer.updateClip(this.verticalClip, clip);
            }

            legend._buildScrollbar();

            // scrollToppageIndex
            if(vanchart._changeDataState){
                this.resetLegendScroll();
            }
        },

        _buildScrollbar: function () {
            var legend = this;
            legend.scrollbar && legend.scrollbar.remove();

            if(legend.yPanEnabled && legend.maxYPan) {
                legend.scrollbar = new Scrollbar({
                    scrollX: false,
                    scrollY: true,
                    view: legend,
                    group: legend.legendGroup,
                    width:legend.bounds.width,
                    height: legend.bounds.height,
                    innerHeight: legend.bounds.height - legend.maxYPan
                });
            }
        },

        getEvents:function(){
            return {
                'wheel':this.onWheel,
                'mouseout':this.mouseOut,
                'mouseover':this.mouseOver,

                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        mouseOut:function(){
            if(this.highlighted){
                this.vanchart.cancelLegendHighlight();
            }
        },

        mouseOver:function () {
        },

        onWheel: function (ev) {
            var e = ev.srcEvent;
            DomUtils.preventDefault(e);
            this.moveLegend(DomUtils.getWheelDelta(e));
        },

        onPanStart:function(ev){
            this.currentY = ev.containerPoint.y;
        },

        onPanMove:function(ev){

            var deltaY = ev.containerPoint.y - this.currentY;

            this.moveLegend(deltaY);

            this.currentY = ev.containerPoint.y;
        },

        onPanEnd:function(){
            this.vanchart.handler.panTarget = null;
        },

        moveLegend: function (deltaY) {
            var transY = 0;

            if(this.yPanEnabled){
                transY = deltaY + (this.legendItemsGroup.currentY || 0);
                transY = Math.max(this.maxYPan, Math.min(0, transY));
            }

            if(this.hasPages && this.pageButton){

                var pageIndex = this.translateMap.length - 1;
                for(var i = 0, len = this.translateMap.length - 1; i < len; i++){
                    var pre = this.translateMap[i], next = this.translateMap[i + 1];
                    if(pre >= transY && next < transY){
                        pageIndex = i;
                    }
                }

                if(this.pageIndex != pageIndex){
                    this.pageIndex = pageIndex;
                    this.pageButton.updatePage();
                }
            }

            this.legendItemsGroup.currentY = transY;
            this.legendItemsGroup.attr('transform', BaseUtils.makeTranslate([0,this.legendItemsGroup.currentY]));

            this.fire('innerChange', {x:0, y:transY});
        },

        /**
         * legendpageIndex
         */
        resetLegendScroll: function () {
            this.legendItemsGroup.currentY = 0;
            this.legendItemsGroup.attr('transform', 'translate(0,0)');

            if(this.hasPages && this.pageButton && this.pageIndex !== 0){
                this.pageIndex = 0;
                this.pageButton.updatePage();
            }
        },

        remove: function () {
            this.legendGroup && this.legendGroup.remove();
            this.verticalClip && this.verticalClip.remove && this.verticalClip.remove();
            this.legendGroup = this.verticalClip = null;
            this.items && (this.items.length = 0);
        },

        _itemBindName:function (point) {
            var sery = point.series;
            return sery.isSeriesAccumulated() ? point.name : sery.name;
        },

        reShowPoint:function (point) {
            var name = this._itemBindName(point);
            return this._stateName(name, Constants.STATE_TO_SHOW);
        },

        showSeries:function (series) {
            return this._stateName(series.name, Constants.STATE_SHOW);
        },

        toDropSeries:function (series) {
            return this._stateName(series.name, Constants.STATE_TO_DROP);
        },

        _stateName:function (name, state) {
            for(var i = 0, len = this.items.length; i < len;i++){
                var item = this.items[i];
                if(item.state == state && item.options.bindName == name){
                    return true;
                }
            }
            return false;
        }
    });

    var PageButton = Evented.extend({

        initialize:function(legend){
            this.legend = legend;
        },

        refresh:function(){
            var legend = this.legend, vanchart = legend.vanchart, renderer = vanchart.renderer, bounds = legend.bounds;
            var width = legend._getPageButtonWidth(legend.pageCount), height = bounds.height, y = height - BUTTON_HEIGHT;
            var startX = (bounds.width - width)/2;

            if(!this.pageGroup){
                this.pageGroup = renderer.group().addTo(legend.legendGroup);
                vanchart.registerInteractiveTarget(this, this.pageGroup);
                this.leftButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.rightButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.pageText = renderer.text().style({'fontFamily':legend.options.style.fontFamily || 'Verdana', 'fontSize':'14px'}).addTo(this.pageGroup);
            }

            var buttonWidth = width - BUTTON_HEIGHT;//
            var leftButtonTopX = startX + (width - buttonWidth) / 2;
            var rightButtonTopX = startX + (width + buttonWidth) / 2;
            var labelX = startX + width/2;

            this.pageGroup.attr('transform', BaseUtils.makeTranslate([0, y]));
            this.leftButton.attr('d', this._prePageButtonPath(leftButtonTopX));
            this.rightButton.attr('d', this._nextPageButtonPath(rightButtonTopX));
            this.pageText.attr({
                'x': labelX,
                'y': '-.14em',
                'dy': '.85em'
            }).attr("text-anchor", "middle");

            this.updatePage();
        },

        remove:function(){
            if(this.pageGroup){
                this.pageGroup.remove();
                this.pageGroup = null;
            }
        },

        updatePage:function(){
            
            var legend = this.legend, pageIndex = legend.pageIndex, pageCount = legend.pageCount;

            this.leftButton.style({'fill': pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR});

            this.rightButton.style({'fill':pageIndex < pageCount - 1 ? ENABLED_COLOR : DISABLED_COLOR});

            var text = pageIndex + 1 + '/' + pageCount;

            this.pageText.textContent(text);
            
            // for IE DIV text
            this.pageText.vMiddle();
        },

        _prePageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var leftBottomX = topX - edge / 2, leftBottomY = (edge / 2) * Math.sqrt(3);
            var rightBottomX = topX + edge / 2, rightBottomY = leftBottomY;
            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var topLeftX = topX - edge/2, topLeftY = topY;
            var topRightX = topX + edge/2, topRightY = topY;
            var bottomX = topX, bottomY = (edge / 2) * Math.sqrt(3);
            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        onTap:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement, legend = this.legend;

            if(this.leftButton.node() == src){
                if(legend.pageIndex <= 0){
                    return;
                }

                legend.pageIndex--;

            }else if(this.rightButton.node() == src){
                if(legend.pageIndex == legend.pageCount - 1){
                    return;
                }

                legend.pageIndex++;
            }

            var transY = legend.translateMap[legend.pageIndex];
            legend.legendItemsGroup.animate({
                duration:500,
                ease:BezierEasing.css.swing,
                attr:{'transform': 'translate(' + 0 + ',' + transY + ')'}
            });

            legend.legendItemsGroup.currentY = transY;
            legend.fire('innerChange', {x:0, y:transY});

            this.updatePage();
        },

        getEvents:function(){
            return {
                'tap':this.onTap
            }
        }

    });

    ComponentLibrary.register(ComponentLibrary.LEGEND_COMPONENT, Legend);
    return Legend;
});
/**
 * Created by eason on 15/10/12.
 */
define('component/Zoom',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/PathGenerator','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    //
    var HEIGHT = 30;
    var WIDTH = 10;

    // 
    var HEIGHT_MIN = 10,
        HEIGHT_MAX = 25;

    var DIRECTION_NONE = 'none';
    var DIRECTION_LEFT_TO_RIGHT = 'left-to-right';
    var DIRECTION_RIGHT_TO_LEFT = 'right-to-left';

    var PADDING = 4;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var Zoom = Base.extend({

        _refresh:function(){
            this.rangeLeftTop = this.rangeRightBottom = null;
        },

        doLayout:function(){

            this.byAxisType = this.vanchart.chartType() == Constants.BAR_CHART ? 'yAxis' : 'xAxis';
            this.byAxis = this.vanchart[this.byAxisType]();

            if(this.zoomToolEnabled()){
                var dataSheet = this.vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
                var plotBounds = this.vanchart.bounds, isHorizontal = this.byAxis.isHorizontal(), padding = PADDING_FUN(); 

                var validHeight = isHorizontal ? plotBounds.height : plotBounds.width; 
 
                var calcZoomHeight = (validHeight - 2 * padding) / 23.3; 
                HEIGHT = calcZoomHeight < HEIGHT_MIN ? HEIGHT_MIN : (calcZoomHeight > HEIGHT_MAX ? HEIGHT_MAX : parseInt(calcZoomHeight)); 
                WIDTH  = Math.ceil(HEIGHT / 3); 
 
                this._setComponentBounds(isHorizontal ? Constants.BOTTOM : Constants.LEFT, HEIGHT + padding * 2); 

                // 
                if(isHorizontal) { 
                    this.bounds.y += padding; 
                    this.bounds.height -= 2 * padding; 
                } else { 
                    this.bounds.x += padding; 
                    this.bounds.width -= 2 * padding; 
                } 
            }
        },

        fixBoundsByPlot:function(){

            if(!this.zoomToolEnabled()){
                return;
            }

            var positionAxis, axisCompo = this.vanchart.components[this.byAxisType];
            var axisCount = axisCompo.getAxisCount();
            for(var axisIndex = 0; axisIndex < axisCount; axisIndex++){
                var axis = axisCompo.getAxis(axisIndex), position = axis.getPosition();
                if(position== Constants.BOTTOM || position == Constants.LEFT){
                    positionAxis = axis;
                }
            }

            positionAxis = positionAxis || this.byAxis;

            var plotBounds = this.vanchart.bounds;

            if(positionAxis.isHorizontal()){
                this.bounds = BaseUtils.makeBounds(plotBounds.x, this.bounds.y, plotBounds.width, this.bounds.height); 
            }else{
                this.bounds = BaseUtils.makeBounds(this.bounds.x, plotBounds.y, this.bounds.width, plotBounds.height); 
            }
        },

        initToolDomain:function (axis) {
            var tool = this.options.zoomTool;

            tool.from = (BaseUtils.hasDefined(tool.from) && tool.from !== '') ? tool.from : null;
            tool.to = (BaseUtils.hasDefined(tool.to) && tool.to !== '') ? tool.to : null;
            if(axis.type === ComponentLibrary.DATE_AXIS_COMPONENT){
                tool.from = BaseUtils.date2int(BaseUtils.object2date(tool.from));
                tool.to = BaseUtils.date2int(BaseUtils.object2date(tool.to));
            }
            // fromto
            if(axis.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT && axis.isMultiCateAxis()){
                tool.from = BaseUtils.encodeCategoryArray(tool.from);
                tool.to = BaseUtils.encodeCategoryArray(tool.to);
            }
        },

        getZoomInitDomain: function (zoomAxis) {
            var axis = this.byAxis;
            if (this.zoomToolEnabled() && axis._isBaseAxis() && zoomAxis == axis) {
                var tool = this.options.zoomTool;

                this.initToolDomain(axis);

                return [tool.from, tool.to]
            }
        },

        getZoomDomain:function(zoomAxis){
            var axis = this.byAxis, dataDomain = zoomAxis.isCategory() ? axis._dataDomain : axis._domain;
            if(this.zoomToolEnabled() && axis._isBaseAxis() && zoomAxis == axis){
                var tool = this.options.zoomTool;

                this.initToolDomain(axis);

                var from = BaseUtils.pick(this.rangeLeftTop, tool.from, dataDomain[0]);

                var to = BaseUtils.pick(this.rangeRightBottom, tool.to, dataDomain[dataDomain.length - 1]);

                return this._getValidDomain(from, to, dataDomain, axis.isCategory());
            }
        },

        getMinAndMaxPos:function(){

            var domain = this.getZoomDomain(this.byAxis), scale = this.axisScale;

            if(!domain){//byAxis has no data
                return [0, this.vanchart.bounds.width];
            }

            var x1 = scale(domain[0]), x2 = scale(domain[domain.length - 1]);

            return [Math.min(x1, x2), (Math.max(x1, x2) + (scale.rangeBand ? scale.rangeBand() : 0))];
        },

        //
        updateRangeLeftAndRight:function(cateAxis, lastDomain, currentDomain){

            var leftIndex = BaseUtils.indexOf(lastDomain, this.rangeLeftTop);
            var rightIndex = BaseUtils.indexOf(lastDomain, this.rangeRightBottom);

            var domain = currentDomain.slice(Math.min(leftIndex, rightIndex), Math.max(leftIndex, rightIndex) + 1);

            if(cateAxis.isAxisReversed() ^ cateAxis.isHorizontal()){
                this.rangeLeftTop = domain[0];
                this.rangeRightBottom = domain[domain.length - 1];
            }else{
                this.rangeLeftTop = domain[domain.length - 1];
                this.rangeRightBottom = domain[0];
            }

        },

        _getValidDomain:function(from, to, dataDomain, isCategory){
            var tmp;
            if(isCategory){
                var maxIndex = dataDomain.length - 1;
                var minIndex = 0;
                from = BaseUtils.indexOf(dataDomain, from);
                to = BaseUtils.indexOf(dataDomain, to);

                from = Math.min(Math.max(from, minIndex), maxIndex);
                to = Math.min(Math.max(to, minIndex), maxIndex);

                if(from > to){
                    tmp = to;
                    to = from;
                    from = tmp;
                }

                return dataDomain.slice(from, to + 1);

            }else{
                from = parseFloat(from);
                to = parseFloat(to);

                if(from > to){
                    tmp = to;
                    to = from;
                    from = tmp;
                }

                return [from, to];
            }
        },

        zoomToolEnabled:function(){
            var opt = this.options;
            return this.vanchart.series.length && opt && opt.zoomTool && opt.zoomTool.enabled && BaseUtils.isSupportSVG();
        },

        _getAxisScale:function(){
            var axis = this.byAxis, scale = axis.scale.copy();
            if (axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                scale.rangeBand ? scale.rangeBands(axis._getPlotRange()) : scale.range(axis._getPlotRange());
            } else {
                var domain = axis._dataDomain, zoomDomain = this.getZoomDomain(axis);

                var min = Math.min(domain[0], zoomDomain[0]);
                var max = Math.max(domain[1], zoomDomain[1]);

                if(axis.type == ComponentLibrary.DATE_AXIS_COMPONENT){
                    min = BaseUtils.int2date(min);
                    max = BaseUtils.int2date(max);
                }

                scale.domain([min, max]);
            }

            return scale;
        },

        render:function(){

            this.remove();

            if(this.zoomBarGroup || !this.zoomToolEnabled()){
                return;
            }

            this.axisScale = this._getAxisScale();

            var zoomBar = this, bounds = zoomBar.bounds, vanchart = zoomBar.vanchart, renderer = vanchart.renderer;
            var pos = this.getMinAndMaxPos(), isVertical = this.byAxis.isVertical();
            var minPos = pos[0], maxPos = pos[1];
            if(!this.zoomBarGroup){
                this.zoomBarGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate(bounds))
                    .style('cursor', isVertical ? 'ns-resize ' : 'ew-resize');

                vanchart.registerInteractiveTarget(this, this.zoomBarGroup);
            }

            this._createLines();

            this.leftTopRect = this._createSideRect(isVertical, minPos, true);

            this.rightBottomRect = this._createSideRect(isVertical, maxPos, false);

            this.centerRect = this._createCenterRect(isVertical, minPos, maxPos);

            this.leftTopButton = this._createButton(isVertical, minPos, true);

            this.rightBottomButton = this._createButton(isVertical, maxPos, false);

            var l_transX = this.leftTopButton.pos, r_transX = this.rightBottomButton.pos;

            this.rangeLeftTop = this._getValueByPosition(l_transX);

            this.rangeRightBottom = this._getValueByPosition(r_transX + WIDTH);
        },

        //
        _createLines:function(){
            if(this.byAxis.series.length === 0){
                return;
            }
            var axisScale = this.axisScale, byAxisType = this.byAxisType, vanchart = this.vanchart, renderer = vanchart.renderer, series = vanchart.series;
            var det = axisScale.rangeBand ? axisScale.rangeBand()/2 : 0, catePoints = vanchart.cateMap;
            var linePoints = [], min = Number.MAX_VALUE,  max = -Number.MAX_VALUE;
            var isHorizontal = this.byAxis.isHorizontal(), isDate = this.byAxis.type === ComponentLibrary.DATE_AXIS_COMPONENT;

            for(var key in catePoints){
                var points = catePoints[key];

                if(points[0].series[byAxisType]){
                    var value = 0;

                    //todo 
                    points.forEach(function(point){
                        value += point.getTargetValue();
                    });
                }

                if(!points[0].isNull){
                    linePoints.push({
                        'x':axisScale(isDate ? BaseUtils.object2date(key) : key) + det,'y':value
                    });
                }

                min = Math.min(min, value);
                max = Math.max(max, value);
            }

            var yRange = isHorizontal ? [HEIGHT, 0] : [0, HEIGHT];

            var yScale = Scale.linear().domain([min, max]).range(yRange);

            var lineSvg = PathGenerator.line().interpolate("linear")
                .x(function (d) {
                    return isHorizontal ? d.x : yScale(d.y);
                })
                .y(function (d) {
                    return isHorizontal ? yScale(d.y) : d.x;
                });

            linePoints.sort(function(pA, pB){
                return pA.x - pB.x;
            });

            this._line = this._line || renderer.path().style({fill:'none', stroke:'black', 'stroke-width':1});
            this._line.attr('d', lineSvg(linePoints)).addTo(this.zoomBarGroup);

            //
            this._innerClip(this._line);
        },

        _createSideRect:function(isVertical, pos, isLeftTop){

            var renderer = this.vanchart.renderer;
            var x = 'x', y = 'y', width = 'width', height = 'height',size = this.bounds.width;
            if(isVertical){
                x = 'y'; y = 'x'; width = 'height'; height = 'width'; size = this.bounds.height;
            }

            var xPos, xWidth;
            if(isLeftTop){
                xPos = 0;
                xWidth = pos;
            }else{
                xPos = pos;
                xWidth = Math.abs(size - xPos);
            }

            return renderer.rect().attr(x, xPos).attr(y, 0)
                .attr(width, xWidth).attr(height, HEIGHT)
                .style({'fill':'rgba(220,221,221,0.4)'})
                .addTo(this.zoomBarGroup);
        },

        _createCenterRect:function(isVertical, startX, endX){
            var renderer = this.vanchart.renderer;

            var x = 'x', y = 'y', width = 'width', height = 'height';

            if(isVertical){
                x = 'y'; y = 'x'; width = 'height'; height = 'width';
            }

            return renderer.rect()
                .attr(x, startX + WIDTH).attr(y, 0)
                .attr(width, endX - startX - 2 * WIDTH).attr(height, HEIGHT)
                .style({
                    'fill':'rgba(255,255,255,0)',
                    'stroke':'#29ABE2',
                    'stroke-width':1
                }).addTo(this.zoomBarGroup);
        },

        /** 
         * : 
         * buttonPath 
         *  
         * @param  {Boolean} isVertical  
         * @param  {Number}  startPos    
         * @param  {Boolean} isLeftTop  LeftTop 
         * @return {Object}              
         */ 
        _createButton:function(isVertical, startPos, isLeftTop){

            startPos = isLeftTop ? startPos : startPos - WIDTH;
            var renderer = this.vanchart.renderer;
            var button = renderer.group().attr('transform', this._getButtonTranslate(isVertical, startPos));
            var lineStyle = {
                'fill': '#FFFFFF',
                'stroke': '#7ADAF4',
                'stroke-width': 2,
                'stroke-linecap': 'round',
                'stroke-linejoin': 'round',
                'stroke-miterlimit': 10
            };

            var buttonPath;
            if(isLeftTop){
                if(isVertical){
                    buttonPath = this.buttonPathGenerator(HEIGHT, WIDTH, WIDTH / 3, [0, 0, 1, 1]);
                }else{
                    buttonPath = this.buttonPathGenerator(WIDTH, HEIGHT, WIDTH / 3, [0, 1, 1, 0]);
                }
            }else{
                if(isVertical){
                    buttonPath = this.buttonPathGenerator(HEIGHT, WIDTH,  WIDTH / 3, [1, 1, 0, 0]); 
                }else{
                    buttonPath = this.buttonPathGenerator(WIDTH, HEIGHT, WIDTH / 3, [1, 0, 0, 1]);
                }
            }

            renderer.path().attr('d', buttonPath).style({'fill':'#29ABE2'}).addTo(button);

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', startY = Math.ceil(HEIGHT / 4), endY = HEIGHT - startY; 
            if(isVertical){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }
            
            var lineWidth = lineStyle['stroke-width'] = Math.floor(WIDTH / 5) || 1; 
            var needSecondLine = WIDTH >= 5; 
            
            var startX1 = needSecondLine ? (WIDTH - lineWidth * 2) / 3 : (WIDTH - lineWidth) / 2; 
            var startX2 = needSecondLine ? (WIDTH - lineWidth * 2) / 3 * 2 + lineWidth : 0;

            renderer.line().attr(x1, startX1).attr(y1, startY).attr(x2, startX1).attr(y2, endY) 
                .style(lineStyle).addTo(button); 
            if(needSecondLine){ 
                renderer.line().attr(x1, startX2).attr(y1, startY).attr(x2, startX2).attr(y2, endY) 
                    .style(lineStyle).addTo(button); 
            } 

            button.pos = startPos;

            button.addTo(this.zoomBarGroup);

            return button;
        },

        /** 
         * :svg 
         * @param  {Number} width  [] 
         * @param  {Number} height [] 
         * @param  {Number} r      [] 
         * @param  {Array} arr     [,1,0] 
         * @return {String}        [svg path string] 
         */ 
        buttonPathGenerator : function (width, height, r, arr){ 
            var endPoints = [[0, 0], [width, 0], [width, height], [0, height]], 
                curvePoints = [ 
                    [0, r], [r, 0], 
                    [width - r, 0], [width, r], 
                    [width, height - r],  [width - r, height], 
                    [r, height], [0, height - r], 
                    [0,r] 
                ]; 
 
            var path = 'M' + point(curvePoints[0]) + move(0) + move(1) + move(2) + move(3) + 'z'; 
 
            return path; 
 
            function point(arr){ 
                return arr.join(','); 
            } 
 
            function move(index){ 
                var p1 = endPoints[index], p2 = curvePoints[index * 2 + 1]; 
                var str = ''; 
                if(arr[index]){ 
                    str =  'L' + point(p1) + 'L' + point(p2); 
                } else { 
                    str = 'Q' + point(p1) + ',' + point(p2); 
                } 
                return str + 'L' + point(curvePoints[index * 2 + 2]) 
            } 
        }, 

        _findDraggingTarget:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement;

            var pos = this.byAxis.isHorizontal() ? (ev.containerPoint.x - this.bounds.x) : (ev.containerPoint.y - this.bounds.y), resizeable = this._resizeable();

            var target;
            while (src) {

                //by position
                var leftTopDet = this.leftTopButton.pos - pos;
                var rightBottomDet = pos - (this.rightBottomButton.pos + WIDTH);

                if(leftTopDet > 0 && leftTopDet < 10 && resizeable){
                    target = this.leftTopButton;
                }

                if(rightBottomDet > 0 && rightBottomDet < 10 && resizeable){
                    target = this.rightBottomButton;
                }

                if(target){
                    break;
                }

                //by dom
                if(src == this.leftTopButton.node() && resizeable){
                    target = this.leftTopButton;
                }else if(src == this.rightBottomButton.node() && resizeable){
                    target = this.rightBottomButton;
                }else if(src == this.centerRect.node() || src == this.zoomBarGroup.node()){
                    target = this.centerRect;
                }

                if (target){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        _panStart:function(ev, target){

            this.target = target || this._findDraggingTarget(ev);

            if(this.target){
                this.downPos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;
                this.initPos = this.target.pos;
                this.initTranslate = 0;
                this.vanchart._zooming = true;
            }

        },

        _panContainerMove:function(ev){

            if(this.target){

                var pos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;

                var direction = pos < this.downPos ? DIRECTION_LEFT_TO_RIGHT : DIRECTION_RIGHT_TO_LEFT;

                this._centerRectMove(this.downPos, this.downPos + this.downPos - pos);

                this._zoomRefresh(direction);
            }

        },

        _panMove:function(ev){

            var direction = DIRECTION_NONE, pos = this.byAxis.isHorizontal() ? ev.containerPoint.x : ev.containerPoint.y;//

            if(!this.target || this.downPos == pos){
                return;
            }


            switch (this.target){

                case this.leftTopButton:
                    this._leftButtonMove(this.downPos, this.initPos, pos);
                    break;

                case this.rightBottomButton:
                    this._rightButtonMove(this.downPos, this.initPos, pos);
                    break;

                case this.centerRect:
                    direction = this._centerRectMove(this.downPos, pos);
                    break;
            }

            this._zoomRefresh(direction);
        },

        _leftButtonMove:function(downPos, initPos, currentPos){
            var minTransPos = 0, maxTransPos = this.rightBottomButton.pos - WIDTH;
            var trans = initPos + currentPos - downPos;
            var isVertical = this.byAxis.isVertical();
            trans = Math.max(Math.min(trans, maxTransPos), minTransPos);
            this.leftTopButton.pos = trans;

            var width = 'width', x = 'x';
            if(isVertical){
                width = 'height'; x = 'y';
            }

            this.leftTopButton.attr('transform', this._getButtonTranslate(isVertical, trans));
            this.leftTopRect.attr(width, trans);
            this.centerRect.attr(x, trans + WIDTH).attr(width, maxTransPos - trans);
        },

        _rightButtonMove:function(downPos, initPos, currentPos){
            var size = this.bounds.width, x = 'x', width = 'width';
            var isVertical = this.byAxis.isVertical();
            if(isVertical){
                size = this.bounds.height; x = 'y'; width = 'height';
            }

            var maxTransPos = size - WIDTH, minTransPos = this.leftTopButton.pos + WIDTH;

            var trans = initPos + currentPos - downPos;

            trans = Math.max(Math.min(trans, maxTransPos), minTransPos);

            this.rightBottomButton.pos = trans;
            this.rightBottomButton.attr('transform', this._getButtonTranslate(isVertical, trans));

            this.rightBottomRect.attr(x, trans + WIDTH).attr(width, size - (trans + WIDTH));
            this.centerRect.attr(width, trans - minTransPos);
        },

        _centerRectMove:function(downPos, currentPos){

            var endPos = this.bounds.width, det = currentPos - downPos - this.initTranslate;
            var x = 'x', width = 'width';
            var isVertical = this.byAxis.isVertical();
            if(isVertical){
                endPos = this.bounds.height; x = 'y'; width = 'height';
            }

            this.initTranslate = currentPos - downPos;

            if(this.leftTopButton.pos + det >=0 && this.rightBottomButton.pos + WIDTH + det <= endPos){

                var l_trans = this.leftTopButton.pos + det;
                this.leftTopButton.pos = l_trans;
                this.leftTopButton.attr('transform', this._getButtonTranslate(isVertical, l_trans));
                this.leftTopRect.attr(width, l_trans);

                var r_trans = this.rightBottomButton.pos + det;
                this.rightBottomButton.pos = r_trans;
                this.rightBottomButton.attr('transform', this._getButtonTranslate(isVertical, r_trans));
                this.rightBottomRect.attr(x, r_trans + WIDTH).attr(width, endPos - (r_trans + WIDTH));

                this.centerRect.attr(x, l_trans + WIDTH);
            }

            return this.initTranslate > 0 ? DIRECTION_LEFT_TO_RIGHT : DIRECTION_RIGHT_TO_LEFT;
        },

        _getValueByPosition:function(x){
            var axis = this.byAxis, scale = this.axisScale;
            switch (axis.type) {
                case ComponentLibrary.CATEGORY_AXIS_COMPONENT:
                    var domain = scale.domain(), range = scale.range();
                    for(var i = 0, len = range.length - 1; i < len; i++){
                        if(x >= range[i] && x < range[i + 1]){
                            return domain[i];
                        }else if(x < range[i] && x >= range[i + 1]){
                            return domain[i + 1];
                        }
                    }
                    return range[0] > range[range.length - 1] ? domain[0] : domain[domain.length - 1];
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    return BaseUtils.date2int(this.axisScale.invert(x));
                default:
                    return this.axisScale.invert(x);
            }
        },

        _getButtonTranslate:function(isVertical, pos){
            var translate = isVertical ? [0, pos] :[pos, 0];

            return 'translate(' + translate +')';
        },

        _zoomRefresh:function(direction){

            var l_trans = this.leftTopButton.pos, r_trans = this.rightBottomButton.pos + WIDTH;

            var rangeLeftTop = this._getValueByPosition(l_trans);
            var rangeRightBottom = this._getValueByPosition(r_trans);

            var vanchart = this.vanchart, axis = this.byAxis, dataDomain = axis._dataDomain, indexOfCate = BaseUtils.indexOf;
            var dataSheet = vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);

            var domain;
            if(axis.isCategory()){

                if(direction == DIRECTION_NONE){

                    domain = this._getValidDomain(rangeLeftTop, rangeRightBottom, dataDomain, true);

                }else{

                    var cateCount = indexOfCate(dataDomain, this.rangeLeftTop) - indexOfCate(dataDomain, this.rangeRightBottom);
                    cateCount = Math.abs(cateCount) + 1;//

                    if(direction == DIRECTION_LEFT_TO_RIGHT && rangeRightBottom != this.rangeRightBottom){

                        if(axis.isAxisReversed() ^ axis.isHorizontal()){
                            var endIndex = indexOfCate(dataDomain, rangeRightBottom);
                            var startIndex = endIndex - cateCount + 1;

                            rangeLeftTop = dataDomain[startIndex];
                            rangeRightBottom = dataDomain[endIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }else{
                            var startIndex = indexOfCate(dataDomain, rangeRightBottom);
                            var endIndex = startIndex + cateCount - 1;

                            rangeLeftTop = dataDomain[endIndex];
                            rangeRightBottom = dataDomain[startIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }

                    }else if(direction == DIRECTION_RIGHT_TO_LEFT && rangeLeftTop != this.rangeLeftTop){

                        if(axis.isAxisReversed() ^ axis.isHorizontal()){

                            var startIndex = indexOfCate(dataDomain, rangeLeftTop);

                            var endIndex = startIndex + cateCount - 1;

                            rangeLeftTop = dataDomain[startIndex];
                            rangeRightBottom = dataDomain[endIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }else{
                            var endIndex = indexOfCate(dataDomain, rangeLeftTop);
                            var startIndex = endIndex - cateCount + 1;

                            rangeLeftTop = dataDomain[endIndex];
                            rangeRightBottom = dataDomain[startIndex];

                            domain = dataDomain.slice(startIndex, endIndex + 1);
                        }

                    }else{

                        //
                        rangeLeftTop = this.rangeLeftTop;
                        rangeRightBottom = this.rangeRightBottom;
                    }
                }

                //
                if(this.rangeLeftTop != rangeLeftTop || this.rangeRightBottom != rangeRightBottom){

                    this.rangeLeftTop =  rangeLeftTop;
                    this.rangeRightBottom = rangeRightBottom;

                    axis.zoomRefresh(domain);
                    axis.fixScaleAndTickData();
                    axis.render();

                    if(dataSheet){
                        dataSheet.zoomRefresh();
                    }

                    vanchart.reRenderSeries();
                }

            }else{

                domain = this._getValidDomain(rangeLeftTop, rangeRightBottom, dataDomain, false);

                this.rangeLeftTop = rangeLeftTop;

                this.rangeRightBottom = rangeRightBottom;

                axis.zoomRefresh(domain);
                axis.fixScaleAndTickData();
                axis.render();
                vanchart.reRenderSeries();
            }
        },

        _panEnd:function(){
            this.target = null;
            this.vanchart._zooming = false;
        },

        _resizeable:function(){
            return this.options && this.options.zoomTool && this.options.zoomTool.resize;
        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove": BaseUtils.throttle(this._panMove, 16, this),  //60
                "panend":this._panEnd
            }
        },

        remove: function () {
            this.zoomBarGroup && this.zoomBarGroup.remove();
            this.zoomBarGroup = null;
        }
    });
    
    require('../ComponentLibrary').register(ComponentLibrary.ZOOM_COMPONENT, Zoom);
    return Zoom;

});
/**
 * Created by eason on 15/8/24.
 */

define('component/ToolbarIcon',['require','./Base','../utils/BaseUtils','../Constants','../dom/Evented'],function(require){

    //icon
    function OPEN_NORMAL(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    function OPEN_HOVER() {
        return {'fill':'black', 'fill-opacity':0.1};
    }

    function CLOSED_NORMAL(){
        return {'fill':'black', 'fill-opacity':0};
    }

    function CLOSED_HOVER(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    var RECT_R = 2;
    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var GAP = ICON_SIZE + ICON_GAP;

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Evented = require('../dom/Evented');

    var ToolbarIcon = Evented.extend({

        initialize:function(iconType, toolbar, pos, visible){
            this.iconType = iconType; this.toolbar = toolbar;
            this.visible = visible; this.pos = pos; this.currentPos = {x:pos.x, y:pos.y};
        },

        render:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            if(!this.iconG){
                this.iconG = renderer.group().style({'cursor':'pointer'}).addTo(toolbar.toolbarGroup);
            }

            vanchart.registerInteractiveTarget(this, this.iconG);

            this.iconG.attr('transform', 'translate('+ icon.pos.x +','+ icon.pos.y +')').style({'display':this.visible ? '' : 'none'});

            this.iconG.rect = this.iconG.rect || renderer.rect().attr('width', ICON_SIZE).attr('height', ICON_SIZE)
                .attr('rx', RECT_R).attr('ry', RECT_R)
                .addTo(this.iconG);

            this.iconG.rect.style(toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());

            this.iconG.path = this.iconG.path || this._getIconPathGraphic(vanchart, renderer, icon);
        },

        _getIconPathGraphic: function (vanchart, renderer, icon) {
            switch (this.iconType){
                case Constants.REFRESH_ICON:
                    return renderer.path().attr('d', icon.getRefreshIconPath()).style({'fill':'#FF9933'}).addTo(this.iconG);
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        return renderer.path().attr('d', icon.getDecreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getIncreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }
                case Constants.EXPORT_ICON:
                    return renderer.path().attr('d', icon.getExportIconPath()).style({'fill':'#6666CC'}).addTo(this.iconG);
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.fullScreenFather){
                        return renderer.path().attr('d', icon.getMinIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getMaxIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }
                case Constants.MENU_ICON:
                    return renderer.path().attr('d', icon.getMenuIconPath()).style({'stroke-width':2, 'stroke':'#AAAAAA'}).addTo(this.iconG);
            }
        },

        refreshMove:function(left, right){

            var pos = this.pos, currentPos = this.currentPos;
            var leftPos = currentPos.x - left, rightPos = leftPos + right;

            this.iconG.animate({
                ease:'circle-out',
                duration:220,
                attr:{transform:'translate('+ leftPos +','+ pos.y +')'}
            }).transition({
                ease:'circle-in',
                duration:220,
                attr:{transform:'translate('+ rightPos +','+ pos.y +')'}
            });

            this.currentPos.x = rightPos;
        },

        refreshMoveWithoutAnimation:function(left, right){

            var rightPos = this.currentPos.x - left + right;

            this.iconG.attr('transform', 'translate('+ rightPos +','+ this.pos.y +')');

            this.currentPos.x = rightPos;
        },

        showIcon:function(){

            this.visible = true;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':''});
            }

        },

        hideIcon:function(){

            this.visible = false;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':'none'});
                //
                this.iconG.attr('transform', 'translate('+ this.pos.x +','+ this.pos.y +')');
                this.currentPos.x = this.pos.x;
            }
        },

        _iconAnimation:function(moveIndex, delay){

            var iconG = this.iconG, pos = this.pos, visible = this.visible;

            if(BaseUtils.isSupportSVG()){
                setTimeout(function(){
                    iconG.style({'display':visible ? '' : 'none'});

                    var moveDet = 4 * moveIndex, leftX = pos.x - moveDet;

                    iconG.animate([{
                        ease:'circle-out',
                        duration:100,
                        attr:{'transform':'translate('+ leftX +','+ pos.y +')'}
                    },{
                        ease:'circle-in',
                        duration:100,
                        attr:{'transform':'translate('+ pos.x +','+ pos.y +')'}
                    }]);

                    iconG.rect.style(visible ? CLOSED_NORMAL() : OPEN_NORMAL()).animate({
                        ease:'linear', duration:200, style:visible ? OPEN_NORMAL() : CLOSED_NORMAL()
                    });

                }, delay);

            }else{
                iconG.attr('transform', 'translate('+ pos.x +','+ pos.y +')').style({'display':visible ? '' : 'none'});

                iconG.rect.style(visible ? OPEN_NORMAL() : CLOSED_NORMAL())
            }
            this.currentPos.x = this.pos.x;
        },

        onMouseOver:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_HOVER() : OPEN_HOVER());

            var toolbar = this.toolbar, options = toolbar.options, vanchart = toolbar.vanchart;
            var tipMsg = '', icon = this;

            if(toolbar.needTooltip()){
                var content = options.tooltip.content;
                switch (icon.iconType) {
                    case Constants.REFRESH_ICON :
                        tipMsg = content['refresh'];
                        break;
                    case Constants.SORT :
                        tipMsg = content['sort'];
                        break;
                    case Constants.EXPORT_ICON:
                        tipMsg = content['toImage'];
                        break;
                    case Constants.FULL_SCREEN_ICON:
                        tipMsg = vanchart.vancharts.fullScreenFather ? content['fullScreenClose'] : content['fullScreenOpen'];
                        break;
                    case Constants.MENU_ICON:
                        tipMsg = toolbar.hidden ? content['menuOpen'] : content['menuClose'];
                        break;
                }
                // 
                tipMsg && vanchart.showToolbarTooltip(icon, tipMsg);
            }
        },

        onMouseOut:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());
            this.toolbar.vanchart.hideTooltip();  // toolbarmouseout
        },

        onTap:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            var dom = vanchart.getDivParentDom();
            vanchart.hideTooltip();  
            switch (icon.iconType){
                case Constants.REFRESH_ICON:
                    vanchart.clearAllEffects();
                    vanchart.refreshRestore();
                    icon.hideIcon();
                    break;
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        vanchart.orderType = Constants.DESCENDING;
                        icon.iconG.path.attr({'d':icon.getIncreaseIconPath()});
                    }else{
                        vanchart.orderType = Constants.ASCENDING;
                        icon.iconG.path.attr({'d':icon.getDecreaseIconPath()});
                    }
                    toolbar.refreshEnabled() && toolbar.refreshIcon.showIcon();
                    vanchart.orderData();
                    // vanchart.orderType = Constants.DISORDER;  todo 
                    break;
                case Constants.EXPORT_ICON:
                    var exportIcon = this.toolbar.options.toImage;
                    exportIcon &&
                    exportIcon.imageUrl &&
                    BaseUtils.toPng(exportIcon.imageUrl);
                    break;
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.fullScreenFather){
                        vanchart.vancharts.hideLightBox(dom, vanchart.vancharts.fullScreenFather);
                    }else{
                        vanchart.vancharts.showLightBox(vanchart)
                    }
                    break;
                case Constants.MENU_ICON:
                    toolbar.showOrHide();
                    break;
            }
        },

        getEvents:function(){
            return {
                mouseover:this.onMouseOver,
                mouseout:this.onMouseOut,
                tap:this.onTap
            }
        },

        getMaxIconPath:function(){
            return 'M24,8v6.5L21.5,12l-3,3L17,13.5l3-3L17.5,8H24z M15,18.5l-3,3l2.5,2.5H8v-6.5l2.5,2.5l3-3L15,18.5z';
        },

        getMinIconPath:function(){
            return 'M15,17v6.5L12.5,21l-3,3L8,22.5l3-3L8.5,17H15z M24,9.5l-3,3l2.5,2.5H17V8.5l2.5,2.5l3-3L24,9.5z';
        },

        getIncreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,16h2v3h-2V16z M13,14h2v5h-2V14z M16,12h2v7h-2V12z M19,9h2v10h-2V9z';
        },

        getDecreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,9h2v10h-2V9z M13,12h2v7h-2V12z M16,15h2v4h-2V15z M19,16h2v3h-2V16z';
        },

        getExportIconPath:function(){
            return 'M22,8H8v16h16V10L22,8z M16,10h2v4h-2V10z M22,22H10V10h1v5h9v-5h1.171L22,10.829V22z';
        },

        getRefreshIconPath:function(){
            return 'M21.656,10.344C20.209,8.896,18.209,8,16,8c-3.43,0-6.354,2.158-7.492,5.19l1.873,0.703C11.234,11.619,13.428,10,16,10c1.657,0,3.156,0.672,4.243,1.757L18,14h6V8L21.656,10.344z M16,22c-1.657,0-3.156-0.671-4.243-1.757L14,18H8v6l2.344-2.344C11.791,23.104,13.791,24,16,24c3.43,0,6.354-2.158,7.492-5.19l-1.873-0.703C20.766,20.381,18.572,22,16,22z';
        },

        getMenuIconPath:function(){
            return 'M8,10L24,10 M8,15L24,15 M8,20L24,20';
        }

    });

    return ToolbarIcon;
});
/**
 * Created by eason on 15/7/27.
 * 
 */
define('component/ToolBar',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../Constants','./ToolbarIcon','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var ToolbarIcon = require('./ToolbarIcon');
    var ComponentLibrary = require('../ComponentLibrary');

    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var DEFAULT_GAP = 5;

    var NONSUPPORT_SORT = [Constants.GANTT_CHART, Constants.TREEMAP_CHART
        , Constants.WORD_CLOUD_CHART, Constants.FUNNEL_CHART, Constants.STRUCTURE_CHART
        , Constants.SCATTER_CHART, Constants.BUBBLE_CHART, Constants.FORCE_BUBBLE_CHART
        , Constants.AREA_MAP, Constants.POINT_MAP, Constants.LINE_MAP, Constants.HEAT_MAP
    ];

    var Toolbar = Base.extend({

        doLayout:function(){
            var options = this.options, hidden = options.hidden;

            // toolbar-tooltip-option
            options.tooltip = options.tooltip || {};
            QueryUtils.merge(options.tooltip, this.getDefaultToolbarTooltipOption());

            var keys = this.sortEnable() ? ['sort', 'toImage', 'fullScreen'] : ['toImage', 'fullScreen'];
            var icons = [Constants.REFRESH_ICON];
            keys.forEach(function(key){
                if(options[key] && options[key].enabled){
                    icons.push(key);
                }
            });

            hidden && icons.push(Constants.MENU_ICON);

            var GAP = ICON_SIZE + ICON_GAP;
            var size = icons.length * GAP + DEFAULT_GAP;

            //resizetranslate
            this.startX = this.vanchart.width - size;

            if(this.toolbarGroup){
                return;
            }

            this.toolbarIcons = []; this.hidden = hidden;

            for(var iconIndex = 0, len = icons.length; iconIndex < len; iconIndex++){
                var pos = {x:iconIndex * GAP, y:DEFAULT_GAP};
                var type = icons[iconIndex];
                var visible = !hidden;
                if(type == Constants.MENU_ICON){
                    this.menuIcon = new ToolbarIcon(type, this, pos, true);
                }else if(type == Constants.REFRESH_ICON){
                    this.refreshIcon = new ToolbarIcon(type, this, pos, false);
                }else{
                    this.toolbarIcons.push(new ToolbarIcon(type, this, pos, visible));
                }
            }

            this.isFloat = true;
        },

        sortEnable: function () {
            var sort = true;
            var options = this.vanchart.options, seriesData = options.series;
            var chartType;

            if(options.chartType){
                chartType = options.chartType;
            }

            seriesData && seriesData.forEach(function (sery) {
                if(sery.type) {
                    if (chartType && chartType != sery.type) {
                        sort = false;//
                        return;
                    }
                    chartType = sery.type;
                }
            });

            return sort && NONSUPPORT_SORT.indexOf(chartType) == -1;
        },

        render:function(){
            var renderer = this.vanchart.renderer;

            if(this.toolbarGroup){
                this.toolbarGroup.attr('transform', BaseUtils.makeTranslate([this.startX, 0]));
                return;//
            }else{
                this.toolbarGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate([this.startX, 0]));
            }
            this.toolbarIcons.forEach(function(icon){
                icon.render();
            });

            this.menuIcon && this.menuIcon.render();
            this.refreshIcon && this.refreshIcon.render();
        },

        showOrHide:function(){
            this.hidden ? this.show() : this.hide();
            this.hidden = !this.hidden;
        },

        hide:function(){

            var toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length, delay = [];

            for(var i = 0; i < iconSize; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].hideIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }

        },

        show:function(){
            var delay = [0], toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize - 1; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].showIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);
            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }
        },

        showRefreshIconWhenZoom:function(){
            if(!this.refreshIcon.visible && this.refreshEnabled()){
                if(this.menuIcon){
                    if(this.hidden){
                        var iconSize = this.toolbarIcons.length;
                        var left = 4 * (iconSize + 1) ;
                        var right = 4 * (iconSize + 1) + 33 * iconSize;
                        this.refreshIcon.refreshMoveWithoutAnimation(left, right);
                        this.refreshIcon.showIcon();
                    }else{
                        this.refreshIcon.showIcon();
                    }
                }else{
                    this.refreshIcon.showIcon();
                }
            }
        },

        refreshEnabled:function(){
            return !(this.options.refresh && this.options.refresh.enabled === false);
        },

        getToolBarInitWidth: function () {
            if (!this.options.enabled) {
                return 0;
            }
            if (this.options.hidden) {
                return ICON_SIZE + DEFAULT_GAP;
            } else {
                return this.toolbarIcons.length * (ICON_SIZE + ICON_GAP) - ICON_GAP + DEFAULT_GAP;
            }
        },

        remove:function(){
            this.toolbarGroup && this.toolbarGroup.remove();
            this.toolbarGroup = null;
        },

        /**
         * toolbar-tooltip-optionoptions
         * @return {Object} [description]
         */
        getDefaultToolbarTooltipOption:function () {
            // 
            return {
                "enabled": true,
                "content":{
                    "menuOpen": "",
                    "menuClose": "",
                    "sort": "",
                    "toImage": "",
                    "refresh": "",
                    "fullScreenOpen": "",
                    "fullScreenClose": ""
                },
                "style":{
                    "fontSize": "12pt",
                    "fontFamily": "Microsoft Yahei",
                    "color": "rgb(255,255,255)"
                },
                "borderRadius": 2,
                "borderWidth" : 0,
                "backgroundColor": "rgba(0,0,0,.3)",
                "padding": 5,
                "animation": true
            }
        },

        /**
         * toolbar
         * @return {Object} 
         */
        getToolbarBounds: function () {
            var boundsWidth = this.menuIcon ? ICON_SIZE : 0,
                totalWidth = boundsWidth,
                otherIcons = [this.refreshIcon].concat(this.toolbarIcons);
            otherIcons.forEach(function(icon){
               if(icon.visible){
                   boundsWidth += ICON_SIZE + ICON_GAP;
               }
               totalWidth += ICON_SIZE + ICON_GAP;
            });


            var boundsX = this.startX + totalWidth - boundsWidth;
            return {
                x : boundsX,
                y : DEFAULT_GAP,
                width : boundsWidth,
                height : ICON_SIZE
            }
        },
        /**
         * icontopleft
         * @param  {Object} icon   Icon
         * @param  {Object} divDim 
         * @return {Array}         lefttop
         */
        calcToolbarTipPos: function (icon, divDim) {
            var toolbarBounds = this.getToolbarBounds();
            var boundsEndX = toolbarBounds.x + toolbarBounds.width;
            var iconStartX = icon.currentPos.x + this.startX;

            var startY = toolbarBounds.y + toolbarBounds.height + ICON_GAP * 2;
            var startX = iconStartX + divDim.width > boundsEndX ? (iconStartX + ICON_SIZE - divDim.width)  : iconStartX;
            
            return [startX, startY];
        },

        needTooltip: function(){
            var options = this.options;
            return options && options.tooltip && options.tooltip.enabled;
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.TOOLBAR_COMPONENT, Toolbar);
    return Toolbar;
});
/**
 * Created by Mitisky on 16/3/21.
 */
define ('component/RangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var RangeLegend = Base.extend({

        doLayout: function () {

            if(this.invisible()){
                this.remove();
                return ;
            }

            var cfg = this.options;
            var position = cfg.position || Constants.RIGHT;
            var gap = PADDING_FUN() * (this.isFloat ? 2 : 4);//*4: *

            if(position == Constants.TOP || position == Constants.BOTTOM){
                this._layoutHorizontal(position, gap);
            } else {
                this._layoutVertical(position, gap);
            }

            if(!this.isFloat) {
                var outGap = this.options.borderWidth + PADDING_FUN() * 2;
                this.bounds.x += outGap/2;
                this.bounds.y += outGap/2;
                this.bounds.width -= outGap;
                this.bounds.height -= outGap;

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled() && zoomComponent.bounds) {
                        this.bounds.y += zoomComponent.bounds.height || 0;
                    }
                }

                if(position == Constants.RIGHT_TOP){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    if(tools){
                        this.bounds.y = Math.max(37, this.bounds.y);
                    }
                }
            }
        },

        _layoutHorizontal: function (position, gap) {
            var dim = this.calculateHorizontalDim();

            var usedSize = dim.height + gap;

            usedSize = this.options.maxHeight ? Math.min(usedSize, this._maxHeight()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var width = dim.width + gap;
            if (!this.isFloat) {
                this.bounds.x += Math.max((this.bounds.width - width)/2, 0);
            }
            this.bounds.width = width;
        },

        _layoutVertical: function (position, gap) {
            var dim = this.calculateVerticalDim();

            var usedSize = dim.width + gap;

            usedSize = this.options.maxWidth ? Math.min(usedSize, this._maxWidth()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var height = dim.height + gap;
            if (!this.isFloat && (position == Constants.RIGHT || position == Constants.LEFT)) {
                this.bounds.y += Math.max((this.bounds.height - height)/2, 0);
            } else if(!this.isFloat && position == Constants.RIGHT_BOTTOM){
                this.bounds.y = Math.round(this.bounds.y + this.bounds.height - height);
            }
            this.bounds.height = height;
        },

        render:function(){
            if(this.invisible()){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.group){
                this.backgroundGroup = renderer.group().addTo(this.getComponentParentGroup());

                this.group = renderer.vgroup().add(this.getComponentParentGroup());

                this.legendGroup = this.group.append(renderer.vgroup());
            }

            var targetG;
            if (this.useHtmlLabel()) {
                targetG = this.legendGroup.divG.attr({
                                'pointer-events': 'auto'
                            })
            } else {
                targetG = this.legendGroup.renderG;
            }
            vanchart.registerInteractiveTarget(this, targetG);

            this._innerClip(this.group);
            this.group.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, bounds);

            this.renderBody(this.legendGroup, bounds);
        },

        getEvents:function(){
            return {
                'mouseout':this.mouseOut
            }
        },

        mouseOut:function(){
            if(this.highlighted){
                this.vanchart.cancelLegendHighlight();
            }
        },

        remove: function () {
            this.group && this.group.remove();
            this.backgroundGroup && this.backgroundGroup.remove();
            this.group = this._barBackground = this._bar = this._minButton = this._maxButton = this._minLabel = this._maxLabel = this.backgroundGroup = null;
            // itemsNULLmaxmin
            // removeitemgraphic
            this.items && this.items.forEach(function (item){
                item.graphic = null;
            });
        }
    });

    return RangeLegend;
});

/**
 * Created by Mitisky on 16/8/10.
 */

define('component/IntervalRangeLegend',['require','../utils/BaseUtils','../Constants','../utils/ColorUtils','../dom/EventObject','./RangeLegend','../ComponentLibrary'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var EventObject = require('../dom/EventObject');
    var RangeLegend = require('./RangeLegend');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var WIDTH = 15;
    
    var BAR_TEXT_GAP = 4;
    var BAR_TEXT_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(BAR_TEXT_GAP);
    };
    
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;
    var ITEM_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(ITEM_GAP);
    };

    var IntervalRangeLegend = RangeLegend.extend({

        type:ComponentLibrary.INTERVAL_RANGE_LEGEND,

        initAttributesWithSeries: function () {
            var options = this.options, range = options.range || {};

            if(!BaseUtils.isArray(range)){//
                var splitNumber = range.splitNumber || 5;
                var color = range.color || this.vanchart.options.colors[0];
                var colors = this.vanchart.isHeatMap() ? ['rgb(0,0,255)','rgb(0,255,0)','rgb(255,255,0)','rgb(255,0,0)'] : ColorUtils.createColorsWithHsb(color, splitNumber);
                var minMax = this.vanchart.getChartMinMaxValue();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], splitNumber);
                var minValue = para[0];
                var gap = para[2];

                range = [];
                if(this.vanchart.isHeatMap()){
                    var sepPara = [0, 0.25, 0.55, 0.85, 1], valueRange = BaseUtils.accMul(gap, splitNumber);
                    for(var i = 1; i < 5; i++){
                        range.push({
                            from:BaseUtils.accAdd(minValue, BaseUtils.accMul(valueRange, sepPara[i - 1])),
                            to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(valueRange, sepPara[i])),
                            color:colors[i - 1]
                        });
                    }
                }else{
                    for(var i = 0; i < splitNumber; i++) {
                        range.push({
                            from:BaseUtils.accAdd(minValue, BaseUtils.accMul(gap, (splitNumber - i - 1))),
                            to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(gap, (splitNumber - i))),
                            color:colors[i]
                        });
                    }
                }
            }

            this.items = this.items || [];
            var realLen = range.length;
            var oldLen = this.items.length;

            for(var removeIndex = realLen; removeIndex < oldLen; removeIndex++){
                this.items[removeIndex].graphic && this.items[removeIndex].graphic.remove();
                this.items[removeIndex] = null;
            }

            var formatter = options.formatter;
            for(var index = 0; index < realLen; index++){
                var item = this.items[index] || new EventObject(this.getItemEvents());
                this.items[index] = item;

                var band = range[index];
                item.from = band.from;
                item.to = band.to;
                item.color = band.color;
                item.label = this._getIntervalLabelContent(band.from, band.to, formatter);
                item.visible = true;
                item.hiddenColor = options.hiddenColor;
                item.hoverColor = options.hoverColor;
                item.points = [];

                item.legend = this;
            }

            this.items.length = realLen;

            var self = this,series = this.vanchart.series;
            this.items.sort(function (itemA, itemB) {
                var itemAMin = Math.min(itemA.from, itemA.to);
                var itemBMin = Math.min(itemB.from, itemB.to);
                return self.isHorizontal() ? itemAMin - itemBMin : itemBMin - itemAMin;
            });

            for (var i = 0, len = series.length; i < len; i++) {
                var sery = series[i], valueKey = sery.getTargetKey();
                var pointS = sery.points;
                pointS.forEach(function (point) {

                    var size = point[valueKey];

                    var item = self._getPointItem(size);
                    if (item) {
                        item.points.push(point);

                        //item
                        point._rangeItem = item;
                    }
                })
            }
        },

        _getMin:function(){

            var index = this.isHorizontal() ? 0 : this.items.length - 1;

            return this.items[index].from;
        },

        _getMax:function(){

            var index = this.isHorizontal() ? this.items.length - 1 : 0;

            return this.items[index].to;
        },

        _getGradient:function(){
            var config = {'0':'white'};
            var min = this._getMin(), max = this._getMax(), det = max - min;

            for(var i = this.items.length - 1; i >= 0; i--){
                var item = this.items[i];
                config[(item.to - min)/det] = item.color;
            }

            return config;
        },

        _getIntervalLabelContent:function(from, to, formatter){
            if(!formatter){
                return from + '-' + to;
            }

            return BaseUtils.format({'from':from,'to':to}, formatter);
        },

        _getPointItem:function(size){
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                var min = Math.min(item.from, item.to);
                var max = Math.max(item.from, item.to);

                if(size >= min && size <= max){
                    return item;
                }
            }
        },

        calculateHorizontalDim: function () {
            var len = this.items.length;
            var width = 0, height = 0;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.options.style, this.options.useHtml);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.options.style, this.options.useHtml);
                var gap = Math.max(0, d1.width - ITEM_WIDTH, d2.width - ITEM_WIDTH);
                width = len * ITEM_WIDTH + (len - 1) * ITEM_GAP_FUN() + gap;
                height = WIDTH + BAR_TEXT_GAP_FUN() * 2 + d1.height * 2
            }
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var len = this.items.length;
            var width = 0, gap = 0;
            var style = this.options.style, legend = this;
            this.items.forEach(function (item) {
                var labelDim = BaseUtils.getTextDimension(item.label, style, legend.options.useHtml);
                width = Math.max(width, labelDim.width);
                gap = Math.max(0, labelDim.height - ITEM_WIDTH)
            });
            return {
                width:width + WIDTH + BAR_TEXT_GAP_FUN(),
                height:len * ITEM_WIDTH + (len - 1) * ITEM_GAP_FUN() + gap
            }
        },

        getColorWithSize: function (size) {
            var item = this._getPointItem(size);
            return item && item.color;
        },

        renderBody: function (itemsGroup, bounds) {

            this.isHorizontal() ? this._renderHorizontalInterval(itemsGroup, bounds)
                : this._renderVerticalInterval(itemsGroup, bounds);
        },

        _renderHorizontalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items;

            var transX = (bounds.width - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP_FUN())/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([transX, PADDING_FUN()]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + PADDING_FUN();

            var labelStyle = this.options.style;
            var vanchart = this.vanchart, renderer = vanchart.renderer;

            var useHtml = this.useHtmlLabel();

            var startX = 0;
            var self = this;
            itemS.forEach(function (item, i) {

                item.graphic = item.graphic || itemsGroup.append(renderer.vgroup().style({'cursor': 'pointer'}));
                var g = item.graphic;
                vanchart.registerInteractiveTarget(item, useHtml ? g.divG : g.renderG);

                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle, self.options.useHtml);
                var height = labelDim.height;
                var iconY = height + BAR_TEXT_GAP_FUN();
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP_FUN();

                g.rect = g.rect || g.append(renderer.rect());
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', startX).attr('y', iconY)
                    .attr('width', ITEM_WIDTH).attr('height', WIDTH);

                var innerX = startX + ITEM_WIDTH/ 2 - labelDim.width / 2,
                    innerY = i%2 === 0 ? 0 : bottomY;

                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startX += (ITEM_WIDTH + ITEM_GAP_FUN());
            });
        },

        _renderVerticalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items, vanchart = this.vanchart;

            var transY = (bounds.height - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP_FUN())/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([PADDING_FUN(), transY]));

            this._absX = bounds.x + PADDING_FUN();
            this._absY = bounds.y + transY;

            var labelStyle = this.options.style;
            var renderer = this.vanchart.renderer;

            var useHtml = this.useHtmlLabel();

            var startY = 0;
            var self = this;
            itemS.forEach(function(item, i){

                item.graphic = item.graphic || itemsGroup.append(renderer.vgroup().style({'cursor': 'pointer'}));
                var g = item.graphic;
                vanchart.registerInteractiveTarget(item, useHtml ? g.divG : g.renderG);

                var labelDim = BaseUtils.getTextDimension(item.label, labelStyle, useHtml);

                g.rect = g.rect || g.append(renderer.rect());
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', 0).attr('y', startY)
                    .attr('width', WIDTH).attr('height', ITEM_WIDTH);

                var innerX = Math.round(WIDTH + BAR_TEXT_GAP_FUN()),
                    innerY = Math.round(startY + ITEM_WIDTH / 2 - labelDim.height / 2);
                
                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startY += (ITEM_WIDTH + ITEM_GAP_FUN());
            });
        },

        _renderItemLabel: function (item, g, innerX, innerY, labelDim, i) {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, options = legend.options;
            var labelContent = item.label, labelStyle = options.style, useHtml = this.useHtmlLabel();
            var textColor = item.visible ? labelStyle.color : item.hiddenColor;

            labelStyle = BaseUtils.extend({}, labelStyle);
            labelStyle.color = textColor;

            g.text = g.text || g.append(renderer.vtext(useHtml));
            g.text.textContent(labelContent)
                .attr('dy', '.88em')
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}))
                .style(labelStyle);
        },

        _getItemIconStyle: function (item) {
            return {
                'fill':item.visible ? item.color : item.hiddenColor,
                'fill-opacity':1,
                'stroke':'none'
            }
        },

        getItemEvents:function(){
            return {
                'mouseover':this.onItemMouseOver,
                'mousemove':this.onItemMouseMove,
                'mouseout':this.onItemMouseOut,

                'tap':this.onItemTap
            }
        },

        onItemMouseOver: function (e) {
            var item = this, legend = item.legend;
            var text = item.graphic && item.graphic.text;

            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(item.hoverColor));
            }else{
                text.style({'fill': item.hoverColor});
            }

            if(this.legend.options.highlight){
                this.legend.highlighted = true;
                this.legend.vanchart.makeLegendHighlight(item);
            }
        },

        onItemMouseMove: function (e) {

        },

        onItemMouseOut: function (e) {
            var item = this, legend = item.legend, options = legend.options;
            var text = item.graphic && item.graphic.text;

            var labelColor = options.style.color;
            var textColor = item.visible ? labelColor : item.hiddenColor;

            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(textColor));
            }else{
                text.style({'fill':textColor});
            }
        },

        onItemTap: function (e) {
            var item = this, legend = item.legend, options = legend.options, vanchart = legend.vanchart;
            var text = item.graphic && item.graphic.text;
            var rect = item.graphic && item.graphic.rect;

            item.visible = !item.visible;
            var labelColor = options.style.color;
            var iconColor = item.visible ? item.color : item.hiddenColor;
            var textColor = item.visible ? labelColor : item.hiddenColor;
            rect.style({'fill':iconColor});
            if(legend.useHtmlLabel()){
                text.style('color', ColorUtils.colorToHex(textColor));
            }else{
                text.style({'fill':textColor});
            }

            if(item.points && item.points.length > 0) {

                var hasMap = vanchart.vanChartType == 'vanChartMap';

                item.points.forEach(function (point) {
                    var isLineMap = point.series.type === Constants.LINE_MAP;
                    if (!hasMap || (hasMap && point.points && point.points[0] == point)
                       || isLineMap) {
                        point.visible = item.visible;
                        if (hasMap && !isLineMap) {
                            var points = point.points;
                            for (var i = 1, len = points.length; i < len; i++) {
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });

                vanchart.filterRender();
            }
        }

    });


    ComponentLibrary.register(ComponentLibrary.INTERVAL_RANGE_LEGEND, IntervalRangeLegend);

    return IntervalRangeLegend;

});


/**
 * Created by Mitisky on 16/8/10.
 */
define('component/GradientRangeLegend',['require','../utils/BaseUtils','../Constants','../utils/ColorUtils','./RangeLegend','../ComponentLibrary','../utils/Scale','../utils/Interpolator'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var RangeLegend = require('./RangeLegend');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var Interpolator = require('../utils/Interpolator');

    var MAX_INTERVAL_IN_LARGE = 10;
    var LARGE_RANGE = Array.apply(null, new Array(MAX_INTERVAL_IN_LARGE))
                    .map(function(d, i) {return i * 1 / MAX_INTERVAL_IN_LARGE});

    var PADDING = 8;
    var PADDING_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    
    var BAR_TEXT_GAP = 4;
    var BAR_TEXT_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(BAR_TEXT_GAP);
    };

    var TOP_BAR_PATH = 'M7.236,10H13c1.105,0,2-0.895,2-2V2c0-1.105-0.895-2-2-2L2.618,0C1.875,0,1.391,0.782,1.724,1.447l3.724,7.447C5.786,9.572,6.479,10,7.236,10z';
    var BOTTOM_BAR_PATH = 'M7.236,0L13,0c1.105,0,2,0.895,2,2v6c0,1.105-0.895,2-2,2H2.618c-0.743,0-1.227-0.782-0.894-1.447l3.724-7.447C5.786,0.428,6.479,0,7.236,0z';
    var LEFT_BAR_PATH = 'M0,7.236V13c0,1.105,0.895,2,2,2h6c1.105,0,2-0.895,2-2V2.618c0-0.743-0.782-1.227-1.447-0.894L1.106,5.447C0.428,5.786,0,6.479,0,7.236z';
    var RIGHT_BAR_PATH = 'M10,7.236V13c0,1.105-0.895,2-2,2H2c-1.105,0-2-0.895-2-2L0,2.618c0-0.743,0.782-1.227,1.447-0.894l7.447,3.724C9.572,5.786,10,6.479,10,7.236z';

    var GradientRangeLegend = RangeLegend.extend({

        type:ComponentLibrary.GradientRangeLegend,

        initAttributesWithSeries: function () {
            var options = this.options, range = options.range || {};
            this.valueAndColors = range.color || this._getDefaultValueAndColors();

            var minValue = range.min, maxValue = range.max;

            if(BaseUtils.hasNotDefined(minValue) && BaseUtils.hasNotDefined(maxValue)){//
                var minMax = this.vanchart.getChartMinMaxValue();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], Math.max(2, this.valueAndColors.length - 1));
                minValue = para[0];
                maxValue = para[1];
            }

            this.min = BaseUtils.pick(range.min, minValue);
            this.max = BaseUtils.pick(range.max, maxValue);

            this.minPos = 0;//
            this.maxPos = HEIGHT;//

            this.valueAndColors.sort(function(d1, d2){
                return d1[0] - d2[0];
            });
            var valueArray = [];
            var colorArray = [];
            for(var i = 0, len = this.valueAndColors.length; i < len; i ++ ){
                valueArray[i] = this.valueAndColors[i][0];
                colorArray[i] = this.valueAndColors[i][1];
            }

            var largeValueScale = Scale.quantize()
                .domain([this.min, this.max])
                .range(LARGE_RANGE);

            this.largeValueScale = function (datum){
                return this.min === this.max ? 0 : largeValueScale(datum);  // 0
            };

            this.valueScale = Scale.linear()
                .domain([this.min, this.max])
                .range([0, 1]);

            this.colorScale = Scale.linear()
                .domain(valueArray)
                .range(colorArray)
                .interpolate(Interpolator.interpolate)
                .interpolate(Interpolator.interpolate);
        },

        _getMin:function(){
            return this.min;
        },

        _getMax:function(){
            return this.max;
        },

        _getGradient:function(){
            var config = {};
            this.valueAndColors.forEach(function(v_c){
                config[v_c[0]] = v_c[1];
            });
            return config;
        },

        _getDefaultValueAndColors: function () {
            var colors = ColorUtils.createColorsWithHsb(this.vanchart.options.colors[0], 3);
            return [[0, colors[2]], [0.5, colors[1]], [1, colors[0]]];
        },

        calculateHorizontalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style, this.options.useHtml);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style, this.options.useHtml);
            var gap = Math.max(d1.width, d2.width, BAR_HEIGHT);
            var width = HEIGHT + gap * 2;
            var height = WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN() + d1.height;
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style, this.options.useHtml);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style, this.options.useHtml);
            var width = WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN() + Math.max(d1.width, d2.width);
            var gap = Math.max(d1.height/2, BAR_HEIGHT/2) * 2;
            var height = HEIGHT + gap * 2;
            return {
                width:width,
                height:height
            }
        },

        getColorWithSize: function (size, large) {
            if (size >= this.min && size <= this.max) {
                return this.colorScale(this[large ? 'largeValueScale' : 'valueScale'](size));
            } else {
                return null;
            }
        },

        _getGradientMinLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.min);
        },

        _getGradientMaxLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.max);
        },

        _getGradientLabelWithFormatter: function (value) {
            var formatter = this.options.formatter;
            if(!formatter){
                return value;
            }

            return BaseUtils.format(value, formatter);
        },

        _getGradientLabelContent: function (value) {
            return this._getGradientLabelWithFormatter(this._gradientScale(value));
        },

        _gradientScale: function (value) {
            var unit = BaseUtils.accDiv(BaseUtils.accAdd(this.max, -this.min), HEIGHT);
            value = BaseUtils.accMul(unit, this.isHorizontal() ? value : (HEIGHT - value));
            value = BaseUtils.accAdd(value, this.min);
            return value;
        },

        _getBarBackgroundStyle: function () {
            return {
                'fill':'#eaeaea',
                'stroke-width':0
            }
        },

        _getGradientFillColor:function(isHorizontal, renderer){

            var attrs = {
                'x1':'0%',
                'y1':isHorizontal ? '0%' : '100%',
                'x2':isHorizontal ? '100%' : '0%',
                'y2':'0%'
            };

            var stop = [];
            this.valueAndColors.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];

                stop.push({
                    'offset': value,
                    'stop-color':color
                })
            });

            if(this._bar.colorGradient){
                renderer.updateColorGradient(this._bar.colorGradient, attrs, stop);
            }else{
                this._bar.colorGradient = renderer.colorGradient(attrs, stop);
            }

            return "url(#" + BaseUtils.stamp(this._bar.colorGradient) +")";
        },

        _updateHorizontalGradientClipRect: function() {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':this.minPos,
                'y':0,
                'width':this.maxPos - this.minPos,
                'height':WIDTH
            };

            if(!this._bar.clipG){
                this._bar.clipG = renderer.createClip(attrs);
                renderer.clip(this._bar, this._bar.clipG);
            }else{
                renderer.updateClip(this._bar.clipG, attrs);
            }
        },

        _updateVerticalGradientClipRect: function () {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':0,
                'y':this.minPos,
                'width':WIDTH,
                'height':this.maxPos - this.minPos
            };

            if(!this._bar.clipG){
                this._bar.clipG = renderer.createClip(attrs);
                renderer.clip(this._bar, this._bar.clipG);
            }else{
                renderer.updateClip(this._bar.clipG, attrs);
            }
        },

        //verticalbuttonmaxPosminButton
        renderBody: function (barGroup, bounds) {

            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, plotBounds = vanchart.bounds;

            var isHorizontal = legend.isHorizontal();

            var transX = isHorizontal ? (bounds.width - HEIGHT)/2 : PADDING_FUN();
            var transY = isHorizontal ? PADDING_FUN() : (bounds.height - HEIGHT)/2;
            barGroup.attr('transform', BaseUtils.makeTranslate([transX, transY]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + transY;

            this._barBackground = this._barBackground || barGroup.append(renderer.rect());
            this._bar = this._bar || barGroup.append(renderer.rect());
            this._minButton = this._minButton || barGroup.append(renderer.path().style({'cursor': 'pointer'}));
            this._maxButton = this._maxButton || barGroup.append(renderer.path().style({'cursor': 'pointer'}));
            this._minLabel = this._minLabel || barGroup.append(renderer.vtext(this.useHtmlLabel()));
            this._maxLabel = this._maxLabel || barGroup.append(renderer.vtext(this.useHtmlLabel()));

            var rectAttr = {
                'rx': 2,
                'ry': 2,
                'x': 0,
                'y': 0,
                'width': isHorizontal ? HEIGHT : WIDTH,
                'height': isHorizontal ? WIDTH : HEIGHT
            };

            this._barBackground
                .style(this._getBarBackgroundStyle())
                .attr(rectAttr);

            this._bar
                .attr(rectAttr)
                .style({
                    'fill':this._getGradientFillColor(isHorizontal, renderer),
                    'stroke-width':0
                });

            //todo iefilter
            if(!BaseUtils.isSupportSVG()){
                renderer._updateGradientFill(this._bar, this._bar.colorGradient);
            }

            this._minButton
                .attr('d', isHorizontal ? LEFT_BAR_PATH : TOP_BAR_PATH);

            this._maxButton
                .attr('d', isHorizontal ? RIGHT_BAR_PATH : BOTTOM_BAR_PATH);

            this._minLabel
                .attr('dy', '.85em')
                .style(this.options.style);

            this._maxLabel
                .attr('dy', '.85em')
                .style(this.options.style);

            this._updateMax();
            this._updateMin();
        },

        _updateMin: function () {
            this.isHorizontal() ? this._updateHorizontalMinBar()
                : this._updateVerticalMinBar();
        },

        _updateMax: function () {
            this.isHorizontal() ? this._updateHorizontalMaxBar()
                : this._updateVerticalMaxBar();
        },

        //
        _updateVerticalMinBar: function() {

            this._minButton
                .attr('transform', 'translate('+ WIDTH  +','+ this.maxPos +')')
                .style({'fill':this.colorScale((HEIGHT - this.maxPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN()),
            innerY = Math.round(this.maxPos + BAR_HEIGHT / 2 - labelDim.height / 2);


            this._minLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateVerticalGradientClipRect();
        },

        //
        _updateHorizontalMinBar: function() {
            var x = this.minPos - BAR_HEIGHT;

            this._minButton
                .attr('transform', 'translate('+ x  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.minPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(this.minPos - labelDim.width),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN());

            this._minLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateHorizontalGradientClipRect();
        },


        //
        _updateVerticalMaxBar: function() {
            var y = this.minPos - BAR_HEIGHT;

            this._maxButton
                .attr('transform', 'translate('+ WIDTH  +','+ y +')')
                .style({'fill': this.colorScale((HEIGHT - this.minPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN()),
                innerY = Math.round(this.minPos - BAR_HEIGHT/2 - labelDim.height / 2);


            this._maxLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateVerticalGradientClipRect();
        },

        //
        _updateHorizontalMaxBar: function() {
            this._maxButton
                .attr('transform', 'translate('+ this.maxPos  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.maxPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);

            var innerX = Math.round(this.maxPos),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP_FUN());

            this._maxLabel.textContent(label)
                .attr('transform', BaseUtils.makeTranslate({x:innerX,y:innerY}));

            this._updateHorizontalGradientClipRect();
        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove":this._panMove,
                "panend":this._panEnd
            }
        },

        _panStart:function(ev){
            var position = this.options.position;

            this.currentX = ev.containerPoint.x;
            this.currentY = ev.containerPoint.y;
            this.eventTarget = position == Constants.TOP || position == Constants.BOTTOM ?
                this._findHorizontalTarget() : this._findVerticalTarget();
        },

        _findHorizontalTarget: function () {
            var gap = (this.maxPos - this.minPos)/5;
            if(this.currentX < this._absX + this.minPos + gap){
                return this._minButton;
            } else if(this.currentX > this._absX + this.maxPos - gap){
                return this._maxButton;
            }
        },

        _findVerticalTarget: function () {
            var gap = (this.maxPos - this.minPos)/5;
            if(this.currentY < this._absY + this.minPos + gap){
                return this._maxButton;
            } else if(this.currentY > this._absY + this.maxPos - gap){
                return this._minButton;
            }
        },

        _panMove: function (ev) {
            if(this.eventTarget == this._minButton){
                this._minButtonMove(this.currentX, this.currentY, ev.containerPoint.x, ev.containerPoint.y);

            } else if(this.eventTarget == this._maxButton){
                this._maxButtonMove(this.currentX, this.currentY, ev.containerPoint.x, ev.containerPoint.y);
            }
        },

        _minButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//left
                var temp = this.minPos;
                this.minPos += Math.round(currentX - oldX);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            } else {//bottom
                var temp = this.maxPos;
                this.maxPos += Math.round(currentY - oldY);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            }

            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMin();
                this.refreshPoints();
            }
        },

        _maxButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//right
                var temp = this.maxPos;
                this.maxPos += Math.round(currentX - oldX);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            } else {//top
                var temp = this.minPos;
                this.minPos += Math.round(currentY - oldY);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            }
            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMax();
                this.refreshPoints();
            }
        },

        _panEnd: function (ev) {
            this.eventTarget = null;
        },

        refreshPoints: function () {
            var minSize = this._gradientScale(this.minPos);
            var maxSize = this._gradientScale(this.maxPos);
            var vanChart = this.vanchart, series = vanChart.series;
            var change = false, hasMap = vanChart.vanChartType == 'vanChartMap';

            var points;
            for (var i = 0, len = series.length; i < len; i++) {
                var sery = series[i];

                sery.points.forEach(function (point) {

                    var isLineMap = point.series.type === Constants.LINE_MAP;

                    if (!hasMap || (hasMap && point.points && point.points[0] == point)
                        || isLineMap) {
                        var temp = point.visible;

                        var size = point.getTargetValue();

                        point.visible = (size >= minSize && size <= maxSize) || (size >= maxSize && size <= minSize);

                        change = change || temp != point.visible;

                        if (hasMap && !isLineMap) {
                            points = point.points;
                            for (var i = 1, len = points.length; i < len; i++) {
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });
            }

            if(change) {
                vanChart.filterRender();
            }
        }

    });

    ComponentLibrary.register(ComponentLibrary.GradientRangeLegend, GradientRangeLegend);

    return GradientRangeLegend;

});

define('component/Polar',['require','../Constants','../utils/BaseUtils','./Base','../ComponentLibrary'],function(require) {
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Base = require('./Base');
    var ComponentLibrary = require('../ComponentLibrary');

    var Polar = Base.extend({

        _refresh:function(){
            this.series = [];
        },

        _isBaseAxis:function(){
            return true;
        },

        doLayout: function () {
            var option = this.options;

            var radius = option.radius;
            var center = option.center;

            // keep origin radius (include null)
            // adjust radius by angleAxis later

            if (!center || center.length === 0) {
                var plotBounds = this.vanchart.bounds;
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            }

            this.setCenter(center);

            if(BaseUtils.hasDefined(radius)){
                this.setRadius(radius);
            }else{
                this.radius = null;
            }

            var plotOptions = this.vanchart.options.plotOptions;
            var shape = (plotOptions.radar && plotOptions.radar.shape) || plotOptions.shape;
            
            this.shape = shape || this.shape;
        },

        /**
         * set polar radius and update radiusAxis scale
         * @param {number|string} radius
         */
        setRadius: function (radius) {
            if (!radius) {
                return;
            }

            this.radius = this._getPercentValue(
                radius,
                Math.min(this.vanchart.width, this.vanchart.height) / 2
            );
        },

        /**
         * set polar center
         * @param {number[]|string[]} center
         */
        setCenter: function (center) {
            if (!center) {
                return;
            }

            this.center = [];

            this.center[0] = this._getPercentValue(center[0], this.vanchart.width);

            this.center[1] = this._getPercentValue(center[1], this.vanchart.height);
        },

        render: function () {
            var R = this.vanchart.renderer, radiusAxis = this.radiusAxis;
            var clipPath = {'d': radiusAxis._getRadiusGridPath(radiusAxis.scale.domain()[1])};
            if (!this.clip) {
                this.clip = R.createClip(clipPath, 'path');
            }else{
                R.updateClip(this.clip, clipPath);
            }

            this.radiusAxis.render();
            this.angleAxis.render();
        }
    });
    
    return Polar;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/AngleAxis',['require','./Base','./CategoryAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/Scale','../utils/PathGenerator'],function(require){
    var Base = require('./Base');
    var CategoryAxis = require('./CategoryAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var Scale = require('../utils/Scale');
    var PathGenerator = require('../utils/PathGenerator');

    var PADDING_GAP = 8;
    
    var PADDING_GAP_FUN = function() {
        return BaseUtils.paddingConvertWithScale(PADDING_GAP);
    };

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var AngleAxis = CategoryAxis.extend({

        _refresh:function(options){
            this.series = [];

            this.piece = null;

            this.initScale();

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.angleAxis = this;
        },

        doLayout:function(){

            this.calculateDomainFromData();

            this.scale.domain(this._dataDomain).rangePoints([0, this._dataDomain.length - 1]);

            this.piece = (Math.PI * 2) / Math.max(this._dataDomain.length, 1);

            this._updateOriginTickData();

            this._updatePolarBounds();

            this._calculateTickData();
        },

        fixScaleAndTickData:function(){
            this.scale.domain(this._dataDomain).rangePoints([0, this._dataDomain.length - 1]);

            this._updateOriginTickData();

            this._calculateTickData();
        },

        _calculateTickData:function(){
            var radius = this.polar.radius, bounds;
            if (this.isBreakLabels) {
                bounds = this._getTestBoundsAndRadius().testBounds;
            }
            this.tickData.map(function (t) {
                this._getCateLabelBounds(radius, t, bounds);
            }, this);
        },

        _getTestBoundsAndRadius: function () {
            var plotBounds = this.vanchart.bounds;
            var center = this.polar.center;

            var tmpBounds = [
                // 0 top
                center[1] - plotBounds.y,
                // 1 right
                plotBounds.x + plotBounds.width - center[0],
                // 2 bottom
                plotBounds.y + plotBounds.height - center[1],
                // 3 left
                center[0] - plotBounds.x
            ];

            var radius = Math.min.apply(null, tmpBounds);
            radius -= PADDING_GAP_FUN();

            var testBounds = {
                x: - tmpBounds[3],
                y: - tmpBounds[0],
                width: plotBounds.width,
                height: plotBounds.height
            };

            return {
                testBounds: testBounds,
                radius: radius
            }
        },

        _updatePolarBounds: function () {

            if (this.polar.radius) {
                return;
            }

            // no radius setting, auto adjust
            var tmp = this._getTestBoundsAndRadius();
            var radius = tmp.radius;
            var testBounds = tmp.testBounds;

            if (this.options.showLabel) {
                if (!this._testRadius(radius, testBounds)) {
                    radius = this._findNiceRadius(testBounds);
                    this._testRadius(radius, testBounds);
                }
            }

            this.polar.setRadius(radius);
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByPolarCoordinate(pos);
        },

        _getIndexByPolarCoordinate: function (pos) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = pos[0]-center[0];
            var y = center[1]-pos[1];

            if ((x*x + y*y) > r*r) {
                return -1;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = 2 * Math.PI / categories.length;
                index = isReversed ? categories.length - 1 - arc / unitLength : arc / unitLength;
            } else {
                index = 0;
            }

            index = Math.round(index);

            index = index % categories.length;

            return index;
        },

        getAngleGridLineData: function () {

            var points = [];

            var angleAxis = this.polar.angleAxis;
            var categories = angleAxis.scale.domain();
            var self = this;

            categories.forEach(function(category){

                var radian = angleAxis.scale(category) * angleAxis.piece;

                var r = self.polar.radius;

                points.push(BaseUtils.getArcPoint(r, radian));

            });

            points = points.length ? points : [BaseUtils.getArcPoint(this.polar.radius, 0)];

            return points;
        },

        // clac the endPos of every gridLine.
        getCateAngleGridLineData : function (){   
            var points = this.getAngleGridLineData();   
            var category = this.polar.angleAxis.scale.domain();   
   
            return points.map(function (p, index) {   
                return {   
                    name : category[index],   
                    pos : p   
                }   
            })   
        },

        _testRadius:function(radius, testBounds){

            for(var i = 0, count = this.tickData.length; i < count; i++){

                var tick = this.tickData[i];
                var labelBounds = this._getCateLabelBounds(radius, tick);

                if(!BaseUtils.containsRect(testBounds, labelBounds)){
                    return false;
                }

            }
            return true;
        },

        _getCateLabelBounds:function(radius, cateTick, testBounds){

            var category = cateTick.tickValue;
            var dim = cateTick.tickRectDim;
            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var arcPoint = BaseUtils.getArcPoint(radius + PADDING_GAP_FUN(), index * this.piece);
            var pos;
            var cfg = this.options;

            var position = this._getPolarPosition(category);

            var originStyle = BaseUtils.extend({
                width: '',
                'white-space': '',
                'text-align': ''
            }, cfg.labelStyle);

            switch (position){

                case TOP:

                    pos = {
                        style: originStyle,
                        x:-dim.width/2,
                        y:-radius - dim.height * 0.65 - PADDING_GAP_FUN()
                    };

                    break;

                case RIGHT:

                    pos = {
                        style: originStyle,
                        x:arcPoint[0],
                        y:arcPoint[1] - dim.height/2
                    };

                    if (testBounds && this.isBreakLabels && (pos.x + dim.width) > (testBounds.x + testBounds.width)) {
                        var width = testBounds.x + testBounds.width - arcPoint[0];
                        var style = BaseUtils.extend({
                            width:width+'px',
                            'white-space': 'normal',
                            'text-align': 'left'
                        }, cfg.labelStyle);
                        dim = BaseUtils.getTextWrapDimension(cateTick.tickContent, style);
                        pos = {
                            style:style,
                            x:arcPoint[0],
                            y:arcPoint[1] - dim.height/2
                        };
                    }

                    break;

                case BOTTOM:

                    pos = {
                        style: originStyle,
                        x:-dim.width/2,
                        y:radius + PADDING_GAP_FUN()
                    };

                    break;

                case LEFT:

                    pos = {
                        style: originStyle,
                        x:arcPoint[0] - dim.width,
                        y:arcPoint[1] - dim.height/2
                    };

                    if (testBounds && this.isBreakLabels && pos.x < testBounds.x) {
                        var width = arcPoint[0] - testBounds.x;
                        var style = BaseUtils.extend({
                            width:width+'px',
                            'white-space': 'normal',
                            'text-align': 'right'
                        }, cfg.labelStyle);
                        dim = BaseUtils.getTextWrapDimension(cateTick.tickContent, style);
                        pos = {
                            style:style,
                            x:arcPoint[0] - dim.width,
                            y:arcPoint[1] - dim.height/2
                        };
                    }

                    break;
            }

            cateTick.tickPos = pos;
            return BaseUtils.makeBounds(pos, dim);
        },

        _getPolarPosition:function(category){

            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var midIndex = domain.length / 2;

            if(index === 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        _findNiceRadius:function(testBounds){

            var tmpBounds = [
                - testBounds.y,
                testBounds.width + testBounds.x,
                testBounds.height + testBounds.y,
                - testBounds.x
            ];

            var minBounds = Math.min.apply(null, tmpBounds);
            var minRadius = minBounds;

            var domain = this.scale.domain();
            var self = this;

            this.tickData.forEach(function(cateTick){
                if(cateTick.tickContent){

                    var category = cateTick.tickValue;
                    var tickDim = cateTick.tickDim;

                    var index = domain.indexOf(category);
                    var position = self._getPolarPosition(category);

                    var radius;
                    switch (position) {
                        case TOP:
                            radius = tmpBounds[0] - tickDim.height;
                            break;
                        case RIGHT:
                            radius = (tmpBounds[1] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        case BOTTOM:
                            radius = tmpBounds[2] - tickDim.height;
                            break;
                        case LEFT:
                            radius = (tmpBounds[3] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        default:
                    }

                    minRadius = Math.min(minRadius, radius);
                }
            });

            if (minRadius < minBounds * 2 / 3) {
                minRadius =  minBounds * 2 / 3;
                // this.breakLabels(this.tickData);
                if (!this.options.labelRotation && !this.options.useHtml) {
                    this.isBreakLabels = true; // break labels in render
                }
            }

            return minRadius - PADDING_GAP_FUN();
        },

        getPointsInCategory: function (containerPoint) {
            var center = this.polar.center;
            var r = this.polar.radius;

            var x = containerPoint.x - center[0];
            var y = center[1] - containerPoint.y;

            if ((x*x + y*y) > r*r) {
                return null;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var domain = this.scale.domain(), range = this.scale.rangeExtent();
            var tmpScale = Scale.quantize().domain(range).range(domain);
            var l = domain.length, index = Math.round(arc / ( 2 * Math.PI ) * l ) % l;
            var category = tmpScale(index);
            return this.vanchart.getValidPointsPara(category);
        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add(vanchart.backGroup);
            }

            // 
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawAxisLine(this.axisGroup);

            this._drawGridLine(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawAxisLine:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this.polar.radiusAxis;

            var angleAxis = this;
            var lineWidth = angleAxis.options.lineWidth;
            var lineColor = angleAxis.options.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            if (!this.axisLine) {
                this.axisLine = axisGroup.append(R.path());
            }

            this.axisLine
                .attr({
                    d: radiusAxis._getRadiusGridPath(maxValue)
                })
                .style({
                    fill:'none',
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                });
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            // 'angle grid line' is like xAxis grid line
            // but now we name it radiusAxis axisLine in options
            // so
            var cfg = this.polar.radiusAxis.options;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var axisLineData = this.getAngleGridLineData();

            var selection = this._bindData(this.gridLines, axisLineData);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.line()).datum(d);
            });

            this.gridLines =
                enter.concat(selection.update).map(function (ele) {
                    var d = ele.datum();
                    return ele.style({'stroke':lineColor, 'stroke-width':lineWidth})
                            .attr({x1:0, y1:0, x2: d[0], y2: d[1]});
            });
        },

        _drawTickLabel:function(axisGroup){
            this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var angleAxis = this;
            var cfg = angleAxis.options;
            var isBreakLabels = this.isBreakLabels;

            var useHtml = cfg.useHtml || isBreakLabels;

            var ticks = angleAxis.tickData;

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
                this.tickLabels = [];
            }

            if (useHtml && this.tickLabels.length && this.tickLabels[0].type !== 'div') {
                this.tickLabels.map(function (d) {
                    d.remove();
                });
                this.tickLabels = [];
            }

            var tickLabelsGroup = this.tickLabelsGroup;

            var selection = this._bindData(this.tickLabels, ticks, function(d){return d.tickValue});

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                this.tickLabels = enter.concat(selection.update)
                    .filter(function (ele) {return ele.datum().tickPos;})
                    .map(function (ele) {
                        var d = ele.datum();

                        var tx = d.tickPos.x,
                            ty = d.tickPos.y;

                        var px = ele.type === 'div' ? 'px' : '';
                        var attr = {
                            transform: 'translate(' + tx + px + ' ' + ty + px + ')',
                            dy: '0.85em'
                        };

                        ele.textContent(d.tickContent)
                            .style(d.tickPos.style)
                            .attr(attr);

                        ele.vRotate(d.labelRotation);

                        return ele;
                    });

            }
        },

        drawHighlightBackground: function (sharedPoints) {
            var category = sharedPoints[0].category;
            var scale = this.scale, columnType = this.series[0] && this.series[0].options.columnType || false;
            var R = this.vanchart.renderer;

            var domain = scale.domain();

            var r = this.polar.radius;
            var radian = scale(category) / domain.length * 2 * Math.PI;

            if (columnType) {
                var halfSize = 1 / domain.length * 2 * Math.PI * 0.5;
                var startRadian = radian - halfSize;
                var endRadian = radian + halfSize;

                var arc = PathGenerator.arc()
                    .innerRadius(0)
                    .outerRadius(r)
                    .startAngle(startRadian)
                    .endAngle(endRadian);

                if (!this.highlightBand) {
                    this.highlightBand = this.axisGroup.append(R.path().style(
                        {
                            'fill': 'rgba(98,179,240,0.2)'
                        }
                    ));
                }

                this.highlightBand.attr('d', arc());
            } else {
                var point = BaseUtils.getArcPoint(r, radian);

                if (!this.highlightLine) {
                    this.highlightLine = this.axisGroup.append(R.line({
                        'stroke': 'rgb(140,140,140)',
                        'stroke-width': '1'
                    }));
                }

                this.highlightLine.attr('x2', point[0]).attr('y2', point[1]);
            }
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.axisGroup = null;
        }

    });

    return AngleAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/RadiusAxis',['require','./Base','./ValueAxis','../utils/BaseUtils','../Constants','../ComponentLibrary','../utils/PathGenerator','../utils/Interpolator','../utils/Scale'],function(require){
    var Base = require('./Base');
    var ValueAxis = require('./ValueAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');
    var PathGenerator = require('../utils/PathGenerator');
    var Interpolate = require('../utils/Interpolator');
    var Scale = require('../utils/Scale');

    var VALUE_TICK_GAP = 2;
    var VALUE_TICK_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(VALUE_TICK_GAP);
    };

    var RadiusAxis = ValueAxis.extend({

        _refresh:function(options){
            this.series = [];

            this.initScale();

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.radiusAxis = this;
        },

        doLayout:function(){
            var series = this.series;
            this.indicator = series.length && series[0].options.indicator && series[0].options.indicator.enabled;  // bind indicator property

            this.calculateDomainFromData();

            this.scale.domain(this._domain).range([0, this.polar.radius]);

            // init categoryScale, used for calc scale value for points radius of every category 
            this._initCateScale(this._domain, [0, this.polar.radius]);  

            this._updateOriginTickData();
        },

        // bind radiusAxis.cateScale
        _initCateScale: function(d, r) {
            var scale = Scale.linear().domain(d).range(r)
            this._cateScale = scale;
        },

        // calc domain form data for every categroy
        // if the category is accumulated, calc sum use value of points on this category.  
        _calculateCateDomainData: function() {
            var radiusAxis = this, series = radiusAxis.series, vanchart = series.vanchart;
            var options = series.length && series[0].options, indicator = options.indicator;
            var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && !this._isBaseAxis();

            var minValue = Number.MAX_VALUE,maxValue = -minValue;
            var dataMap = {}, indicatorDataDomain; 
            this._cateDataDomain = [];
            // option
            if(indicator.data && indicator.data.length) {
                indicatorDataDomain = indicator.data.map(function (data) {
                    return {
                        name : data.name,
                        domain : [data.min, data.max]
                    }
                })
            }

            var visible = false;
            for(var i = 0, len = series.length; i < len && !visible; i++){
                visible = series[i].visible;
            }

            series.forEach(function (ser) {
                if(ser.visible || !visible) {
                    var isAccumulate = !(BaseUtils.hasNotDefined(ser.stack) || radiusAxis._isBaseAxis());

                    ser.points.forEach(function (point) {
                        var key = point.category, value = point.value;
                        if(!point.isNull && point.visible) {
                            if( isAccumulate ) {
                                dataMap[key] = dataMap[key] || [0, 0];
                                if(value >= 0) {
                                    dataMap[key][1] += value;
                                } else {
                                    dataMap[key][0] += value;
                                }
                            } else {
                                dataMap[key] = dataMap[key] || [minValue,maxValue];
                                dataMap[key][0] = Math.min(dataMap[key][0], value);
                                dataMap[key][1] = Math.max(dataMap[key][1], value);
                            }
                        }
                    })
                }
            });
            for(key in dataMap) {
                this._cateDataDomain.push({
                    useIndicator : false,
                    name : key,
                    domain : dataMap[key]
                })
            }
            // 00
            var checkMaxAndMin  = function (arr) {
                if(fromZero) {
                    if(arr[0] > 0) { 
                        arr[0] = 0; 
                    }else if(arr[1] < 0){ 
                        arr[1] = 0; 
                    } 
                }
            }
            // 
            // 
            if (indicatorDataDomain) {
                indicatorDataDomain.forEach(function (cate) {
                    var name = cate.name, min = cate.domain[0], max = cate.domain[1];
                    // 
                    radiusAxis._cateDataDomain.forEach(function (_cate) {
                        // 
                        if(name === _cate.name) {
                            // 
                            if(min==null && max==null) { return; }
                            // 
                            if(min!=null && max != null && min >= max){ return; }
                            var d_0 = _cate.domain[0],
                                d_1 = _cate.domain[1];

                            // 0
                            var _min = min || (fromZero ? (d_0 > 0 ? 0 : d_0) : d_0),
                                _max = max || (fromZero ? (d_1 < 0 ? 0 : d_1) : d_1);

                            var hasMin = false, hasMax = false;
                            if(min) {
                                hasMin = true;
                            }
                            if(max){
                                hasMax = true;
                            }
                            // 
                            if(hasMin && !hasMax) {
                                _max = _max <= _min ? _min + 100 : _max;
                            // 
                            }else if(hasMax && !hasMin){
                                _min = _min > _max ? _max - 100 : _min;
                            }
                            _cate.useIndicator = true;
                            _cate.domain = [_min, _max];
                        }
                    })
                })
            }
            // 0
            this._cateDataDomain.forEach(function (d){
                if(!d.useIndicator) {
                    checkMaxAndMin(d.domain)
                }
            })
            
            // As we get Max and Min of each category, next setp is to calc cateNiceDomain, cateStartTick, cateStep and cateTickData.
            this._calculateCateNiceDomain();
            this._updateCategoryTickData();
        },
        // clac nice domain for every category
        // and get each's tickStartValue,tickStep by the way.
        _calculateCateNiceDomain : function () {
            var radiusAxis = this, series = radiusAxis.series, vanchart = series.vanchart;


            this._cateTickStart = [];
            this._cateStep = [];
            this._cateDomain = [];

            var hasIndicator = false, defaultTickCount = this._getDefaultTickCount()
            // 
            // tickCount
            this._cateDataDomain.forEach(function (data) {
                var name = data.name, _domain = data.domain, useIndicator = data.useIndicator;
                
                var step, domain, start;
                if (data.useIndicator) {
                    hasIndicator = true;
                    start = _domain[0],
                    domain = [_domain[0], _domain[1]];
                    step = parseFloat((_domain[1] - _domain[0]) / defaultTickCount);
                }else{
                    step = radiusAxis._linearTickInterval(_domain[0], _domain[1]),
                    domain = radiusAxis._linearNiceDomain(_domain[0], _domain[1], step);
                    start = domain[0];
                }

                radiusAxis._cateTickStart.push(start);
                
                radiusAxis._cateDomain.push({
                    useIndicator : useIndicator,
                    name : name, 
                    domain : domain 
                })

                radiusAxis._cateStep.push(step)
            });

            // 
            // 4grinLine
            if(!hasIndicator) {
                var labelsLengthArr = this._getCateTickValues().map(function (d) {
                    return d.labels.length;
                })
                defaultTickCount = Math.max.apply(Math, labelsLengthArr);
            }
            
            this._cateDomain.forEach(function (d, i) {
                var min = d.domain[0], max = d.domain[1], useIndicator = d.useIndicator;
                // stepmaxtickLabels
                if(!useIndicator) {
                    _step = Math.ceil((max - min) / defaultTickCount);
                    d.domain[1] = min + _step * defaultTickCount;
                    radiusAxis._cateStep[i] = _step;
                }
            })
        },

        // Update TickData for every radiusAxis
        _updateCategoryTickData: function() {
            var radiusAxis = this;
            var cateLabels = this._getCateTickValues();
            this.cateTickData = [];
  
            for(var i = 0, len = cateLabels.length; i < len; i++) {  
                var cateName = cateLabels[i].name,  
                    cateLabel = cateLabels[i].labels;  
                var cateTickData = [];  

                for(var j = 0, labelLen = cateLabel.length; j < labelLen; j++) {  
                    cateTickData.push(radiusAxis._labelInfoFormatter(cateLabel[j]));  
                }  
                radiusAxis.cateTickData.push({  
                    name : cateName,  
                    tickData : cateTickData  
                })  
            }  
        },
        // tickLabel info formatter, copy from BaseAxis._updateOriginTickData
        _labelInfoFormatter : function (tickValue) {
            var radiusAxis = this, axisOption = this.options;
            var formatter = axisOption.formatter, useHtml = axisOption.useHtml;

            var style = axisOption.labelStyle || {};
            var tbStyle = BaseUtils.extend({
                'writingMode': 'tb-rl',
                'writing-mode': 'tb-rl',
                '-webkit-writing-mode': 'vertical-rl'
            }, style);

            var tickContent = radiusAxis._getTickContent(tickValue, formatter);
            if (radiusAxis.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                tickContent = tickContent.trim();
            }
            var rectDim, labelDim, tmpStyle = style;
            var labelRotation = radiusAxis.labelRotation;

            if (Math.abs(labelRotation) === 90 && BaseUtils.hasChn(tickContent)) {
                labelRotation = 360; // as a log
                tmpStyle = tbStyle;
            }

            rectDim = BaseUtils.getTextDimension(tickContent, tmpStyle, useHtml);
            labelDim = BaseUtils.getTextDimRotated(rectDim, labelRotation);

            if(useHtml){
                labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
            }

            return {
                tickValue:tickValue,
                tickContent:tickContent,
                tickDim:labelDim,
                tickRectDim:rectDim,
                labelRotation: labelRotation
            }
        },
        // calc tickLabels info for ervery radiusAxis
        _getCateTickValues : function () {
            if(!this._cateDataDomain){  
                return [];  
            }  
            var cateValueList = [];  
            var radiusAxis = this;  
            this._cateDomain.forEach(function (d, i) {  
                var cateLabel = [];  
                var start = radiusAxis._cateTickStart[i],  
                    step = radiusAxis._cateStep[i];  
                var max = d.domain[1];
                for(; start <=max; start = BaseUtils.accAdd(start, step)){  
                    cateLabel.push(start);  
                }  
                cateValueList.push({  
                    name : d.name,  
                    labels : cateLabel   
                })  
            })  
            return cateValueList;  
        },

        fixScaleAndTickData:function(){
            this.scale.domain(this._domain).range([0, this.polar.radius]);

            this._updateOriginTickData();
        },


        getRadiusPlotBands:function(){

            var plotBands = this._getPlotBands();

            var result = [];

            var self = this;

            plotBands.forEach(function(d){
                result.push({
                    path: self._getRadiusPlotBandsPath(d.from, d.to),
                    color: d.color
                });
            });

            return result;
        },

        _getRadiusPlotBandsPath: function (from, to) {

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {
                return this._getRadiusGridPath(Math.min(from, to)) + this._getRadiusGridPath(Math.max(from, to), true)
            } else {
                var arc = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI);
                return arc.innerRadius(this.scale(Math.min(from, to)))
                    .outerRadius(this.scale(Math.max(from, to)))();
            }

        },

        getPlotLines:function(){

            var plotLines = this.options.plotLines || [];
            var self = this;

            var result = [];
            plotLines.forEach(function(d){

                var text, style, align;
                if(d.label && d.label.text && d.label.style){
                    text = d.label.text;
                    style = d.label.style;
                    align = d.label.align;
                }

                result.push({
                    color: d.color,
                    value: d.value,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],
                    text:text,
                    baseY:-self.scale(d.value),
                    textAnchor:align == Constants.LEFT ? 'end' : 'start',
                    style:style
                });
            });

            return result;
        },

        // radius grids are circles
        _getRadiusGridPath: function (value, reversed) {

            var data = this._getRadiusGridData(value, reversed);

            return this._getRadiusGridPathByData(data);
        },

        _getRadiusGridData: function (value, reversed, scale) {

            var radiusScale = scale || this.scale;
            var angleAxis = this.polar.angleAxis;

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {

                var points = [];

                var cateScale = angleAxis.scale;
                var categories = cateScale.domain();

                categories.forEach(function(category){

                    var radian = cateScale(category) * angleAxis.piece;

                    var r = radiusScale(value);

                    points.push(BaseUtils.getArcPoint(r, radian));

                });

                if (reversed) {
                    points.reverse();
                }

                return points;

            } else {
                return radiusScale(value);
            }
        },

        _getRadiusGridPathByData: function(data) {

            if(BaseUtils.isArray(data)){

                var path = "";

                if(data.length){
                    for(var i = 0, count = data.length; i < count; i++){

                        var mOrl = i ? 'L' : 'M';

                        path += (mOrl + BaseUtils.dealFloatPrecision(data[i][0]) + "," + BaseUtils.dealFloatPrecision(data[i][1]));
                    }

                    path += 'Z';
                }

                return path;

            }else{

                var arc = PathGenerator.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                return arc.outerRadius(data)();
            }

        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add(vanchart.backGroup);
                renderer.clip(this.axisGroup.renderG, this.polar.clip);
            }

            // 
            if(this.series.length === 0){
                this.remove();
                return;
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawPlotBands(this.axisGroup);

            this.indicator ? this._drawCateGridLine(this.axisGroup) : this._drawGridLine(this.axisGroup);

            this._drawPlotLines(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            var radiusAxis = this;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var selection = this._bindData(this.gridLines, ticks);

            selection.exit.map(function (ele) {
                var d = ele.datum();
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                var curPos = radiusAxis._getRadiusGridData(d.tickValue);

                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}}).remove();
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.path()).datum(d);
            });

            this.gridLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var curPos = radiusAxis._getRadiusGridData(d.tickValue);

                ele.style({
                    fill: 'none',
                    'stroke': gridLineColor,
                    'stroke-width': gridLineWidth,
                    'opacity': 1
                });

                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}});

                return ele;
            });

        },

        _drawCateGridLine: function(axisGroup) { 
            var R = this.vanchart.renderer; 
            var radiusAxis = this; 
            var lastScale = radiusAxis.lastScale || radiusAxis._cateScale; 
            var cfg = radiusAxis.options; 
            var ticks = radiusAxis.cateTickData[0].tickData; 
 
            var gridLineColor = cfg.gridLineColor; 
            var gridLineWidth = cfg.gridLineWidth; 
            
            var domain = radiusAxis._cateDomain[0].domain; 
 
 
            if(!this.gridLinesGroup){ 
                this.gridLinesGroup = axisGroup.append(R.group()); 
                this.gridLines = []; 
            } 
            var gridLinesGroup = this.gridLinesGroup; 
 
            var selection = this._bindData(this.gridLines, ticks); 
            selection.exit.map(function (ele) {
                var d = ele.datum();
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                var curPos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);

                ele.animate({'attrTween':{'d':function(){
                    var interpolate = Interpolate(prePos, curPos);

                    return function (t) {
                        return radiusAxis._getRadiusGridPathByData(interpolate(t));
                    };
                }}}).remove();
            });

            var enter = selection.enter.map(function (d) { 
                return gridLinesGroup.append(R.path()).datum(d); 
            }); 
 
            this.gridLines = enter.concat(selection.update).map(function (ele) { 
                var d = ele.datum(); 

                lastScale.domain(domain); 
                var curPos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale); 
 
                ele.style({ 
                    fill: 'none', 
                    'stroke': gridLineColor, 
                    'stroke-width': gridLineWidth, 
                    'opacity': 1 
                }); 
                var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale); 
                ele.animate({'attrTween':{'d':function(){ 
                    var interpolate = Interpolate(prePos, curPos); 
 
                    return function (t) { 
                        return radiusAxis._getRadiusGridPathByData(interpolate(t)); 
                    }; 
                }}}); 
                return ele; 
            }); 
        }, 

        _drawPlotLines: function (axisGroup) {
            var R = this.vanchart.renderer;

            var plotLines = this.getPlotLines();

            if(!this.plotLinesGroup){
                this.plotLinesGroup = axisGroup.append(R.vgroup());
                this.plotLines = [];
            }
            var plotLinesGroup = this.plotLinesGroup;

            var selection = this._bindData(this.plotLines, plotLines);

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            var enter = selection.enter.map(function (d) {
                var path = plotLinesGroup.append(R.path().datum(d));
                if (d.text) {
                    path.text = plotLinesGroup.append(R.vtext());
                }
                return path;
            });

            this.plotLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var path = this._getRadiusGridPath(d.value);

                ele.style({
                    'fill': 'none',
                    'stroke': d.color,
                    'stroke-width': d.width,
                    'stroke-dasharray': d.dataArray
                }).animate({'attr':{'d':path}});

                ele.text && ele.text.textContent(d.text).style(d.style)
                    .attr({y: d.baseY});

                return ele;
            }, this);

        },

        _drawPlotBands: function (axisGroup) {
            var R = this.vanchart.renderer;

            var plotBands = this.getRadiusPlotBands();

            if(!this.plotBandsGroup){
                this.plotBandsGroup = axisGroup.append(R.group());
                this.plotBands = [];
            }
            var plotBandsGroup = this.plotBandsGroup;

            var selection = this._bindData(this.plotBands, plotBands);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return plotBandsGroup.append(R.path()).datum(d);
            });

            this.plotBands =
                enter.concat(selection.update).map(function (ele) {
                    var d = ele.datum();
                    ele.style('fill', d.color).animate({
                        'attr':{'d': d.path}
                    });
                    return ele;
            }, this);

        },

        _drawTickLabel:function(axisGroup){
            this.indicator ? this._drawCateSvgTickLabel(axisGroup) : this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            //
            var ticks = cfg.showLabel ? radiusAxis.getTickData().slice(0, -1) : [];

            var labelStyle = cfg.labelStyle;
            var useHtml = cfg.useHtml;

            var selection = this._bindData(this.tickLabels || [], ticks, function(d){return d.tickValue});
            this.tickLabels = [];

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
            }
            var tickLabelsGroup = this.tickLabelsGroup;

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                this.tickLabels = enter.concat(selection.update)
                    .map(function (ele) {
                        var d = ele.datum();

                        ele.textContent(d.tickContent).style(BaseUtils.clone(labelStyle));

                        var tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP_FUN(),
                            ty = -scale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                        var attr = {
                            transform: 'translate(' + tx + ' ' + ty + ')',
                            dy: '0.85em'
                        };

                        if (!useHtml) {

                            var rotateStr = (d.labelRotation % 360) ?
                                ele.vRotate(d.labelRotation).rotateStr : '';
                            attr.transform += rotateStr;

                            var _tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP_FUN(),
                                _ty = -lastScale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                            var lastAttr = {
                                transform: 'translate(' + _tx + ' ' + _ty + ')',
                                dy: '0.85em'
                            };
                            lastAttr.transform += rotateStr;

                            ele.attr(lastAttr).animate({'attr':attr});

                        } else {
                            ele.attr(attr);
                            ele.vRotate(d.labelRotation);
                        }
                        return ele;
                    });
            }
        },

        _drawCateSvgTickLabel : function (axisGroup) {  
            var R = this.vanchart.renderer;  
            var radiusAxis = this;  
            var lastScale = radiusAxis.lastScale || radiusAxis._cateScale;  
            var cfg = radiusAxis.options;  
            //  
            var ticks = radiusAxis.getTickData().slice(0, -1);  
  
            var labelStyle = cfg.labelStyle;  
            var useHtml = cfg.useHtml;  
  
            if(!this.cateTickLabelsGroup){  
                this.cateTickLabelsGroup = axisGroup.append(R.vgroup());  
                this.cateTickLabels = [];  
                this._cateDataDomain.forEach(function () {  
                    radiusAxis.cateTickLabels.push([]);  
                })  
            }  
            var tickLabelsGroup = this.cateTickLabelsGroup;  
  
            var cateSelection = [];  
  
            var getDir = function (x, y) {  
                var horizontal = x >= 0 ? 'RIGHT' : 'LEFT',  
                    vertical  = y >= 0 ? 'BOTTOM' : 'TOP';  
  
                return horizontal + '_' + vertical;  
            }  
  
            // label  
            var calcPostion = function (dir, x, y, rect_w, rect_h, dim_w, dim_h) {  
                  
                var gap = VALUE_TICK_GAP_FUN();  
                var _w = (rect_w + dim_w) / 2,  
                    _h = (rect_h + dim_h) / 2;  
                  
                switch(dir) {  
                    case 'LEFT_TOP' :  
                        _x = x + gap;  
                        _y = y + gap;  
                        break;  
                    case 'RIGHT_TOP' :  
                        _x = x - _w - gap;  
                        _y = y + gap;  
                        break;  
                    case 'RIGHT_BOTTOM' :  
                        _x = x + - _w - gap;  
                        _y = y - _h - gap;  
                        break;  
                    case 'LEFT_BOTTOM' :  
                        _x = x + gap;  
                        _y = y - _h - gap;  
                        break;  
                }  
                return {  
                    x : _x,  
                    y : _y  
                }  
            }  
            //   
            var gridLineEndPosData = this.series[0].angleAxis.getCateAngleGridLineData();  
            var labelLenArr = this.cateTickData.map(function (tick) {
                return tick.tickData.length;
            })
            
            var lastDomain = lastScale.domain(),
                lastRange = lastScale.range();

            this.cateTickData.forEach(function (tick, i){  
                var cateName = tick.name, pos;  
                var selection = radiusAxis._bindData(radiusAxis.cateTickLabels[i], tick.tickData, function(d) { return d.tickValue });  

                gridLineEndPosData.forEach(function (d) {  
                    if(d.name == cateName) {  
                        pos = d.pos;  
                    }  
                })      
                selection.exit.map(function (d) {  
                    d.remove();  
                });  
  
                var x0 = pos[0], y0 = pos[1], dir = getDir(x0, y0);  
  
                if(cfg.showLabel){  
                    var _enter = selection.enter.map(function (d) {  
                        return tickLabelsGroup.append(R.vtext(useHtml).datum(d));  
                    });  
  
                    radiusAxis.cateTickLabels[i] = _enter.concat(selection.update)  
                        .map(function (ele, j, labels) {  
                            var d = ele.datum();  
                            ele.textContent(d.tickContent).style(labelStyle);  
                            
                            // scale
                            lastScale.domain(radiusAxis._cateDomain[i].domain)
                            lastScale.range([0,x0]);
                            var _x0 = lastScale(d.tickValue);
                            lastScale.range([0,y0]);
                            var _y0 = lastScale(d.tickValue);

                            var _pos = calcPostion(dir, _x0, _y0, d.tickRectDim.width, d.tickRectDim.height, d.tickDim.width, d.tickDim.height);  
                            var tx = _pos.x,  
                                ty = _pos.y;  
  
                            var attr = {  
                                transform: 'translate(' + tx + ' ' + ty + ')',  
                                dy: '0.85em'  
                            };  
  
                            if (!useHtml) {  
  
                                var rotateStr = (d.labelRotation % 360) ?  
                                    ele.vRotate(d.labelRotation).rotateStr : '';  
                                attr.transform += rotateStr;  
  
                                var _tx = tx,  
                                    _ty = ty;  
  
                                var lastAttr = {  
                                    transform: 'translate(' + _tx + ' ' + _ty + ')',  
                                    dy: '0.85em'  
                                };  
                                lastAttr.transform += rotateStr;  
  
                                ele.attr(lastAttr).animate({'attr':attr});  
  
                            } else {  
                                ele.attr(attr);  
                                ele.vRotate(d.labelRotation);  
                            }  
                            return ele;  
                        });  
                }  
            })  

            lastScale.range(lastRange).domain(lastDomain);
        }
    });

    return RadiusAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/PolarAxis',['require','./Base','../utils/BaseUtils','../Constants','./Axis','./Polar','./AngleAxis','./RadiusAxis','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var Polar = require('./Polar');
    var AngleAxis = require('./AngleAxis');
    var RadiusAxis = require('./RadiusAxis');
    var ComponentLibrary = require('../ComponentLibrary');

    var PolarAxis = Axis.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //option
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else {
                    var AxisClass;
                    if (this.componentType === ComponentLibrary.POLAR_COMPONENT) {
                        AxisClass = Polar;
                    } else {

                        var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                        if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                            AxisClass = RadiusAxis;
                        } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                            AxisClass = AngleAxis;
                        }
                    }

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }

            }
        },

        doLayout: function () {
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].doLayout();
            }
        },

        render:function(){
           this._axisList.map(function (axis) {
               if (axis.componentType === ComponentLibrary.POLAR_COMPONENT) {
                   axis.render();
               }
           });
        }

    });

    ComponentLibrary.register(ComponentLibrary.RADIUS_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.ANGLE_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.POLAR_COMPONENT, PolarAxis);

    return PolarAxis;
});
/**
 * Created by eason on 15/5/4.
 * 
 */
define('component/Title',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 8;

    var PADDING_FUN = function() {
        return BaseUtils.paddingConvertWithScale(PADDING);
    };

    var Title = Base.extend({

        doLayout:function(){

            var cfg = this.options;

            if(!cfg.text){
                return;
            }

            var originBounds = this.vanchart.bounds;

            var remainWidth = originBounds.width;
            var remainHeight = originBounds.height;

            var textDim;

            // get maximal area
            if (this.isFloat) {

                remainWidth -= (this._floatX - originBounds.x);
                remainHeight -= (this._floatY - originBounds.y);

            } else {

                var toolbar = this.vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];
                this.initBarWidth = toolbar && toolbar.getToolBarInitWidth() || 0;
                remainWidth -= this.initBarWidth;

                if (cfg.align === 'center') {
                    remainWidth -= this.initBarWidth;
                }
            }

            // cut padding to place text
            remainWidth -= 2 * PADDING_FUN();
            remainHeight -= 2 * PADDING_FUN();

            // try to get minimal text width
            textDim = BaseUtils.getTextDimension(cfg.text, cfg.style, cfg.useHtml);

            // wrap text when too long
            if (textDim.width > remainWidth) {
                var newStyle = BaseUtils.clone(cfg.style);
                newStyle.width = Math.max(remainWidth, 0) + 'px';
                textDim = BaseUtils.getTextWrapDimension(cfg.text, newStyle, cfg.useHtml);
            } else {
                textDim.width += 0.5;
            }

            // title and text height are the same and should be minimal
            textDim.height = Math.min(this._maxHeight(), remainHeight, textDim.height);

            var doublePadding = 2 * PADDING_FUN();

            // heightbounds.height+2*padding
            var height = Math.min(this._maxHeight(), remainHeight + doublePadding, textDim.height + doublePadding);

            // while widths are different
            // floating title width is text width
            // fixed title width remains plot width; cut toolbar is text width


            if (this.isFloat) {

                this.bounds = {
                    x: this._floatX,
                    y: this._floatY,
                    // contract floating title's background width
                    width: textDim.width + 2 * PADDING_FUN(),
                    height: height
                };

            } else {

                this._setComponentBounds(Constants.TOP, height === 0 ? 0 : (height+ 0.5 * PADDING_FUN()));
                this.bounds.height = height;
            }

            // 
            var textTranslateY = (height - textDim.height) / 2;

            if (this.isFloat) {
                this.textBounds = {x:PADDING_FUN(), y: textTranslateY, width: textDim.width, height:textDim.height};
            } else {
                var x;
                switch (cfg.align) {
                    case 'right':
                        x = remainWidth - textDim.width;
                        break;
                    case 'center':
                        x = this.bounds.width / 2 - textDim.width / 2;
                        break;
                    case 'left':
                    default:
                        x = this.bounds.x + PADDING_FUN();
                }
                this.textBounds = {
                    x: x,
                    y: textTranslateY,
                    width: textDim.width,
                    height: textDim.height
                };
            }

            if (cfg.useHtml) {
                this.labels = [];
                this.labels.push({
                    text: cfg.text,
                    dim: textDim,
                    style: cfg.style
                });
            } else {
                var texts = BaseUtils.splitText(cfg.text, cfg.style, this.textBounds.width);
                this.labels = texts.map(function (text) {
                    return {
                        text: text,
                        dim: BaseUtils.getTextDimension(text, cfg.style, cfg.useHtml),
                        style: cfg.style
                    }
                });
            }
        },

        render: function () {

            if(!this.textBounds || this.textBounds.width < 0 || this.textBounds.height < 0){
                this.remove();
                return;
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.titleGroup){
                this.titleGroup = renderer.vgroup();

                //addcomponentGrouptoolbar
                this.titleGroup.renderG.addTo(this.isFloat ? vanchart.frontGroup : vanchart.backGroup);
                this.titleGroup.divG.add();

                this.titleGroup.divG.style('pointer-events', 'auto');
            }

            this.titleGroup.attr('transform', BaseUtils.makeTranslate([this.bounds.x, this.bounds.y]));

            this._innerClip(this.titleGroup);

            // use renderG to avoid style on div
            this.drawBackground(this.titleGroup.renderG);

            this.drawTitle(this.titleGroup);
        },

        drawBackground: function (titleGroup) {
            var cfg = this.options, bounds = this.bounds;
            if (cfg.backgroundColor) {
                this.vanchart._renderRectangleBackground(titleGroup, cfg, {x:0, y:0, width:bounds.width, height:bounds.height});
            }
        },

        drawTitle: function (titleGroup) {

            if (this.text) {
                this.text.remove();
                this.text = null;
            }

            var R = this.vanchart.renderer;

            var cfg = this.options;
            var textBounds = this.textBounds;
            var useHtml = cfg.useHtml;
            var align = cfg.align;

            var text = R.vtext(useHtml).attr({
                'transform': BaseUtils.makeTranslate([textBounds.x, textBounds.y]),
                'width': textBounds.width + 'px',
                'text-align': align,
                'white-space': 'normal'
            });

            this.text = text;

            var svgOffset = useHtml ? {} :
                BaseUtils.isMS ? {'dy': '1em'} :
                {'dominant-baseline': 'central', 'dy': textBounds.height/this.labels.length/2};

            var y = 0;
            this.labels.map(function (label) {
                var dx, labelDim = label.dim;
                switch (align) {
                    case Constants.LEFT:
                        dx = 0;
                        break;
                    case Constants.RIGHT:
                        dx = textBounds.width - labelDim.width;
                        break;
                    case Constants.CENTER:
                    default:
                        dx = (textBounds.width - labelDim.width)/2;
                }
                text.append(
                    R.vtspan(useHtml)
                        .attr({
                            'y': y,
                            'x': 0,
                            'dx': dx
                        })
                        .attr(svgOffset)
                        .textContent(label.text)
                        .style(label.style)
                        // .style('outline','1px solid #aaa')//
                );

                y += (labelDim.height);
            });

            titleGroup.append(text);
        },

        remove:function(){
            this.titleGroup && this.titleGroup.remove();
            this._clip && this._clip.remove && this._clip.remove();  // VmlRender_clipremove
            this.titleGroup = this._clip = null;
        }
    });
    ComponentLibrary.register(ComponentLibrary.TITLE_COMPONENT, Title);

    return Title;
});
/**
 * Created by eason on 2017/2/9.
 */

define('utils/GeoUtils',['require','./Bounds'],function(require){

    var Bounds = require('./Bounds');

    var d3_geo_streamObjectType = {
        Feature: function(feature, pointsArray) {
            d3_geo_streamGeometry(feature.geometry, pointsArray);
        },
        FeatureCollection: function(object, pointsArray) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) { d3_geo_streamGeometry(features[i].geometry, pointsArray) }
        }
    };

    function d3_geo_streamGeometry(geometry, pointsArray) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, pointsArray);
        }
    }

    var d3_geo_streamGeometryType = {
        Point: function(object, pointsArray) {
            pointsArray.push(object.coordinates);
        },
        MultiPoint: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { object = coordinates[i]; pointsArray.push(object); }
        },
        LineString: function(object, pointsArray) {
            d3_geo_streamLine(object.coordinates, pointsArray);
        },
        MultiLineString: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { d3_geo_streamLine(coordinates[i], pointsArray) }
        },
        Polygon: function(object, pointsArray) {
            d3_geo_streamPolygon(object.coordinates, pointsArray);
        },
        MultiPolygon: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) { d3_geo_streamPolygon(coordinates[i], pointsArray) }
        },
        GeometryCollection: function(object, pointsArray) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) { d3_geo_streamGeometry(geometries[i], pointsArray) }
        }
    };
    function d3_geo_streamLine(coordinates, pointsArray) {
        var i = -1, n = coordinates.length, coordinate;
        while (++i < n) { coordinate = coordinates[i]; pointsArray.push(coordinate) }
    }

    function d3_geo_streamPolygon(coordinates, pointsArray) {
        var i = -1, n = coordinates.length;
        while (++i < n) { d3_geo_streamLine(coordinates[i], pointsArray) }
    }

    function getAllPoints(object) {
        var allPoints = [];
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, allPoints);
        } else {
            d3_geo_streamGeometry(object, allPoints);
        }

        return allPoints;
    }

    function scaleGeo(geoJson, scale){
        var features = geoJson.features;
        for(var i = 0, len = features.length; i < len; i++){
            var center = features[i].properties.center;
            if(center){
                center[0] *= scale;
                center[1] *= scale;
            }
        }
        var points = getAllPoints(geoJson);
        for(var i = 0, len = points.length; i < len; i++){
            points[i][0] *= scale;
            points[i][1] *= scale;
        }
    }

    function bounds(geoJson){
        var bounds = new Bounds(getAllPoints(geoJson));
        return [[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]];
    }

    return {
        'getAllPoints':getAllPoints,
        'scaleGeo':scaleGeo,
        'bounds':bounds
    }

});
/**
 * Created by eason on 2017/2/6.
 */

define('chart/map/layer/ImageOverlay',['require','./../../../vector/Layer','../LatLngBounds','../../../utils/BaseUtils','../../../dom/DomUtils','../../../utils/Bounds'],function(require){

    var Layer = require('./../../../vector/Layer');
    var LatLngBounds = require('../LatLngBounds');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var Bounds = require('../../../utils/Bounds');

    var ImageOverlay = Layer.extend({

        // @section
        // @aka ImageOverlay options
        options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,

            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: '',

            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,

            // @option crossOrigin: Boolean = false
            // If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
            crossOrigin: false
        },

        initialize: function (url, bounds, options){ // (String, LatLngBounds, Object)
            this._url = url;
            this._bounds = LatLngBounds.create(bounds);
            BaseUtils.setOptions(this, options);
        },

        onAdd: function () {
            if (!this._image) {
                this._initImage();

                if (this.options.opacity < 1) {
                    this._updateOpacity();
                }
            }

            this.getPane().appendChild(this._image);
            this._reset();
        },

        onRemove: function () {
            DomUtils.remove(this._image);
            if (this.options.interactive) {
                this.removeInteractiveTarget(this._image);
            }
        },

        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function (opacity) {
            this.options.opacity = opacity;

            if (this._image) {
                this._updateOpacity();
            }
            return this;
        },

        setStyle: function (styleOpts) {
            if (styleOpts.opacity) {
                this.setOpacity(styleOpts.opacity);
            }
            return this;
        },

        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function () {
            if (this._map) {
                DomUtils.toFront(this._image);
            }
            return this;
        },

        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function () {
            if (this._map) {
                DomUtils.toBack(this._image);
            }
            return this;
        },

        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function (url) {
            this._url = url;

            if (this._image) {
                this._image.src = url;
            }
            return this;
        },

        setBounds: function (bounds) {
            this._bounds = bounds;

            if (this._map) {
                this._reset();
            }
            return this;
        },

        getEvents: function () {
            var events = {
                zoom: this._reset,
                viewreset: this._reset
            };

            if (this._zoomAnimated) {
                events.zoomanim = this._animateZoom;
            }

            return events;
        },

        getBounds: function () {
            return this._bounds;
        },

        _initImage: function () {
            var img = this._image = DomUtils.create('img',
                'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

            img.onselectstart = BaseUtils.falseFn;
            img.onmousemove = BaseUtils.falseFn;

            img.onload = BaseUtils.bind(this.fire, this, 'load');

            if (this.options.crossOrigin) {
                img.crossOrigin = '';
            }

            img.src = this._url;
            img.alt = this.options.alt;
        },

        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

            DomUtils.setTransform(this._image, offset, scale);
        },

        _reset: function () {
            var image = this._image,
                bounds = new Bounds(
                    this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                size = bounds.getSize();

            DomUtils.setPosition(image, bounds.min);

            image.style.width  = size.x + 'px';
            image.style.height = size.y + 'px';
        },

        _updateOpacity: function () {
            DomUtils.setOpacity(this._image, this.options.opacity);
        }

    });

    return ImageOverlay;
});
/**
 * Created by eason on 2017/1/20.
 */

define('chart/map/layer/GridLayer',['require','./../../../vector/Layer','../../../utils/BaseUtils','../../../dom/DomUtils','../../../dom/Browser','../../../utils/Point2D','../../../utils/Bounds','../LatLngBounds'],function(require){

    var Layer = require('./../../../vector/Layer');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var Browser = require('../../../dom/Browser');
    var Point = require('../../../utils/Point2D');
    var Bounds = require('../../../utils/Bounds');
    var LatLngBounds = require('../LatLngBounds');


    var GridLayer = Layer.extend({

        // @section
        // @aka GridLayer options
        options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,

            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,

            // @option updateWhenIdle: Boolean = depends
            // If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
            updateWhenIdle: Browser.mobile,

            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,

            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,

            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,

            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,

            // @option minZoom: Number = 0
            // The minimum zoom level that tiles will be loaded at. By default the entire map.
            minZoom: 0,

            // @option maxZoom: Number = undefined
            // The maximum zoom level that tiles will be loaded at.
            maxZoom: undefined,

            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around.
            noWrap: false,

            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: 'tilePane',

            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: '',

            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        onAdd: function () {
            this._initContainer();

            this._levels = {};
            this._tiles = {};

            this._resetView();
            this._update();
        },

        beforeAdd: function (map) {
            map._addZoomLimit(this);
        },

        onRemove: function (map) {
            this._removeAllTiles();
            DomUtils.remove(this._container);
            map._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = null;
        },

        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function () {
            if (this._map) {
                DomUtils.toFront(this._container);
                this._setAutoZIndex(Math.max);
            }
            return this;
        },

        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function () {
            if (this._map) {
                DomUtils.toBack(this._container);
                this._setAutoZIndex(Math.min);
            }
            return this;
        },

        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function () {
            return this._container;
        },

        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function (opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },

        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function (zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();

            return this;
        },

        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function () {
            return this._loading;
        },

        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function () {
            if (this._map) {
                this._removeAllTiles();
                this._update();
            }
            return this;
        },

        getEvents: function () {
            var events = {
                viewprereset: this._invalidateAll,
                viewreset: this._resetView,
                zoom: this._resetView,
                panend: this._onPanEnd,
                resize:this._onResize
            };

            if (!this.options.updateWhenIdle) {
                // update tiles on move, but not more often than once per given interval
                if (!this._onPanMove) {
                    this._onPanMove = BaseUtils.throttle(this._onPanEnd, this.options.updateInterval, this);
                }

                events.panmove = this._onPanMove;
            }

            if (this._zoomAnimated) {
                events.zoomanim = this._animateZoom;
            }

            return events;
        },

        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overriden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function () {
            return document.createElement('div');
        },

        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function () {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
        },

        _updateZIndex: function () {
            if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
                this._container.style.zIndex = this.options.zIndex;
            }
        },

        _setAutoZIndex: function (compare) {
            // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

            var layers = this.getPane().children,
                edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

            for (var i = 0, len = layers.length, zIndex; i < len; i++) {

                zIndex = layers[i].style.zIndex;

                if (layers[i] !== this._container && zIndex) {
                    edgeZIndex = compare(edgeZIndex, +zIndex);
                }
            }

            if (isFinite(edgeZIndex)) {
                this.options.zIndex = edgeZIndex + compare(-1, 1);
                this._updateZIndex();
            }
        },

        _updateOpacity: function () {
            if (!this._map) { return; }

            // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
            if (Browser.ielt9) { return; }

            DomUtils.setOpacity(this._container, this.options.opacity);

            var now = +new Date(),
                nextFrame = false,
                willPrune = false;

            for (var key in this._tiles) {
                var tile = this._tiles[key];
                if (!tile.current || !tile.loaded) { continue; }

                var fade = Math.min(1, (now - tile.loaded) / 200);

                DomUtils.setOpacity(tile.el, fade);
                if (fade < 1) {
                    nextFrame = true;
                } else {
                    if (tile.active) { willPrune = true; }
                    tile.active = true;
                }
            }

            if (willPrune && !this._noPrune) { this._pruneTiles(); }

            if (nextFrame) {
                BaseUtils.cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = BaseUtils.requestAnimFrame(this._updateOpacity, this);
            }
        },

        _initContainer: function () {
            if (this._container) { return; }

            this._container = DomUtils.create('div', 'leaflet-layer ' + (this.options.className || ''));
            this._updateZIndex();

            if (this.options.opacity < 1) {
                this._updateOpacity();
            }

            this.getPane().appendChild(this._container);
        },

        _updateLevels: function () {

            var zoom = this._tileZoom,
                maxZoom = this.options.maxZoom;

            if (zoom === undefined) { return undefined; }

            for (var z in this._levels) {
                if (this._levels[z].el.children.length || z === zoom) {
                    this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
                } else {
                    DomUtils.remove(this._levels[z].el);
                    this._removeTilesAtZoom(z);
                    delete this._levels[z];
                }
            }

            var level = this._levels[zoom],
                map = this._map;

            if (!level) {
                level = this._levels[zoom] = {};

                level.el = DomUtils.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
                level.el.style.zIndex = maxZoom;

                level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
                level.zoom = zoom;

                this._setZoomTransform(level, map.getCenter(), map.getZoom());

                // force the browser to consider the newly added element for transition
                BaseUtils.falseFn(level.el.offsetWidth);
            }

            this._level = level;

            return level;
        },

        _pruneTiles: function () {
            if (!this._map) {
                return;
            }

            var key, tile;

            var zoom = this._map.getZoom();
            if (zoom > this.options.maxZoom ||
                zoom < this.options.minZoom) {
                this._removeAllTiles();
                return;
            }

            for (key in this._tiles) {
                tile = this._tiles[key];
                tile.retain = tile.current;
            }

            for (key in this._tiles) {
                tile = this._tiles[key];
                if (tile.current && !tile.active) {
                    var coords = tile.coords;
                    if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                        this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                    }
                }
            }

            for (key in this._tiles) {
                if (!this._tiles[key].retain) {
                    this._removeTile(key);
                }
            }
        },

        _removeTilesAtZoom: function (zoom) {
            for (var key in this._tiles) {
                if (this._tiles[key].coords.z !== zoom) {
                    continue;
                }
                this._removeTile(key);
            }
        },

        _removeAllTiles: function () {
            for (var key in this._tiles) {
                this._removeTile(key);
            }
        },

        _invalidateAll: function () {
            for (var z in this._levels) {
                DomUtils.remove(this._levels[z].el);
                delete this._levels[z];
            }
            this._removeAllTiles();

            this._tileZoom = null;
        },

        _retainParent: function (x, y, z, minZoom) {
            var x2 = Math.floor(x / 2),
                y2 = Math.floor(y / 2),
                z2 = z - 1,
                coords2 = new Point(+x2, +y2);
            coords2.z = +z2;

            var key = this._tileCoordsToKey(coords2),
                tile = this._tiles[key];

            if (tile && tile.active) {
                tile.retain = true;
                return true;

            } else if (tile && tile.loaded) {
                tile.retain = true;
            }

            if (z2 > minZoom) {
                return this._retainParent(x2, y2, z2, minZoom);
            }

            return false;
        },

        _retainChildren: function (x, y, z, maxZoom) {

            for (var i = 2 * x; i < 2 * x + 2; i++) {
                for (var j = 2 * y; j < 2 * y + 2; j++) {

                    var coords = new Point(i, j);
                    coords.z = z + 1;

                    var key = this._tileCoordsToKey(coords),
                        tile = this._tiles[key];

                    if (tile && tile.active) {
                        tile.retain = true;
                        continue;

                    } else if (tile && tile.loaded) {
                        tile.retain = true;
                    }

                    if (z + 1 < maxZoom) {
                        this._retainChildren(i, j, z + 1, maxZoom);
                    }
                }
            }
        },

        _resetView: function (e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },

        _animateZoom: function (e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
        },

        _setView: function (center, zoom, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom);
            if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
                (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
                tileZoom = undefined;
            }

            var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

            if (!noUpdate || tileZoomChanged) {

                this._tileZoom = tileZoom;

                if (this._abortLoading) {
                    this._abortLoading();
                }

                this._updateLevels();
                this._resetGrid();

                if (tileZoom !== undefined) {
                    this._update(center);
                }

                if (!noPrune) {
                    this._pruneTiles();
                }

                // Flag to prevent _updateOpacity from pruning tiles during
                // a zoom anim or a pinch gesture
                this._noPrune = !!noPrune;
            }

            this._setZoomTransforms(center, zoom);
        },

        _setZoomTransforms: function (center, zoom) {
            for (var i in this._levels) {
                this._setZoomTransform(this._levels[i], center, zoom);
            }
        },

        _setZoomTransform: function (level, center, zoom) {
            var scale = this._map.getZoomScale(zoom, level.zoom),
                translate = level.origin.multiplyBy(scale)
                    .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

            if (Browser.any3d) {
                DomUtils.setTransform(level.el, translate, scale);
            } else {
                DomUtils.setPosition(level.el, translate);
            }
        },

        _resetGrid: function () {
            var map = this._map,
                crs = map.options.crs,
                tileSize = this._tileSize = this.getTileSize(),
                tileZoom = this._tileZoom;

            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
                this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }

            this._wrapX = crs.wrapLng && !this.options.noWrap && [
                    Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
                    Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
                ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
                    Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
                    Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
                ];
        },

        _onPanEnd: function () {
            if (!this._map || this._map._animatingZoom) { return; }
            this._update();
        },

        _onResize: function () {
            this._update();
        },

        _getTiledPixelBounds: function (center) {
            var map = this._map,
                mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
                scale = map.getZoomScale(mapZoom, this._tileZoom),
                pixelCenter = map.project(center, this._tileZoom).floor(),
                halfSize = map.getSize().divideBy(scale * 2);

            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },

        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function (center) {
            var map = this._map;
            if (!map) { return; }
            var zoom = map.getZoom();

            if (center === undefined) { center = map.getCenter(); }
            if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

            var pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                tileCenter = tileRange.getCenter(),
                queue = [],
                margin = this.options.keepBuffer,
                noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
                    tileRange.getTopRight().add([margin, -margin]));

            for (var key in this._tiles) {
                var c = this._tiles[key].coords;
                if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                    this._tiles[key].current = false;
                }
            }

            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

            // create a queue of coordinates to load tiles from
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
                for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                    var coords = new Point(i, j);
                    coords.z = this._tileZoom;

                    if (!this._isValidTile(coords)) { continue; }

                    var tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        queue.push(coords);
                    }
                }
            }

            // sort tile queue to load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });

            if (queue.length !== 0) {
                // if it's the first batch of tiles to load
                if (!this._loading) {
                    this._loading = true;
                    // @event loading: Event
                    // Fired when the grid layer starts loading tiles.
                    this.fire('loading');
                }

                // create DOM fragment to append tiles in one batch
                var fragment = document.createDocumentFragment();

                for (i = 0; i < queue.length; i++) {
                    this._addTile(queue[i], fragment);
                }

                this._level.el.appendChild(fragment);
            }
        },

        _isValidTile: function (coords) {
            var crs = this._map.options.crs;

            if (!crs.infinite) {
                // don't load tile if it's out of bounds and not wrapped
                var bounds = this._globalTileRange;
                if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
                    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
            }

            if (!this.options.bounds) { return true; }

            // don't load tile if it doesn't intersect the bounds in options
            var tileBounds = this._tileCoordsToBounds(coords);
            return LatLngBounds.create(this.options.bounds).overlaps(tileBounds);
        },

        _keyToBounds: function (key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },

        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function (coords) {

            var map = this._map,
                tileSize = this.getTileSize(),

                nwPoint = coords.scaleBy(tileSize),
                sePoint = nwPoint.add(tileSize),

                nw = map.unproject(nwPoint, coords.z),
                se = map.unproject(sePoint, coords.z);

            if (!this.options.noWrap) {
                nw = map.wrapLatLng(nw);
                se = map.wrapLatLng(se);
            }

            return new LatLngBounds(nw, se);
        },

        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function (coords) {
            return coords.x + ':' + coords.y + ':' + coords.z;
        },

        // converts tile cache key to coordinates
        _keyToTileCoords: function (key) {
            var k = key.split(':'),
                coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
        },

        _removeTile: function (key) {
            var tile = this._tiles[key];
            if (!tile) { return; }

            DomUtils.remove(tile.el);

            delete this._tiles[key];

            // @event tileunload: TileEvent
            // Fired when a tile is removed (e.g. when a tile goes off the screen).
            this.fire('tileunload', {
                tile: tile.el,
                coords: this._keyToTileCoords(key)
            });
        },

        _initTile: function (tile) {
            DomUtils.addClass(tile, 'leaflet-tile');

            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + 'px';
            tile.style.height = tileSize.y + 'px';

            tile.onselectstart = BaseUtils.falseFn;
            tile.onmousemove = BaseUtils.falseFn;

            // update opacity on tiles in IE7-8 because of filter inheritance problems
            if (Browser.ielt9 && this.options.opacity < 1) {
                DomUtils.setOpacity(tile, this.options.opacity);
            }

            // without this hack, tiles disappear after zoom on Chrome for Android
            // https://github.com/Leaflet/Leaflet/issues/2078
            if (Browser.android && !Browser.android23) {
                tile.style.WebkitBackfaceVisibility = 'hidden';
            }
        },

        _addTile: function (coords, container) {
            var tilePos = this._getTilePos(coords),
                key = this._tileCoordsToKey(coords);

            var tile = this.createTile(this._wrapCoords(coords), BaseUtils.bind(this._tileReady, this, coords));

            this._initTile(tile);

            // if createTile is defined with a second argument ("done" callback),
            // we know that tile is async and will be ready later; otherwise
            if (this.createTile.length < 2) {
                // mark tile as ready, but delay one frame for opacity animation to happen
                BaseUtils.requestAnimFrame(BaseUtils.bind(this._tileReady, this, coords, null, tile));
            }

            DomUtils.setPosition(tile, tilePos);

            // save tile in cache
            this._tiles[key] = {
                el: tile,
                coords: coords,
                current: true
            };

            container.appendChild(tile);
            // @event tileloadstart: TileEvent
            // Fired when a tile is requested and starts loading.
            this.fire('tileloadstart', {
                tile: tile,
                coords: coords
            });
        },

        _tileReady: function (coords, err, tile) {
            if (!this._map) { return; }

            if (err) {
                // @event tileerror: TileErrorEvent
                // Fired when there is an error loading a tile.
                this.fire('tileerror', {
                    error: err,
                    tile: tile,
                    coords: coords
                });
            }

            var key = this._tileCoordsToKey(coords);

            tile = this._tiles[key];
            if (!tile) { return; }

            tile.loaded = +new Date();
            if (this._map._fadeAnimated) {
                DomUtils.setOpacity(tile.el, 0);
                BaseUtils.cancelAnimFrame(this._fadeFrame);
                this._fadeFrame = BaseUtils.requestAnimFrame(this._updateOpacity, this);
            } else {
                tile.active = true;

                if(!this._map.options.toPhantom){
                    this._pruneTiles();
                }
            }

            if (!err) {
                DomUtils.addClass(tile.el, 'leaflet-tile-loaded');

                // @event tileload: TileEvent
                // Fired when a tile loads.
                this.fire('tileload', {
                    tile: tile.el,
                    coords: coords
                });
            }

            if (this._noTilesToLoad()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');

                if(this._map.options.toPhantom){

                    window.console && console.log('done');

                }else{
                    if (Browser.ielt9 || !this._map._fadeAnimated) {
                        BaseUtils.requestAnimFrame(this._pruneTiles, this);
                    } else {
                        // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                        // to trigger a pruning.
                        setTimeout(BaseUtils.bind(this._pruneTiles, this), 250);
                    }
                }


            }
        },

        _getTilePos: function (coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },

        _wrapCoords: function (coords) {
            var newCoords = new Point(
                this._wrapX ? BaseUtils.wrapNum(coords.x, this._wrapX) : coords.x,
                this._wrapY ? BaseUtils.wrapNum(coords.y, this._wrapY) : coords.y);
            newCoords.z = coords.z;
            return newCoords;
        },

        _pxBoundsToTileRange: function (bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
                bounds.min.unscaleBy(tileSize).floor(),
                bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
        },

        _noTilesToLoad: function () {
            for (var key in this._tiles) {
                if (!this._tiles[key].loaded) { return false; }
            }
            return true;
        }
    });


    return GridLayer;
});
/**
 * Created by eason on 2017/1/20.
 */

define('chart/map/layer/TileLayer',['require','./GridLayer','../../../utils/BaseUtils','../../../dom/DomUtils','../CRS','../../../dom/Browser'],function(require){

    var GridLayer = require('./GridLayer');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');
    var CRS = require('../CRS');
    var Browser = require('../../../dom/Browser');
    var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

    var TileLayer = GridLayer.extend({

        // @section
        // @aka TileLayer options
        options: {
            // @option minZoom: Number = 0
            // Minimum zoom number.
            minZoom: 0,

            // @option maxZoom: Number = 18
            // Maximum zoom number.
            maxZoom: 18,

            // @option maxNativeZoom: Number = null
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: null,

            // @option minNativeZoom: Number = null
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: null,

            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: 'abc',

            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: '',

            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,

            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,

            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,

            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,

            // @option crossOrigin: Boolean = false
            // If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
            crossOrigin: false
        },

        initialize: function (url, options) {

            this._url = url;

            options = BaseUtils.setOptions(this, options);

            // detecting retina displays, adjusting tileSize and zoom levels
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

                options.tileSize = Math.floor(options.tileSize / 2);

                if (!options.zoomReverse) {
                    options.zoomOffset++;
                    options.maxZoom--;
                } else {
                    options.zoomOffset--;
                    options.minZoom++;
                }

                options.minZoom = Math.max(0, options.minZoom);
            }

            if (typeof options.subdomains === 'string') {
                options.subdomains = options.subdomains.split('');
            }

            // for https://github.com/Leaflet/Leaflet/issues/137
            // if (!Browser.android) {
            //     this.on('tileunload', this._onTileRemove);
            // }
        },

        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        setUrl: function (url, noRedraw) {
            this._url = url;

            if (!noRedraw) {
                this.redraw();
            }
            return this;
        },

        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function (coords, done) {
            var tile = document.createElement('img');

            VanHammer.on(tile, 'load', BaseUtils.bind(this._tileOnLoad, this, done, tile));
            VanHammer.on(tile, 'error', BaseUtils.bind(this._tileOnError, this, done, tile));

            if (this.options.crossOrigin) {
                tile.crossOrigin = '';
            }

            /*
             Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
             http://www.w3.org/TR/WCAG20-TECHS/H67
             */
            tile.alt = '';

            /*
             Set role="presentation" to force screen readers to ignore this
             https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
             */
            tile.setAttribute('role', 'presentation');

            tile.src = this.getTileUrl(coords);

            return tile;
        },

        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function (coords) {
            var data = {
                r: Browser.retina ? '@2x' : '',
                s: this._getSubdomain(coords),
                x: coords.x,
                y: coords.y,
                z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
                var invertedY = this._globalTileRange.max.y - coords.y;
                if (this.options.tms) {
                    data['y'] = invertedY;
                }
                data['-y'] = invertedY;
            }

            return BaseUtils.template(this._url, BaseUtils.extend(data, this.options));
        },

        _tileOnLoad: function (done, tile) {
            // For https://github.com/Leaflet/Leaflet/issues/3332
            if (Browser.ielt9) {
                setTimeout(BaseUtils.bind(done, this, null, tile), 0);
            } else {
                done(null, tile);
            }
        },

        _tileOnError: function (done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl) {
                tile.src = errorUrl;
            }
            done(e, tile);
        },

        getTileSize: function () {
            var map = this._map,
                tileSize = GridLayer.prototype.getTileSize.call(this),
                zoom = this._tileZoom + this.options.zoomOffset,
                minNativeZoom = this.options.minNativeZoom,
                maxNativeZoom = this.options.maxNativeZoom;

            // decrease tile size when scaling below minNativeZoom
            if (minNativeZoom !== null && zoom < minNativeZoom) {
                return tileSize.divideBy(map.getZoomScale(minNativeZoom, zoom)).round();
            }

            // increase tile size when scaling above maxNativeZoom
            if (maxNativeZoom !== null && zoom > maxNativeZoom) {
                return tileSize.divideBy(map.getZoomScale(maxNativeZoom, zoom)).round();
            }

            return tileSize;
        },

        _onTileRemove: function (e) {
            e.tile.onload = null;
        },

        _getZoomForUrl: function () {
            var zoom = this._tileZoom,
                maxZoom = this.options.maxZoom,
                zoomReverse = this.options.zoomReverse,
                zoomOffset = this.options.zoomOffset,
                minNativeZoom = this.options.minNativeZoom,
                maxNativeZoom = this.options.maxNativeZoom;

            if (zoomReverse) {
                zoom = maxZoom - zoom;
            }

            zoom += zoomOffset;

            if (minNativeZoom !== null && zoom < minNativeZoom) {
                return minNativeZoom;
            }

            if (maxNativeZoom !== null && zoom > maxNativeZoom) {
                return maxNativeZoom;
            }

            return zoom;
        },

        _getSubdomain: function (tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },

        // stops loading all tiles in the background layer
        _abortLoading: function () {
            var i, tile;
            for (i in this._tiles) {
                if (this._tiles[i].coords.z !== this._tileZoom) {
                    tile = this._tiles[i].el;

                    tile.onload = BaseUtils.falseFn;
                    tile.onerror = BaseUtils.falseFn;

                    if (!tile.complete) {
                        tile.src = emptyImageUrl;
                        DomUtils.remove(tile);
                    }
                }
            }
        }
    });

    TileLayer.WMS = TileLayer.extend({

        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
            service: 'WMS',
            request: 'GetMap',

            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: '',

            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: '',

            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: 'image/jpeg',

            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,

            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: '1.1.1'
        },

        options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,

            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
        },

        initialize: function (url, options) {

            this._url = url;

            var wmsParams = BaseUtils.extend({}, this.defaultWmsParams);

            // all keys that are not TileLayer options go to WMS params
            for (var i in options) {
                if (!(i in this.options)) {
                    wmsParams[i] = options[i];
                }
            }

            options = BaseUtils.setOptions(this, options);

            wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && Browser.retina ? 2 : 1);

            this.wmsParams = wmsParams;
        },

        onAdd: function (map) {

            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);

            var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
            this.wmsParams[projectionKey] = this._crs.code;

            TileLayer.prototype.onAdd.call(this, map);
        },

        getTileUrl: function (coords) {

            var tileBounds = this._tileCoordsToBounds(coords),
                nw = this._crs.project(tileBounds.getNorthWest()),
                se = this._crs.project(tileBounds.getSouthEast()),

                bbox = (this._wmsVersion >= 1.3 && this._crs === CRS.EPSG4326 ?
                    [se.y, nw.x, nw.y, se.x] :
                    [nw.x, se.y, se.x, nw.y]).join(','),

                url = TileLayer.prototype.getTileUrl.call(this, coords);

            return url +
                BaseUtils.getParamString(this.wmsParams, url, this.options.uppercase) +
                (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
        },

        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function (params, noRedraw) {

            BaseUtils.extend(this.wmsParams, params);

            if (!noRedraw) {
                this.redraw();
            }

            return this;
        }
    });

    return TileLayer;

});
/**
 * Created by eason on 2017/2/6.
 */
define('chart/map/layer/Control',['require','../../../utils/Class','../../../utils/BaseUtils','../../../dom/DomUtils'],function(require){

    var Class = require('../../../utils/Class');
    var BaseUtils = require('../../../utils/BaseUtils');
    var DomUtils = require('../../../dom/DomUtils');

    var Control = Class.extend({

        options: {
            position: 'bottomleft'
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);
        },

        getPosition: function () {
            return this.options.position;
        },

        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function (position) {
            var map = this._map;

            if (map) {
                map.removeControl(this);
            }

            this.options.position = position;

            if (map) {
                map.addControl(this);
            }

            return this;
        },

        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function () {
            return this._container;
        },

        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function (map) {
            this.remove();
            this._map = map;

            var container = this._container = this.onAdd(map),
                pos = this.getPosition(),
                corner = map._controlCorners[pos];

            DomUtils.addClass(container, 'leaflet-control');

            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }

            return this;
        },

        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function () {
            if (!this._map) {
                return this;
            }

            DomUtils.remove(this._container);

            if (this.onRemove) {
                this.onRemove(this._map);
            }

            this._map = null;

            return this;
        },

        _refocusOnMap: function (e) {
            // if map exists and event is not a keyboard event
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
                this._map.getContainer().focus();
            }
        }
    });

    Control.Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
            position: 'bottomright',

            // @option prefix: String = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: ''
        },

        initialize: function (options) {
            BaseUtils.setOptions(this, options);

            this._attributions = {};
        },

        onAdd: function (map) {
            map.attributionControl = this;
            this._container = DomUtils.create('div', 'leaflet-control-attribution');

            this._update();

            return this._container;
        },

        // @method setPrefix(prefix: String): this
        // Sets the text before the attributions.
        setPrefix: function (prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },

        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
        addAttribution: function (text) {
            if (!text) { return this; }

            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;

            this._update();

            return this;
        },

        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function (text) {
            if (!text) { return this; }

            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }

            return this;
        },

        _update: function () {
            if (!this._map) { return; }

            var attribs = [];

            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }

            var prefixAndAttribs = [];

            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(', '));
            }

            this._container.innerHTML = prefixAndAttribs.join(' | ');
        }
    });

    Control.Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
            position: 'topleft',

            // @option zoomInText: String = '+'
            // The text set on the 'zoom in' button.
            zoomInText: '+',

            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: 'Zoom in',

            // @option zoomOutText: String = '-'
            // The text set on the 'zoom out' button.
            zoomOutText: '-',

            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: 'Zoom out'
        },

        onAdd: function (map) {
            var zoomName = 'leaflet-control-zoom',
                container = DomUtils.create('div', zoomName + ' leaflet-bar'),
                options = this.options;

            this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
                zoomName + '-in',  container, this._zoomIn);
            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
                zoomName + '-out', container, this._zoomOut);

            this._updateDisabled();
            map.on('zoomend zoomlevelschange', this._updateDisabled, this);

            container.style.position = 'absolute';
            container.style.left = options._topLeft.x + 'px';
            container.style.top = options._topLeft.y + 'px';
            container.style['z-index'] = 800;
            container.style['pointer-events'] = 'auto';

            return container;
        },

        onRemove: function (map) {
            map.off('zoomend zoomlevelschange', this._updateDisabled, this);
        },

        disable: function () {
            this._disabled = true;
            this._updateDisabled();
            return this;
        },

        enable: function () {
            this._disabled = false;
            this._updateDisabled();
            return this;
        },

        _zoomIn: function (e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
                this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
        },

        _zoomOut: function (e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
                this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
        },

        _createButton: function (html, title, className, container, fn) {
            var link = DomUtils.create('a', className, container);
            link.innerHTML = html;
            link.href = '#';
            link.title = title;

            /*
             * Will force screen readers like VoiceOver to read this as "Zoom in - button"
             */
            link.setAttribute('role', 'button');
            link.setAttribute('aria-label', title);

            VanHammer
                .on(link, 'mousedown dblclick', DomUtils.stopPropagation)
                .on(link, 'click', DomUtils.stop)
                .on(link, 'click', fn.bind(this))
                .on(link, 'click', this._refocusOnMap.bind(this));

            return link;
        },

        _updateDisabled: function () {
            var map = this._map,
                className = 'leaflet-disabled';

            DomUtils.removeClass(this._zoomInButton, className);
            DomUtils.removeClass(this._zoomOutButton, className);

            if (this._disabled || map._zoom === map.getMinZoom()) {
                DomUtils.addClass(this._zoomOutButton, className);
            }
            if (this._disabled || map._zoom === map.getMaxZoom()) {
                DomUtils.addClass(this._zoomInButton, className);
            }
        }
    });


    return Control;
});
/**
 * Created by eason on 2017/1/20.
 */
define('chart/map/layer/FeatureGroup',['require','./../../../vector/shape/LayerGroup','../LatLngBounds'],function(require){

    var LayerGroup = require('./../../../vector/shape/LayerGroup');
    var LatLngBounds = require('../LatLngBounds');

    var FeatureGroup = LayerGroup.extend({

        addLayer: function (layer) {
            if (this.hasLayer(layer)) {
                return this;
            }

            layer.addEventParent(this);

            LayerGroup.prototype.addLayer.call(this, layer);

            return this;
        },

        removeLayer: function (layer) {
            if (!this.hasLayer(layer)) {
                return this;
            }
            if (layer in this._layers) {
                layer = this._layers[layer];
            }

            layer.removeEventParent(this);

            LayerGroup.prototype.removeLayer.call(this, layer);

            return this;
        },

        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function (style) {
            return this.invoke('setStyle', style);
        },

        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function () {
            return this.invoke('bringToFront');
        },

        // @method bringToBack(): this
        // Brings the layer group to the top of all other layers
        bringToBack: function () {
            return this.invoke('bringToBack');
        },

        getBounds: function () {
            var bounds = new LatLngBounds();

            for (var id in this._layers) {
                var layer = this._layers[id];
                bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }

            return bounds;
        }
    });

    return FeatureGroup;
});
/**
 * Created by eason on 2017/2/8.
 */

define('utils/LineUtils',['require','./Point2D'],function(require){

    var Point = require('./Point2D');

    return {

        // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
        // Improves rendering performance dramatically by lessening the number of points to draw.

        // @function simplify(points: Point[], tolerance: Number): Point[]
        // Dramatically reduces the number of points in a polyline while retaining
        // its shape and returns a new array of simplified points, using the
        // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
        // Used for a huge performance boost when processing/displaying Leaflet polylines for
        // each zoom level and also reducing visual noise. tolerance affects the amount of
        // simplification (lesser value means higher quality but slower and with more points).
        // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
        simplify: function (points, tolerance) {
            if (!tolerance || !points.length) {
                return points.slice();
            }

            var sqTolerance = tolerance * tolerance;

            // stage 1: vertex reduction
            points = this._reducePoints(points, sqTolerance);

            // stage 2: Douglas-Peucker simplification
            points = this._simplifyDP(points, sqTolerance);

            return points;
        },

        // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
        // Returns the distance between point `p` and segment `p1` to `p2`.
        pointToSegmentDistance:  function (p, p1, p2) {
            return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
        },

        // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
        // Returns the closest point from a point `p` on a segment `p1` to `p2`.
        closestPointOnSegment: function (p, p1, p2) {
            return this._sqClosestPointOnSegment(p, p1, p2);
        },

        // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
        _simplifyDP: function (points, sqTolerance) {

            var len = points.length,
                ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                markers = new ArrayConstructor(len);

            markers[0] = markers[len - 1] = 1;

            this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

            var i,
                newPoints = [];

            for (i = 0; i < len; i++) {
                if (markers[i]) {
                    newPoints.push(points[i]);
                }
            }

            return newPoints;
        },

        _simplifyDPStep: function (points, markers, sqTolerance, first, last) {

            var maxSqDist = 0,
                index, i, sqDist;

            for (i = first + 1; i <= last - 1; i++) {
                sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist > sqTolerance) {
                markers[index] = 1;

                this._simplifyDPStep(points, markers, sqTolerance, first, index);
                this._simplifyDPStep(points, markers, sqTolerance, index, last);
            }
        },

        // reduce points that are too close to each other to a single point
        _reducePoints: function (points, sqTolerance) {
            var reducedPoints = [points[0]];

            for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                    reducedPoints.push(points[i]);
                    prev = i;
                }
            }
            if (prev < len - 1) {
                reducedPoints.push(points[len - 1]);
            }
            return reducedPoints;
        },


        // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
        // Clips the segment a to b by rectangular bounds with the
        // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
        // (modifying the segment points directly!). Used by Leaflet to only show polyline
        // points that are on the screen or near, increasing performance.
        clipSegment: function (a, b, bounds, useLastCode, round) {
            var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                codeB = this._getBitCode(b, bounds),

                codeOut, p, newCode;

            // save 2nd code to avoid calculating it on the next segment
            this._lastCode = codeB;

            while (true) {
                // if a,b is inside the clip window (trivial accept)
                if (!(codeA | codeB)) {
                    return [a, b];
                }

                // if a,b is outside the clip window (trivial reject)
                if (codeA & codeB) {
                    return false;
                }

                // other cases
                codeOut = codeA || codeB;
                p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
                newCode = this._getBitCode(p, bounds);

                if (codeOut === codeA) {
                    a = p;
                    codeA = newCode;
                } else {
                    b = p;
                    codeB = newCode;
                }
            }
        },

        _getEdgeIntersection: function (a, b, code, bounds, round) {
            var dx = b.x - a.x,
                dy = b.y - a.y,
                min = bounds.min,
                max = bounds.max,
                x, y;

            if (code & 8) { // top
                x = a.x + dx * (max.y - a.y) / dy;
                y = max.y;

            } else if (code & 4) { // bottom
                x = a.x + dx * (min.y - a.y) / dy;
                y = min.y;

            } else if (code & 2) { // right
                x = max.x;
                y = a.y + dy * (max.x - a.x) / dx;

            } else if (code & 1) { // left
                x = min.x;
                y = a.y + dy * (min.x - a.x) / dx;
            }

            return new Point(x, y, round);
        },

        _getBitCode: function (p, bounds) {
            var code = 0;

            if (p.x < bounds.min.x) { // left
                code |= 1;
            } else if (p.x > bounds.max.x) { // right
                code |= 2;
            }

            if (p.y < bounds.min.y) { // bottom
                code |= 4;
            } else if (p.y > bounds.max.y) { // top
                code |= 8;
            }

            return code;
        },

        // square distance (to avoid unnecessary Math.sqrt calls)
        _sqDist: function (p1, p2) {
            var dx = p2.x - p1.x,
                dy = p2.y - p1.y;
            return dx * dx + dy * dy;
        },

        // return closest point on segment or distance to that point
        _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
            var x = p1.x,
                y = p1.y,
                dx = p2.x - x,
                dy = p2.y - y,
                dot = dx * dx + dy * dy,
                t;

            if (dot > 0) {
                t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = p.x - x;
            dy = p.y - y;

            return sqDist ? dx * dx + dy * dy : new Point(x, y);
        },

        clipPolygon:function(points, bounds, round){

            var clippedPoints,
                edges = [1, 4, 2, 8],
                i, j, k,
                a, b,
                len, edge, p;

            for (i = 0, len = points.length; i < len; i++) {
                points[i]._code = this._getBitCode(points[i], bounds);
            }

            // for each edge (left, bottom, right, top)
            for (k = 0; k < 4; k++) {
                edge = edges[k];
                clippedPoints = [];

                for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                    a = points[i];
                    b = points[j];

                    // if a is inside the clip window
                    if (!(a._code & edge)) {
                        // if b is outside the clip window (a->b goes out of screen)
                        if (b._code & edge) {
                            p = this._getEdgeIntersection(b, a, edge, bounds, round);
                            p._code = this._getBitCode(p, bounds);
                            clippedPoints.push(p);
                        }
                        clippedPoints.push(a);

                        // else if b is inside the clip window (a->b enters the screen)
                    } else if (!(b._code & edge)) {
                        p = this._getEdgeIntersection(b, a, edge, bounds, round);
                        p._code = this._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                }
                points = clippedPoints;
            }

            return points;
        }
    };
});
/**
 * Created by eason on 2017/1/20.
 */
define('chart/map/layer/GeoJSON',['require','./FeatureGroup','../../../utils/BaseUtils','../../../utils/Point2D','../../../utils/Bounds','../LatLng','../LatLngBounds','../Marker','../../../vector/shape/Path','../../../utils/LineUtils'],function(require){

    var FeatureGroup = require('./FeatureGroup');
    var BaseUtils = require('../../../utils/BaseUtils');
    var Point = require('../../../utils/Point2D');
    var Bounds = require('../../../utils/Bounds');
    var LatLng = require('../LatLng');
    var LatLngBounds = require('../LatLngBounds');
    var Marker = require('../Marker');
    var Path = require('../../../vector/shape/Path');
    var LineUtils = require('../../../utils/LineUtils');

    var GeoJSON = FeatureGroup.extend({

        initialize: function (geojson, options) {
            BaseUtils.setOptions(this, options);

            this._layers = {};

            this._featureLayerMap = {};

            if (geojson) {
                this.addData(geojson);
            }
        },

        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function (geojson) {
            var features = BaseUtils.isArray(geojson) ? geojson : geojson.features,
                i, len, feature;

            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    // only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        this.addData(feature);
                    }
                }
                return this;
            }

            var options = this.options;

            if (options.filter && !options.filter(geojson)) { return this; }

            var layer = this.geometryToLayer(geojson, options);
            if (!layer) {
                return this;
            }

            layer.options = BaseUtils.extend({}, this.options);
            this._featureLayerMap[BaseUtils.stamp(geojson)] = layer;

            return this.addLayer(layer);
        },

        getLayerByFeature:function(geoJson){
            return this._featureLayerMap[BaseUtils.stamp(geoJson)];
        },

        geometryToLayer: function (geojson, options) {

            var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                coords = geometry ? geometry.coordinates : null,
                layers = [],
                coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
                latlng, latlngs, i, len;

            if (!coords && !geometry) {
                return null;
            }

            switch (geometry.type) {
                case 'Polygon':
                case 'MultiPolygon':
                    latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
                    return new Polygon(latlngs, options);

                case 'GeometryCollection':
                    for (i = 0, len = geometry.geometries.length; i < len; i++) {
                        var layer = this.geometryToLayer({
                            geometry: geometry.geometries[i],
                            type: 'Feature',
                            properties: geojson.properties
                        }, options);

                        if (layer) {
                            layers.push(layer);
                        }
                    }
                    return new FeatureGroup(layers);
            }
        },

        // @function coordsToLatLng(coords: Array): LatLng
        // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
        // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
        coordsToLatLng: function (coords) {
            return new LatLng(coords[1], coords[0], coords[2]);
        },

        // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
        // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
        // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
        // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
        coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
            var latlngs = [];

            for (var i = 0, len = coords.length, latlng; i < len; i++) {
                latlng = levelsDeep ?
                    this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
                    (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                latlngs.push(latlng);
            }

            return latlngs;
        },

        // @function latLngToCoords(latlng: LatLng): Array
        // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
        latLngToCoords: function (latlng) {
            return latlng.alt !== undefined ?
                [latlng.lng, latlng.lat, latlng.alt] :
                [latlng.lng, latlng.lat];
        },

        // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
        // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
        // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
        latLngsToCoords: function (latlngs, levelsDeep, closed) {
            var coords = [];

            for (var i = 0, len = latlngs.length; i < len; i++) {
                coords.push(levelsDeep ?
                    GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
                    GeoJSON.latLngToCoords(latlngs[i]));
            }

            if (!levelsDeep && closed) {
                coords.push(coords[0]);
            }

            return coords;
        },

        // @function asFeature(geojson: Object): Object
        // Normalize GeoJSON geometries/features into GeoJSON features.
        asFeature: function (geojson) {
            if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
                return geojson;
            }

            return {
                type: 'Feature',
                properties: {},
                geometry: geojson
            };
        }
    });

    var Polyline = Path.extend({

        initialize: function (latlngs, options) {
            BaseUtils.setOptions(this, options);
            this._setLatLngs(latlngs);
        },

        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function () {
            return this._latlngs;
        },

        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function (latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
        },

        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function () {
            return !this._latlngs.length;
        },

        closestLayerPoint: function (p) {
            var minDistance = Infinity,
                minPoint = null,
                closest = LineUtils._sqClosestPointOnSegment,
                p1, p2;

            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
                var points = this._parts[j];

                for (var i = 1, len = points.length; i < len; i++) {
                    p1 = points[i - 1];
                    p2 = points[i];

                    var sqDist = closest(p, p1, p2, true);

                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = closest(p, p1, p2);
                    }
                }
            }
            if (minPoint) {
                minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
        },

        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function () {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) {
                throw new Error('Must add layer to map before using getCenter()');
            }

            var i, halfDist, segDist, dist, p1, p2, ratio,
                points = this._rings[0],
                len = points.length;

            if (!len) { return null; }

            // polyline centroid algorithm; only uses the first ring if there are multiple

            for (i = 0, halfDist = 0; i < len - 1; i++) {
                halfDist += points[i].distanceTo(points[i + 1]) / 2;
            }

            // The line is so small in the current view that all points are on the same pixel.
            if (halfDist === 0) {
                return this._map.layerPointToLatLng(points[0]);
            }

            for (i = 0, dist = 0; i < len - 1; i++) {
                p1 = points[i];
                p2 = points[i + 1];
                segDist = p1.distanceTo(p2);
                dist += segDist;

                if (dist > halfDist) {
                    ratio = (dist - halfDist) / segDist;
                    return this._map.layerPointToLatLng([
                        p2.x - ratio * (p2.x - p1.x),
                        p2.y - ratio * (p2.y - p1.y)
                    ]);
                }
            }
        },

        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function () {
            return this._bounds;
        },

        // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function (latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = LatLng.create(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
        },

        _setLatLngs: function (latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
        },

        _defaultShape: function () {
            return Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },

        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function (latlngs) {
            var result = [],
                flat = Polyline._flat(latlngs);

            for (var i = 0, len = latlngs.length; i < len; i++) {
                if (flat) {
                    result[i] = LatLng.create(latlngs[i]);
                    this._bounds.extend(result[i]);
                } else {
                    result[i] = this._convertLatLngs(latlngs[i]);
                }
            }

            return result;
        },

        _project: function () {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);

            var w = this._clickTolerance(),
                p = new Point(w, w);

            if (this._bounds.isValid() && pxBounds.isValid()) {
                pxBounds.min._subtract(p);
                pxBounds.max._add(p);
                this._pxBounds = pxBounds;
            }
        },

        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function (latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng,
                len = latlngs.length,
                i, ring;

            if (flat) {
                ring = [];
                for (i = 0; i < len; i++) {
                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                    projectedBounds.extend(ring[i]);
                }
                result.push(ring);
            } else {
                for (i = 0; i < len; i++) {
                    this._projectLatlngs(latlngs[i], result, projectedBounds);
                }
            }
        },

        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function () {
            var bounds = this._renderer._bounds;

            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                return;
            }

            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }

            var parts = this._parts,
                i, j, k, len, len2, segment, points;

            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
                points = this._rings[i];

                for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                    segment = LineUtils.clipSegment(points[j], points[j + 1], bounds, j, true);

                    if (!segment) { continue; }

                    parts[k] = parts[k] || [];
                    parts[k].push(segment[0]);

                    // if segment goes out of screen, or it's the last one, it's the end of the line part
                    if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
                        parts[k].push(segment[1]);
                        k++;
                    }
                }
            }
        },

        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function () {
            var parts = this._parts,
                tolerance = this.options.smoothFactor;

            for (var i = 0, len = parts.length; i < len; i++) {
                parts[i] = LineUtils.simplify(parts[i], tolerance);
            }
        },

        _update: function () {
            if (!this._map) { return; }

            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
        },

        _updatePath:function(){
            this._updatePoly();
        },

        _updatePoly: function (closed) {
            this._path.attr('d', this.pointsToPath(this._parts, closed));
        },

        pointsToPath: function (rings, closed) {
            var str = '',
                i, j, len, len2, points, p;

            for (i = 0, len = rings.length; i < len; i++) {
                points = rings[i];

                for (j = 0, len2 = points.length; j < len2; j++) {
                    p = points[j];
                    str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
                }

                // closes the ring for polygons; "x" is VML syntax
                str += closed ? 'z' : '';
            }

            // SVG complains about empty path strings
            return str || 'M0 0';
        },

        _containsPoint:function(p, closed){
            var i, j, k, len, len2, part,
                w = this._clickTolerance();

            if (!this._pxBounds.contains(p)) { return false; }

            // hit detection for polylines
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];

                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    if (!closed && (j === 0)) { continue; }

                    if (LineUtils.pointToSegmentDistance(p, part[k], part[j]) <= w) {
                        return true;
                    }
                }
            }
            return false;
        }
    });

    Polyline._flat = function (latlngs) {
        // true if it's a flat array of latlngs; false if nested
        return !BaseUtils.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
    };

    var Polygon = Polyline.extend({

        isEmpty: function () {
            return !this._latlngs.length || !this._latlngs[0].length;
        },

        getCenter: function () {
            // throws error when not yet added to map as this center calculation requires projected coordinates
            if (!this._map) {
                throw new Error('Must add layer to map before using getCenter()');
            }

            var i, j, p1, p2, f, area, x, y, center,
                points = this._rings[0],
                len = points.length;

            if (!len) { return null; }

            // polygon centroid algorithm; only uses the first ring if there are multiple

            area = x = y = 0;

            for (i = 0, j = len - 1; i < len; j = i++) {
                p1 = points[i];
                p2 = points[j];

                f = p1.y * p2.x - p2.y * p1.x;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
                area += f * 3;
            }

            if (area === 0) {
                // Polygon is so small that all points are on same pixel.
                center = points[0];
            } else {
                center = [x / area, y / area];
            }
            return this._map.layerPointToLatLng(center);
        },

        _convertLatLngs: function (latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
                len = result.length;

            // remove last point if it equals first one
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
                result.pop();
            }
            return result;
        },

        _setLatLngs: function (latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (Polyline._flat(this._latlngs)) {
                this._latlngs = [this._latlngs];
            }
        },

        _defaultShape: function () {
            return Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },

        _clipPoints: function () {
            // polygons need a different clipping algorithm so we redefine that

            var bounds = this._renderer._bounds,
                w = this.options['stroke-width'],
                p = new Point(w, w);

            // increase clip padding by stroke width to avoid stroke on clip edges
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
                return;
            }

            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }

            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
                clipped = LineUtils.clipPolygon(this._rings[i], bounds, true);
                if (clipped.length) {
                    this._parts.push(clipped);
                }
            }
        },

        _updatePath:function(){
            this._updatePoly(true);
        },

        _containsPoint:function(p){
            var inside = false,
                part, p1, p2, i, j, k, len, len2;

            if (!this._pxBounds.contains(p)) { return false; }

            // ray casting algorithm for detecting if point is in polygon
            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];

                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    p1 = part[j];
                    p2 = part[k];

                    if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                        inside = !inside;
                    }
                }
            }

            // also check if it's on polygon stroke
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
    });

    return GeoJSON;
});
/**
 * Created by eason on 2017/3/17.
 */

define('utils/getJson',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }

    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }

    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = BaseUtils.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) { request = new XDomainRequest(); }
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                result = response.call(xhr, request);
                callback(result);
            }
        }

        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) { return headers[name]; }
            if (value == null) { delete headers[name];} else { headers[name] = value + ""; }
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) { return mimeType; }
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) { return responseType; }
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(BaseUtils.toArray(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") { callback = data; data = null; }
            request.open(method, url, false);
            if (mimeType != null && !("accept" in headers)) { headers["accept"] = mimeType + ",*/*"; }
            if (request.setRequestHeader) { for (var name in headers) { request.setRequestHeader(name, headers[name]); } }
            if (mimeType != null && request.overrideMimeType) { request.overrideMimeType(mimeType); }
            if (responseType != null) { request.responseType = responseType; }
            if (callback != null) {
                xhr.on("error", callback).on("load", function (request) {
                    callback(null, request);
                });
            }
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        BaseUtils.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }

    function d3_json(request) {
        return JSON['parse'](request.responseText);
    }

    return function(url, callback){
        return d3_xhr(url, "application/json", d3_json, callback)
    };

});
/**
 * Created by eason on 16/5/23.
 * 
 */

define('component/Geo',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../utils/GeoUtils','../Constants','../ComponentLibrary','../chart/map/layer/ImageOverlay','../chart/map/layer/TileLayer','../chart/map/layer/Control','../chart/map/layer/GeoJSON','../utils/getJson','../chart/map/CRS','../chart/map/LatLngBounds'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var GeoUtils = require('../utils/GeoUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var _loadedLayerMap = {};//tileLayer
    var ImageOverlay = require('../chart/map/layer/ImageOverlay');
    var TileLayer = require('../chart/map/layer/TileLayer');
    var Control = require('../chart/map/layer/Control');
    var GeoJSON = require('../chart/map/layer/GeoJSON');
    var getJson = require('../utils/getJson');
    var CRS = require('../chart/map/CRS');
    var LatLngBounds = require('../chart/map/LatLngBounds');

    var POINT  = 'Point';
    var LINE_STRING = 'LineString';
    var MULTI_LINE_STRING = 'MultiLineString';

    function get(resource){
        var mapData;
        if(resource && typeof resource === 'object'){
            mapData = resource;
        }else{
            if(window.FR && window.FR.ajax){
                FR.ajax({
                    type: 'GET',
                    url: resource,
                    dataType: 'json',
                    async: false,
                    success: function (result) {
                        mapData = result;
                    }
                });
            } else {
                getJson(resource, function (result) {
                    mapData = result;
                });
            }
        }
        return mapData;
    }

    var Geo = Base.extend({

        _refresh:function(){
            this._loaded = false;

            var vanchartsID = BaseUtils.stamp(this.vanchart);
            _loadedLayerMap[vanchartsID] = _loadedLayerMap[vanchartsID] || {};
        },

        doLayout:function(){

            this._loadGeo();

            var map = this.vanchart, options = this.options;
            var level;
            if(BaseUtils.hasDefined(options.zoomListener)){
                level = options.zoomListener;
            }else if(BaseUtils.hasDefined(options.zoomLevel)){
                level = options.zoomLevel;
            }

            var center = options.viewCenter ? [options.viewCenter[1], options.viewCenter[0]] : null;

            var isValidLevel = !isNaN(+level);

            if (isValidLevel && center) { // has level, has center
                map.setView(center, level);
            } else {
                var _fitBounds = this._getFitBounds();

                if (isValidLevel) { // has level, no center
                    // get center
                    map.fitBounds(_fitBounds, {animate:false});
                    // than set level
                    center = map.getCenter();
                    map.setView(center, level);
                } else { // no level, ?center
                    map.fitBounds(_fitBounds);
                }
                // force refresh background in case of blank
                if (center = map.getCenter()) {
                    map.panTo(center, {animate:false});
                }
            }

            this._topLeft = {x:0, y:map.bounds.y};
        },

        render:function(){

            var options = this.options, json = this.jsonData, vanchartsID = BaseUtils.stamp(this.vanchart);

            var url = options.tileLayer || this.vanchart.options.geo.tileLayer;
            var attribution = options.attribution || this.vanchart.options.geo.attribution || '';

            var wmsUrl = options.wmsUrl || this.vanchart.options.geo.wmsUrl;
            var wmsLayer = options.wmsLayer || this.vanchart.options.geo.wmsLayer;

            var lastLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;
            this._imageBackgroundLayer = this._tileLayer = this._wmsLayer = null;

            if(this._isImageMap() && (options.imageUrl || json.imageString)){

                var imageUrl = options.imageUrl || ("data:image/"+json.imageSuffix+";base64," + json.imageString);

                var bounds = [[0,0], [json.imageHeight * this.scale, json.imageWidth * this.scale]];

                this._imageBackgroundLayer = new ImageOverlay(imageUrl, bounds).addTo(this.vanchart);

            }else if(url){

                this._attribution = _loadedLayerMap[vanchartsID][attribution] || new Control.Attribution().addAttribution(attribution);
                _loadedLayerMap[vanchartsID][attribution] = this._attribution;

                this._tileLayer = _loadedLayerMap[vanchartsID][url] || new TileLayer(url);
                _loadedLayerMap[vanchartsID][url] = this._tileLayer;

                _loadedLayerMap[vanchartsID][url].addTo(this.vanchart);
                _loadedLayerMap[vanchartsID][attribution].addTo(this.vanchart);

            }else if(wmsUrl){

                this._wmsLayer = _loadedLayerMap[vanchartsID][wmsUrl] || new TileLayer.WMS(wmsUrl, {layers: wmsLayer.join(',')});
                _loadedLayerMap[vanchartsID][wmsUrl] = this._wmsLayer;

                _loadedLayerMap[vanchartsID][wmsUrl].addTo(this.vanchart);
            }

            this.renderAreaFeatures();

            if(options.control){
                options._topLeft = this._topLeft;
                this._zoomControl = this._zoomControl || new Control.Zoom(options).addTo(this.vanchart);  // @CHART-990
            }

            //updateLayer
            var currentLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;
            if(lastLayer && lastLayer != currentLayer){
                this.vanchart.removeLayer(lastLayer);
            }
        },

        needsNullArea:function(){
            var vanchart = this.vanchart;
            return vanchart.isAreaMap() || vanchart.isHeatMap() || vanchart.seriesOfType(Constants.AREA_MAP).length;
        },

        renderAreaFeatures:function(){
            if(this.needsNullArea()){
                var options =  this.defaultAreaStyle();
                this.geoJsonLayer = this.geoJsonLayer || new GeoJSON(this.jsonData, options);
                this.geoJsonLayer.addTo(this.vanchart);
            }
        },

        getLayerByFeature:function(feature){
            return this.geoJsonLayer.getLayerByFeature(feature);
        },

        defaultAreaStyle:function(){
            var plotOptions = this.vanchart.options.plotOptions;
            var queryList = [plotOptions[Constants.AREA_MAP], plotOptions];
            return {
                'fill':BaseUtils.pick(QueryUtils.queryList(queryList, 'nullColor'), '#cccccc'),
                'fill-opacity':BaseUtils.pick(QueryUtils.queryList(queryList, 'opacity'), 0.75) ,
                'stroke-width':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderWidth'), 1),
                'stroke':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderColor'), '#ffffff'),
                'stroke-opacity':BaseUtils.pick(QueryUtils.queryList(queryList, 'borderOpacity'), 1)
            };
        },

        geoName:function(){
            return this.options.name;
        },

        _loadGeo:function(){

            if(this._loaded || (this._dataUrl == this.options.data)){

                this._loaded = true;

                this._checkCRS();

                return;
            }

            this._loaded = true;
            this._dataUrl = this.options.data;
            this.geoJsonLayer && this.geoJsonLayer.remove();
            this.geoJsonLayer = null;//data

            var options = this.options, geo = this, vanchart = this.vanchart;

            geo._validPointName = {}, geo._validAreaName = {}, geo._extendedLineFeature = [];

            if (options.data) {
                geo.jsonData = get(options.data);
            } else {
                geo.jsonData = {};
            }

            var features = geo.jsonData && geo.jsonData.features || [];
            for(var i = 0, len = features.length; i < len; i++){
                var feature = features[i];
                var geometry = feature.geometry;
                if(geometry.type == POINT){//
                    geo._validPointName[feature.properties.name] = geo._validPointName[feature.properties.name] || [];
                    geo._validPointName[feature.properties.name].push(feature);
                }else if(geometry.type == LINE_STRING || geometry.type == MULTI_LINE_STRING){
                    geo._extendedLineFeature.push(feature);
                }else{//
                    geo._validAreaName[feature.properties.name] = geo._validAreaName[feature.properties.name] || [];
                    geo._validAreaName[feature.properties.name].push(feature);
                }
            }

            this.scale = 1;
            if(this._isImageMap()){
                var chartWidth = vanchart.width, chartHeight = vanchart.height;

                var wR = chartWidth / geo.jsonData.imageWidth, wH = chartHeight / geo.jsonData.imageHeight;

                this.scale = Math.min(wR, wH);

                GeoUtils.scaleGeo(geo.jsonData, geo.scale);
            }

            this._checkCRS();
        },

        getDataPointLngLat: function (point, feature) {

            if(!feature || point.options.lnglat){
                return point.options.lnglat;
            }

            var lnglat = point.series && point.series.type == Constants.AREA_MAP ? feature.properties.center : feature.geometry.coordinates;
            if(!lnglat){
                if(this._isImageMap()){
                    var lngMin = this.jsonData.imageWidth,lngMax = 0;
                    var latMin = this.jsonData.imageHeight, latMax = 0;
                    var points = GeoUtils.getAllPoints(feature);
                    points.forEach(function (point) {

                        if(isNaN(point[0]) || isNaN(point[1])){
                            return;
                        }

                        lngMin = Math.min(lngMin, point[0]);
                        lngMax = Math.max(lngMax, point[0]);

                        latMin = Math.min(latMin, point[1]);
                        latMax = Math.max(latMax, point[1]);
                    });
                    lnglat = [(lngMax + lngMin)/2, (latMax + latMin)/2];
                }else{
                    var bounds = GeoUtils.bounds(feature);
                    var lng = (bounds[0][0] + bounds[1][0])/2;
                    var lat = (bounds[0][1] + bounds[1][1])/2;
                    lnglat = [lng, lat];
                }
            }
            return lnglat;
        },

        getZoomListener:function(){
            return this.options.zoomListener || this.options.zoomLevel;
        },

        getFeaturesByName:function(name, type){
            this._loadGeo();

            if(!this._validAreaName || !this._validPointName){
                return;//data
            }

            return type == Constants.AREA_MAP ? this._validAreaName[name] : this._validPointName[name];
        },

        _isImageMap:function(){
            return this.jsonData && this.jsonData.imageWidth;
        },

        _checkCRS:function () {
            this.vanchart.options.crs = this._isImageMap() ? CRS.Simple : CRS.EPSG3857;
        },

        //fitboundsjson,
        _getFitBounds:function(){
            //,
            var byJson = true, geo = this;
            var lngMin = 180, lngMax = -180, latMin = 90, latMax = -90;

            if(this._isImageMap()){
                lngMin = this.jsonData.imageWidth * this.scale; lngMax = 0;
                latMin = this.jsonData.imageHeight * this.scale; latMax = 0;
            }else{
                var series = this.vanchart.series;
                for(var i = 0, len = series.length; i < len; i++){
                    if(series[i].visible && series[i].type != Constants.AREA_MAP){
                        if (series[i].type === Constants.LINE_MAP) {
                            series[i].points.forEach(function (item) {
                                getLngLatMinMax(item.options.from);
                                getLngLatMinMax(item.options.to);
                            });
                        } else {
                            series[i].points.forEach(getLngLatMinMax);
                        }
                    }
                }

                if(byJson && this.jsonData && this.jsonData.features.length){
                    var fitBounds = GeoUtils.bounds(this.jsonData);
                    var southWest = fitBounds[0];
                    var northEast = fitBounds[1];
                    return [[southWest[1], southWest[0]], [northEast[1], northEast[0]]];
                }
            }

            function getLngLatMinMax(point){
                // lineMap:
                // from.lnglat, from.name;
                // others:
                // p.options.lnglat, p.name
                //
                // lineMap from,to get lnglat in Normalizer.
                //
                var lnglat = point.lnglat || point.options.lnglat;
                if(!lnglat){
                    var features = geo.getFeaturesByName(point.name, point.series.type);
                    lnglat = geo.getDataPointLngLat(point, features && features[0]);
                }

                if(lnglat){
                    //
                    byJson = false;

                    lngMin = Math.min(lngMin, lnglat[0]);
                    lngMax = Math.max(lngMax, lnglat[0]);

                    latMin = Math.min(latMin, lnglat[1]);
                    latMax = Math.max(latMax, lnglat[1]);
                }
            }

            return [[Math.min(latMin, latMax), Math.min(lngMin, lngMax)],[Math.max(latMax, latMin), Math.max(lngMax, lngMin)]];
        },

        remove:function(){
            this.geoJsonLayer && this.geoJsonLayer.remove();//

            if(this.geoJsonLayer){
                var defaultOptions = this.geoJsonLayer.options;
                // removelayeroption.addTo(vanchart)
                this.geoJsonLayer.eachLayer(function (layer){
                    layer.options = BaseUtils.extend({}, defaultOptions);
                }, this);
            }

            this._imageBackgroundLayer && this.vanchart.removeLayer(this._imageBackgroundLayer);
            this._attribution && this._attribution.remove();
            this._tileLayer && this._tileLayer.remove();
            this._wmsLayer && this._wmsLayer.remove();

            this._imageBackgroundLayer = this._attribution = this._tileLayer = this._wmsLayer;
        },

        resize:function(){
            if(!this._isImageMap()){
                return;
            }

            var options = this.options, json = this.jsonData, lastScale = this.scale;

            var vanchart = this.vanchart, chartWidth = vanchart.width, chartHeight = vanchart.height;

            var wR = chartWidth / json.imageWidth, wH = chartHeight / json.imageHeight;

            this.scale = Math.min(wR, wH);

            GeoUtils.scaleGeo(json, this.scale / lastScale);

            if(this._imageBackgroundLayer){
                var bounds = [[0,0], [json.imageHeight * this.scale, json.imageWidth * this.scale]];
                this._imageBackgroundLayer.setBounds(LatLngBounds.create(bounds));
            }

            if(this.geoJsonLayer){
                this.geoJsonLayer.remove();
                this.geoJsonLayer = null;
                vanchart.validPoints.forEach(function(point){
                    if(point.series.type == Constants.AREA_MAP){
                        point.layers = null;
                    }
                });
            }
        }
    });

    ComponentLibrary.register(ComponentLibrary.GEO_COMPONENT, Geo);
    return Geo;
});
/**
 * Created by eason on 16/5/17.
 */
define('component/DrillTools',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var FIRST_LEFT_PADDING = 0.417;
    var LEFT_PADDING = 0.583;
    var RIGHT_PADDING = 0.25;
    var ARROW_SIZE = 0.333;
    var TOP_PADDING = 0.1665;

    var PADDING = 8; 
    var PADDING_FUN = function () { 
        return BaseUtils.paddingConvertWithScale(PADDING) 
    }; 

    var DrillTools = Base.extend({

        _refresh:function(){
            this.iconData = [];
        },

        doLayout:function(){
            BaseUtils.calculateFontSizeWithScale(this.options && this.options.style);
            var dim = BaseUtils.getTextDimension('test', this.options.style);
            this._setComponentBounds(Constants.TOP, dim.height * (TOP_PADDING * 2 + 1));
        },

        getBookMarkPath:function(d){

            var style = this.options.style, index = d.layerIndex;
            var dim = BaseUtils.getTextDimension(d.geo.geoName(), style);

            var rectWidth = (index === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            rectWidth = dim.height * rectWidth + dim.width;
            var arrowWidth = dim.height * ARROW_SIZE;
            var rectHeight = (1 + TOP_PADDING * 2) * dim.height;

            var ltop = [0,0], rtop = [rectWidth, 0], cp = [rectWidth + arrowWidth, rectHeight/2];
            var rbottom = [rectWidth, rectHeight], lbottom = [0, rectHeight];

            return 'M' + ltop + 'L' + rtop + 'L' + cp + 'L' + rbottom + 'L' + lbottom + 'Z';
        },

        isCurrent:function(d){
            var currentD = this.iconData[this.iconData.length - 1];
            return  currentD.series == d.series;
        },

        textColor:function(d){
            return this.isCurrent(d) ? this.options.currentColor : this.options.style.color;
        },

        mouseOverColor:function(d){
            var mouseOverColor;
            if(!(mouseOverColor = this.options.mouseOverColor)){
                var textColor = this.textColor(d);
                var rgba = ColorUtils.getRGBAColorArray(textColor);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var rgb = ColorUtils.hsb2rgb(hsb[0], hsb[1]/2, (hsb[2] + 1)/2);
                mouseOverColor = ColorUtils.toColor(rgb, 'rgb');
            }
            return mouseOverColor;
        },

        leftPadding:function(d){
            return d.layerIndex === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING;
        },

        calculateExitAnimation:function(exitData){
            var time = 600;
            var i = 0, len = exitData.length;
            for(; i < len; i++){
                exitData[i].time = time;
                time = Math.max(time - 100, 0);
            }

            var delay = 0;
            for(i = len - 1; i >= 0; i--){
                if(exitData[i].time){
                    exitData[i].delay = delay;
                    delay += 200;
                }else{
                    exitData[i].delay = 0;
                }
            }
        },

        getMarkPos:function(d){
            var x = 0;
            for(var i = 0; i < d.layerIndex; i++){
                x += this.getBookMarkLength(this.iconData[i], i);
            }
            return x;
        },

        getMarkAnimationStartPos:function(d){
            var index = d.layerIndex;
            return index === 0 ? 0 : (this.getMarkPos(this.iconData[index - 1]) - this.getBookMarkLength(d, index));
        },

        getBookMarkLength:function(data, index){
            var textHeight = BaseUtils.getTextDimension(data.geo.geoName(), this.options.style).height;
            var length = BaseUtils.getTextDimension(data.geo.geoName(), this.options.style).width;
            var padding = (index === 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            return length + padding * textHeight;
        },

        render:function(){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer;
            var clipBounds = {'x':0, 'y':0, 'width':this.bounds.width, 'height':this.bounds.height + PADDING_FUN()};
            if(!this.dToolsGroup){
                this.dToolsGroup = this.createComponentGroup();
                this.clip = renderer.createClip(clipBounds);
                this.shadow = renderer.createDropShadowFilter(0, 0, 0.15, 1);
                renderer.clip(this.dToolsGroup, this.clip);
                this.drillItems = [];
                vanchart.registerInteractiveTarget(this, this.dToolsGroup);
            }

            this.iconData = this.vanchart.layerMap;
            this.dToolsGroup.attr('transform', BaseUtils.makeTranslate([this.bounds.x, this.bounds.y + PADDING_FUN()]));
            renderer.updateClip(this.clip, clipBounds);

            for(var i = this.iconData.length - 1; i >= 0; i--) {
                var d = this.iconData[i];

                if(!this.drillItems[i]){
                    d.aniStart = this.getMarkAnimationStartPos(d);
                    d.aniEnd = this.getMarkPos(d);
                    this.drillItems[i] = this._createItem(d);
                }else{
                    var item = this.drillItems[i];
                    item.datum(d); 
                    item.path.attr({'d':dTools.getBookMarkPath(d)});
                    item.text
                        .style(BaseUtils.extend({},this.options.style))  
                        .attr(dTools._getTextAttr(d))
                        .style({'fill':this.textColor(d)})
                        .textContent(d.geo.geoName());
                }
            }

            var exitItems = this.drillItems.splice(this.iconData.length, this.drillItems.length);

            this.calculateExitAnimation(exitItems);
            for(var i = 0, len = exitItems.length; i < len; i++){
                var d = exitItems[i];
                d.animate({
                    duration:d.time,
                    delay:d.delay,
                    ease:'quad-in',
                    attr:{
                        transform:BaseUtils.makeTranslate([d.datum().aniStart, 0]),
                        opacity:0
                    }
                }).remove();
            }

            this.drillItems.length = this.iconData.length;
        },

        _createItem:function(d){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer;
            var cfg = this.options;

            var item = renderer.group().style({'cursor': 'pointer'}).datum(d);
            item.path = renderer.path({'d':dTools.getBookMarkPath(d)})
                .style({
                    'fill':cfg.backgroundColor,
                    "filter":'url(#'+ BaseUtils.stamp(this.shadow) +')'
                })
                .addTo(item);

            item.text = renderer.text()
                .attr(dTools._getTextAttr(d))
                .style(cfg.style).style({'fill':this.textColor(d)}).textContent(d.geo.geoName()).addTo(item);

            item.attr('transform', BaseUtils.makeTranslate([d.aniStart, 0])).addTo(this.dToolsGroup)
                .animate({
                    duration:500,
                    ease:'cubic-out',
                    attr:{transform:BaseUtils.makeTranslate([d.aniEnd, 0])}
                });

            BaseUtils.toBack(item.node());
            return item;
        },

        _findDrillTarget:function(ev){

            var event = ev.srcEvent, src = event.target || event.srcElement;

            var target;
            while (src) {

                for(var i = this.drillItems.length - 1; i >= 0; i--){
                    if(this.drillItems[i].node() == src){
                        target = this.drillItems[i];
                    }
                }

                if (target || src == this.dToolsGroup.node()){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        onTap:function(ev){
            var target = this._findDrillTarget(ev);
            var index = this.drillItems.indexOf(target);
            var iconData = this.vanchart.layerMap[index];
            if(target && iconData){
                var iconData = target.datum();
                if(this.options.click && iconData.drillUpDataPoint){
                    var click = BaseUtils.getFormatterFunction(this.options.click);
                    click(iconData.drillUpDataPoint, ev.srcEvent);
                }

                this.vanchart.drillUp(iconData);
            }
        },

        onMouseOver:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.mouseOverColor(target.datum())});
            }
        },

        onMouseOut:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.textColor(target.datum())});
            }
        },

        getEvents:function(){
            return {
                "tap":this.onTap,

                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut
            }
        },

        remove:function(){
            this.dToolsGroup && this.dToolsGroup.remove();
            this.dToolsGroup = null;
            this.iconData = this.drillItems = [];
        },

        _getTextAttr: function(d){
            var cfg = this.options, textHeight = BaseUtils.getTextDimension(d.geo.geoName(), cfg.style).height;

            return {
                'x':this.leftPadding(d) * textHeight,
                'y':(TOP_PADDING) * textHeight,
                'dy': "0.85em"
            }
        }
    });

    ComponentLibrary.register(ComponentLibrary.DRILL_TOOLS, DrillTools);
    return DrillTools;
});
/**
 * Created by eason on 15/5/4.
 * 
 */
define('component/DataSheet',['require','./Base','../utils/BaseUtils','../Constants','./LegendIconFactory','../ComponentLibrary','../utils/BezierEasing','../utils/QueryUtils'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var ComponentLibrary = require('../ComponentLibrary');
    var BezierEasing = require('../utils/BezierEasing');
    var QueryUtils = require('../utils/QueryUtils');
    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var PADDING_GAP = 4;
    var PADDING_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(PADDING_GAP);
    };

    var ICON_GAP = 2;
    var ICON_GAP_FUN = function () {
        return BaseUtils.paddingConvertWithScale(ICON_GAP);
    };

    var MAX_ICON_SIZE = 18;

    var STYLE = { color : "#666666", fontSize: "14px", fontFamily:"Verdana"};

    var DataSheet = Base.extend({

        /**
         *
         */
        doLayout:function(){
            this._recordForPlotBounds(Constants.LEFT, Math.round(this.getSeriesNameLength()));
        },

        reCalculateSize:function(){
            this.doLayout();
        },

        updateAxisSizeAndBounds:function(){
            this.maxCateLineHeight = this.maxSeriesLineHeight = null;

            this._setComponentBounds(Constants.BOTTOM, this._calculateLineHeight());
        },

        //
        // 
        _calculateLineHeight:function(){
            this.calculateShowText();

            //
            var cateStyle = this._categoryStyle(), valueHeight = 0;
            var seriesLineHeight = Math.ceil(BaseUtils.getTextHeight(this._seriesStyle()));  // ,

            var borderWidth = this.options.borderWidth;

            this.maxCateLineHeight = PADDING_GAP_FUN() * (this.maxCateLine + 1) + this.maxCateLine * Math.ceil(BaseUtils.getTextHeight(cateStyle)) + borderWidth * 2;

            this.maxSeriesLineHeight = [];
            // 
            for(var sIndex = 0, sCount = this.seriesNames.length; sIndex < sCount; sIndex++){

                var s_count = this.maxSeriesLine[sIndex];
                var s_height = s_count * seriesLineHeight + (s_count + 1) * PADDING_GAP_FUN() + borderWidth * 2;

                this.maxSeriesLineHeight[sIndex] = Math.max(s_height, this.maxValueLineHeight[sIndex]);

                valueHeight += this.maxSeriesLineHeight[sIndex];
            }

            this.sheetHeight = Math.ceil(this.maxCateLineHeight + valueHeight) + borderWidth * 2;

            return this.sheetHeight;
        },

        /**
         * 
         * @return {[type]} [description]
         */
        calculateShowText:function(){
            this.maxCateLine = 0;
            this.maxValueLineHeight = [];

            this.showTextMap = this.showTextMap || {};

            var axis = this.vanchart.xAxis(), categories = axis._dataDomain, showCategories = axis._domain;
            var cateStyle = this._categoryStyle(), cateHeight = BaseUtils.getTextHeight(cateStyle) + PADDING_GAP_FUN();
            var unitLength = this.vanchart.bounds.width / showCategories.length;

            var self = this;

            var borderWidth = this.options.borderWidth;

            categories.forEach(function(category){
                var sCateName = BaseUtils.splitText(category, cateStyle, unitLength - 2 * borderWidth, PADDING_GAP_FUN());
                if(self.maxCateLineHeight){
                    var endIndex = Math.min(parseInt(self.maxCateLineHeight / cateHeight, 10), sCateName.length);
                    sCateName = sCateName.slice(0, endIndex);
                }

                if(BaseUtils.indexOf(showCategories, category) != -1){
                    self.maxCateLine = Math.max(self.maxCateLine, sCateName.length);
                }

                self.showTextMap[category] = self.showTextMap[category] || {};
                self.showTextMap[category].categoryArray = sCateName;
            });

            var series = this.vanchart.series;

            series.forEach(function (sery, index){
                var points = sery.points, dataSheetCfg;
                for(var dIndex = 0, len = points.length; dIndex < len; dIndex++){
                    var point = points[dIndex], value = point.options[sery.getTargetKey()], category = point.category;

                    //dataSheet,DataSheet.options
                    dataSheetCfg = point.options.dataSheet || {};
                    dataSheetCfg = QueryUtils.merge(dataSheetCfg, self.options);
                    var pointFormat = dataSheetCfg.formatter;
                    var pointStyle = self._valueStyle(dataSheetCfg.style);
                    var pointBorderWidth = dataSheetCfg.borderWidth;

                    //
                    var valueHeight = Math.ceil(BaseUtils.getTextHeight(pointStyle)) + PADDING_GAP_FUN();

                    var f_value = point.isNull ? '-' : self._getTickContent(value, pointFormat);
                    var sValue = BaseUtils.splitText(f_value, pointStyle, unitLength - 2 * borderWidth, PADDING_GAP_FUN());

                    if(self.maxSeriesLineHeight && self.maxSeriesLineHeight[index]){
                        var endIndex = Math.min(parseInt(self.maxSeriesLineHeight[index] / valueHeight, 10), sValue.length);
                        sValue = sValue.slice(0, endIndex);
                    }

                    self.showTextMap[category].value = self.showTextMap[category].value || [];
                    self.showTextMap[category].value[index] = self.showTextMap[category].value[index] || {};
                    self.showTextMap[category].value[index].valueArray = sValue;

                    //dataSheetdraw
                    self.showTextMap[category].value[index].dataSheet = dataSheetCfg;

                    // 
                    var curLineHeight = sValue.length * valueHeight + PADDING_GAP_FUN() + pointBorderWidth * 2;
                    self.maxValueLineHeight[index] = Math.max(self.maxValueLineHeight[index]||0, curLineHeight);
                }
            });

            // 
            for(var j = -1; ++j < categories.length;) {
                var cate = categories[j], showCate = self.showTextMap[cate];
                for(var i = -1; ++i < series.length;) {
                    if(!showCate.value[i]){
                        showCate.value[i] = {
                            "dataSheet": this.options,
                            "valueArray" : ['-']
                        }
                    }
                }
            }
        },

        fixBoundsByPlot:function() {
            var plotBounds = this.vanchart.bounds;

            var xAxisComponent = this.vanchart.getComponent(ComponentLibrary.X_AXIS_COMPONENT);
            var posY = plotBounds.y + plotBounds.height + this.options.borderWidth / 2;
            if(xAxisComponent && xAxisComponent._axisList.length){
                xAxisComponent._axisList.forEach(function(axis){
                    if(axis.getPosition() == Constants.BOTTOM){
                        posY = Math.max(posY, axis.bounds.y + axis.bounds.height);
                    }
                })
            }

            this.bounds = {
                x: plotBounds.x - this.maxSeriesWidth,
                y: posY,
                width: this.maxSeriesWidth + plotBounds.width,
                height: this.sheetHeight
            };
        },
        //
        getSeriesNameLength:function(){

            this.seriesNames = [];
            this.maxSeriesLine = [];
            this.seriesIconType = [];

            var borderWidth = this.options.borderWidth;

            var  dataSheet = this, vanchart = dataSheet.vanchart, series = vanchart.series;

            var style = this._seriesStyle();

            var limitedWidth = vanchart.getChartBounds().width / 4 - (MAX_ICON_SIZE + ICON_GAP_FUN() * 2) - borderWidth * 2;

            var maxWidth = 0;

            var iconSize = 0;

            series.forEach(function (sery) {
                var width = BaseUtils.getTextDimension(sery.name, style, false).width + PADDING_GAP_FUN() * 2;

                if(width > limitedWidth){

                    var s_names = BaseUtils.splitText(sery.name, style, limitedWidth, PADDING_GAP_FUN());

                    dataSheet.maxSeriesLine.push(s_names.length);

                    dataSheet.seriesNames.push(s_names);

                    maxWidth = limitedWidth;
                }else{
                    dataSheet.maxSeriesLine.push(1);

                    dataSheet.seriesNames.push([sery.name]);

                    maxWidth = Math.max(width + borderWidth * 2, maxWidth);
                }

                var iconType = dataSheet._getLegendType(sery);

                dataSheet.seriesIconType.push(iconType);

                iconSize = Math.max(iconSize, LegendIconFactory.getLegendIconSize(iconType).width);
            });

            this.maxSeriesWidth = Math.ceil(maxWidth + ICON_GAP_FUN() * 2 + iconSize);

            return  this.maxSeriesWidth + PADDING_GAP_FUN();
        },

        _categoryStyle:function(){
            var cateAxis = this.vanchart.xAxis();
            var style = cateAxis ? cateAxis.options.labelStyle : STYLE;
            return BaseUtils.calculateFontSizeWithScale(style);
        },

        _seriesStyle:function(){
            var legend = this.vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            var style = legend ? legend.options.style : STYLE;
            return BaseUtils.calculateFontSizeWithScale(style);
        },

        _valueStyle:function(style){
            return BaseUtils.calculateFontSizeWithScale(style || this.options.style);
        },

        getTextPadding:function(){
            return PADDING_GAP_FUN();
        },

        render:function(){

            this.remove();

            if(!this.vanchart.series.length){
                return;
            }

            this.calculateShowText();

            var vanchart = this.vanchart, bounds = this.bounds, renderer = vanchart.renderer;

            var clipBounds = {x:this.maxSeriesWidth, y:0, width:bounds.width - this.maxSeriesWidth, height:bounds.height};
            this.animationClip = renderer.createClip(clipBounds);
            this.dataSheetGroup = this.createComponentGroup().attr('transform', BaseUtils.makeTranslate(this.bounds));
            this.borderGroup    = renderer.group().addTo(this.dataSheetGroup);
            this.animationGroup = renderer.group().addTo(this.dataSheetGroup);
            renderer.clip(this.animationGroup, this.animationClip);
            renderer.clip(this.borderGroup, this.animationClip);

            this._drawBaseTable();

            this._drawTableContent();
        },

        /**
         * 
         * @return {[type]} [description]
         */
        _drawBaseTable:function(){

            var cfg = this.options, seriesWidth = this.maxSeriesWidth, categoryHeight = this.maxCateLineHeight;

            var vanchart = this.vanchart, renderer = vanchart.renderer, group = this.dataSheetGroup;

            var borderWidth = cfg.borderWidth;

            var endX = this.bounds.width, endY = this.bounds.height - borderWidth;

            var styles = {'fill':'none', 'stroke':cfg.borderColor, 'stroke-width':cfg.borderWidth};

            var baseTableBorderPath = 'M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight + "L" + seriesWidth + "," + categoryHeight + "Z";

            renderer.path().attr('d', baseTableBorderPath)
                .style(styles).addTo(group);

            this._drawSeries();
        },

        /**
         * +
         * @return {[type]} [description]
         */
        _drawTableContent:function(){

            var vanchart = this.vanchart, axis = vanchart.xAxis();

            var domain = axis._domain, dataDomain = axis._dataDomain, rangeLength = this.getPlotBounds().width;

            var unitLength = rangeLength / domain.length;

            var startX = - BaseUtils.indexOf(dataDomain, domain[0]) * unitLength + this.maxSeriesWidth;

            for(var i = 0, len = dataDomain.length; i < len; i++){
                var text = this.showTextMap[dataDomain[i]];
                // scale
                // unitLength*i
                var x = startX + unitLength * (axis.isAxisReversed() ? (len - 1 -i) : i);

                this._drawCategory(text, x, unitLength);

                this._drawValues(text, x, unitLength);

            }
        },

        /**
         * 
         * @return {[type]} [description]
         */
        zoomRefresh:function(){

            this.calculateShowText();

            this._drawTableContent();
        },

        /**
         * +
         * @param  {[type]} text       [description]
         * @param  {[type]} x          [description]
         * @param  {[type]} unitLength [description]
         * @return {[type]}            [description]
         */
        _drawCategory:function(text, x, unitLength){

            var categoryArray = text.categoryArray, renderer = this.vanchart.renderer;

            text._category = text._category || [];

            var categoryStyle = this._categoryStyle(), categoryLineHeight = BaseUtils.getTextHeight(categoryStyle), textPadding = this.getTextPadding();

            var option = this.options;

            var startY = this._getStartY(categoryArray, categoryStyle, this.maxCateLineHeight);

            var textX, textY;

            var borderWidth = option.borderWidth,
                borderX = x + borderWidth / 2,
                borderY = borderWidth;

            for(var i = 0; i < categoryArray.length; i++){
                textX = x + unitLength/2;
                textY = startY + (categoryLineHeight + textPadding) * i + categoryLineHeight/2 + borderWidth / 2;
                text._category[i] = text._category[i] || renderer.text().attr({'text-anchor':'middle', 'dy':'.32em', 'x': textX, 'y': textY})
                        .style('margin-top', '-0.53em').style(categoryStyle).addTo(this.animationGroup);

                text._category[i].textContent(categoryArray[i]).animate({
                    'attr':{'x':textX, 'y':textY},'duration':TIME, 'ease':EASE
                });

                text._category[i].textContent(categoryArray[i]).vMiddle();
            }

            var borderAttr = {
                "width": unitLength - borderWidth,
                "height": this.maxCateLineHeight - borderWidth,
                "transform": "translate(" + borderX + "," + borderY + ")"
            }

            text.border = text.border || this._drawTableElementBorder(this.borderGroup);
            text.border.attr(borderAttr);

            for(var i = categoryArray.length; i < text._category.length; i ++){
                text._category[i].remove();
            }

            text._category.length = categoryArray.length;

        },

        /**
         * +
         * @param  {[type]} text       [description]
         * @param  {[type]} x          [description]
         * @param  {[type]} unitLength [description]
         * @return {[type]}            [description]
         */
        _drawValues:function(text, x, unitLength){
            var renderer = this.vanchart.renderer, valueStyle = this._valueStyle();
            var textPadding = this.getTextPadding();
            var startY = this.maxCateLineHeight;

            if(!text.value){
                text.value = [];
                for(var i = 0, len = this.vanchart.series.length; i < len; i++){
                    text.value.push({
                        valueArray:['']
                    });
                }
            }

            var textX, textY;
            for(var seriesIndex = 0;seriesIndex < text.value.length; seriesIndex++){

                var value = text.value[seriesIndex], valueHeight = this.maxSeriesLineHeight[seriesIndex];

                var valueArray = value.valueArray;

                value._value = value._value || [];

                var pointStyle = value.dataSheet.style;
                var valueLineHeight = BaseUtils.getTextHeight(pointStyle);

                var firstY = startY + this._getStartY(valueArray, pointStyle, valueHeight);

                var valueOption = value.dataSheet,
                    borderWidth = valueOption.borderWidth,
                    defaultBorderWidth = this.options.borderWidth;

                for(var i = 0; i < valueArray.length; i++){
                    textX = x + unitLength/2;
                    textY = firstY + (valueLineHeight + textPadding) * i + valueLineHeight/2 +  defaultBorderWidth / 2;

                    value._value[i] = value._value[i] || renderer.text().attr({'text-anchor':'middle', 'dy':'.32em', 'x': textX, 'y': textY})
                            .style('margin-top', '-0.53em').style(pointStyle).addTo(this.animationGroup);

                    value._value[i].textContent(valueArray[i]).animate({
                        'duration':TIME, 'ease':EASE, 'attr':{'x':textX, 'y':textY}
                    });

                    value._value[i].textContent(valueArray[i]).vMiddle();

                }

                value.border = value.border || this._drawTableElementBorder(this.borderGroup);
                
                var borderStyle =  {
                    "fill": "none",
                    "stroke-width": borderWidth,
                    "stroke": valueOption.borderColor
                };

                var borderAttr = {
                    "width": unitLength - borderWidth,
                    "height": valueHeight - borderWidth,
                    "transform": "translate(" + (x + borderWidth / 2) + "," + (startY + (borderWidth + defaultBorderWidth) / 2) + ")"
                }
                
                value.border.style(borderStyle).attr(borderAttr);

                for(var i = valueArray.length; i < value._value.length; i ++){
                    value._value[i].remove();
                }

                value._value.length = valueArray.length;

                startY += valueHeight;
            }
        },

        /**
         * +
         * @return {[type]} [description]
         */
        _drawSeries:function(){
            var renderer = this.vanchart.renderer, seriesG = renderer.group().addTo(this.dataSheetGroup);
            var seriesNames = this.seriesNames, seriesWidth = this.maxSeriesWidth, categoryHeight = this.maxCateLineHeight;

            var option = this.options,
                borderWidth = option.borderWidth;

            var startX = 16 + borderWidth, startY = categoryHeight;
            var seriesStyle = this._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.getTextPadding();
            var series = this.vanchart.series;

            var textMiddleX = (seriesWidth + startX) / 2;

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.maxSeriesLineHeight[index];
                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.85 + borderWidth /2 ;

                for(var i = 0; i < singleName.length; i++){
                    renderer.text()
                        .attr('x', textMiddleX)
                        .attr('text-anchor', 'middle')
                        .attr('y', firstY + (seriesLineHeight + textPadding) * i)
                        .textContent(singleName[i]).style(seriesStyle)
                        .style('margin-top', '-1em') // ie
                        .addTo(seriesG)
                        .vMiddle();
                }

                var seriesBorder = this._drawTableElementBorder(seriesG);
                seriesBorder.attr({
                    "width": seriesWidth - borderWidth,
                    "height": seriesHeight - borderWidth,
                    "transform": "translate(" + (borderWidth) + "," + (startY + borderWidth) + ")"
                })

                //
                var iconType = this.seriesIconType[index];
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                var iconX = PADDING_GAP_FUN() + this.options.borderWidth * 1.5,
                    iconY =  (seriesHeight - iconHeight) / 2 + startY + borderWidth / 2 ;

                if(LegendIconFactory.hasIcon(iconType)){
                    renderer.path().addTo(seriesG)
                        .attr('d', LegendIconFactory.getLegendIconPath(iconType))
                        .attr('transform', 'translate('+iconX+',' + iconY + ')')
                        .style({'fill': series[index].color});
                }else{
                    renderer.image(
                        {
                            'preserveAspectRatio':'none',
                            'x':iconX ,'y': iconY,
                            'width': 12, 'height': 12
                        })
                        .imageContent(iconType).addTo(seriesG)
                }

                startY += seriesHeight;
            }
        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        /**
         * 
         * @param  {[type]} group [group]
         * @param  {[type]} style []
         * @return {[type]}       [description]
         */
        _drawTableElementBorder: function(group, attr, style){
            var renderer = this.vanchart.renderer;

            var border = renderer.rect().addTo(group);

            border.style(style || this._getTableElementBorderStyle());

            return border;
        },

        /**
         * 
         * @return {[type]} [description]
         */
        _getTableElementBorderStyle: function(){
            var option = this.options;

            return {
                "stroke": option.borderColor,
                "stroke-width": option.borderWidth,
                "fill": "none"
            }
        },

        remove:function(){
            this.dataSheetGroup && this.dataSheetGroup.remove();
            this.dataSheetGroup = null;
            this.showTextMap = null;
        }
    });

    ComponentLibrary.register(ComponentLibrary.DATA_SHEET_COMPONENT, DataSheet);
    return DataSheet;
});
/**
 * Created by Yuqian on 2016/10/14.
 */
define('component/TrendLine',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../vans/VanChart','../utils/PathGenerator'],function (require) {
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var VanChart = require('../vans/VanChart');
    var PathGenerator = require('../utils/PathGenerator');

    function isInvert(location) {
        return location === Constants.LEFT || location === Constants.RIGHT;
    }

    function leastSquares (asXsues, asYsues){
        var reduceSumFunc = function(prev, cur) { return prev + cur; };

        var xBar = asXsues.reduce(reduceSumFunc) * 1.0 / asXsues.length;
        var yBar = asYsues.reduce(reduceSumFunc) * 1.0 / asYsues.length;

        var ssXX = asXsues.map(function(d) { return Math.pow(d - xBar, 2); })
            .reduce(reduceSumFunc);

        var ssYY = asYsues.map(function(d) { return Math.pow(d - yBar, 2); })
            .reduce(reduceSumFunc);

        var ssXY = asXsues.map(function(d, i) { return (d - xBar) * (asYsues[i] - yBar); })
            .reduce(reduceSumFunc);

        var slope = ssXY / ssXX;
        var intercept = yBar - (xBar * slope);

        return [slope, intercept];
    }

    VanChart.include({

        trendLines: [],

        calcTrendLines:function(){
            var trendLines = [], vanchart = this, series = vanchart.series;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i], trendLine = sery.options.trendLine;
                //
                if(!trendLine || !sery.visible){
                    continue;
                }

                var func;
                switch (trendLine.type) {
                    case Constants.LINEAR:
                        func = vanchart.linear;
                        break;
                    case Constants.LOGARITHMIC:
                        func = vanchart.logarithmic;
                        break;
                    case Constants.POLYNOMIAL:
                        func = vanchart.polynomial;
                        break;
                    default:
                    case Constants.EXPONENTIAL:
                        func = vanchart.exponential;
                }

                var XY = sery.getTrendLineXYValues(sery);
                if (XY[0].length <= 1) {
                    continue;
                }
                var isInverted = isInvert(XY[2]);
                var asXs, asYs;

                if (isInverted) {
                    asYs = XY[0];
                    asXs = XY[1];
                } else {
                    asXs = XY[0];
                    asYs = XY[1];
                }

                var data = func(asXs, asYs, this.extendXs(asXs, trendLine.period));

                var lineGen = PathGenerator.line().interpolate('cardinal');
                if (isInverted) {
                    // normal: [x, y]; inverted: [y, x]
                    lineGen.x(function (d) {return d[1];}).y(function (d) {return d[0];});
                }

                var line = {
                    d: lineGen(data),
                    trendLine: trendLine
                };

                trendLines.push(line);
            }

            this.trendLines = trendLines;
        },

        extendXs: function (asXs, period) {
            if (period && period.length === 2 && asXs.length > 1) {
                var gap = asXs[1] - asXs[0];

                return newArray(-period[0], function (t, i) { return asXs[0] - (i + 1) * gap; })
                    .reverse()
                    .concat(asXs)
                    .concat(
                        newArray(period[1], function (t, i) { return asXs[asXs.length - 1] + (i + 1) * gap; })
                    );
            }
            return asXs;

            function newArray(length, fillFun) {
                return Array.apply(null, Array(length)).map(fillFun)
            }
        },

        linear: function (asXs, asYs, extXs) {
            var x1,x2,y1,y2;

            var coeff = leastSquares(asXs, asYs);
            x1 = extXs[0];
            y1 = coeff[0] * x1 + coeff[1];
            x2 = extXs[extXs.length - 1];
            y2 = coeff[0] * x2 + coeff[1];

            return [[x1, y1], [x2, y2]];
        },

        logarithmic: function (asXs, asYs, extXs) {

            var newXs = [], newYs = [];

            // get min X in extendXs
            var minX = Math.min.apply(null, extXs);

            asXs
                .map(function (val, i) {
                    if (minX <= 0) {
                        // offset to positive
                        val += (-minX) + 1;
                    }
                    newXs.push(Math.log(val));
                    newYs.push(asYs[i]);
                });

            var coeff = leastSquares(newXs, newYs);

            return extXs
                .map(function (val) {
                    var x = val; // x is the true position
                    if (minX <= 0) {
                        val += (-minX) + 1; // value offset is equation's value
                    }
                    return [x, coeff[0] * Math.log(val) + coeff[1]];
                })
        },

        exponential: function (asXs, asYs, extXs) {

            var newXs = [], newYs = [];

            var minY = Math.min.apply(null, asYs);

            asXs
                .map(function (val, i) {
                    if (minY <= 0) {
                        // offset to positive
                        asYs[i] += (-minY) + 1;
                    }
                    newXs.push(val);
                    newYs.push(Math.log(asYs[i]));
                });

            var coeff = leastSquares(newXs, newYs);

            var tmp = coeff[0];
            coeff[0] = Math.exp(coeff[1]);
            coeff[1] = tmp;

            return extXs
                .map(function (val) {
                    var y = coeff[0] * Math.exp(val * coeff[1]);
                    if (minY <= 0) {
                        y -= (-minY) + 1;
                    }
                    return [val, y];
                });
        },

        polynomial: function (asXs, asYs, extXs) {
            var M = Math.min(asXs.length - 1, 6);
            M++;
            var t;
            var b = [];
            var A = [];
            for (var i = 0; i < M; i++) {
                b[i] = [];
                A[i] = [];
            }
            var B = [];
            var y = [];
            var coeff = [];

            var i, j, k, l;
            for (i = 0; i < M; i++) {
                for (j = 0; j < asXs.length; j++) {
                    t = 1;
                    for (l = 0; l < i; l++) {
                        t = t * asXs[j];
                    }
                    b[i][j] = t;
                }
            }

            for (i = 0; i < M; i++) {
                for (k = 0; k < M; k++) {
                    t = 0;
                    for (j = 0; j < asXs.length; j++) {
                        t += b[i][j] * b[k][j];
                    }
                    A[i][k] = t;
                }
            }
            for (i = 0; i < M; i++) {
                t = 0;
                for (j = 0; j < asXs.length; j++) {
                    t += asYs[j] * b[i][j];
                }
                B[i] = t;
            }

            for (i = 1; i < M; i++) {
                A[i][0] = A[i][0] / A[0][0];
            }
            for (i = 1; i < M; i++) {
                for (j = i; j < M; j++) {
                    var tmp1 = 0;
                    for (k = 0; k < i; k++) {
                        tmp1 += A[k][j] * A[i][k];
                    }
                    A[i][j] = A[i][j] - tmp1;
                    if (j + 1 != M) {
                        var tmp2 = 0;
                        for (k = 0; k < i; k++) {
                            tmp2 += A[k][i] * A[j + 1][k];
                        }
                        A[j + 1][i] = (A[j + 1][i] - tmp2) / A[i][i];
                    }

                }
            }
            y[0] = B[0];
            for (i = 1; i < M; i++) {
                t = 0;
                for (j = 0; j < i; j++) {
                    t += A[i][j] * y[j];
                }
                y[i] = B[i] - t;
            }

            coeff[M - 1] = y[M - 1] / A[M - 1][M - 1];
            for (i = M - 2; i >= 0; i--) {
                t = 0;
                for (j = i + 1; j < M; j++) {
                    t += A[i][j] * coeff[j];
                }
                coeff[i] = (y[i] - t) / A[i][i];
            }

            return extXs
                .map(function (val) {
                    return [
                        val,
                        coeff.reduce(function (prev, curr, i) {
                            return prev + curr * Math.pow(val, i);
                        }, 0)
                    ]
                });
        },

        _renderTrendLine:function(){
            this.calcTrendLines();
            var trendLineOptions = this.trendLines, plotBounds = this.bounds, renderer = this.renderer;

            if(!this.trendLineGroup){
                // don't render it if empty
                if (!(this.trendLines && this.trendLines.length)) {
                    return
                }
                this.trendLineGroup = this.seriesGroup.append(renderer.group());
                renderer.clip(this.trendLineGroup, this.plotClip);
            }
            this.trendLineGroup.trendLines = this.trendLineGroup.trendLines || [];
            var trendLines = this.trendLineGroup.trendLines;

            for(var i = 0, len = trendLineOptions.length; i < len; i++){
                var options = trendLineOptions[i], attrs = {'d': options.d},
                    style = {'fill': 'none', 'stroke':options.trendLine.color, 'stroke-width':options.trendLine.width, 'stroke-dasharray':Constants.DASH_TYPE[options.trendLine.dashStyle]};
                if(trendLines[i]){
                    trendLines[i].attr(attrs).style(style);
                }else{
                    trendLines[i] = renderer.path(attrs).style(style).addTo(this.trendLineGroup);
                }
                trendLines[i].attr('transform', BaseUtils.makeTranslate(plotBounds));
            }

            for(var i = trendLineOptions.length; i < trendLines.length; i++){
                trendLines[i].remove(); trendLines[i] = null;
            }

            trendLines.length = trendLineOptions.length;
            return this.trendLineGroup;
        }
    })
});
/**
 * Created by Cmen on 2017/6/20.
 */
define('component/MoreLabel',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Base','../ComponentLibrary','../utils/BezierEasing','../dom/DomUtils','../vector/SvgRenderer','../vector/VmlRenderer','../utils/ColorUtils'],function(require) {
    var Constants = require("../Constants");
    var BaseUtils = require("../utils/BaseUtils");
    var QueryUtils = require("../utils/QueryUtils");
    var Base = require("./Base");
    var ComponentLibrary = require("../ComponentLibrary");
    var BezierEasing = require("../utils/BezierEasing");
    var DomUtils = require("../dom/DomUtils");
    var SvgRenderer = require("../vector/SvgRenderer");
    var VmlRenderer = require("../vector/VmlRenderer");
    var ColorUtils = require("../utils/ColorUtils");

    var DEFAULT_PADDING = 6,
        DEFAULT_GAP = 5;

    // deley
    var MORELABEL_BORDER_INIT_TIME = 250,
        MORELABEL_CONTENT_INIT_TIME = 350,
        MORELABEL_CONTENT_REMOVE_TIME = 350,
        MORELABEL_BORDER_REMOVE_TIME = 250;

    var MORELABEL_BORDER_INIT_EASE = BezierEasing.css["ease"], // init
        MORELABEL_BORDER_EXIT_EASE = BezierEasing.css["ease"], // exit
        MORELABEL_CONTENT_INIT_EASE = BezierEasing.css["ease"], // Init
        MORELABEL_CONTENT_EXIT_EASE = BezierEasing.css["ease"]; // exit

    var MORELABEL_TOTAL_TIME = MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + MORELABEL_CONTENT_REMOVE_TIME + MORELABEL_BORDER_REMOVE_TIME;

    // 
    var DEFAULT_TRIANGLE_SIZE = 5,
        DEFAULT_BORDER_RADIUS = 8;

    // x, y, 
    var identifiers = [
        'changedValue', // 
        'changedPercent', // 
        'changedArrivalRate', // 
        'changedWordRate', // 
        'value', // 
        'percent', // 
        'name', // 
        'wordRate', // 
        'arrivalRate', // 
        'x', // x
        'y', // y
        'series', // 
        'category', // 
        'size'
    ];

    var contentType = {
        'changedValue': 'changedValue',
        'changedPercent': 'changedValue',
        'changedArrivalRate': 'changedValue',
        'changedWordRate': 'changedValue',
        'value': 'value',
        'size': 'value',
        'percentage': 'value',
        'x': 'value',
        'y': 'value',
        'arrivalRate': 'value',
        'wordRate': 'value',
        'seriesName': 'series',
        'category': 'series',
        'name': 'series'
    }

    var identifierMap = {};

    identifiers.forEach(function(identifier) {
        var key = "{" + identifier.toUpperCase() + "}";
        identifierMap[key] = [identifier, identifier + "Format"];
    });


    identifierMap['{SERIES}'] = ['seriesName', 'seriesFormat'];
    identifierMap['{PERCENT}'] = ['percentage', 'percentFormat'];
    identifierMap['{X}'] = ['x', 'XFormat'];
    identifierMap['{Y}'] = ['y', 'YFormat'];

    var MoreLabel = Base.extend({
        /**
         * @override Base.initialize
         * @param options  moreLabel
         * @param componentType  
         * @param vanchart    vanchart
         */
        initialize: function(options, componentType, vanchart) {
            this.componentType = componentType;
            this.vanchart = vanchart;
            this.refresh(options);

            this.hasAniamtion = vanchart.renderer.isAnimation;
            // 
            this.pointsContentArray = [];
            this.contentArray = [];
            // moreLabelGdivLabelG
            this.svgMoreLabels = [];
            this.divMoreLabels = [];
        },

        /**
         * 
         * @param options
         * @private
         */
        _refresh: function(options) {
            QueryUtils.merge(options, this.getDefaultMoreLabelOptions());

            // 0moreLabel
            if(options.duration == 0){
                options.enabled = false;
            }
        },

        /**
         * Domsvgdiv
         * @param dom
         */
        doLayout: function(dom) {
            if (!this._dom) {
                dom = dom || this.vanchart.getDivParentDom();

                this._dom = DomUtils.create("div", "moreLabelWrapper", dom);
                this._dom.style.cssText = "width:100%;height:100%;top:0;left:0;position:absolute;pointer-events:none;";

                this.renderer = BaseUtils.isSupportSVG() ? new SvgRenderer(this._dom, this.vanchart) : new VmlRenderer(this._dom, this.vanchart);
                this.renderer.onAdd();
            }
        },

        /**
         * MoreLabel
         */
        removeAllMoreLabels: function() {
            if (this.svgMoreLabels.length === 0 && this.divMoreLabels.length === 0) {
                return;
            }

            this.svgMoreLabels.forEach(function(moreLabel) {
                moreLabel.remove();
            });
            this.divMoreLabels.forEach(function(moreLabel) {
                moreLabel.remove();
            });

            this.svgMoreLabels = [];
            this.divMoreLabels = [];
        },

        /**
         * group
         * MoreLabeltooltipmoreLabel
         * MoreLabel
         * @return {[type]} [description]
         */
        remove: function (){
            this.removeAllMoreLabels();
        },

        /**
         * pointmoreLabel, like Tooltip.showWithPoint.
         * @param point  point
         * @param startX moreLabelX(seires.calcMoreLabelPosition)
         * @param startY moreLabelX(startX)
         */
        showWithPoint: function(point, startX, startY) {
            if (this.pointsContentArray.length === 0) {
                return;
            }

            var series = point.series, vanchart = series.vanchart;
            // 
            this.layoutContent();
            var moreLabelDim = {
                width: this.moreLabelWidth,
                height: this.moreLabelHeight
            };

            var position;
            if (BaseUtils.hasDefined(startX) && BaseUtils.hasDefined(startY)) {
                position = {
                    startX: startX,
                    startY: startY,
                    direction: "top"
                }
            } else {
                position = series.calcMoreLabelPosition(point, moreLabelDim);
            }

            position = this._calculateBeyondBounds(position)

            this._show(position);
        },

        /**
         * moreLabel:
         * 
         * @param position
         */
        _calculateBeyondBounds: function(position) {
            position.direction = position.direction || "top";

            var domWidth = BaseUtils.getDomWidth(this._dom),
                domHeight = BaseUtils.getDomHeight(this._dom);

            var dir = position.direction,
                startX = position.startX,
                startY = position.startY,
                moreLabelHeight = this.moreLabelHeight,
                moreLabelWidth = this.moreLabelWidth;

            switch (dir) {
                case "top":
                    if (startY - moreLabelHeight - DEFAULT_TRIANGLE_SIZE < 0) {
                        dir = "bottom";
                    }
                    break;
                case "bottom":
                    if (startY + moreLabelHeight + DEFAULT_TRIANGLE_SIZE > domHeight) {
                        dir = "top";
                    }
                    break;
                case "left":
                    if (startX - moreLabelWidth - DEFAULT_TRIANGLE_SIZE < 0) {
                        dir = "right";
                    }
                    break;
                case "right":
                    if (startX + moreLabelWidth + DEFAULT_TRIANGLE_SIZE > domWidth) {
                        dir = "left";
                    }
                    break;
            }

            position.direction = dir;
            return position;
        },

        /**
         * MoreLabel
         * @param position moreLabel
         */
        _show: function(position) {
            var moreLabel = this,
                option = this.options,
                renderer = this.renderer;

            var svgContainer = renderer._container,
                divContainer = renderer._divContainer;

            var useHtml = BaseUtils.isSupportSVG() ? option.useHtml : true;
            var direction = position.direction || "top";

            var moreLabelG, moreLabelDivG;

            if(this.vanchart.isMap()){
                position = this._considerMapPane(position);
            }

            var translateInfo = this.calculateTranslate(position);

            moreLabelG = renderer.group().addTo(svgContainer);
            this.svgMoreLabels.push(moreLabelG);
            moreLabelG.attr({
                "transform": "translate(" + translateInfo[0] + "," + translateInfo[1] + ")"
            });

            this.renderSvgBorder(moreLabelG, renderer, direction);
            if (useHtml) {
                moreLabelDivG = renderer.div().addTo(divContainer);
                moreLabelDivG.style({
                    "left": translateInfo[0] + "px",
                    "top": translateInfo[1] + "px"
                });
                this.divMoreLabels.push(moreLabelDivG);
                this.renderHtmlContent(moreLabelDivG, renderer);
            } else {
                this.renderSvgContent(moreLabelG, renderer);
            }

            var removeMoreLabelDelay = MORELABEL_TOTAL_TIME + this.getMoreLabelDuration();

            // moreLabel
            this.vanchart.setTimeout('moreLabel_remove_timer', function() {
                moreLabel.removeAllMoreLabels();
            }, removeMoreLabelDelay);

            this.resetContentArray();
        },

        /**
         * Path
         * @param width 
         * @param height 
         * @param triangleDirection 
         * @param borderWidth 
         * @param borderRadius 
         * @param triangleSize 
         * @returns {string} path
         */
        borderPathGenerator: function(width, height, triangleDirection, borderWidth, borderRadius, triangleSize) {
            width += borderWidth;
            height += borderWidth;
            var r = borderRadius;
            // 
            var isVertical = triangleDirection === "top" || triangleDirection === "bottom";
            var maxBorderRadius = Math.min((width - (isVertical ? triangleSize * 2 : 0)), (height - (isVertical ? 0 : triangleSize * 2))) / 2;
            if(r > maxBorderRadius) {
                r = maxBorderRadius;
            }

            var endPoints = [
                    [0, 0],
                    [width, 0],
                    [width, height],
                    [0, height]
                ],
                curvePoints = [
                    [0, r],
                    [r, 0],
                    [width - r, 0],
                    [width, r],
                    [width, height - r],
                    [width - r, height],
                    [r, height],
                    [0, height - r],
                    [0, r]
                ];

            var direction = ['top', 'right', 'bottom', 'left'];
            // 4
            var path = 'M' + points(curvePoints[0]) + angle(0) + line(0) + angle(1) + line(1) + angle(2) + line(2) + angle(3) + line(3);

            return path;

            function points(arr) {
                return arr.join(',');
            }
            // 
            function angle(index) {
                var p1 = endPoints[index],
                    p2 = curvePoints[index * 2 + 1];
                return 'Q' + points(p1) + ',' + points(p2);
            }
            // 
            function line(index) {
                var p1 = curvePoints[index * 2 + 1],
                    p2 = curvePoints[index * 2 + 2]

                if (direction[index] === triangleDirection) { // 
                    var centerPoints = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];

                    var centerX = centerPoints[0],
                        centerY = centerPoints[1];

                    var x1, x2, y1, y2;

                    switch (index) {
                        case 0:
                            x1 = -1;
                            y1 = 0;
                            x2 = 0;
                            y2 = -1;
                            break;
                        case 1:
                            x1 = 0;
                            y1 = -1;
                            x2 = 1;
                            y2 = 0;
                            break;
                        case 2:
                            x1 = 1;
                            y1 = 0;
                            x2 = 0;
                            y2 = 1;
                            break;
                        case 3:
                            x1 = 0;
                            y1 = 1;
                            x2 = -1;
                            y2 = 0;
                            break;
                    }

                    var m1 = [centerX + x1 * triangleSize, centerY + y1 * triangleSize];
                    var m2 = [centerX + x2 * triangleSize, centerY + y2 * triangleSize];
                    var m3 = [centerX - x1 * triangleSize, centerY - y1 * triangleSize];

                    return 'L' + points(m1) + 'L' + points(m2) + 'L' + points(m3) + 'L' + points(p2);
                }
                return 'L' + points(p2);
            }
        },

        /**
         * moreLabel
         * @param moreLabelG group
         * @param renderer
         * @param direction moreLabel
         */
        renderSvgBorder: function(moreLabelG, renderer, direction) {
            var position = {
                'top': 'bottom',
                'bottom': 'top',
                'right': 'left',
                'left': 'right'
            };

            var option = this.options,
                borderWidth = option.borderWidth,
                width = this.moreLabelWidth,
                height = this.moreLabelHeight,
                triangleDirection = position[direction],
                borderRadius = option.borderRadius || DEFAULT_BORDER_RADIUS;

            var path = this.borderPathGenerator(width, height, triangleDirection, borderWidth, borderRadius, DEFAULT_TRIANGLE_SIZE);
            var duration = this.getMoreLabelDuration();

            var moreLabelBorder = renderer.path().addTo(moreLabelG);
            var borderShadow = this._createMoreLabelShadow(renderer);

            var transformOrigin = this.getSvgTransformOrigin(width, height,direction);
            // IEfireFoxSVG-transform-origintranslate(a,b) scale(c) translate(-a, -b)
            var setScaleWithOrigin = function (scale, origin){
                var leftTranslate = "translate("+origin[0]+","+origin[1]+")",
                rightTranslate = "translate("+ (-origin[0])+","+(-origin[1])+")";
                var translateScale = leftTranslate +" scale(" + scale + ") " + rightTranslate;

                // IE8SVG-transform-origin:
                // IE8
                // VMLRendertranslatetopleft
                return BaseUtils.isSupportSVG() ? translateScale : 'scale('+ scale +')';
            };


            var fillColor = typeof option.backgroundColor === 'string' ?
                    (option.backgroundColor || "rgba(0,0,0,0)") :
                    this._createGradientBackground(renderer, option.backgroundColor);

            moreLabelBorder
                .attr({
                    "d": path,
                    "transform": setScaleWithOrigin(1, transformOrigin),
                    "filter": option.shadow ? borderShadow : "none"
                })
                .style({
                    'fill': fillColor,
                    'stroke': option.borderColor,
                    'stroke-width': option.borderWidth
                });

            // 
            // transition
            // transition
            this.hasAniamtion && moreLabelBorder
                .attr("transform", setScaleWithOrigin(0, transformOrigin))
                .transition()
                .ease(MORELABEL_BORDER_INIT_EASE)
                .duration(MORELABEL_BORDER_INIT_TIME)
                .attr('transform', setScaleWithOrigin(1, transformOrigin))
                .transition()
                .ease(MORELABEL_BORDER_EXIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration + MORELABEL_CONTENT_REMOVE_TIME)
                .duration(MORELABEL_BORDER_REMOVE_TIME)
                .attr('transform', setScaleWithOrigin(0, transformOrigin));
        },

        /**
         * 
         * @param renderer
         * @returns {string}
         * @private
         */
        _createMoreLabelShadow: function (renderer) {
            this.borderShadow = this.borderShadow || renderer.createDropShadowFilter(0,0,4, 2);
            return 'url(#' + BaseUtils.stamp(this.borderShadow) + ')'
        },

        /**
         * 
         * @private
         */
        _createGradientBackground: function (renderer, color) {
            var toPercent = function (n){ return n * 100 + '%';}
            var x1 = toPercent(color.x1),
                x2 = toPercent(color.x2),
                y1 = toPercent(color.y1),
                y2 = toPercent(color.y2);

            var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
            var stop1 = {'offset':'0%', 'stop-color': ColorUtils.colorToHex(color.startColor)};
            var stop2 = {'offset':'100%', 'stop-color':  ColorUtils.colorToHex(color.endColor)};

            this.backgourndColorGradient = this.backgourndColorGradient || renderer.colorGradient(attrs, [stop1, stop2]);

            return "url(#" + BaseUtils.stamp(this.backgourndColorGradient) +")";
        },

        /**
         * SVGScaleIEfireFoxtransform-origin
         * @param width
         * @param height
         * @param direction
         */
        getSvgTransformOrigin: function (width, height, direction) {
            var centerX = width / 2,
                centerY = height / 2;

            var originPosition;

            switch(direction) {
                case "top":
                    originPosition = [centerX, height];
                    break;
                case "bottom":
                    originPosition = [centerX, 0];
                    break;
                case "right":
                    originPosition = [0, centerY];
                    break;
                case "left":
                    originPosition = [width, centerY];
                    break;
            }
            return originPosition;
        },

        /**
         * SVG
         * @param moreLabelG group
         * @param renderer
         */
        renderSvgContent: function(moreLabelG, renderer) {
            var contentArray = this.contentArray;
            var svgOffset = !BaseUtils.isSupportSVG() ? {} : {
                'dy': '0.32em'
            };
            var option = this.options;

            var duration = this.getMoreLabelDuration();

            var textGroup = renderer.group().addTo(moreLabelG);

            contentArray.forEach(function(content) {
                var textG = renderer.group()
                    .attr({
                        'transform': BaseUtils.makeTranslate([content.x + option.borderWidth, option.borderWidth + content.y + content.height / 2])
                    })
                    .addTo(textGroup);

                var text = renderer.text().attr(svgOffset).addTo(textG);
                content.data.forEach(function(c) {
                    renderer.tspan().style(c.style).textContent(c.content).addTo(text);
                })
            });

            this.hasAniamtion && textGroup
                .attr('fill-opacity', 0)
                .transition()
                .ease(MORELABEL_CONTENT_INIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME)
                .duration(MORELABEL_CONTENT_INIT_TIME)
                .attr('fill-opacity', 1)
                .transition()
                .ease(MORELABEL_CONTENT_EXIT_EASE)
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration)
                .duration(MORELABEL_CONTENT_REMOVE_TIME)
                .attr('fill-opacity', 0);
        },

        /**
         * HTML
         * @param divG div
         * @param renderer
         */
        renderHtmlContent: function(divG, renderer) {
            var contentArray = this.contentArray;
            var duration = this.getMoreLabelDuration();

            contentArray.forEach(function(content) {
                var lineHeight = content.height;
                var lineDiv = renderer.div()
                                .style({
                                    "top": content.y + 'px',
                                    "left": content.x + 'px'
                                })
                                .addTo(divG);

                var translateX = 0;
                content.data.forEach(function(d) {
                    var dim = d.dim;
                    var style = BaseUtils.clone(d.style);
                    style.display = 'inline-block';
                    style['lineHeight'] = parseFloat(style.fontSize) * 1.33 + 'px';
                    style['top'] = lineHeight - dim.height + 'px';
                    style['left'] = translateX + 'px';

                    renderer.div()
                        .style(style)
                        .textContent(d.content)
                        .addTo(lineDiv);

                    translateX += dim.width;
                });
            });

            this.hasAniamtion && divG
                .style("opacity", 0)
                .transition()
                .style({
                    "opacity": 1
                })
                .delay(MORELABEL_BORDER_INIT_TIME)
                .duration(MORELABEL_CONTENT_INIT_TIME)
                .ease(MORELABEL_CONTENT_INIT_EASE)
                .transition()
                .style({
                    "opacity": 0
                })
                .delay(MORELABEL_BORDER_INIT_TIME + MORELABEL_CONTENT_INIT_TIME + duration)
                .duration(MORELABEL_CONTENT_REMOVE_TIME)
                .ease(MORELABEL_CONTENT_EXIT_EASE)
        },

        /**
         * moreLabel.pointsContentArray
         * @param point
         * @returns {*}
         */
        collectPoint: function(point) {
            var option = this.options,
                formatter = option.formatter;

            // MoreLabelvanchart.domMoreLabel
            // MoreLabelMoreLabel
            // 
            var series = point.series, vanchart = series.vanchart, plotBounds = vanchart.bounds;
            var isOutChartBounds = function (x, y){
                return x < plotBounds.x || x > plotBounds.x + plotBounds.width || y < plotBounds.y || y > plotBounds.y + plotBounds.height;
            };

            // 
            if(series.calcMoreLabelPosition){
                var pointPos = series.calcMoreLabelPosition(point, {width: 0, height: 0})
                if(isOutChartBounds(pointPos.startX, pointPos.startY)){
                    return;
                }
            }

            // ,calculateContent
            if (typeof formatter !== 'object') {
                try {
                    var content =  BaseUtils.getFormatterFunction(formatter).call(point);
                    if(content){
                        this.pointsContentArray.push({
                            point: point,
                            seriesMap:[
                                {
                                    type: "series",
                                    content: content
                                }
                            ],
                            changedValueMap: [],
                            valueMap: [],
                            categoryMap: []
                        });
                    }
                    return;
                } catch (e) {
                    return;
                }
            }
            // 
            if (formatter.identifier === "") {
                return;
            }

            this.calculateContent(formatter, point);
        },

        /**
         * MoreLabel
         * @return {[type]} [description]
         */
        getMoreLabelDuration: function (){
            var duration = this.options.duration;
            return BaseUtils.hasDefined(duration) ? duration * 1000 : 3000;
        },

        /**
         * 
         */
        layoutContent: function() {
            var self = this;

            // ()
            if (this.pointsContentArray.length === 1) {
                this.onePointMoreLabelLayout(this.pointsContentArray[0]);
            } else {
                this.pointsContentArray.forEach(function(pointContentObj, index, arr) {
                    // lastPoint
                    if (index === arr.length - 1) {
                        self.morePointsMoreLabelLayout(pointContentObj, true);
                    } else {
                        self.morePointsMoreLabelLayout(pointContentObj);
                    }

                })
            }

            // 
            this.calculateContentDim();
        },

        /**
         * MoreLabelMoreLabel
         * @param position
         * @returns {[*,*]}
         */
        calculateTranslate: function(position) {
            var translateX = 0,
                translateY = 0,
                moreLabelPosX = position.startX,
                moreLabelPosY = position.startY;

            var moreLabelWidth = this.moreLabelWidth,
                moreLabelHeight = this.moreLabelHeight;

            switch (position.direction) {
                case 'top':
                    translateX = moreLabelPosX - moreLabelWidth / 2;
                    translateY = moreLabelPosY - moreLabelHeight - DEFAULT_TRIANGLE_SIZE;
                    break;
                case 'bottom':
                    translateX = moreLabelPosX - moreLabelWidth / 2;
                    translateY = moreLabelPosY + DEFAULT_TRIANGLE_SIZE;
                    break;
                case 'right':
                    translateX = moreLabelPosX + DEFAULT_TRIANGLE_SIZE;
                    translateY = moreLabelPosY - moreLabelHeight / 2;
                    break;
                case 'left':
                    translateX = moreLabelPosX - moreLabelWidth - DEFAULT_TRIANGLE_SIZE;
                    translateY = moreLabelPosY - moreLabelHeight / 2;
                    break;
            }

            return [translateX, translateY];
        },

        /**
         * 
         * @param pointContentObj
         */
        onePointMoreLabelLayout: function(pointContentObj) {
            var self = this;

            var point = pointContentObj.point, series = point.series, chartType = series.type;
            var vanchart = series.vanchart;

            var Style = this._getContentStyle(),
                plusStyle = Style.plus,
                minusStyle = Style.minus,
                numericalStyle = Style.numerical,
                textStyle = Style.text,
                delimiterStyle = Style.delimiter;

            var changedStyle = point.changedValue > 0 ? plusStyle : minusStyle;

            var changedValueMap = pointContentObj.changedValueMap,
                valueMap = pointContentObj.valueMap,
                seriesMap = pointContentObj.seriesMap,
                categoryMap = pointContentObj.categoryMap;

            // 
            seriesMap = categoryMap.concat(seriesMap);


            var changedCount = changedValueMap.length,
                valueCount = valueMap.length,
                seriesCount = seriesMap.length;

            // 
            if (!vanchart.isMap() && (chartType === Constants.BUBBLE_CHART || chartType === Constants.SCATTER_CHART)) {
                bubbleContentLayoutFuc();
            } else {
                defaultContentLayoutFuc();
            }

            // 
            function bubbleContentLayoutFuc() {
                var xContent, yContent, valueContent;

                valueMap.forEach(function(value) {
                    var type = value.type,
                        content = value.content;

                    if (type === 'x') {
                        xContent = content + ''; // 0false
                    } else if (type === 'y') {
                        yContent = content + '';
                    } else if (type === 'size' || type === 'value') {
                        valueContent = content;
                    }
                });

                var lineOne = [],
                    lineTwo = [];

                // 
                changedCount && pushContent(lineOne, changedValueMap[0].content, changedStyle);

                // 
                ((changedCount === 1 && valueCount) || changedCount === 2) && pushContent(lineOne, "/", delimiterStyle);

                // 
                (changedCount === 2) && pushContent(lineOne, changedValueMap[1].content, changedStyle);

                // 
                var newValueContent = '';
                if (valueCount) {
                    newValueContent += valueContent;
                }

                // 
                if (xContent && yContent) {
                    newValueContent += '  (' + xContent + ',' + yContent + ')';
                } else if (xContent || yContent) {
                    newValueContent += '  (' + (xContent || yContent) + ')';
                }
                // 
                newValueContent && pushContent(lineOne, newValueContent, textStyle);

                pushLine(lineOne);

                seriesCount && lineTwo.push(lineContentFuc(seriesMap, " ", textStyle));
                pushLine(lineTwo);
            }

            /**
             * 
             * 2/
             */
            function defaultContentLayoutFuc() {
                var lineOne = [],
                    lineTwo = [],
                    lineThree = [];
                // 
                if (changedCount + valueCount > 2) {
                    lineOne.push(lineContentFuc(changedValueMap, '/', changedStyle));
                    lineTwo.push(lineContentFuc(valueMap, '/', numericalStyle))
                }
                // 
                else {
                    changedCount && lineOne.push(lineContentFuc(changedValueMap, '/', changedStyle));
                    if (changedCount === 1 && valueCount === 1) {
                        lineOne.push({
                            content: '/',
                            style: delimiterStyle
                        });
                    }
                    valueCount && lineOne.push(lineContentFuc(valueMap, '/', numericalStyle))
                }

                seriesCount && lineThree.push(lineContentFuc(seriesMap, ' ', textStyle));

                lineOne.length && self.contentArray.push({
                    data: lineOne
                });

                lineTwo.length && self.contentArray.push({
                    data: lineTwo
                });

                lineThree.length && self.contentArray.push({
                    data: lineThree
                });
            }

            /**
             * contentArray.
             * @param line
             */
            function pushLine(line) {
                line.length && self.contentArray.push({
                    data: line
                });
            }

            function pushContent(line, content, style) {
                line.push({
                    content: content,
                    style: style
                })
            }
            /**
             * 
             */
            function lineContentFuc(contentMap, separator, style) {
                var content, len = contentMap.length;
                if (len === 1) {
                    content = contentMap[0].content;
                } else if (len === 2) {
                    content = contentMap[0].content + separator + contentMap[1].content;
                }
                if (content) {
                    return {
                        content: content,
                        style: style
                    }
                }
            }
        },

        /**
         * 
         * @param pointContentObj 
         * @param lastPoint ()
         */
        morePointsMoreLabelLayout: function(pointContentObj, lastPoint) {
            var self = this;

            var point = pointContentObj.point, series = point.series, chartType = series.type;

            var Style = this._getContentStyle();

            var plusStyle = Style.plus,
                minusStyle = Style.minus,
                numericalStyle = Style.numerical,
                textStyle = Style.text,
                delimiterStyle = Style.delimiter;

            var changedStyle = point.changedValue > 0 ? plusStyle : minusStyle;

            var changedValueMap = pointContentObj.changedValueMap,
                valueMap = pointContentObj.valueMap,
                seriesMap = pointContentObj.seriesMap,
                categoryMap = pointContentObj.categoryMap;

            var cateContent = this._isPointOrAreaMap(chartType) ? point.name : point.category;

            var changedCount = changedValueMap.length,
                valueCount = valueMap.length,
                seriesCount = seriesMap.length,
                categoryCount = categoryMap.length;

            var lineData = [];

            var changedContent = createContent(changedValueMap);
            var valueContent = createContent(valueMap, true);
            var seriesContent = createContent(seriesMap, true);

            // 
            changedCount && pushContent(lineData, changedContent, changedStyle);
            // 
            if (changedCount === 1 && (valueCount || seriesCount)) {
                pushContent(lineData, "/", delimiterStyle)
            }
            // 
            valueCount && pushContent(lineData, valueContent, numericalStyle)
                // 
            seriesCount && pushContent(lineData, seriesContent, textStyle)
                // contentArray
            lineData.length && self.contentArray.push({
                data: lineData
            });
            // 
            if (lastPoint && categoryCount && cateContent) {
                self.contentArray.push({
                    data: [{
                        content: cateContent,
                        style: textStyle
                    }]
                })
            }

            function createContent(contentMap, space) {
                var content = space ? "  " : "";
                switch(contentMap.length) {
                    case 2 :
                        content += contentMap[0].content + '/' + contentMap[1].content;
                        break;
                    case 1 :
                        content += contentMap[0].content;
                        break;
                }
                return content;
            }

            function pushContent(line, content, style) {
                line.push({
                    content: content,
                    style: style
                })
            }
        },

        /**
         * , 
         * 
         */
        _getContentStyle: function() {
            // TODO this
            // 
            // 
            if(this.moreLabelStyle) {
                return this.moreLabelStyle;
            }

            var style = this.options.style,
                customStyle = style.custom;

            // Scale
            if(customStyle) {
                customStyle = BaseUtils.calculateFontSizeWithScale(customStyle);
            }

            ['plus', 'minus', 'numerical', 'text'].forEach(function (name) {
                style[name] = BaseUtils.calculateFontSizeWithScale(style[name]);
            })

            var plusStyle = customStyle ? customStyle : style.plus,
                minusStyle = customStyle ? customStyle : style.minus,
                numericalStyle = customStyle ? customStyle : style.numerical,
                textStyle = customStyle ? customStyle : style.text,
                delimiterStyle = customStyle ? customStyle : {
                    "fontSize": style.plus.fontSize,
                    "fontFamily": style.plus.fontFamily,
                    "color": "#1515151"
                };

            this.moreLabelStyle = {
                plus: plusStyle,
                minus: minusStyle,
                numerical: numericalStyle,
                text: textStyle,
                delimiter: delimiterStyle
            }

            return this.moreLabelStyle;
        },

        /**
         * 
         * @param formatter
         * @param point
         */
        calculateContent: function(formatter, point) {
            var series = point.series,
                chartType = series.type;

            var changedValueMap = [],
                valueMap        = [],
                seriesMap       = [],
                categoryMap     = [];

            var moreLabel = this;

            var sortContent = function (type, content) {
                if(!content){ return; }  // 
                var contentObj = {
                    type: type,
                    content: content
                };

                switch(contentType[type]) {
                    case 'changedValue':
                        changedValueMap.push(contentObj);
                        break;
                    case 'value':
                        valueMap.push(contentObj);
                        break;
                    case 'series':
                        if((moreLabel._isPointOrAreaMap(chartType) && type === 'name') || type === 'category') {
                            categoryMap.push(contentObj)
                        } else {
                            seriesMap.push(contentObj);
                        }
                        break;
                }
            };

            formatter.identifier.substring(1).split("$").forEach(function(id) {
                var type = identifierMap[id][0],
                    formatKey = identifierMap[id][1];

                var content;

                // 
                if (chartType === Constants.TREEMAP_CHART && type === 'name') {
                    content = treeMapNameContentFuc(point);
                } else {
                    content = BaseUtils.format(point[type == 'size' ? 'value' : type], formatter[formatKey]);
                }
                // FR.format+,+
                if(type === 'changedValue' && content > 0) {
                    content = '+' + content;
                }

                sortContent(type, content);

            });

            this.pointsContentArray.push({
                point: point,
                changedValueMap: changedValueMap,
                valueMap: valueMap,
                seriesMap: seriesMap,
                categoryMap: categoryMap
            });

            // 
            function treeMapNameContentFuc(point) {
                var p, d = point,
                    points = [point.name];
                while ((p = d.parent) && p.depth) {
                    d = p;
                    points.unshift(p.name);
                }

                return points.join(' / ');
            }
        },

        _isPointOrAreaMap: function (chartType){
            return chartType === Constants.AREA_MAP || chartType === Constants.POINT_MAP;
        },

        /**
         * showWithPointmoreLabel
         */
        resetContentArray: function() {
            this.pointsContentArray = [];
            this.contentArray = [];
        },

        /**
         * 
         * @param contentArray
         */
        calculateContentDim: function() {
            var gap = DEFAULT_GAP,
                padding = DEFAULT_PADDING;
            var maxWidth = 0,
                maxHeight = padding;

            var useHtml = this.options.useHtml;

            this.contentArray.forEach(function(line) {
                var lineWidth = 0,
                    lineHeight = 0;

                line.data.forEach(function(content) {
                    var dim = BaseUtils.getTextDimension(content.content, content.style, useHtml);
                    content.dim = dim;
                    lineWidth += dim.width;
                    lineHeight = Math.max(dim.height || 0, lineHeight);
                });

                line.x = padding;
                line.y = maxHeight;
                line.width = lineWidth;
                line.height = lineHeight;

                maxWidth = Math.max(lineWidth, maxWidth);
                maxHeight += lineHeight + gap;
            });

            this.moreLabelWidth = maxWidth + 2 * padding;
            this.moreLabelHeight = maxHeight - gap + padding;
        },

        /**
         * do nothing
         */
        render: function() {

        },

        /**
         * moreLabel.options
         */
        getDefaultMoreLabelOptions: function() {
            return {
                "style": {
                    "plus": {
                        "color": "#FF4848",
                        "fontSize": "22px",
                        "fontFamily": "Akrobat,Helvetica"
                    },
                    "minus": {
                        "color": "#1CBE91",
                        "fontSize": "22px",
                        "fontFamily": "Akrobat,Helvetica"
                    },
                    "numerical": {
                        "color": "#151515",
                        "fontSize": "12px",
                        "fontFamily": "Helvetica,Akrobat"
                    },
                    "text": {
                        "color": "#151515",
                        "fontSize": "12px",
                        "fontFamily": "Microsoft YaHei, PingFang SC"
                    }
                },
                "duration": 3000,
                "borderWidth": 1,
                "borderColor": "#000",
                "shadow": false,
                "useHtml": false
            }
        },

        /**
         * paneMovepixel
         * leaflettranslate
         * translate
         * @param position 
         * @returns {*}  
         * @private
         */
        _considerMapPane: function (position) {
            var mapTranslateInfo = this.vanchart._getMapPanePos();
            position.startX += mapTranslateInfo.x;
            position.startY += mapTranslateInfo.y;

            return position;
        }
    });

    ComponentLibrary.register(ComponentLibrary.MORELABEL_COMPONENT, MoreLabel);
    return MoreLabel;
});
/**
 * Created by eason on 16/2/5.
 */

define('FullChartTypes',['require','./VanCharts','./Carousel','./chart/Bar','./chart/Pie','./chart/Line','./chart/LineRadar','./chart/ColumnRadar','./chart/Bubble','./chart/Scatter','./chart/PointerGauge','./chart/SlotGauge','./chart/RingGauge','./chart/ThermometerGauge','./chart/MultiPie','./chart/TreeMap','./chart/Funnel','./chart/WordCloud','./chart/Structure','./chart/ForceBubble','./chart/Map','./chart/LineMap','./chart/gantt/Gantt','./component/Tooltip','./component/Axis','./component/GaugeAxis','./component/Legend','./component/Zoom','./component/ToolBar','./component/IntervalRangeLegend','./component/GradientRangeLegend','./component/Polar','./component/PolarAxis','./component/Title','./component/Geo','./component/DrillTools','./component/DataSheet','./component/TrendLine','./component/MoreLabel'],function(require){

    require('./VanCharts');
    require('./Carousel');

    //chart types
    require('./chart/Bar');
    require('./chart/Pie');
    require('./chart/Line');
    require('./chart/LineRadar');
    require('./chart/ColumnRadar');
    require('./chart/Bubble');
    require('./chart/Scatter');

    require('./chart/PointerGauge');
    require('./chart/SlotGauge');
    require('./chart/RingGauge');
    require('./chart/ThermometerGauge');


    //@Jeffrey
    require('./chart/MultiPie');
    require('./chart/TreeMap');

    require('./chart/Funnel');
    require('./chart/WordCloud');
    require('./chart/Structure');

    require('./chart/ForceBubble');

    require('./chart/Map');
    require('./chart/LineMap');

    require('./chart/gantt/Gantt');

    //components
    require('./component/Tooltip');
    require('./component/Axis');
    require('./component/GaugeAxis');
    require('./component/Legend');
    require('./component/Zoom');
    require('./component/ToolBar');
    require('./component/IntervalRangeLegend');
    require('./component/GradientRangeLegend');
    require('./component/Polar');
    require('./component/PolarAxis');
    require('./component/Title');
    require('./component/Geo');
    require('./component/DrillTools');
    require('./component/DataSheet');
    require('./component/TrendLine');

    require('./component/MoreLabel'); 
});
/**
 * Created by eason on 15/12/25.
 */

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
var VanCharts = require('VanCharts');

require('./Carousel');

//chart types
require('./chart/Bar');
require('./chart/Pie');
require('./chart/Line');
require('./chart/LineRadar');
require('./chart/ColumnRadar');

require('./chart/TreeMap');
require('./chart/Bubble');
require('./chart/ForceBubble');
require('./chart/Scatter');
require('./chart/MultiPie');

require('./chart/PointerGauge');
require('./chart/SlotGauge');
require('./chart/RingGauge');
require('./chart/ThermometerGauge');

require('./chart/Map');
require('./chart/Funnel');
require('./chart/WordCloud');
require('./chart/LineMap');
require('./chart/Structure');

//components
require('./component/Tooltip');
require('./component/Axis');
require('./component/GaugeAxis');
require('./component/Legend');
require('./component/Zoom');
require('./component/ToolBar');
require('./component/IntervalRangeLegend');
require('./component/GradientRangeLegend');
require('./component/Polar');
require('./component/PolarAxis');
require('./component/Title');
require('./component/Geo');
require('./component/DrillTools');
require('./component/DataSheet');
require('./component/TrendLine');

require('./component/MoreLabel');
return VanCharts;
}));